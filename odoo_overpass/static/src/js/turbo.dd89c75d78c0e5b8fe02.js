/******/
(function(modules) { // webpackBootstrap
    /******/ // install a JSONP callback for chunk loading
    /******/
    var parentJsonpFunction = window["webpackJsonp"];
    /******/
    window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
        /******/ // add "moreModules" to the modules object,
        /******/ // then flag all "chunkIds" as loaded and fire callback
        /******/
        var moduleId, chunkId, i = 0,
            resolves = [],
            result;
        /******/
        for (; i < chunkIds.length; i++) {
            /******/
            chunkId = chunkIds[i];
            /******/
            if (installedChunks[chunkId]) {
                /******/
                resolves.push(installedChunks[chunkId][0]);
                /******/
            }
            /******/
            installedChunks[chunkId] = 0;
            /******/
        }
        /******/
        for (moduleId in moreModules) {
            /******/
            if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
                /******/
                modules[moduleId] = moreModules[moduleId];
                /******/
            }
            /******/
        }
        /******/
        if (parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
        /******/
        while (resolves.length) {
            /******/
            resolves.shift()();
            /******/
        }
        /******/
        /******/
    };
    /******/
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // objects to store loaded and loading chunks
    /******/
    var installedChunks = {
        /******/
        53: 0
        /******/
    };
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/ // This file contains only the entry chunk.
    /******/ // The chunk loading function for additional chunks
    /******/
    __webpack_require__.e = function requireEnsure(chunkId) {
        /******/
        var installedChunkData = installedChunks[chunkId];
        /******/
        if (installedChunkData === 0) {
            /******/
            return new Promise(function(resolve) {
                resolve();
            });
            /******/
        }
        /******/
        /******/ // a Promise means "currently loading".
        /******/
        if (installedChunkData) {
            /******/
            return installedChunkData[2];
            /******/
        }
        /******/
        /******/ // setup Promise in chunk cache
        /******/
        var promise = new Promise(function(resolve, reject) {
            /******/
            installedChunkData = installedChunks[chunkId] = [resolve, reject];
            /******/
        });
        /******/
        installedChunkData[2] = promise;
        /******/
        /******/ // start chunk loading
        /******/
        var head = document.getElementsByTagName('head')[0];
        /******/
        var script = document.createElement('script');
        /******/
        script.type = 'text/javascript';
        /******/
        script.charset = 'utf-8';
        /******/
        script.async = true;
        /******/
        script.timeout = 120000;
        /******/
        /******/
        if (__webpack_require__.nc) {
            /******/
            script.setAttribute("nonce", __webpack_require__.nc);
            /******/
        }
        /******/
        script.src = __webpack_require__.p + "" + chunkId + "." + {
            "0": "b70df35a335f81b515c8",
            "1": "9453c1b620faf4d304b1",
            "2": "0a8071ac20f8756e9705",
            "3": "785e2a372b7754c41a86",
            "4": "f33b96f2edf1db86ab44",
            "5": "4551744e86a0cbf166a6",
            "6": "412c674b44f3bfcc5875",
            "7": "b16fabb9ad1c2966880f",
            "8": "22a62795de3bd07bab32",
            "9": "a33510f52a57e0cdf0eb",
            "10": "c03a473f6cdcd1d50e15",
            "11": "cd177e8cf021face8286",
            "12": "f41f444b4811871efb26",
            "13": "9016be5cf4bc79713934",
            "14": "2266239e0ebb6ac0bb47",
            "15": "9d30bc932f80c8a376b6",
            "16": "c012112e52f98b916662",
            "17": "058681e0fc84f4a0009d",
            "18": "ff53d8c323211ea9d8b8",
            "19": "086277caa1935dbf6b5a",
            "20": "c9b009ca3394cf286855",
            "21": "a212e98972f37a3be34a",
            "22": "6fee0ca705bd232eef50",
            "23": "d18ae21ca22f6657aab5",
            "24": "650694f69091c94f05e7",
            "25": "847bde8e3e80d71c42c0",
            "26": "37e5e3189d32810397b8",
            "27": "2106a4c5dff9df088ac5",
            "28": "957829d48c31f1474073",
            "29": "42e92c663d0906f7b31b",
            "30": "5884e093967618fe20c0",
            "31": "378535a88274e8e319d6",
            "32": "350a61703e83d1bcbfa0",
            "33": "a3b8218f2a8c26bd6db9",
            "34": "03d37781dade14abfb9e",
            "35": "f67bf4597b676ac03cdf",
            "36": "52055869707637c15db5",
            "37": "ebdd3069aa8aa14b1455",
            "38": "16f8f3bd6246edabd1d0",
            "39": "fcda513e2b1ca56c1a1a",
            "40": "6ac7e7887b5ba5981bad",
            "41": "dde89888697209aa008d",
            "42": "f71d83fff1feb91fe2c9",
            "43": "bb7f3a549cbfad86558a",
            "44": "5cd8b707ce7458dcfcc2",
            "45": "5c2e57865e6322cbc7cf",
            "46": "af65c5a468f2eac19d84",
            "47": "44f978dd38d323aa5cf3",
            "48": "1b2ea3309076cf4724de",
            "49": "a375865a3d55ec96b8f7",
            "50": "83409ae5e51a729780b0",
            "51": "82eb2602757aaae3b532",
            "52": "f2e76641f2ae84348e49"
        }[chunkId] + ".js";
        /******/
        var timeout = setTimeout(onScriptComplete, 120000);
        /******/
        script.onerror = script.onload = onScriptComplete;
        /******/
        function onScriptComplete() {
            /******/ // avoid mem leaks in IE.
            /******/
            script.onerror = script.onload = null;
            /******/
            clearTimeout(timeout);
            /******/
            var chunk = installedChunks[chunkId];
            /******/
            if (chunk !== 0) {
                /******/
                if (chunk) {
                    /******/
                    chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
                    /******/
                }
                /******/
                installedChunks[chunkId] = undefined;
                /******/
            }
            /******/
        };
        /******/
        head.appendChild(script);
        /******/
        /******/
        return promise;
        /******/
    };
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // identity function for calling harmony imports with the correct context
    /******/
    __webpack_require__.i = function(value) {
        return value;
    };
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/ // on error function for async loading
    /******/
    __webpack_require__.oe = function(err) {
        console.error(err);
        throw err;
    };
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 137);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global, module) {
            var __WEBPACK_AMD_DEFINE_RESULT__; //! moment.js
            //! version : 2.8.3
            //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
            //! license : MIT
            //! momentjs.com

            (function(undefined) {
                /************************************
                    Constants
                ************************************/

                var moment,
                    VERSION = '2.8.3',
                    // the global-scope this is NOT the global object in Node.js
                    globalScope = typeof global !== 'undefined' ? global : this,
                    oldGlobalMoment,
                    round = Math.round,
                    hasOwnProperty = Object.prototype.hasOwnProperty,
                    i,

                    YEAR = 0,
                    MONTH = 1,
                    DATE = 2,
                    HOUR = 3,
                    MINUTE = 4,
                    SECOND = 5,
                    MILLISECOND = 6,

                    // internal storage for locale config files
                    locales = {},

                    // extra moment internal properties (plugins register props here)
                    momentProperties = [],

                    // check for nodeJS
                    hasModule = (typeof module !== 'undefined' && module.exports),

                    // ASP.NET json date format regex
                    aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
                    aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

                    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
                    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
                    isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

                    // format tokens
                    formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
                    localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

                    // parsing token regexes
                    parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
                    parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
                    parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
                    parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
                    parseTokenDigits = /\d+/, // nonzero number of digits
                    parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
                    parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
                    parseTokenT = /T/i, // T (ISO separator)
                    parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
                    parseTokenOrdinal = /\d{1,2}/,

                    //strict parsing regexes
                    parseTokenOneDigit = /\d/, // 0 - 9
                    parseTokenTwoDigits = /\d\d/, // 00 - 99
                    parseTokenThreeDigits = /\d{3}/, // 000 - 999
                    parseTokenFourDigits = /\d{4}/, // 0000 - 9999
                    parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
                    parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

                    // iso 8601 regex
                    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
                    isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

                    isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

                    isoDates = [
                        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
                        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
                        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
                        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
                        ['YYYY-DDD', /\d{4}-\d{3}/]
                    ],

                    // iso time formats and regexes
                    isoTimes = [
                        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
                        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
                        ['HH:mm', /(T| )\d\d:\d\d/],
                        ['HH', /(T| )\d\d/]
                    ],

                    // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-15', '30']
                    parseTimezoneChunker = /([\+\-]|\d\d)/gi,

                    // getter and setter names
                    proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
                    unitMillisecondFactors = {
                        'Milliseconds': 1,
                        'Seconds': 1e3,
                        'Minutes': 6e4,
                        'Hours': 36e5,
                        'Days': 864e5,
                        'Months': 2592e6,
                        'Years': 31536e6
                    },

                    unitAliases = {
                        ms: 'millisecond',
                        s: 'second',
                        m: 'minute',
                        h: 'hour',
                        d: 'day',
                        D: 'date',
                        w: 'week',
                        W: 'isoWeek',
                        M: 'month',
                        Q: 'quarter',
                        y: 'year',
                        DDD: 'dayOfYear',
                        e: 'weekday',
                        E: 'isoWeekday',
                        gg: 'weekYear',
                        GG: 'isoWeekYear'
                    },

                    camelFunctions = {
                        dayofyear: 'dayOfYear',
                        isoweekday: 'isoWeekday',
                        isoweek: 'isoWeek',
                        weekyear: 'weekYear',
                        isoweekyear: 'isoWeekYear'
                    },

                    // format function strings
                    formatFunctions = {},

                    // default relative time thresholds
                    relativeTimeThresholds = {
                        s: 45, // seconds to minute
                        m: 45, // minutes to hour
                        h: 22, // hours to day
                        d: 26, // days to month
                        M: 11 // months to year
                    },

                    // tokens to ordinalize and pad
                    ordinalizeTokens = 'DDD w W M D d'.split(' '),
                    paddedTokens = 'M D H h m s w W'.split(' '),

                    formatTokenFunctions = {
                        M: function() {
                            return this.month() + 1;
                        },
                        MMM: function(format) {
                            return this.localeData().monthsShort(this, format);
                        },
                        MMMM: function(format) {
                            return this.localeData().months(this, format);
                        },
                        D: function() {
                            return this.date();
                        },
                        DDD: function() {
                            return this.dayOfYear();
                        },
                        d: function() {
                            return this.day();
                        },
                        dd: function(format) {
                            return this.localeData().weekdaysMin(this, format);
                        },
                        ddd: function(format) {
                            return this.localeData().weekdaysShort(this, format);
                        },
                        dddd: function(format) {
                            return this.localeData().weekdays(this, format);
                        },
                        w: function() {
                            return this.week();
                        },
                        W: function() {
                            return this.isoWeek();
                        },
                        YY: function() {
                            return leftZeroFill(this.year() % 100, 2);
                        },
                        YYYY: function() {
                            return leftZeroFill(this.year(), 4);
                        },
                        YYYYY: function() {
                            return leftZeroFill(this.year(), 5);
                        },
                        YYYYYY: function() {
                            var y = this.year(),
                                sign = y >= 0 ? '+' : '-';
                            return sign + leftZeroFill(Math.abs(y), 6);
                        },
                        gg: function() {
                            return leftZeroFill(this.weekYear() % 100, 2);
                        },
                        gggg: function() {
                            return leftZeroFill(this.weekYear(), 4);
                        },
                        ggggg: function() {
                            return leftZeroFill(this.weekYear(), 5);
                        },
                        GG: function() {
                            return leftZeroFill(this.isoWeekYear() % 100, 2);
                        },
                        GGGG: function() {
                            return leftZeroFill(this.isoWeekYear(), 4);
                        },
                        GGGGG: function() {
                            return leftZeroFill(this.isoWeekYear(), 5);
                        },
                        e: function() {
                            return this.weekday();
                        },
                        E: function() {
                            return this.isoWeekday();
                        },
                        a: function() {
                            return this.localeData().meridiem(this.hours(), this.minutes(), true);
                        },
                        A: function() {
                            return this.localeData().meridiem(this.hours(), this.minutes(), false);
                        },
                        H: function() {
                            return this.hours();
                        },
                        h: function() {
                            return this.hours() % 12 || 12;
                        },
                        m: function() {
                            return this.minutes();
                        },
                        s: function() {
                            return this.seconds();
                        },
                        S: function() {
                            return toInt(this.milliseconds() / 100);
                        },
                        SS: function() {
                            return leftZeroFill(toInt(this.milliseconds() / 10), 2);
                        },
                        SSS: function() {
                            return leftZeroFill(this.milliseconds(), 3);
                        },
                        SSSS: function() {
                            return leftZeroFill(this.milliseconds(), 3);
                        },
                        Z: function() {
                            var a = -this.zone(),
                                b = '+';
                            if (a < 0) {
                                a = -a;
                                b = '-';
                            }
                            return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
                        },
                        ZZ: function() {
                            var a = -this.zone(),
                                b = '+';
                            if (a < 0) {
                                a = -a;
                                b = '-';
                            }
                            return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
                        },
                        z: function() {
                            return this.zoneAbbr();
                        },
                        zz: function() {
                            return this.zoneName();
                        },
                        X: function() {
                            return this.unix();
                        },
                        Q: function() {
                            return this.quarter();
                        }
                    },

                    deprecations = {},

                    lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

                // Pick the first defined of two or three arguments. dfl comes from
                // default.
                function dfl(a, b, c) {
                    switch (arguments.length) {
                        case 2:
                            return a != null ? a : b;
                        case 3:
                            return a != null ? a : b != null ? b : c;
                        default:
                            throw new Error('Implement me');
                    }
                }

                function hasOwnProp(a, b) {
                    return hasOwnProperty.call(a, b);
                }

                function defaultParsingFlags() {
                    // We need to deep clone this object, and es5 standard is not very
                    // helpful.
                    return {
                        empty: false,
                        unusedTokens: [],
                        unusedInput: [],
                        overflow: -2,
                        charsLeftOver: 0,
                        nullInput: false,
                        invalidMonth: null,
                        invalidFormat: false,
                        userInvalidated: false,
                        iso: false
                    };
                }

                function printMsg(msg) {
                    if (moment.suppressDeprecationWarnings === false &&
                        typeof console !== 'undefined' && console.warn) {
                        console.warn('Deprecation warning: ' + msg);
                    }
                }

                function deprecate(msg, fn) {
                    var firstTime = true;
                    return extend(function() {
                        if (firstTime) {
                            printMsg(msg);
                            firstTime = false;
                        }
                        return fn.apply(this, arguments);
                    }, fn);
                }

                function deprecateSimple(name, msg) {
                    if (!deprecations[name]) {
                        printMsg(msg);
                        deprecations[name] = true;
                    }
                }

                function padToken(func, count) {
                    return function(a) {
                        return leftZeroFill(func.call(this, a), count);
                    };
                }

                function ordinalizeToken(func, period) {
                    return function(a) {
                        return this.localeData().ordinal(func.call(this, a), period);
                    };
                }

                while (ordinalizeTokens.length) {
                    i = ordinalizeTokens.pop();
                    formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
                }
                while (paddedTokens.length) {
                    i = paddedTokens.pop();
                    formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
                }
                formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


                /************************************
                    Constructors
                ************************************/

                function Locale() {}

                // Moment prototype object
                function Moment(config, skipOverflow) {
                    if (skipOverflow !== false) {
                        checkOverflow(config);
                    }
                    copyConfig(this, config);
                    this._d = new Date(+config._d);
                }

                // Duration Constructor
                function Duration(duration) {
                    var normalizedInput = normalizeObjectUnits(duration),
                        years = normalizedInput.year || 0,
                        quarters = normalizedInput.quarter || 0,
                        months = normalizedInput.month || 0,
                        weeks = normalizedInput.week || 0,
                        days = normalizedInput.day || 0,
                        hours = normalizedInput.hour || 0,
                        minutes = normalizedInput.minute || 0,
                        seconds = normalizedInput.second || 0,
                        milliseconds = normalizedInput.millisecond || 0;

                    // representation for dateAddRemove
                    this._milliseconds = +milliseconds +
                        seconds * 1e3 + // 1000
                        minutes * 6e4 + // 1000 * 60
                        hours * 36e5; // 1000 * 60 * 60
                    // Because of dateAddRemove treats 24 hours as different from a
                    // day when working around DST, we need to store them separately
                    this._days = +days +
                        weeks * 7;
                    // It is impossible translate months into days without knowing
                    // which months you are are talking about, so we have to store
                    // it separately.
                    this._months = +months +
                        quarters * 3 +
                        years * 12;

                    this._data = {};

                    this._locale = moment.localeData();

                    this._bubble();
                }

                /************************************
                    Helpers
                ************************************/


                function extend(a, b) {
                    for (var i in b) {
                        if (hasOwnProp(b, i)) {
                            a[i] = b[i];
                        }
                    }

                    if (hasOwnProp(b, 'toString')) {
                        a.toString = b.toString;
                    }

                    if (hasOwnProp(b, 'valueOf')) {
                        a.valueOf = b.valueOf;
                    }

                    return a;
                }

                function copyConfig(to, from) {
                    var i, prop, val;

                    if (typeof from._isAMomentObject !== 'undefined') {
                        to._isAMomentObject = from._isAMomentObject;
                    }
                    if (typeof from._i !== 'undefined') {
                        to._i = from._i;
                    }
                    if (typeof from._f !== 'undefined') {
                        to._f = from._f;
                    }
                    if (typeof from._l !== 'undefined') {
                        to._l = from._l;
                    }
                    if (typeof from._strict !== 'undefined') {
                        to._strict = from._strict;
                    }
                    if (typeof from._tzm !== 'undefined') {
                        to._tzm = from._tzm;
                    }
                    if (typeof from._isUTC !== 'undefined') {
                        to._isUTC = from._isUTC;
                    }
                    if (typeof from._offset !== 'undefined') {
                        to._offset = from._offset;
                    }
                    if (typeof from._pf !== 'undefined') {
                        to._pf = from._pf;
                    }
                    if (typeof from._locale !== 'undefined') {
                        to._locale = from._locale;
                    }

                    if (momentProperties.length > 0) {
                        for (i in momentProperties) {
                            prop = momentProperties[i];
                            val = from[prop];
                            if (typeof val !== 'undefined') {
                                to[prop] = val;
                            }
                        }
                    }

                    return to;
                }

                function absRound(number) {
                    if (number < 0) {
                        return Math.ceil(number);
                    } else {
                        return Math.floor(number);
                    }
                }

                // left zero fill a number
                // see http://jsperf.com/left-zero-filling for performance comparison
                function leftZeroFill(number, targetLength, forceSign) {
                    var output = '' + Math.abs(number),
                        sign = number >= 0;

                    while (output.length < targetLength) {
                        output = '0' + output;
                    }
                    return (sign ? (forceSign ? '+' : '') : '-') + output;
                }

                function positiveMomentsDifference(base, other) {
                    var res = {
                        milliseconds: 0,
                        months: 0
                    };

                    res.months = other.month() - base.month() +
                        (other.year() - base.year()) * 12;
                    if (base.clone().add(res.months, 'M').isAfter(other)) {
                        --res.months;
                    }

                    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

                    return res;
                }

                function momentsDifference(base, other) {
                    var res;
                    other = makeAs(other, base);
                    if (base.isBefore(other)) {
                        res = positiveMomentsDifference(base, other);
                    } else {
                        res = positiveMomentsDifference(other, base);
                        res.milliseconds = -res.milliseconds;
                        res.months = -res.months;
                    }

                    return res;
                }

                // TODO: remove 'name' arg after deprecation is removed
                function createAdder(direction, name) {
                    return function(val, period) {
                        var dur, tmp;
                        //invert the arguments, but complain about it
                        if (period !== null && !isNaN(+period)) {
                            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                            tmp = val;
                            val = period;
                            period = tmp;
                        }

                        val = typeof val === 'string' ? +val : val;
                        dur = moment.duration(val, period);
                        addOrSubtractDurationFromMoment(this, dur, direction);
                        return this;
                    };
                }

                function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
                    var milliseconds = duration._milliseconds,
                        days = duration._days,
                        months = duration._months;
                    updateOffset = updateOffset == null ? true : updateOffset;

                    if (milliseconds) {
                        mom._d.setTime(+mom._d + milliseconds * isAdding);
                    }
                    if (days) {
                        rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
                    }
                    if (months) {
                        rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
                    }
                    if (updateOffset) {
                        moment.updateOffset(mom, days || months);
                    }
                }

                // check if is an array
                function isArray(input) {
                    return Object.prototype.toString.call(input) === '[object Array]';
                }

                function isDate(input) {
                    return Object.prototype.toString.call(input) === '[object Date]' ||
                        input instanceof Date;
                }

                // compare two arrays, return the number of differences
                function compareArrays(array1, array2, dontConvert) {
                    var len = Math.min(array1.length, array2.length),
                        lengthDiff = Math.abs(array1.length - array2.length),
                        diffs = 0,
                        i;
                    for (i = 0; i < len; i++) {
                        if ((dontConvert && array1[i] !== array2[i]) ||
                            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                            diffs++;
                        }
                    }
                    return diffs + lengthDiff;
                }

                function normalizeUnits(units) {
                    if (units) {
                        var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
                        units = unitAliases[units] || camelFunctions[lowered] || lowered;
                    }
                    return units;
                }

                function normalizeObjectUnits(inputObject) {
                    var normalizedInput = {},
                        normalizedProp,
                        prop;

                    for (prop in inputObject) {
                        if (hasOwnProp(inputObject, prop)) {
                            normalizedProp = normalizeUnits(prop);
                            if (normalizedProp) {
                                normalizedInput[normalizedProp] = inputObject[prop];
                            }
                        }
                    }

                    return normalizedInput;
                }

                function makeList(field) {
                    var count, setter;

                    if (field.indexOf('week') === 0) {
                        count = 7;
                        setter = 'day';
                    } else if (field.indexOf('month') === 0) {
                        count = 12;
                        setter = 'month';
                    } else {
                        return;
                    }

                    moment[field] = function(format, index) {
                        var i, getter,
                            method = moment._locale[field],
                            results = [];

                        if (typeof format === 'number') {
                            index = format;
                            format = undefined;
                        }

                        getter = function(i) {
                            var m = moment().utc().set(setter, i);
                            return method.call(moment._locale, m, format || '');
                        };

                        if (index != null) {
                            return getter(index);
                        } else {
                            for (i = 0; i < count; i++) {
                                results.push(getter(i));
                            }
                            return results;
                        }
                    };
                }

                function toInt(argumentForCoercion) {
                    var coercedNumber = +argumentForCoercion,
                        value = 0;

                    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                        if (coercedNumber >= 0) {
                            value = Math.floor(coercedNumber);
                        } else {
                            value = Math.ceil(coercedNumber);
                        }
                    }

                    return value;
                }

                function daysInMonth(year, month) {
                    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
                }

                function weeksInYear(year, dow, doy) {
                    return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
                }

                function daysInYear(year) {
                    return isLeapYear(year) ? 366 : 365;
                }

                function isLeapYear(year) {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                }

                function checkOverflow(m) {
                    var overflow;
                    if (m._a && m._pf.overflow === -2) {
                        overflow =
                            m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                            m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                            m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                            m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                            m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                            m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                            -1;

                        if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                            overflow = DATE;
                        }

                        m._pf.overflow = overflow;
                    }
                }

                function isValid(m) {
                    if (m._isValid == null) {
                        m._isValid = !isNaN(m._d.getTime()) &&
                            m._pf.overflow < 0 &&
                            !m._pf.empty &&
                            !m._pf.invalidMonth &&
                            !m._pf.nullInput &&
                            !m._pf.invalidFormat &&
                            !m._pf.userInvalidated;

                        if (m._strict) {
                            m._isValid = m._isValid &&
                                m._pf.charsLeftOver === 0 &&
                                m._pf.unusedTokens.length === 0;
                        }
                    }
                    return m._isValid;
                }

                function normalizeLocale(key) {
                    return key ? key.toLowerCase().replace('_', '-') : key;
                }

                // pick the locale from the array
                // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
                // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
                function chooseLocale(names) {
                    var i = 0,
                        j, next, locale, split;

                    while (i < names.length) {
                        split = normalizeLocale(names[i]).split('-');
                        j = split.length;
                        next = normalizeLocale(names[i + 1]);
                        next = next ? next.split('-') : null;
                        while (j > 0) {
                            locale = loadLocale(split.slice(0, j).join('-'));
                            if (locale) {
                                return locale;
                            }
                            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                                //the next array item is better than a shallower substring of this one
                                break;
                            }
                            j--;
                        }
                        i++;
                    }
                    return null;
                }

                function loadLocale(name) {
                    var oldLocale = null;
                    if (!locales[name] && hasModule) {
                        try {
                            oldLocale = moment.locale();
                            __webpack_require__(149)("./" + name);
                            // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                            moment.locale(oldLocale);
                        } catch (e) {}
                    }
                    return locales[name];
                }

                // Return a moment from input, that is local/utc/zone equivalent to model.
                function makeAs(input, model) {
                    return model._isUTC ? moment(input).zone(model._offset || 0) :
                        moment(input).local();
                }

                /************************************
                    Locale
                ************************************/


                extend(Locale.prototype, {

                    set: function(config) {
                        var prop, i;
                        for (i in config) {
                            prop = config[i];
                            if (typeof prop === 'function') {
                                this[i] = prop;
                            } else {
                                this['_' + i] = prop;
                            }
                        }
                    },

                    _months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                    months: function(m) {
                        return this._months[m.month()];
                    },

                    _monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                    monthsShort: function(m) {
                        return this._monthsShort[m.month()];
                    },

                    monthsParse: function(monthName) {
                        var i, mom, regex;

                        if (!this._monthsParse) {
                            this._monthsParse = [];
                        }

                        for (i = 0; i < 12; i++) {
                            // make the regex if we don't have it already
                            if (!this._monthsParse[i]) {
                                mom = moment.utc([2000, i]);
                                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                            }
                            // test the regex
                            if (this._monthsParse[i].test(monthName)) {
                                return i;
                            }
                        }
                    },

                    _weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                    weekdays: function(m) {
                        return this._weekdays[m.day()];
                    },

                    _weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                    weekdaysShort: function(m) {
                        return this._weekdaysShort[m.day()];
                    },

                    _weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                    weekdaysMin: function(m) {
                        return this._weekdaysMin[m.day()];
                    },

                    weekdaysParse: function(weekdayName) {
                        var i, mom, regex;

                        if (!this._weekdaysParse) {
                            this._weekdaysParse = [];
                        }

                        for (i = 0; i < 7; i++) {
                            // make the regex if we don't have it already
                            if (!this._weekdaysParse[i]) {
                                mom = moment([2000, 1]).day(i);
                                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                            }
                            // test the regex
                            if (this._weekdaysParse[i].test(weekdayName)) {
                                return i;
                            }
                        }
                    },

                    _longDateFormat: {
                        LT: 'h:mm A',
                        L: 'MM/DD/YYYY',
                        LL: 'MMMM D, YYYY',
                        LLL: 'MMMM D, YYYY LT',
                        LLLL: 'dddd, MMMM D, YYYY LT'
                    },
                    longDateFormat: function(key) {
                        var output = this._longDateFormat[key];
                        if (!output && this._longDateFormat[key.toUpperCase()]) {
                            output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                                return val.slice(1);
                            });
                            this._longDateFormat[key] = output;
                        }
                        return output;
                    },

                    isPM: function(input) {
                        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
                        // Using charAt should be more compatible.
                        return ((input + '').toLowerCase().charAt(0) === 'p');
                    },

                    _meridiemParse: /[ap]\.?m?\.?/i,
                    meridiem: function(hours, minutes, isLower) {
                        if (hours > 11) {
                            return isLower ? 'pm' : 'PM';
                        } else {
                            return isLower ? 'am' : 'AM';
                        }
                    },

                    _calendar: {
                        sameDay: '[Today at] LT',
                        nextDay: '[Tomorrow at] LT',
                        nextWeek: 'dddd [at] LT',
                        lastDay: '[Yesterday at] LT',
                        lastWeek: '[Last] dddd [at] LT',
                        sameElse: 'L'
                    },
                    calendar: function(key, mom) {
                        var output = this._calendar[key];
                        return typeof output === 'function' ? output.apply(mom) : output;
                    },

                    _relativeTime: {
                        future: 'in %s',
                        past: '%s ago',
                        s: 'a few seconds',
                        m: 'a minute',
                        mm: '%d minutes',
                        h: 'an hour',
                        hh: '%d hours',
                        d: 'a day',
                        dd: '%d days',
                        M: 'a month',
                        MM: '%d months',
                        y: 'a year',
                        yy: '%d years'
                    },

                    relativeTime: function(number, withoutSuffix, string, isFuture) {
                        var output = this._relativeTime[string];
                        return (typeof output === 'function') ?
                            output(number, withoutSuffix, string, isFuture) :
                            output.replace(/%d/i, number);
                    },

                    pastFuture: function(diff, output) {
                        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
                        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
                    },

                    ordinal: function(number) {
                        return this._ordinal.replace('%d', number);
                    },
                    _ordinal: '%d',

                    preparse: function(string) {
                        return string;
                    },

                    postformat: function(string) {
                        return string;
                    },

                    week: function(mom) {
                        return weekOfYear(mom, this._week.dow, this._week.doy).week;
                    },

                    _week: {
                        dow: 0, // Sunday is the first day of the week.
                        doy: 6 // The week that contains Jan 1st is the first week of the year.
                    },

                    _invalidDate: 'Invalid date',
                    invalidDate: function() {
                        return this._invalidDate;
                    }
                });

                /************************************
                    Formatting
                ************************************/


                function removeFormattingTokens(input) {
                    if (input.match(/\[[\s\S]/)) {
                        return input.replace(/^\[|\]$/g, '');
                    }
                    return input.replace(/\\/g, '');
                }

                function makeFormatFunction(format) {
                    var array = format.match(formattingTokens),
                        i, length;

                    for (i = 0, length = array.length; i < length; i++) {
                        if (formatTokenFunctions[array[i]]) {
                            array[i] = formatTokenFunctions[array[i]];
                        } else {
                            array[i] = removeFormattingTokens(array[i]);
                        }
                    }

                    return function(mom) {
                        var output = '';
                        for (i = 0; i < length; i++) {
                            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
                        }
                        return output;
                    };
                }

                // format date using native date object
                function formatMoment(m, format) {
                    if (!m.isValid()) {
                        return m.localeData().invalidDate();
                    }

                    format = expandFormat(format, m.localeData());

                    if (!formatFunctions[format]) {
                        formatFunctions[format] = makeFormatFunction(format);
                    }

                    return formatFunctions[format](m);
                }

                function expandFormat(format, locale) {
                    var i = 5;

                    function replaceLongDateFormatTokens(input) {
                        return locale.longDateFormat(input) || input;
                    }

                    localFormattingTokens.lastIndex = 0;
                    while (i >= 0 && localFormattingTokens.test(format)) {
                        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                        localFormattingTokens.lastIndex = 0;
                        i -= 1;
                    }

                    return format;
                }


                /************************************
                    Parsing
                ************************************/


                // get the regex to find the next token
                function getParseRegexForToken(token, config) {
                    var a, strict = config._strict;
                    switch (token) {
                        case 'Q':
                            return parseTokenOneDigit;
                        case 'DDDD':
                            return parseTokenThreeDigits;
                        case 'YYYY':
                        case 'GGGG':
                        case 'gggg':
                            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
                        case 'Y':
                        case 'G':
                        case 'g':
                            return parseTokenSignedNumber;
                        case 'YYYYYY':
                        case 'YYYYY':
                        case 'GGGGG':
                        case 'ggggg':
                            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
                        case 'S':
                            if (strict) {
                                return parseTokenOneDigit;
                            }
                            /* falls through */
                        case 'SS':
                            if (strict) {
                                return parseTokenTwoDigits;
                            }
                            /* falls through */
                        case 'SSS':
                            if (strict) {
                                return parseTokenThreeDigits;
                            }
                            /* falls through */
                        case 'DDD':
                            return parseTokenOneToThreeDigits;
                        case 'MMM':
                        case 'MMMM':
                        case 'dd':
                        case 'ddd':
                        case 'dddd':
                            return parseTokenWord;
                        case 'a':
                        case 'A':
                            return config._locale._meridiemParse;
                        case 'X':
                            return parseTokenTimestampMs;
                        case 'Z':
                        case 'ZZ':
                            return parseTokenTimezone;
                        case 'T':
                            return parseTokenT;
                        case 'SSSS':
                            return parseTokenDigits;
                        case 'MM':
                        case 'DD':
                        case 'YY':
                        case 'GG':
                        case 'gg':
                        case 'HH':
                        case 'hh':
                        case 'mm':
                        case 'ss':
                        case 'ww':
                        case 'WW':
                            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
                        case 'M':
                        case 'D':
                        case 'd':
                        case 'H':
                        case 'h':
                        case 'm':
                        case 's':
                        case 'w':
                        case 'W':
                        case 'e':
                        case 'E':
                            return parseTokenOneOrTwoDigits;
                        case 'Do':
                            return parseTokenOrdinal;
                        default:
                            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
                            return a;
                    }
                }

                function timezoneMinutesFromString(string) {
                    string = string || '';
                    var possibleTzMatches = (string.match(parseTokenTimezone) || []),
                        tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
                        parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
                        minutes = +(parts[1] * 60) + toInt(parts[2]);

                    return parts[0] === '+' ? -minutes : minutes;
                }

                // function to convert string input to date
                function addTimeToArrayFromToken(token, input, config) {
                    var a, datePartArray = config._a;

                    switch (token) {
                        // QUARTER
                        case 'Q':
                            if (input != null) {
                                datePartArray[MONTH] = (toInt(input) - 1) * 3;
                            }
                            break;
                            // MONTH
                        case 'M': // fall through to MM
                        case 'MM':
                            if (input != null) {
                                datePartArray[MONTH] = toInt(input) - 1;
                            }
                            break;
                        case 'MMM': // fall through to MMMM
                        case 'MMMM':
                            a = config._locale.monthsParse(input);
                            // if we didn't find a month name, mark the date as invalid.
                            if (a != null) {
                                datePartArray[MONTH] = a;
                            } else {
                                config._pf.invalidMonth = input;
                            }
                            break;
                            // DAY OF MONTH
                        case 'D': // fall through to DD
                        case 'DD':
                            if (input != null) {
                                datePartArray[DATE] = toInt(input);
                            }
                            break;
                        case 'Do':
                            if (input != null) {
                                datePartArray[DATE] = toInt(parseInt(input, 10));
                            }
                            break;
                            // DAY OF YEAR
                        case 'DDD': // fall through to DDDD
                        case 'DDDD':
                            if (input != null) {
                                config._dayOfYear = toInt(input);
                            }

                            break;
                            // YEAR
                        case 'YY':
                            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                            break;
                        case 'YYYY':
                        case 'YYYYY':
                        case 'YYYYYY':
                            datePartArray[YEAR] = toInt(input);
                            break;
                            // AM / PM
                        case 'a': // fall through to A
                        case 'A':
                            config._isPm = config._locale.isPM(input);
                            break;
                            // 24 HOUR
                        case 'H': // fall through to hh
                        case 'HH': // fall through to hh
                        case 'h': // fall through to hh
                        case 'hh':
                            datePartArray[HOUR] = toInt(input);
                            break;
                            // MINUTE
                        case 'm': // fall through to mm
                        case 'mm':
                            datePartArray[MINUTE] = toInt(input);
                            break;
                            // SECOND
                        case 's': // fall through to ss
                        case 'ss':
                            datePartArray[SECOND] = toInt(input);
                            break;
                            // MILLISECOND
                        case 'S':
                        case 'SS':
                        case 'SSS':
                        case 'SSSS':
                            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                            break;
                            // UNIX TIMESTAMP WITH MS
                        case 'X':
                            config._d = new Date(parseFloat(input) * 1000);
                            break;
                            // TIMEZONE
                        case 'Z': // fall through to ZZ
                        case 'ZZ':
                            config._useUTC = true;
                            config._tzm = timezoneMinutesFromString(input);
                            break;
                            // WEEKDAY - human
                        case 'dd':
                        case 'ddd':
                        case 'dddd':
                            a = config._locale.weekdaysParse(input);
                            // if we didn't get a weekday name, mark the date as invalid
                            if (a != null) {
                                config._w = config._w || {};
                                config._w['d'] = a;
                            } else {
                                config._pf.invalidWeekday = input;
                            }
                            break;
                            // WEEK, WEEK DAY - numeric
                        case 'w':
                        case 'ww':
                        case 'W':
                        case 'WW':
                        case 'd':
                        case 'e':
                        case 'E':
                            token = token.substr(0, 1);
                            /* falls through */
                        case 'gggg':
                        case 'GGGG':
                        case 'GGGGG':
                            token = token.substr(0, 2);
                            if (input) {
                                config._w = config._w || {};
                                config._w[token] = toInt(input);
                            }
                            break;
                        case 'gg':
                        case 'GG':
                            config._w = config._w || {};
                            config._w[token] = moment.parseTwoDigitYear(input);
                    }
                }

                function dayOfYearFromWeekInfo(config) {
                    var w, weekYear, week, weekday, dow, doy, temp;

                    w = config._w;
                    if (w.GG != null || w.W != null || w.E != null) {
                        dow = 1;
                        doy = 4;

                        // TODO: We need to take the current isoWeekYear, but that depends on
                        // how we interpret now (local, utc, fixed offset). So create
                        // a now version of current config (take local/utc/offset flags, and
                        // create now).
                        weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
                        week = dfl(w.W, 1);
                        weekday = dfl(w.E, 1);
                    } else {
                        dow = config._locale._week.dow;
                        doy = config._locale._week.doy;

                        weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
                        week = dfl(w.w, 1);

                        if (w.d != null) {
                            // weekday -- low day numbers are considered next week
                            weekday = w.d;
                            if (weekday < dow) {
                                ++week;
                            }
                        } else if (w.e != null) {
                            // local weekday -- counting starts from begining of week
                            weekday = w.e + dow;
                        } else {
                            // default to begining of week
                            weekday = dow;
                        }
                    }
                    temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

                    config._a[YEAR] = temp.year;
                    config._dayOfYear = temp.dayOfYear;
                }

                // convert an array to a date.
                // the array should mirror the parameters below
                // note: all values past the year are optional and will default to the lowest possible value.
                // [year, month, day , hour, minute, second, millisecond]
                function dateFromConfig(config) {
                    var i, date, input = [],
                        currentDate, yearToUse;

                    if (config._d) {
                        return;
                    }

                    currentDate = currentDateArray(config);

                    //compute day of the year from weeks and weekdays
                    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                        dayOfYearFromWeekInfo(config);
                    }

                    //if the day of the year is set, figure out what it is
                    if (config._dayOfYear) {
                        yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

                        if (config._dayOfYear > daysInYear(yearToUse)) {
                            config._pf._overflowDayOfYear = true;
                        }

                        date = makeUTCDate(yearToUse, 0, config._dayOfYear);
                        config._a[MONTH] = date.getUTCMonth();
                        config._a[DATE] = date.getUTCDate();
                    }

                    // Default to current date.
                    // * if no year, month, day of month are given, default to today
                    // * if day of month is given, default month and year
                    // * if month is given, default only year
                    // * if year is given, don't default anything
                    for (i = 0; i < 3 && config._a[i] == null; ++i) {
                        config._a[i] = input[i] = currentDate[i];
                    }

                    // Zero out whatever was not defaulted, including time
                    for (; i < 7; i++) {
                        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
                    }

                    config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
                    // Apply timezone offset from input. The actual zone can be changed
                    // with parseZone.
                    if (config._tzm != null) {
                        config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
                    }
                }

                function dateFromObject(config) {
                    var normalizedInput;

                    if (config._d) {
                        return;
                    }

                    normalizedInput = normalizeObjectUnits(config._i);
                    config._a = [
                        normalizedInput.year,
                        normalizedInput.month,
                        normalizedInput.day,
                        normalizedInput.hour,
                        normalizedInput.minute,
                        normalizedInput.second,
                        normalizedInput.millisecond
                    ];

                    dateFromConfig(config);
                }

                function currentDateArray(config) {
                    var now = new Date();
                    if (config._useUTC) {
                        return [
                            now.getUTCFullYear(),
                            now.getUTCMonth(),
                            now.getUTCDate()
                        ];
                    } else {
                        return [now.getFullYear(), now.getMonth(), now.getDate()];
                    }
                }

                // date from string and format string
                function makeDateFromStringAndFormat(config) {
                    if (config._f === moment.ISO_8601) {
                        parseISO(config);
                        return;
                    }

                    config._a = [];
                    config._pf.empty = true;

                    // This array is used to make a Date, either with `new Date` or `Date.UTC`
                    var string = '' + config._i,
                        i, parsedInput, tokens, token, skipped,
                        stringLength = string.length,
                        totalParsedInputLength = 0;

                    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

                    for (i = 0; i < tokens.length; i++) {
                        token = tokens[i];
                        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                        if (parsedInput) {
                            skipped = string.substr(0, string.indexOf(parsedInput));
                            if (skipped.length > 0) {
                                config._pf.unusedInput.push(skipped);
                            }
                            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                            totalParsedInputLength += parsedInput.length;
                        }
                        // don't parse if it's not a known token
                        if (formatTokenFunctions[token]) {
                            if (parsedInput) {
                                config._pf.empty = false;
                            } else {
                                config._pf.unusedTokens.push(token);
                            }
                            addTimeToArrayFromToken(token, parsedInput, config);
                        } else if (config._strict && !parsedInput) {
                            config._pf.unusedTokens.push(token);
                        }
                    }

                    // add remaining unparsed input length to the string
                    config._pf.charsLeftOver = stringLength - totalParsedInputLength;
                    if (string.length > 0) {
                        config._pf.unusedInput.push(string);
                    }

                    // handle am pm
                    if (config._isPm && config._a[HOUR] < 12) {
                        config._a[HOUR] += 12;
                    }
                    // if is 12 am, change hours to 0
                    if (config._isPm === false && config._a[HOUR] === 12) {
                        config._a[HOUR] = 0;
                    }

                    dateFromConfig(config);
                    checkOverflow(config);
                }

                function unescapeFormat(s) {
                    return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    });
                }

                // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
                function regexpEscape(s) {
                    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                }

                // date from string and array of format strings
                function makeDateFromStringAndArray(config) {
                    var tempConfig,
                        bestMoment,

                        scoreToBeat,
                        i,
                        currentScore;

                    if (config._f.length === 0) {
                        config._pf.invalidFormat = true;
                        config._d = new Date(NaN);
                        return;
                    }

                    for (i = 0; i < config._f.length; i++) {
                        currentScore = 0;
                        tempConfig = copyConfig({}, config);
                        if (config._useUTC != null) {
                            tempConfig._useUTC = config._useUTC;
                        }
                        tempConfig._pf = defaultParsingFlags();
                        tempConfig._f = config._f[i];
                        makeDateFromStringAndFormat(tempConfig);

                        if (!isValid(tempConfig)) {
                            continue;
                        }

                        // if there is any input that was not parsed add a penalty for that format
                        currentScore += tempConfig._pf.charsLeftOver;

                        //or tokens
                        currentScore += tempConfig._pf.unusedTokens.length * 10;

                        tempConfig._pf.score = currentScore;

                        if (scoreToBeat == null || currentScore < scoreToBeat) {
                            scoreToBeat = currentScore;
                            bestMoment = tempConfig;
                        }
                    }

                    extend(config, bestMoment || tempConfig);
                }

                // date from iso format
                function parseISO(config) {
                    var i, l,
                        string = config._i,
                        match = isoRegex.exec(string);

                    if (match) {
                        config._pf.iso = true;
                        for (i = 0, l = isoDates.length; i < l; i++) {
                            if (isoDates[i][1].exec(string)) {
                                // match[5] should be 'T' or undefined
                                config._f = isoDates[i][0] + (match[6] || ' ');
                                break;
                            }
                        }
                        for (i = 0, l = isoTimes.length; i < l; i++) {
                            if (isoTimes[i][1].exec(string)) {
                                config._f += isoTimes[i][0];
                                break;
                            }
                        }
                        if (string.match(parseTokenTimezone)) {
                            config._f += 'Z';
                        }
                        makeDateFromStringAndFormat(config);
                    } else {
                        config._isValid = false;
                    }
                }

                // date from iso format or fallback
                function makeDateFromString(config) {
                    parseISO(config);
                    if (config._isValid === false) {
                        delete config._isValid;
                        moment.createFromInputFallback(config);
                    }
                }

                function map(arr, fn) {
                    var res = [],
                        i;
                    for (i = 0; i < arr.length; ++i) {
                        res.push(fn(arr[i], i));
                    }
                    return res;
                }

                function makeDateFromInput(config) {
                    var input = config._i,
                        matched;
                    if (input === undefined) {
                        config._d = new Date();
                    } else if (isDate(input)) {
                        config._d = new Date(+input);
                    } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
                        config._d = new Date(+matched[1]);
                    } else if (typeof input === 'string') {
                        makeDateFromString(config);
                    } else if (isArray(input)) {
                        config._a = map(input.slice(0), function(obj) {
                            return parseInt(obj, 10);
                        });
                        dateFromConfig(config);
                    } else if (typeof(input) === 'object') {
                        dateFromObject(config);
                    } else if (typeof(input) === 'number') {
                        // from milliseconds
                        config._d = new Date(input);
                    } else {
                        moment.createFromInputFallback(config);
                    }
                }

                function makeDate(y, m, d, h, M, s, ms) {
                    //can't just apply() to create a date:
                    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
                    var date = new Date(y, m, d, h, M, s, ms);

                    //the date constructor doesn't accept years < 1970
                    if (y < 1970) {
                        date.setFullYear(y);
                    }
                    return date;
                }

                function makeUTCDate(y) {
                    var date = new Date(Date.UTC.apply(null, arguments));
                    if (y < 1970) {
                        date.setUTCFullYear(y);
                    }
                    return date;
                }

                function parseWeekday(input, locale) {
                    if (typeof input === 'string') {
                        if (!isNaN(input)) {
                            input = parseInt(input, 10);
                        } else {
                            input = locale.weekdaysParse(input);
                            if (typeof input !== 'number') {
                                return null;
                            }
                        }
                    }
                    return input;
                }

                /************************************
                    Relative Time
                ************************************/


                // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
                function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
                }

                function relativeTime(posNegDuration, withoutSuffix, locale) {
                    var duration = moment.duration(posNegDuration).abs(),
                        seconds = round(duration.as('s')),
                        minutes = round(duration.as('m')),
                        hours = round(duration.as('h')),
                        days = round(duration.as('d')),
                        months = round(duration.as('M')),
                        years = round(duration.as('y')),

                        args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                        minutes === 1 && ['m'] ||
                        minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                        hours === 1 && ['h'] ||
                        hours < relativeTimeThresholds.h && ['hh', hours] ||
                        days === 1 && ['d'] ||
                        days < relativeTimeThresholds.d && ['dd', days] ||
                        months === 1 && ['M'] ||
                        months < relativeTimeThresholds.M && ['MM', months] ||
                        years === 1 && ['y'] || ['yy', years];

                    args[2] = withoutSuffix;
                    args[3] = +posNegDuration > 0;
                    args[4] = locale;
                    return substituteTimeAgo.apply({}, args);
                }


                /************************************
                    Week of Year
                ************************************/


                // firstDayOfWeek       0 = sun, 6 = sat
                //                      the day of the week that starts the week
                //                      (usually sunday or monday)
                // firstDayOfWeekOfYear 0 = sun, 6 = sat
                //                      the first week is the week that contains the first
                //                      of this day of the week
                //                      (eg. ISO weeks use thursday (4))
                function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
                    var end = firstDayOfWeekOfYear - firstDayOfWeek,
                        daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
                        adjustedMoment;


                    if (daysToDayOfWeek > end) {
                        daysToDayOfWeek -= 7;
                    }

                    if (daysToDayOfWeek < end - 7) {
                        daysToDayOfWeek += 7;
                    }

                    adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
                    return {
                        week: Math.ceil(adjustedMoment.dayOfYear() / 7),
                        year: adjustedMoment.year()
                    };
                }

                //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
                function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
                    var d = makeUTCDate(year, 0, 1).getUTCDay(),
                        daysToAdd, dayOfYear;

                    d = d === 0 ? 7 : d;
                    weekday = weekday != null ? weekday : firstDayOfWeek;
                    daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
                    dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

                    return {
                        year: dayOfYear > 0 ? year : year - 1,
                        dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
                    };
                }

                /************************************
                    Top Level Functions
                ************************************/

                function makeMoment(config) {
                    var input = config._i,
                        format = config._f;

                    config._locale = config._locale || moment.localeData(config._l);

                    if (input === null || (format === undefined && input === '')) {
                        return moment.invalid({
                            nullInput: true
                        });
                    }

                    if (typeof input === 'string') {
                        config._i = input = config._locale.preparse(input);
                    }

                    if (moment.isMoment(input)) {
                        return new Moment(input, true);
                    } else if (format) {
                        if (isArray(format)) {
                            makeDateFromStringAndArray(config);
                        } else {
                            makeDateFromStringAndFormat(config);
                        }
                    } else {
                        makeDateFromInput(config);
                    }

                    return new Moment(config);
                }

                moment = function(input, format, locale, strict) {
                    var c;

                    if (typeof(locale) === 'boolean') {
                        strict = locale;
                        locale = undefined;
                    }
                    // object construction must be done this way.
                    // https://github.com/moment/moment/issues/1423
                    c = {};
                    c._isAMomentObject = true;
                    c._i = input;
                    c._f = format;
                    c._l = locale;
                    c._strict = strict;
                    c._isUTC = false;
                    c._pf = defaultParsingFlags();

                    return makeMoment(c);
                };

                moment.suppressDeprecationWarnings = false;

                moment.createFromInputFallback = deprecate(
                    'moment construction falls back to js Date. This is ' +
                    'discouraged and will be removed in upcoming major ' +
                    'release. Please refer to ' +
                    'https://github.com/moment/moment/issues/1407 for more info.',
                    function(config) {
                        config._d = new Date(config._i);
                    }
                );

                // Pick a moment m from moments so that m[fn](other) is true for all
                // other. This relies on the function fn to be transitive.
                //
                // moments should either be an array of moment objects or an array, whose
                // first element is an array of moment objects.
                function pickBy(fn, moments) {
                    var res, i;
                    if (moments.length === 1 && isArray(moments[0])) {
                        moments = moments[0];
                    }
                    if (!moments.length) {
                        return moment();
                    }
                    res = moments[0];
                    for (i = 1; i < moments.length; ++i) {
                        if (moments[i][fn](res)) {
                            res = moments[i];
                        }
                    }
                    return res;
                }

                moment.min = function() {
                    var args = [].slice.call(arguments, 0);

                    return pickBy('isBefore', args);
                };

                moment.max = function() {
                    var args = [].slice.call(arguments, 0);

                    return pickBy('isAfter', args);
                };

                // creating with utc
                moment.utc = function(input, format, locale, strict) {
                    var c;

                    if (typeof(locale) === 'boolean') {
                        strict = locale;
                        locale = undefined;
                    }
                    // object construction must be done this way.
                    // https://github.com/moment/moment/issues/1423
                    c = {};
                    c._isAMomentObject = true;
                    c._useUTC = true;
                    c._isUTC = true;
                    c._l = locale;
                    c._i = input;
                    c._f = format;
                    c._strict = strict;
                    c._pf = defaultParsingFlags();

                    return makeMoment(c).utc();
                };

                // creating with unix timestamp (in seconds)
                moment.unix = function(input) {
                    return moment(input * 1000);
                };

                // duration
                moment.duration = function(input, key) {
                    var duration = input,
                        // matching against regexp is expensive, do it on demand
                        match = null,
                        sign,
                        ret,
                        parseIso,
                        diffRes;

                    if (moment.isDuration(input)) {
                        duration = {
                            ms: input._milliseconds,
                            d: input._days,
                            M: input._months
                        };
                    } else if (typeof input === 'number') {
                        duration = {};
                        if (key) {
                            duration[key] = input;
                        } else {
                            duration.milliseconds = input;
                        }
                    } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
                        sign = (match[1] === '-') ? -1 : 1;
                        duration = {
                            y: 0,
                            d: toInt(match[DATE]) * sign,
                            h: toInt(match[HOUR]) * sign,
                            m: toInt(match[MINUTE]) * sign,
                            s: toInt(match[SECOND]) * sign,
                            ms: toInt(match[MILLISECOND]) * sign
                        };
                    } else if (!!(match = isoDurationRegex.exec(input))) {
                        sign = (match[1] === '-') ? -1 : 1;
                        parseIso = function(inp) {
                            // We'd normally use ~~inp for this, but unfortunately it also
                            // converts floats to ints.
                            // inp may be undefined, so careful calling replace on it.
                            var res = inp && parseFloat(inp.replace(',', '.'));
                            // apply sign while we're at it
                            return (isNaN(res) ? 0 : res) * sign;
                        };
                        duration = {
                            y: parseIso(match[2]),
                            M: parseIso(match[3]),
                            d: parseIso(match[4]),
                            h: parseIso(match[5]),
                            m: parseIso(match[6]),
                            s: parseIso(match[7]),
                            w: parseIso(match[8])
                        };
                    } else if (typeof duration === 'object' &&
                        ('from' in duration || 'to' in duration)) {
                        diffRes = momentsDifference(moment(duration.from), moment(duration.to));

                        duration = {};
                        duration.ms = diffRes.milliseconds;
                        duration.M = diffRes.months;
                    }

                    ret = new Duration(duration);

                    if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
                        ret._locale = input._locale;
                    }

                    return ret;
                };

                // version number
                moment.version = VERSION;

                // default format
                moment.defaultFormat = isoFormat;

                // constant that refers to the ISO standard
                moment.ISO_8601 = function() {};

                // Plugins that add properties should also add the key here (null value),
                // so we can properly clone ourselves.
                moment.momentProperties = momentProperties;

                // This function will be called whenever a moment is mutated.
                // It is intended to keep the offset in sync with the timezone.
                moment.updateOffset = function() {};

                // This function allows you to set a threshold for relative time strings
                moment.relativeTimeThreshold = function(threshold, limit) {
                    if (relativeTimeThresholds[threshold] === undefined) {
                        return false;
                    }
                    if (limit === undefined) {
                        return relativeTimeThresholds[threshold];
                    }
                    relativeTimeThresholds[threshold] = limit;
                    return true;
                };

                moment.lang = deprecate(
                    'moment.lang is deprecated. Use moment.locale instead.',
                    function(key, value) {
                        return moment.locale(key, value);
                    }
                );

                // This function will load locale and then set the global locale.  If
                // no arguments are passed in, it will simply return the current global
                // locale key.
                moment.locale = function(key, values) {
                    var data;
                    if (key) {
                        if (typeof(values) !== 'undefined') {
                            data = moment.defineLocale(key, values);
                        } else {
                            data = moment.localeData(key);
                        }

                        if (data) {
                            moment.duration._locale = moment._locale = data;
                        }
                    }

                    return moment._locale._abbr;
                };

                moment.defineLocale = function(name, values) {
                    if (values !== null) {
                        values.abbr = name;
                        if (!locales[name]) {
                            locales[name] = new Locale();
                        }
                        locales[name].set(values);

                        // backwards compat for now: also set the locale
                        moment.locale(name);

                        return locales[name];
                    } else {
                        // useful for testing
                        delete locales[name];
                        return null;
                    }
                };

                moment.langData = deprecate(
                    'moment.langData is deprecated. Use moment.localeData instead.',
                    function(key) {
                        return moment.localeData(key);
                    }
                );

                // returns locale data
                moment.localeData = function(key) {
                    var locale;

                    if (key && key._locale && key._locale._abbr) {
                        key = key._locale._abbr;
                    }

                    if (!key) {
                        return moment._locale;
                    }

                    if (!isArray(key)) {
                        //short-circuit everything else
                        locale = loadLocale(key);
                        if (locale) {
                            return locale;
                        }
                        key = [key];
                    }

                    return chooseLocale(key);
                };

                // compare moment object
                moment.isMoment = function(obj) {
                    return obj instanceof Moment ||
                        (obj != null && hasOwnProp(obj, '_isAMomentObject'));
                };

                // for typechecking Duration objects
                moment.isDuration = function(obj) {
                    return obj instanceof Duration;
                };

                for (i = lists.length - 1; i >= 0; --i) {
                    makeList(lists[i]);
                }

                moment.normalizeUnits = function(units) {
                    return normalizeUnits(units);
                };

                moment.invalid = function(flags) {
                    var m = moment.utc(NaN);
                    if (flags != null) {
                        extend(m._pf, flags);
                    } else {
                        m._pf.userInvalidated = true;
                    }

                    return m;
                };

                moment.parseZone = function() {
                    return moment.apply(null, arguments).parseZone();
                };

                moment.parseTwoDigitYear = function(input) {
                    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
                };

                /************************************
                    Moment Prototype
                ************************************/


                extend(moment.fn = Moment.prototype, {

                    clone: function() {
                        return moment(this);
                    },

                    valueOf: function() {
                        return +this._d + ((this._offset || 0) * 60000);
                    },

                    unix: function() {
                        return Math.floor(+this / 1000);
                    },

                    toString: function() {
                        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
                    },

                    toDate: function() {
                        return this._offset ? new Date(+this) : this._d;
                    },

                    toISOString: function() {
                        var m = moment(this).utc();
                        if (0 < m.year() && m.year() <= 9999) {
                            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                        } else {
                            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                        }
                    },

                    toArray: function() {
                        var m = this;
                        return [
                            m.year(),
                            m.month(),
                            m.date(),
                            m.hours(),
                            m.minutes(),
                            m.seconds(),
                            m.milliseconds()
                        ];
                    },

                    isValid: function() {
                        return isValid(this);
                    },

                    isDSTShifted: function() {
                        if (this._a) {
                            return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
                        }

                        return false;
                    },

                    parsingFlags: function() {
                        return extend({}, this._pf);
                    },

                    invalidAt: function() {
                        return this._pf.overflow;
                    },

                    utc: function(keepLocalTime) {
                        return this.zone(0, keepLocalTime);
                    },

                    local: function(keepLocalTime) {
                        if (this._isUTC) {
                            this.zone(0, keepLocalTime);
                            this._isUTC = false;

                            if (keepLocalTime) {
                                this.add(this._dateTzOffset(), 'm');
                            }
                        }
                        return this;
                    },

                    format: function(inputString) {
                        var output = formatMoment(this, inputString || moment.defaultFormat);
                        return this.localeData().postformat(output);
                    },

                    add: createAdder(1, 'add'),

                    subtract: createAdder(-1, 'subtract'),

                    diff: function(input, units, asFloat) {
                        var that = makeAs(input, this),
                            zoneDiff = (this.zone() - that.zone()) * 6e4,
                            diff, output, daysAdjust;

                        units = normalizeUnits(units);

                        if (units === 'year' || units === 'month') {
                            // average number of days in the months in the given dates
                            diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                            // difference in months
                            output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                            // adjust by taking difference in days, average number of days
                            // and dst in the given months.
                            daysAdjust = (this - moment(this).startOf('month')) -
                                (that - moment(that).startOf('month'));
                            // same as above but with zones, to negate all dst
                            daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -
                                (that.zone() - moment(that).startOf('month').zone())) * 6e4;
                            output += daysAdjust / diff;
                            if (units === 'year') {
                                output = output / 12;
                            }
                        } else {
                            diff = (this - that);
                            output = units === 'second' ? diff / 1e3 : // 1000
                                units === 'minute' ? diff / 6e4 : // 1000 * 60
                                units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                                units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                diff;
                        }
                        return asFloat ? output : absRound(output);
                    },

                    from: function(time, withoutSuffix) {
                        return moment.duration({
                            to: this,
                            from: time
                        }).locale(this.locale()).humanize(!withoutSuffix);
                    },

                    fromNow: function(withoutSuffix) {
                        return this.from(moment(), withoutSuffix);
                    },

                    calendar: function(time) {
                        // We want to compare the start of today, vs this.
                        // Getting start-of-today depends on whether we're zone'd or not.
                        var now = time || moment(),
                            sod = makeAs(now, this).startOf('day'),
                            diff = this.diff(sod, 'days', true),
                            format = diff < -6 ? 'sameElse' :
                            diff < -1 ? 'lastWeek' :
                            diff < 0 ? 'lastDay' :
                            diff < 1 ? 'sameDay' :
                            diff < 2 ? 'nextDay' :
                            diff < 7 ? 'nextWeek' : 'sameElse';
                        return this.format(this.localeData().calendar(format, this));
                    },

                    isLeapYear: function() {
                        return isLeapYear(this.year());
                    },

                    isDST: function() {
                        return (this.zone() < this.clone().month(0).zone() ||
                            this.zone() < this.clone().month(5).zone());
                    },

                    day: function(input) {
                        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                        if (input != null) {
                            input = parseWeekday(input, this.localeData());
                            return this.add(input - day, 'd');
                        } else {
                            return day;
                        }
                    },

                    month: makeAccessor('Month', true),

                    startOf: function(units) {
                        units = normalizeUnits(units);
                        // the following switch intentionally omits break keywords
                        // to utilize falling through the cases.
                        switch (units) {
                            case 'year':
                                this.month(0);
                                /* falls through */
                            case 'quarter':
                            case 'month':
                                this.date(1);
                                /* falls through */
                            case 'week':
                            case 'isoWeek':
                            case 'day':
                                this.hours(0);
                                /* falls through */
                            case 'hour':
                                this.minutes(0);
                                /* falls through */
                            case 'minute':
                                this.seconds(0);
                                /* falls through */
                            case 'second':
                                this.milliseconds(0);
                                /* falls through */
                        }

                        // weeks are a special case
                        if (units === 'week') {
                            this.weekday(0);
                        } else if (units === 'isoWeek') {
                            this.isoWeekday(1);
                        }

                        // quarters are also special
                        if (units === 'quarter') {
                            this.month(Math.floor(this.month() / 3) * 3);
                        }

                        return this;
                    },

                    endOf: function(units) {
                        units = normalizeUnits(units);
                        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
                    },

                    isAfter: function(input, units) {
                        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
                        if (units === 'millisecond') {
                            input = moment.isMoment(input) ? input : moment(input);
                            return +this > +input;
                        } else {
                            return +this.clone().startOf(units) > +moment(input).startOf(units);
                        }
                    },

                    isBefore: function(input, units) {
                        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
                        if (units === 'millisecond') {
                            input = moment.isMoment(input) ? input : moment(input);
                            return +this < +input;
                        } else {
                            return +this.clone().startOf(units) < +moment(input).startOf(units);
                        }
                    },

                    isSame: function(input, units) {
                        units = normalizeUnits(units || 'millisecond');
                        if (units === 'millisecond') {
                            input = moment.isMoment(input) ? input : moment(input);
                            return +this === +input;
                        } else {
                            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
                        }
                    },

                    min: deprecate(
                        'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
                        function(other) {
                            other = moment.apply(null, arguments);
                            return other < this ? this : other;
                        }
                    ),

                    max: deprecate(
                        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
                        function(other) {
                            other = moment.apply(null, arguments);
                            return other > this ? this : other;
                        }
                    ),

                    // keepLocalTime = true means only change the timezone, without
                    // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
                    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
                    // +0200, so we adjust the time as needed, to be valid.
                    //
                    // Keeping the time actually adds/subtracts (one hour)
                    // from the actual represented time. That is why we call updateOffset
                    // a second time. In case it wants us to change the offset again
                    // _changeInProgress == true case, then we have to adjust, because
                    // there is no such time in the given timezone.
                    zone: function(input, keepLocalTime) {
                        var offset = this._offset || 0,
                            localAdjust;
                        if (input != null) {
                            if (typeof input === 'string') {
                                input = timezoneMinutesFromString(input);
                            }
                            if (Math.abs(input) < 16) {
                                input = input * 60;
                            }
                            if (!this._isUTC && keepLocalTime) {
                                localAdjust = this._dateTzOffset();
                            }
                            this._offset = input;
                            this._isUTC = true;
                            if (localAdjust != null) {
                                this.subtract(localAdjust, 'm');
                            }
                            if (offset !== input) {
                                if (!keepLocalTime || this._changeInProgress) {
                                    addOrSubtractDurationFromMoment(this,
                                        moment.duration(offset - input, 'm'), 1, false);
                                } else if (!this._changeInProgress) {
                                    this._changeInProgress = true;
                                    moment.updateOffset(this, true);
                                    this._changeInProgress = null;
                                }
                            }
                        } else {
                            return this._isUTC ? offset : this._dateTzOffset();
                        }
                        return this;
                    },

                    zoneAbbr: function() {
                        return this._isUTC ? 'UTC' : '';
                    },

                    zoneName: function() {
                        return this._isUTC ? 'Coordinated Universal Time' : '';
                    },

                    parseZone: function() {
                        if (this._tzm) {
                            this.zone(this._tzm);
                        } else if (typeof this._i === 'string') {
                            this.zone(this._i);
                        }
                        return this;
                    },

                    hasAlignedHourOffset: function(input) {
                        if (!input) {
                            input = 0;
                        } else {
                            input = moment(input).zone();
                        }

                        return (this.zone() - input) % 60 === 0;
                    },

                    daysInMonth: function() {
                        return daysInMonth(this.year(), this.month());
                    },

                    dayOfYear: function(input) {
                        var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
                        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
                    },

                    quarter: function(input) {
                        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
                    },

                    weekYear: function(input) {
                        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
                        return input == null ? year : this.add((input - year), 'y');
                    },

                    isoWeekYear: function(input) {
                        var year = weekOfYear(this, 1, 4).year;
                        return input == null ? year : this.add((input - year), 'y');
                    },

                    week: function(input) {
                        var week = this.localeData().week(this);
                        return input == null ? week : this.add((input - week) * 7, 'd');
                    },

                    isoWeek: function(input) {
                        var week = weekOfYear(this, 1, 4).week;
                        return input == null ? week : this.add((input - week) * 7, 'd');
                    },

                    weekday: function(input) {
                        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                        return input == null ? weekday : this.add(input - weekday, 'd');
                    },

                    isoWeekday: function(input) {
                        // behaves the same as moment#day except
                        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
                        // as a setter, sunday should belong to the previous week.
                        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
                    },

                    isoWeeksInYear: function() {
                        return weeksInYear(this.year(), 1, 4);
                    },

                    weeksInYear: function() {
                        var weekInfo = this.localeData()._week;
                        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                    },

                    get: function(units) {
                        units = normalizeUnits(units);
                        return this[units]();
                    },

                    set: function(units, value) {
                        units = normalizeUnits(units);
                        if (typeof this[units] === 'function') {
                            this[units](value);
                        }
                        return this;
                    },

                    // If passed a locale key, it will set the locale for this
                    // instance.  Otherwise, it will return the locale configuration
                    // variables for this instance.
                    locale: function(key) {
                        var newLocaleData;

                        if (key === undefined) {
                            return this._locale._abbr;
                        } else {
                            newLocaleData = moment.localeData(key);
                            if (newLocaleData != null) {
                                this._locale = newLocaleData;
                            }
                            return this;
                        }
                    },

                    lang: deprecate(
                        'moment().lang() is deprecated. Use moment().localeData() instead.',
                        function(key) {
                            if (key === undefined) {
                                return this.localeData();
                            } else {
                                return this.locale(key);
                            }
                        }
                    ),

                    localeData: function() {
                        return this._locale;
                    },

                    _dateTzOffset: function() {
                        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
                        // https://github.com/moment/moment/pull/1871
                        return Math.round(this._d.getTimezoneOffset() / 15) * 15;
                    }
                });

                function rawMonthSetter(mom, value) {
                    var dayOfMonth;

                    // TODO: Move this out of here!
                    if (typeof value === 'string') {
                        value = mom.localeData().monthsParse(value);
                        // TODO: Another silent failure?
                        if (typeof value !== 'number') {
                            return mom;
                        }
                    }

                    dayOfMonth = Math.min(mom.date(),
                        daysInMonth(mom.year(), value));
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
                    return mom;
                }

                function rawGetter(mom, unit) {
                    return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
                }

                function rawSetter(mom, unit, value) {
                    if (unit === 'Month') {
                        return rawMonthSetter(mom, value);
                    } else {
                        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                    }
                }

                function makeAccessor(unit, keepTime) {
                    return function(value) {
                        if (value != null) {
                            rawSetter(this, unit, value);
                            moment.updateOffset(this, keepTime);
                            return this;
                        } else {
                            return rawGetter(this, unit);
                        }
                    };
                }

                moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
                moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
                moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
                // Setting the hour should keep the time, because the user explicitly
                // specified which hour he wants. So trying to maintain the same hour (in
                // a new timezone) makes sense. Adding/subtracting hours does not follow
                // this rule.
                moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
                // moment.fn.month is defined separately
                moment.fn.date = makeAccessor('Date', true);
                moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
                moment.fn.year = makeAccessor('FullYear', true);
                moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

                // add plural methods
                moment.fn.days = moment.fn.day;
                moment.fn.months = moment.fn.month;
                moment.fn.weeks = moment.fn.week;
                moment.fn.isoWeeks = moment.fn.isoWeek;
                moment.fn.quarters = moment.fn.quarter;

                // add aliased format methods
                moment.fn.toJSON = moment.fn.toISOString;

                /************************************
                    Duration Prototype
                ************************************/


                function daysToYears(days) {
                    // 400 years have 146097 days (taking into account leap year rules)
                    return days * 400 / 146097;
                }

                function yearsToDays(years) {
                    // years * 365 + absRound(years / 4) -
                    //     absRound(years / 100) + absRound(years / 400);
                    return years * 146097 / 400;
                }

                extend(moment.duration.fn = Duration.prototype, {

                    _bubble: function() {
                        var milliseconds = this._milliseconds,
                            days = this._days,
                            months = this._months,
                            data = this._data,
                            seconds, minutes, hours, years = 0;

                        // The following code bubbles up values, see the tests for
                        // examples of what that means.
                        data.milliseconds = milliseconds % 1000;

                        seconds = absRound(milliseconds / 1000);
                        data.seconds = seconds % 60;

                        minutes = absRound(seconds / 60);
                        data.minutes = minutes % 60;

                        hours = absRound(minutes / 60);
                        data.hours = hours % 24;

                        days += absRound(hours / 24);

                        // Accurately convert days to years, assume start from year 0.
                        years = absRound(daysToYears(days));
                        days -= absRound(yearsToDays(years));

                        // 30 days to a month
                        // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
                        months += absRound(days / 30);
                        days %= 30;

                        // 12 months -> 1 year
                        years += absRound(months / 12);
                        months %= 12;

                        data.days = days;
                        data.months = months;
                        data.years = years;
                    },

                    abs: function() {
                        this._milliseconds = Math.abs(this._milliseconds);
                        this._days = Math.abs(this._days);
                        this._months = Math.abs(this._months);

                        this._data.milliseconds = Math.abs(this._data.milliseconds);
                        this._data.seconds = Math.abs(this._data.seconds);
                        this._data.minutes = Math.abs(this._data.minutes);
                        this._data.hours = Math.abs(this._data.hours);
                        this._data.months = Math.abs(this._data.months);
                        this._data.years = Math.abs(this._data.years);

                        return this;
                    },

                    weeks: function() {
                        return absRound(this.days() / 7);
                    },

                    valueOf: function() {
                        return this._milliseconds +
                            this._days * 864e5 +
                            (this._months % 12) * 2592e6 +
                            toInt(this._months / 12) * 31536e6;
                    },

                    humanize: function(withSuffix) {
                        var output = relativeTime(this, !withSuffix, this.localeData());

                        if (withSuffix) {
                            output = this.localeData().pastFuture(+this, output);
                        }

                        return this.localeData().postformat(output);
                    },

                    add: function(input, val) {
                        // supports only 2.0-style add(1, 's') or add(moment)
                        var dur = moment.duration(input, val);

                        this._milliseconds += dur._milliseconds;
                        this._days += dur._days;
                        this._months += dur._months;

                        this._bubble();

                        return this;
                    },

                    subtract: function(input, val) {
                        var dur = moment.duration(input, val);

                        this._milliseconds -= dur._milliseconds;
                        this._days -= dur._days;
                        this._months -= dur._months;

                        this._bubble();

                        return this;
                    },

                    get: function(units) {
                        units = normalizeUnits(units);
                        return this[units.toLowerCase() + 's']();
                    },

                    as: function(units) {
                        var days, months;
                        units = normalizeUnits(units);

                        if (units === 'month' || units === 'year') {
                            days = this._days + this._milliseconds / 864e5;
                            months = this._months + daysToYears(days) * 12;
                            return units === 'month' ? months : months / 12;
                        } else {
                            // handle milliseconds separately because of floating point math errors (issue #1867)
                            days = this._days + yearsToDays(this._months / 12);
                            switch (units) {
                                case 'week':
                                    return days / 7 + this._milliseconds / 6048e5;
                                case 'day':
                                    return days + this._milliseconds / 864e5;
                                case 'hour':
                                    return days * 24 + this._milliseconds / 36e5;
                                case 'minute':
                                    return days * 24 * 60 + this._milliseconds / 6e4;
                                case 'second':
                                    return days * 24 * 60 * 60 + this._milliseconds / 1000;
                                    // Math.floor prevents floating point math errors here
                                case 'millisecond':
                                    return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
                                default:
                                    throw new Error('Unknown unit ' + units);
                            }
                        }
                    },

                    lang: moment.fn.lang,
                    locale: moment.fn.locale,

                    toIsoString: deprecate(
                        'toIsoString() is deprecated. Please use toISOString() instead ' +
                        '(notice the capitals)',
                        function() {
                            return this.toISOString();
                        }
                    ),

                    toISOString: function() {
                        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
                        var years = Math.abs(this.years()),
                            months = Math.abs(this.months()),
                            days = Math.abs(this.days()),
                            hours = Math.abs(this.hours()),
                            minutes = Math.abs(this.minutes()),
                            seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

                        if (!this.asSeconds()) {
                            // this is the same as C#'s (Noda) and python (isodate)...
                            // but not other JS (goog.date)
                            return 'P0D';
                        }

                        return (this.asSeconds() < 0 ? '-' : '') +
                            'P' +
                            (years ? years + 'Y' : '') +
                            (months ? months + 'M' : '') +
                            (days ? days + 'D' : '') +
                            ((hours || minutes || seconds) ? 'T' : '') +
                            (hours ? hours + 'H' : '') +
                            (minutes ? minutes + 'M' : '') +
                            (seconds ? seconds + 'S' : '');
                    },

                    localeData: function() {
                        return this._locale;
                    }
                });

                moment.duration.fn.toString = moment.duration.fn.toISOString;

                function makeDurationGetter(name) {
                    moment.duration.fn[name] = function() {
                        return this._data[name];
                    };
                }

                for (i in unitMillisecondFactors) {
                    if (hasOwnProp(unitMillisecondFactors, i)) {
                        makeDurationGetter(i.toLowerCase());
                    }
                }

                moment.duration.fn.asMilliseconds = function() {
                    return this.as('ms');
                };
                moment.duration.fn.asSeconds = function() {
                    return this.as('s');
                };
                moment.duration.fn.asMinutes = function() {
                    return this.as('m');
                };
                moment.duration.fn.asHours = function() {
                    return this.as('h');
                };
                moment.duration.fn.asDays = function() {
                    return this.as('d');
                };
                moment.duration.fn.asWeeks = function() {
                    return this.as('weeks');
                };
                moment.duration.fn.asMonths = function() {
                    return this.as('M');
                };
                moment.duration.fn.asYears = function() {
                    return this.as('y');
                };

                /************************************
                    Default Locale
                ************************************/


                // Set default locale, other locale will inherit from English.
                moment.locale('en', {
                    ordinal: function(number) {
                        var b = number % 10,
                            output = (toInt(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                            (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
                        return number + output;
                    }
                });

                /* EMBED_LOCALES */

                /************************************
                    Exposing Moment
                ************************************/

                function makeGlobal(shouldDeprecate) {
                    /*global ender:false */
                    if (typeof ender !== 'undefined') {
                        return;
                    }
                    oldGlobalMoment = globalScope.moment;
                    if (shouldDeprecate) {
                        globalScope.moment = deprecate(
                            'Accessing Moment through the global scope is ' +
                            'deprecated, and will be removed in an upcoming ' +
                            'release.',
                            moment);
                    } else {
                        globalScope.moment = moment;
                    }
                }

                // CommonJS module is defined
                if (hasModule) {
                    module.exports = moment;
                } else if (true) {
                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
                            if (module.config && module.config() && module.config().noGlobal === true) {
                                // release the global variable
                                globalScope.moment = oldGlobalMoment;
                            }

                            return moment;
                        }.call(exports, __webpack_require__, exports, module),
                        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    makeGlobal(true);
                } else {
                    makeGlobal();
                }
            }).call(this);

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(4), __webpack_require__(10)(module)))

        /***/
    }),
    /* 1 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__eval_pegjs__ = __webpack_require__(31);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__eval_pegjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__eval_pegjs__);


        var styleparser = {};
        styleparser.Style = function() {
            this.__init__();
        };

        styleparser.Style.prototype = {
            merged: false,
            edited: false,
            //sublayer: 5, // TODO: commented out. see RuleSet.js
            //interactive: true, // TODO: commented out. see RuleSet.js
            properties: [],
            styleType: "Style",
            evals: null,

            __init__: function() {
                this.evals = {};
            },

            drawn: function() {
                return false;
            },

            has: function(k) {
                return this.properties.indexOf(k) > -1;
            },

            mergeWith: function(additional) {
                for (var prop in this.properties) {
                    if (additional[prop]) {
                        this[prop] = additional[prop];
                    }
                }
                this.merged = true;
            },

            setPropertyFromString: function(k, v, isEval) {
                this.edited = true;
                if (isEval) {
                    this.evals[k] = v;
                    return;
                }

                if (typeof this[k] == "boolean") {
                    v = Boolean(v);
                } else if (typeof this[k] == "number") {
                    v = Number(v);
                } else if (this[k] && this[k].constructor == Array) {
                    v = v.split(",").map(function(a) {
                        return Number(a);
                    });
                }
                this[k] = v;
                return true;
            },

            runEvals: function(tags) {
                // helper object for eval() properties
                for (var k in this.evals) {
                    try {
                        __WEBPACK_IMPORTED_MODULE_0__eval_pegjs___default.a.tag = function(t) {
                            return tags[t] || "";
                        };
                        this.setPropertyFromString(k, __WEBPACK_IMPORTED_MODULE_0__eval_pegjs___default.a.parse(this.evals[k]));
                    } catch (e) {
                        console.error("Error while evaluating mapcss evals", e);
                    }
                }
            },

            toString: function() {
                var str = "";
                for (var k in this.properties) {
                    if (this.hasOwnProperty(k)) {
                        str += k + "=" + this[k] + "; ";
                    }
                }
                return str;
            }
        };
        styleparser.inherit_from_Style = function(target) {
            for (var p in styleparser.Style.prototype)
                if (target[p] === undefined) target[p] = styleparser.Style.prototype[p];
        };

        // ----------------------------------------------------------------------
        // InstructionStyle class

        styleparser.InstructionStyle = function() {
            this.__init__();
        };
        styleparser.InstructionStyle.prototype = {
            set_tags: null,
            breaker: false,
            styleType: "InstructionStyle",

            __init__: function() {},

            addSetTag: function(k, v) {
                this.edited = true;
                if (!this.set_tags) this.set_tags = {};
                this.set_tags[k] = v;
            }
        };
        styleparser.inherit_from_Style(styleparser.InstructionStyle.prototype);

        // ----------------------------------------------------------------------
        // PointStyle class

        styleparser.PointStyle = function() {
            this.__init__();
        };
        styleparser.PointStyle.prototype = {
            properties: [
                "icon_image",
                "icon_width",
                "icon_height",
                "icon_opacity",
                "rotation"
            ],
            icon_image: null,
            icon_width: 0,
            icon_height: NaN,
            rotation: NaN,
            styleType: "PointStyle",

            drawn: function() {
                return this.icon_image !== null;
            },

            maxwidth: function() {
                return this.evals.icon_width ? 0 : this.icon_width;
            }
        };
        styleparser.inherit_from_Style(styleparser.PointStyle.prototype);

        // ----------------------------------------------------------------------
        // ShapeStyle class

        styleparser.ShapeStyle = function() {
            this.__init__();
        };

        styleparser.ShapeStyle.prototype = {
            properties: [
                "width",
                "offset",
                "color",
                "opacity",
                "dashes",
                "linecap",
                "linejoin",
                "line_style",
                "fill_image",
                "fill_color",
                "fill_opacity",
                "casing_width",
                "casing_color",
                "casing_opacity",
                "casing_dashes",
                "layer"
            ],

            width: 0,
            color: null,
            opacity: NaN,
            dashes: [],
            linecap: null,
            linejoin: null,
            line_style: null,
            fill_image: null,
            fill_color: null,
            fill_opacity: NaN,
            casing_width: NaN,
            casing_color: null,
            casing_opacity: NaN,
            casing_dashes: [],
            layer: NaN, // optional layer override (usually set by OSM tag)
            styleType: "ShapeStyle",

            drawn: function() {
                return (
                    this.fill_image ||
                    !isNaN(this.fill_color) ||
                    this.width ||
                    this.casing_width
                );
            },
            maxwidth: function() {
                // If width is set by an eval, then we can't use it to calculate maxwidth, or it'll just grow on each invocation...
                if (this.evals.width || this.evals.casing_width) {
                    return 0;
                }
                return this.width + (this.casing_width ? this.casing_width * 2 : 0);
            },
            strokeStyler: function() {
                var cap, join;
                switch (this.linecap) {
                    case "round":
                        cap = "round";
                        break;
                    case "square":
                        cap = "square";
                        break;
                    default:
                        cap = "butt";
                        break;
                }
                switch (this.linejoin) {
                    case "bevel":
                        join = "bevel";
                        break;
                    case "miter":
                        join = 4;
                        break;
                    default:
                        join = "round";
                        break;
                }
                return {
                    color: this.dojoColor(
                        this.color ? this.color : 0,
                        this.opacity ? this.opacity : 1
                    ),
                    style: "Solid", // needs to parse dashes
                    width: this.width,
                    cap: cap,
                    join: join
                };
            },
            shapeStrokeStyler: function() {
                if (isNaN(this.casing_color)) {
                    return {
                        width: 0
                    };
                }
                return {
                    color: this.dojoColor(
                        this.casing_color,
                        this.casing_opacity ? this.casing_opacity : 1
                    ),
                    width: this.casing_width ? this.casing_width : 1
                };
            },
            shapeFillStyler: function() {
                if (isNaN(this.color)) {
                    return null;
                }
                return this.dojoColor(this.color, this.opacity ? this.opacity : 1);
            },
            fillStyler: function() {
                return this.dojoColor(
                    this.fill_color,
                    this.fill_opacity ? this.fill_opacity : 1
                );
            },
            casingStyler: function() {
                var cap, join;
                switch (this.linecap) {
                    case "round":
                        cap = "round";
                        break;
                    case "square":
                        cap = "square";
                        break;
                    default:
                        cap = "butt";
                        break;
                }
                switch (this.linejoin) {
                    case "bevel":
                        join = "bevel";
                        break;
                    case "miter":
                        join = 4;
                        break;
                    default:
                        join = "round";
                        break;
                }
                return {
                    color: this.dojoColor(
                        this.casing_color ? this.casing_color : 0,
                        this.casing_opacity ? this.casing_opacity : 1
                    ),
                    width: this.width + this.casing_width * 2,
                    style: "Solid",
                    cap: cap,
                    join: join
                };
            }
        };
        styleparser.inherit_from_Style(styleparser.ShapeStyle.prototype);

        // ----------------------------------------------------------------------
        // TextStyle class

        styleparser.TextStyle = function() {
            this.__init__();
        };
        styleparser.TextStyle.prototype = {
            properties: [
                "font_family",
                "font_bold",
                "font_italic",
                "font_caps",
                "font_underline",
                "font_size",
                "text_color",
                "text_offset",
                "max_width",
                "text",
                "text_halo_color",
                "text_halo_radius",
                "text_center",
                "letter_spacing"
            ],
            // TODO: font_bold??? wtf? -> support propper MapCSS properites!

            font_family: null,
            font_bold: false,
            font_italic: false,
            font_underline: false,
            font_caps: false,
            font_size: NaN,
            text_color: null,
            text_offset: NaN,
            max_width: NaN,
            text: null,
            text_halo_color: null,
            text_halo_radius: 0,
            text_center: true,
            letter_spacing: 0,
            styleType: "TextStyle",

            fontStyler: function() {
                return {
                    family: this.font_family ? this.font_family : "Arial",
                    size: this.font_size ? this.font_size * 2 : "10px",
                    weight: this.font_bold ? "bold" : "normal",
                    style: this.font_italic ? "italic" : "normal"
                };
            },
            textStyler: function(_text) {
                return {
                    decoration: this.font_underline ? "underline" : "none",
                    align: "middle",
                    text: _text
                };
            },
            fillStyler: function() {
                // not implemented yet
                return this.dojoColor(0, 1);
            }

            // getTextFormat, getHaloFilter, writeNameLabel
        };
        styleparser.inherit_from_Style(styleparser.TextStyle.prototype);

        // ----------------------------------------------------------------------
        // ShieldStyle class

        styleparser.ShieldStyle = function() {
            this.__init__();
        };

        styleparser.ShieldStyle.prototype = {
            has: function(k) {
                return this.properties.indexOf(k) > -1;
            },
            properties: ["shield_image", "shield_width", "shield_height"],
            shield_image: null,
            shield_width: NaN,
            shield_height: NaN,
            styleType: "ShieldStyle"
        };
        styleparser.inherit_from_Style(styleparser.ShieldStyle.prototype);

        // ----------------------------------------------------------------------
        // End of module

        /* harmony default export */
        __webpack_exports__["a"] = (styleparser);


        /***/
    }),
    /* 2 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * jQuery JavaScript Library v1.11.1
         * http://jquery.com/
         *
         * Includes Sizzle.js
         * http://sizzlejs.com/
         *
         * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2014-05-01T17:42Z
         */

        (function(global, factory) {

            if (typeof module === "object" && typeof module.exports === "object") {
                // For CommonJS and CommonJS-like environments where a proper window is present,
                // execute the factory and get jQuery
                // For environments that do not inherently posses a window with a document
                // (such as Node.js), expose a jQuery-making factory as module.exports
                // This accentuates the need for the creation of a real window
                // e.g. var jQuery = require("jquery")(window);
                // See ticket #14549 for more info
                module.exports = global.document ?
                    factory(global, true) :
                    function(w) {
                        if (!w.document) {
                            throw new Error("jQuery requires a window with a document");
                        }
                        return factory(w);
                    };
            } else {
                factory(global);
            }

            // Pass this if window is not defined yet
        }(typeof window !== "undefined" ? window : this, function(window, noGlobal) {

            // Can't do this because several apps including ASP.NET trace
            // the stack via arguments.caller.callee and Firefox dies if
            // you try to trace through "use strict" call chains. (#13335)
            // Support: Firefox 18+
            //

            var deletedIds = [];

            var slice = deletedIds.slice;

            var concat = deletedIds.concat;

            var push = deletedIds.push;

            var indexOf = deletedIds.indexOf;

            var class2type = {};

            var toString = class2type.toString;

            var hasOwn = class2type.hasOwnProperty;

            var support = {};



            var
                version = "1.11.1",

                // Define a local copy of jQuery
                jQuery = function(selector, context) {
                    // The jQuery object is actually just the init constructor 'enhanced'
                    // Need init if jQuery is called (just allow error to be thrown if not included)
                    return new jQuery.fn.init(selector, context);
                },

                // Support: Android<4.1, IE<9
                // Make sure we trim BOM and NBSP
                rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

                // Matches dashed string for camelizing
                rmsPrefix = /^-ms-/,
                rdashAlpha = /-([\da-z])/gi,

                // Used by jQuery.camelCase as callback to replace()
                fcamelCase = function(all, letter) {
                    return letter.toUpperCase();
                };

            jQuery.fn = jQuery.prototype = {
                // The current version of jQuery being used
                jquery: version,

                constructor: jQuery,

                // Start with an empty selector
                selector: "",

                // The default length of a jQuery object is 0
                length: 0,

                toArray: function() {
                    return slice.call(this);
                },

                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function(num) {
                    return num != null ?

                        // Return just the one element from the set
                        (num < 0 ? this[num + this.length] : this[num]) :

                        // Return all the elements in a clean array
                        slice.call(this);
                },

                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function(elems) {

                    // Build a new jQuery matched element set
                    var ret = jQuery.merge(this.constructor(), elems);

                    // Add the old object onto the stack (as a reference)
                    ret.prevObject = this;
                    ret.context = this.context;

                    // Return the newly-formed element set
                    return ret;
                },

                // Execute a callback for every element in the matched set.
                // (You can seed the arguments with an array of args, but this is
                // only used internally.)
                each: function(callback, args) {
                    return jQuery.each(this, callback, args);
                },

                map: function(callback) {
                    return this.pushStack(jQuery.map(this, function(elem, i) {
                        return callback.call(elem, i, elem);
                    }));
                },

                slice: function() {
                    return this.pushStack(slice.apply(this, arguments));
                },

                first: function() {
                    return this.eq(0);
                },

                last: function() {
                    return this.eq(-1);
                },

                eq: function(i) {
                    var len = this.length,
                        j = +i + (i < 0 ? len : 0);
                    return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
                },

                end: function() {
                    return this.prevObject || this.constructor(null);
                },

                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: push,
                sort: deletedIds.sort,
                splice: deletedIds.splice
            };

            jQuery.extend = jQuery.fn.extend = function() {
                var src, copyIsArray, copy, name, options, clone,
                    target = arguments[0] || {},
                    i = 1,
                    length = arguments.length,
                    deep = false;

                // Handle a deep copy situation
                if (typeof target === "boolean") {
                    deep = target;

                    // skip the boolean and the target
                    target = arguments[i] || {};
                    i++;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if (typeof target !== "object" && !jQuery.isFunction(target)) {
                    target = {};
                }

                // extend jQuery itself if only one argument is passed
                if (i === length) {
                    target = this;
                    i--;
                }

                for (; i < length; i++) {
                    // Only deal with non-null/undefined values
                    if ((options = arguments[i]) != null) {
                        // Extend the base object
                        for (name in options) {
                            src = target[name];
                            copy = options[name];

                            // Prevent never-ending loop
                            if (target === copy) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray(src) ? src : [];

                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[name] = jQuery.extend(deep, clone, copy);

                                // Don't bring in undefined values
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            jQuery.extend({
                // Unique for each copy of jQuery on the page
                expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

                // Assume jQuery is ready without the ready module
                isReady: true,

                error: function(msg) {
                    throw new Error(msg);
                },

                noop: function() {},

                // See test/unit/core.js for details concerning isFunction.
                // Since version 1.3, DOM methods and functions like alert
                // aren't supported. They return false on IE (#2968).
                isFunction: function(obj) {
                    return jQuery.type(obj) === "function";
                },

                isArray: Array.isArray || function(obj) {
                    return jQuery.type(obj) === "array";
                },

                isWindow: function(obj) {
                    /* jshint eqeqeq: false */
                    return obj != null && obj == obj.window;
                },

                isNumeric: function(obj) {
                    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                    // subtraction forces infinities to NaN
                    return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;
                },

                isEmptyObject: function(obj) {
                    var name;
                    for (name in obj) {
                        return false;
                    }
                    return true;
                },

                isPlainObject: function(obj) {
                    var key;

                    // Must be an Object.
                    // Because of IE, we also have to check the presence of the constructor property.
                    // Make sure that DOM nodes and window objects don't pass through, as well
                    if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                        return false;
                    }

                    try {
                        // Not own constructor property must be Object
                        if (obj.constructor &&
                            !hasOwn.call(obj, "constructor") &&
                            !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                            return false;
                        }
                    } catch (e) {
                        // IE8,9 Will throw exceptions on certain host objects #9897
                        return false;
                    }

                    // Support: IE<9
                    // Handle iteration over inherited properties before own properties.
                    if (support.ownLast) {
                        for (key in obj) {
                            return hasOwn.call(obj, key);
                        }
                    }

                    // Own properties are enumerated firstly, so to speed up,
                    // if last one is own, then all properties are own.
                    for (key in obj) {}

                    return key === undefined || hasOwn.call(obj, key);
                },

                type: function(obj) {
                    if (obj == null) {
                        return obj + "";
                    }
                    return typeof obj === "object" || typeof obj === "function" ?
                        class2type[toString.call(obj)] || "object" :
                        typeof obj;
                },

                // Evaluates a script in a global context
                // Workarounds based on findings by Jim Driscoll
                // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
                globalEval: function(data) {
                    if (data && jQuery.trim(data)) {
                        // We use execScript on Internet Explorer
                        // We use an anonymous function so that context is window
                        // rather than jQuery in Firefox
                        (window.execScript || function(data) {
                            window["eval"].call(window, data);
                        })(data);
                    }
                },

                // Convert dashed to camelCase; used by the css and data modules
                // Microsoft forgot to hump their vendor prefix (#9572)
                camelCase: function(string) {
                    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
                },

                nodeName: function(elem, name) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                },

                // args is for internal usage only
                each: function(obj, callback, args) {
                    var value,
                        i = 0,
                        length = obj.length,
                        isArray = isArraylike(obj);

                    if (args) {
                        if (isArray) {
                            for (; i < length; i++) {
                                value = callback.apply(obj[i], args);

                                if (value === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                value = callback.apply(obj[i], args);

                                if (value === false) {
                                    break;
                                }
                            }
                        }

                        // A special, fast, case for the most common use of each
                    } else {
                        if (isArray) {
                            for (; i < length; i++) {
                                value = callback.call(obj[i], i, obj[i]);

                                if (value === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                value = callback.call(obj[i], i, obj[i]);

                                if (value === false) {
                                    break;
                                }
                            }
                        }
                    }

                    return obj;
                },

                // Support: Android<4.1, IE<9
                trim: function(text) {
                    return text == null ?
                        "" :
                        (text + "").replace(rtrim, "");
                },

                // results is for internal usage only
                makeArray: function(arr, results) {
                    var ret = results || [];

                    if (arr != null) {
                        if (isArraylike(Object(arr))) {
                            jQuery.merge(ret,
                                typeof arr === "string" ? [arr] : arr
                            );
                        } else {
                            push.call(ret, arr);
                        }
                    }

                    return ret;
                },

                inArray: function(elem, arr, i) {
                    var len;

                    if (arr) {
                        if (indexOf) {
                            return indexOf.call(arr, elem, i);
                        }

                        len = arr.length;
                        i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

                        for (; i < len; i++) {
                            // Skip accessing in sparse arrays
                            if (i in arr && arr[i] === elem) {
                                return i;
                            }
                        }
                    }

                    return -1;
                },

                merge: function(first, second) {
                    var len = +second.length,
                        j = 0,
                        i = first.length;

                    while (j < len) {
                        first[i++] = second[j++];
                    }

                    // Support: IE<9
                    // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
                    if (len !== len) {
                        while (second[j] !== undefined) {
                            first[i++] = second[j++];
                        }
                    }

                    first.length = i;

                    return first;
                },

                grep: function(elems, callback, invert) {
                    var callbackInverse,
                        matches = [],
                        i = 0,
                        length = elems.length,
                        callbackExpect = !invert;

                    // Go through the array, only saving the items
                    // that pass the validator function
                    for (; i < length; i++) {
                        callbackInverse = !callback(elems[i], i);
                        if (callbackInverse !== callbackExpect) {
                            matches.push(elems[i]);
                        }
                    }

                    return matches;
                },

                // arg is for internal usage only
                map: function(elems, callback, arg) {
                    var value,
                        i = 0,
                        length = elems.length,
                        isArray = isArraylike(elems),
                        ret = [];

                    // Go through the array, translating each of the items to their new values
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback(elems[i], i, arg);

                            if (value != null) {
                                ret.push(value);
                            }
                        }

                        // Go through every key on the object,
                    } else {
                        for (i in elems) {
                            value = callback(elems[i], i, arg);

                            if (value != null) {
                                ret.push(value);
                            }
                        }
                    }

                    // Flatten any nested arrays
                    return concat.apply([], ret);
                },

                // A global GUID counter for objects
                guid: 1,

                // Bind a function to a context, optionally partially applying any
                // arguments.
                proxy: function(fn, context) {
                    var args, proxy, tmp;

                    if (typeof context === "string") {
                        tmp = fn[context];
                        context = fn;
                        fn = tmp;
                    }

                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if (!jQuery.isFunction(fn)) {
                        return undefined;
                    }

                    // Simulated bind
                    args = slice.call(arguments, 2);
                    proxy = function() {
                        return fn.apply(context || this, args.concat(slice.call(arguments)));
                    };

                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                    return proxy;
                },

                now: function() {
                    return +(new Date());
                },

                // jQuery.support is not used in Core but other projects attach their
                // properties to it so it needs to exist.
                support: support
            });

            // Populate the class2type map
            jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
                class2type["[object " + name + "]"] = name.toLowerCase();
            });

            function isArraylike(obj) {
                var length = obj.length,
                    type = jQuery.type(obj);

                if (type === "function" || jQuery.isWindow(obj)) {
                    return false;
                }

                if (obj.nodeType === 1 && length) {
                    return true;
                }

                return type === "array" || length === 0 ||
                    typeof length === "number" && length > 0 && (length - 1) in obj;
            }
            var Sizzle =
                /*!
                 * Sizzle CSS Selector Engine v1.10.19
                 * http://sizzlejs.com/
                 *
                 * Copyright 2013 jQuery Foundation, Inc. and other contributors
                 * Released under the MIT license
                 * http://jquery.org/license
                 *
                 * Date: 2014-04-18
                 */
                (function(window) {

                    var i,
                        support,
                        Expr,
                        getText,
                        isXML,
                        tokenize,
                        compile,
                        select,
                        outermostContext,
                        sortInput,
                        hasDuplicate,

                        // Local document vars
                        setDocument,
                        document,
                        docElem,
                        documentIsHTML,
                        rbuggyQSA,
                        rbuggyMatches,
                        matches,
                        contains,

                        // Instance-specific data
                        expando = "sizzle" + -(new Date()),
                        preferredDoc = window.document,
                        dirruns = 0,
                        done = 0,
                        classCache = createCache(),
                        tokenCache = createCache(),
                        compilerCache = createCache(),
                        sortOrder = function(a, b) {
                            if (a === b) {
                                hasDuplicate = true;
                            }
                            return 0;
                        },

                        // General-purpose constants
                        strundefined = typeof undefined,
                        MAX_NEGATIVE = 1 << 31,

                        // Instance methods
                        hasOwn = ({}).hasOwnProperty,
                        arr = [],
                        pop = arr.pop,
                        push_native = arr.push,
                        push = arr.push,
                        slice = arr.slice,
                        // Use a stripped-down indexOf if we can't use a native one
                        indexOf = arr.indexOf || function(elem) {
                            var i = 0,
                                len = this.length;
                            for (; i < len; i++) {
                                if (this[i] === elem) {
                                    return i;
                                }
                            }
                            return -1;
                        },

                        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                        // Regular expressions

                        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                        whitespace = "[\\x20\\t\\r\\n\\f]",
                        // http://www.w3.org/TR/css3-syntax/#characters
                        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                        // Loosely modeled on CSS identifier characters
                        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                        identifier = characterEncoding.replace("w", "w#"),

                        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
                        // Operator (capture 2)
                        "*([*^$|!~]?=)" + whitespace +
                        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                        "*\\]",

                        pseudos = ":(" + characterEncoding + ")(?:\\((" +
                        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                        // 1. quoted (capture 3; capture 4 or capture 5)
                        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                        // 2. simple (capture 6)
                        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                        // 3. anything else (capture 2)
                        ".*" +
                        ")\\)|)",

                        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

                        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

                        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

                        rpseudo = new RegExp(pseudos),
                        ridentifier = new RegExp("^" + identifier + "$"),

                        matchExpr = {
                            "ID": new RegExp("^#(" + characterEncoding + ")"),
                            "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
                            "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                            "ATTR": new RegExp("^" + attributes),
                            "PSEUDO": new RegExp("^" + pseudos),
                            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                                "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                                "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                            // For use in libraries implementing .is()
                            // We use this for POS matching in `select`
                            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                                whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                        },

                        rinputs = /^(?:input|select|textarea|button)$/i,
                        rheader = /^h\d$/i,

                        rnative = /^[^{]+\{\s*\[native \w/,

                        // Easily-parseable/retrievable ID or TAG or CLASS selectors
                        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                        rsibling = /[+~]/,
                        rescape = /'|\\/g,

                        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                        funescape = function(_, escaped, escapedWhitespace) {
                            var high = "0x" + escaped - 0x10000;
                            // NaN means non-codepoint
                            // Support: Firefox<24
                            // Workaround erroneous numeric interpretation of +"0x"
                            return high !== high || escapedWhitespace ?
                                escaped :
                                high < 0 ?
                                // BMP codepoint
                                String.fromCharCode(high + 0x10000) :
                                // Supplemental Plane codepoint (surrogate pair)
                                String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                        };

                    // Optimize for push.apply( _, NodeList )
                    try {
                        push.apply(
                            (arr = slice.call(preferredDoc.childNodes)),
                            preferredDoc.childNodes
                        );
                        // Support: Android<4.0
                        // Detect silently failing push.apply
                        arr[preferredDoc.childNodes.length].nodeType;
                    } catch (e) {
                        push = {
                            apply: arr.length ?

                                // Leverage slice if possible
                                function(target, els) {
                                    push_native.apply(target, slice.call(els));
                                } :

                                // Support: IE<9
                                // Otherwise append directly
                                function(target, els) {
                                    var j = target.length,
                                        i = 0;
                                    // Can't trust NodeList.length
                                    while ((target[j++] = els[i++])) {}
                                    target.length = j - 1;
                                }
                        };
                    }

                    function Sizzle(selector, context, results, seed) {
                        var match, elem, m, nodeType,
                            // QSA vars
                            i, groups, old, nid, newContext, newSelector;

                        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                            setDocument(context);
                        }

                        context = context || document;
                        results = results || [];

                        if (!selector || typeof selector !== "string") {
                            return results;
                        }

                        if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                            return [];
                        }

                        if (documentIsHTML && !seed) {

                            // Shortcuts
                            if ((match = rquickExpr.exec(selector))) {
                                // Speed-up: Sizzle("#ID")
                                if ((m = match[1])) {
                                    if (nodeType === 9) {
                                        elem = context.getElementById(m);
                                        // Check parentNode to catch when Blackberry 4.6 returns
                                        // nodes that are no longer in the document (jQuery #6963)
                                        if (elem && elem.parentNode) {
                                            // Handle the case where IE, Opera, and Webkit return items
                                            // by name instead of ID
                                            if (elem.id === m) {
                                                results.push(elem);
                                                return results;
                                            }
                                        } else {
                                            return results;
                                        }
                                    } else {
                                        // Context is not a document
                                        if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
                                            contains(context, elem) && elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    }

                                    // Speed-up: Sizzle("TAG")
                                } else if (match[2]) {
                                    push.apply(results, context.getElementsByTagName(selector));
                                    return results;

                                    // Speed-up: Sizzle(".CLASS")
                                } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                                    push.apply(results, context.getElementsByClassName(m));
                                    return results;
                                }
                            }

                            // QSA path
                            if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                                nid = old = expando;
                                newContext = context;
                                newSelector = nodeType === 9 && selector;

                                // qSA works strangely on Element-rooted queries
                                // We can work around this by specifying an extra ID on the root
                                // and working up from there (Thanks to Andrew Dupont for the technique)
                                // IE 8 doesn't work on object elements
                                if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                                    groups = tokenize(selector);

                                    if ((old = context.getAttribute("id"))) {
                                        nid = old.replace(rescape, "\\$&");
                                    } else {
                                        context.setAttribute("id", nid);
                                    }
                                    nid = "[id='" + nid + "'] ";

                                    i = groups.length;
                                    while (i--) {
                                        groups[i] = nid + toSelector(groups[i]);
                                    }
                                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                                    newSelector = groups.join(",");
                                }

                                if (newSelector) {
                                    try {
                                        push.apply(results,
                                            newContext.querySelectorAll(newSelector)
                                        );
                                        return results;
                                    } catch (qsaError) {} finally {
                                        if (!old) {
                                            context.removeAttribute("id");
                                        }
                                    }
                                }
                            }
                        }

                        // All others
                        return select(selector.replace(rtrim, "$1"), context, results, seed);
                    }

                    /**
                     * Create key-value caches of limited size
                     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
                     *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                     *  deleting the oldest entry
                     */
                    function createCache() {
                        var keys = [];

                        function cache(key, value) {
                            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                            if (keys.push(key + " ") > Expr.cacheLength) {
                                // Only keep the most recent entries
                                delete cache[keys.shift()];
                            }
                            return (cache[key + " "] = value);
                        }
                        return cache;
                    }

                    /**
                     * Mark a function for special use by Sizzle
                     * @param {Function} fn The function to mark
                     */
                    function markFunction(fn) {
                        fn[expando] = true;
                        return fn;
                    }

                    /**
                     * Support testing using an element
                     * @param {Function} fn Passed the created div and expects a boolean result
                     */
                    function assert(fn) {
                        var div = document.createElement("div");

                        try {
                            return !!fn(div);
                        } catch (e) {
                            return false;
                        } finally {
                            // Remove from its parent by default
                            if (div.parentNode) {
                                div.parentNode.removeChild(div);
                            }
                            // release memory in IE
                            div = null;
                        }
                    }

                    /**
                     * Adds the same handler for all of the specified attrs
                     * @param {String} attrs Pipe-separated list of attributes
                     * @param {Function} handler The method that will be applied
                     */
                    function addHandle(attrs, handler) {
                        var arr = attrs.split("|"),
                            i = attrs.length;

                        while (i--) {
                            Expr.attrHandle[arr[i]] = handler;
                        }
                    }

                    /**
                     * Checks document order of two siblings
                     * @param {Element} a
                     * @param {Element} b
                     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                     */
                    function siblingCheck(a, b) {
                        var cur = b && a,
                            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                            (~b.sourceIndex || MAX_NEGATIVE) -
                            (~a.sourceIndex || MAX_NEGATIVE);

                        // Use IE sourceIndex if available on both nodes
                        if (diff) {
                            return diff;
                        }

                        // Check if b follows a
                        if (cur) {
                            while ((cur = cur.nextSibling)) {
                                if (cur === b) {
                                    return -1;
                                }
                            }
                        }

                        return a ? 1 : -1;
                    }

                    /**
                     * Returns a function to use in pseudos for input types
                     * @param {String} type
                     */
                    function createInputPseudo(type) {
                        return function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for buttons
                     * @param {String} type
                     */
                    function createButtonPseudo(type) {
                        return function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return (name === "input" || name === "button") && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for positionals
                     * @param {Function} fn
                     */
                    function createPositionalPseudo(fn) {
                        return markFunction(function(argument) {
                            argument = +argument;
                            return markFunction(function(seed, matches) {
                                var j,
                                    matchIndexes = fn([], seed.length, argument),
                                    i = matchIndexes.length;

                                // Match elements found at the specified indexes
                                while (i--) {
                                    if (seed[(j = matchIndexes[i])]) {
                                        seed[j] = !(matches[j] = seed[j]);
                                    }
                                }
                            });
                        });
                    }

                    /**
                     * Checks a node for validity as a Sizzle context
                     * @param {Element|Object=} context
                     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                     */
                    function testContext(context) {
                        return context && typeof context.getElementsByTagName !== strundefined && context;
                    }

                    // Expose support vars for convenience
                    support = Sizzle.support = {};

                    /**
                     * Detects XML nodes
                     * @param {Element|Object} elem An element or a document
                     * @returns {Boolean} True iff elem is a non-HTML XML node
                     */
                    isXML = Sizzle.isXML = function(elem) {
                        // documentElement is verified for cases where it doesn't yet exist
                        // (such as loading iframes in IE - #4833)
                        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                        return documentElement ? documentElement.nodeName !== "HTML" : false;
                    };

                    /**
                     * Sets document-related variables once based on the current document
                     * @param {Element|Object} [doc] An element or document object to use to set the document
                     * @returns {Object} Returns the current document
                     */
                    setDocument = Sizzle.setDocument = function(node) {
                        var hasCompare,
                            doc = node ? node.ownerDocument || node : preferredDoc,
                            parent = doc.defaultView;

                        // If no document and documentElement is available, return
                        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                            return document;
                        }

                        // Set our document
                        document = doc;
                        docElem = doc.documentElement;

                        // Support tests
                        documentIsHTML = !isXML(doc);

                        // Support: IE>8
                        // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                        // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                        // IE6-8 do not support the defaultView property so parent will be undefined
                        if (parent && parent !== parent.top) {
                            // IE11 does not have attachEvent, so all must suffer
                            if (parent.addEventListener) {
                                parent.addEventListener("unload", function() {
                                    setDocument();
                                }, false);
                            } else if (parent.attachEvent) {
                                parent.attachEvent("onunload", function() {
                                    setDocument();
                                });
                            }
                        }

                        /* Attributes
                        ---------------------------------------------------------------------- */

                        // Support: IE<8
                        // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
                        support.attributes = assert(function(div) {
                            div.className = "i";
                            return !div.getAttribute("className");
                        });

                        /* getElement(s)By*
                        ---------------------------------------------------------------------- */

                        // Check if getElementsByTagName("*") returns only elements
                        support.getElementsByTagName = assert(function(div) {
                            div.appendChild(doc.createComment(""));
                            return !div.getElementsByTagName("*").length;
                        });

                        // Check if getElementsByClassName can be trusted
                        support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div) {
                            div.innerHTML = "<div class='a'></div><div class='a i'></div>";

                            // Support: Safari<4
                            // Catch class over-caching
                            div.firstChild.className = "i";
                            // Support: Opera<10
                            // Catch gEBCN failure to find non-leading classes
                            return div.getElementsByClassName("i").length === 2;
                        });

                        // Support: IE<10
                        // Check if getElementById returns elements by name
                        // The broken getElementById methods don't pick up programatically-set names,
                        // so use a roundabout getElementsByName test
                        support.getById = assert(function(div) {
                            docElem.appendChild(div).id = expando;
                            return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                        });

                        // ID find and filter
                        if (support.getById) {
                            Expr.find["ID"] = function(id, context) {
                                if (typeof context.getElementById !== strundefined && documentIsHTML) {
                                    var m = context.getElementById(id);
                                    // Check parentNode to catch when Blackberry 4.6 returns
                                    // nodes that are no longer in the document #6963
                                    return m && m.parentNode ? [m] : [];
                                }
                            };
                            Expr.filter["ID"] = function(id) {
                                var attrId = id.replace(runescape, funescape);
                                return function(elem) {
                                    return elem.getAttribute("id") === attrId;
                                };
                            };
                        } else {
                            // Support: IE6/7
                            // getElementById is not reliable as a find shortcut
                            delete Expr.find["ID"];

                            Expr.filter["ID"] = function(id) {
                                var attrId = id.replace(runescape, funescape);
                                return function(elem) {
                                    var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                                    return node && node.value === attrId;
                                };
                            };
                        }

                        // Tag
                        Expr.find["TAG"] = support.getElementsByTagName ?
                            function(tag, context) {
                                if (typeof context.getElementsByTagName !== strundefined) {
                                    return context.getElementsByTagName(tag);
                                }
                            } :
                            function(tag, context) {
                                var elem,
                                    tmp = [],
                                    i = 0,
                                    results = context.getElementsByTagName(tag);

                                // Filter out possible comments
                                if (tag === "*") {
                                    while ((elem = results[i++])) {
                                        if (elem.nodeType === 1) {
                                            tmp.push(elem);
                                        }
                                    }

                                    return tmp;
                                }
                                return results;
                            };

                        // Class
                        Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                            if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                                return context.getElementsByClassName(className);
                            }
                        };

                        /* QSA/matchesSelector
                        ---------------------------------------------------------------------- */

                        // QSA and matchesSelector support

                        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                        rbuggyMatches = [];

                        // qSa(:focus) reports false when true (Chrome 21)
                        // We allow this because of a bug in IE8/9 that throws an error
                        // whenever `document.activeElement` is accessed on an iframe
                        // So, we allow :focus to pass through QSA all the time to avoid the IE error
                        // See http://bugs.jquery.com/ticket/13378
                        rbuggyQSA = [];

                        if ((support.qsa = rnative.test(doc.querySelectorAll))) {
                            // Build QSA regex
                            // Regex strategy adopted from Diego Perini
                            assert(function(div) {
                                // Select is set to empty string on purpose
                                // This is to test IE's treatment of not explicitly
                                // setting a boolean content attribute,
                                // since its presence should be enough
                                // http://bugs.jquery.com/ticket/12359
                                div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

                                // Support: IE8, Opera 11-12.16
                                // Nothing should be selected when empty strings follow ^= or $= or *=
                                // The test attribute must be unknown in Opera but "safe" for WinRT
                                // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                if (div.querySelectorAll("[msallowclip^='']").length) {
                                    rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                                }

                                // Support: IE8
                                // Boolean attributes and "value" are not treated correctly
                                if (!div.querySelectorAll("[selected]").length) {
                                    rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                                }

                                // Webkit/Opera - :checked should return selected option elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                // IE8 throws error here and will not see later tests
                                if (!div.querySelectorAll(":checked").length) {
                                    rbuggyQSA.push(":checked");
                                }
                            });

                            assert(function(div) {
                                // Support: Windows 8 Native Apps
                                // The type and name attributes are restricted during .innerHTML assignment
                                var input = doc.createElement("input");
                                input.setAttribute("type", "hidden");
                                div.appendChild(input).setAttribute("name", "D");

                                // Support: IE8
                                // Enforce case-sensitivity of name attribute
                                if (div.querySelectorAll("[name=d]").length) {
                                    rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                                }

                                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                // IE8 throws error here and will not see later tests
                                if (!div.querySelectorAll(":enabled").length) {
                                    rbuggyQSA.push(":enabled", ":disabled");
                                }

                                // Opera 10-11 does not throw on post-comma invalid pseudos
                                div.querySelectorAll("*,:x");
                                rbuggyQSA.push(",.*:");
                            });
                        }

                        if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                                docElem.webkitMatchesSelector ||
                                docElem.mozMatchesSelector ||
                                docElem.oMatchesSelector ||
                                docElem.msMatchesSelector)))) {

                            assert(function(div) {
                                // Check to see if it's possible to do matchesSelector
                                // on a disconnected node (IE 9)
                                support.disconnectedMatch = matches.call(div, "div");

                                // This should fail with an exception
                                // Gecko does not error, returns false instead
                                matches.call(div, "[s!='']:x");
                                rbuggyMatches.push("!=", pseudos);
                            });
                        }

                        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                        /* Contains
                        ---------------------------------------------------------------------- */
                        hasCompare = rnative.test(docElem.compareDocumentPosition);

                        // Element contains another
                        // Purposefully does not implement inclusive descendent
                        // As in, an element does not contain itself
                        contains = hasCompare || rnative.test(docElem.contains) ?
                            function(a, b) {
                                var adown = a.nodeType === 9 ? a.documentElement : a,
                                    bup = b && b.parentNode;
                                return a === bup || !!(bup && bup.nodeType === 1 && (
                                    adown.contains ?
                                    adown.contains(bup) :
                                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                                ));
                            } :
                            function(a, b) {
                                if (b) {
                                    while ((b = b.parentNode)) {
                                        if (b === a) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            };

                        /* Sorting
                        ---------------------------------------------------------------------- */

                        // Document order sorting
                        sortOrder = hasCompare ?
                            function(a, b) {

                                // Flag for duplicate removal
                                if (a === b) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                // Sort on method existence if only one input has compareDocumentPosition
                                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                if (compare) {
                                    return compare;
                                }

                                // Calculate position if both inputs belong to the same document
                                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
                                    a.compareDocumentPosition(b) :

                                    // Otherwise we know they are disconnected
                                    1;

                                // Disconnected nodes
                                if (compare & 1 ||
                                    (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                                    // Choose the first element that is related to our preferred document
                                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                        return -1;
                                    }
                                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                        return 1;
                                    }

                                    // Maintain original order
                                    return sortInput ?
                                        (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
                                        0;
                                }

                                return compare & 4 ? -1 : 1;
                            } :
                            function(a, b) {
                                // Exit early if the nodes are identical
                                if (a === b) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                var cur,
                                    i = 0,
                                    aup = a.parentNode,
                                    bup = b.parentNode,
                                    ap = [a],
                                    bp = [b];

                                // Parentless nodes are either documents or disconnected
                                if (!aup || !bup) {
                                    return a === doc ? -1 :
                                        b === doc ? 1 :
                                        aup ? -1 :
                                        bup ? 1 :
                                        sortInput ?
                                        (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
                                        0;

                                    // If the nodes are siblings, we can do a quick check
                                } else if (aup === bup) {
                                    return siblingCheck(a, b);
                                }

                                // Otherwise we need full lists of their ancestors for comparison
                                cur = a;
                                while ((cur = cur.parentNode)) {
                                    ap.unshift(cur);
                                }
                                cur = b;
                                while ((cur = cur.parentNode)) {
                                    bp.unshift(cur);
                                }

                                // Walk down the tree looking for a discrepancy
                                while (ap[i] === bp[i]) {
                                    i++;
                                }

                                return i ?
                                    // Do a sibling check if the nodes have a common ancestor
                                    siblingCheck(ap[i], bp[i]) :

                                    // Otherwise nodes in our document sort first
                                    ap[i] === preferredDoc ? -1 :
                                    bp[i] === preferredDoc ? 1 :
                                    0;
                            };

                        return doc;
                    };

                    Sizzle.matches = function(expr, elements) {
                        return Sizzle(expr, null, null, elements);
                    };

                    Sizzle.matchesSelector = function(elem, expr) {
                        // Set document vars if needed
                        if ((elem.ownerDocument || elem) !== document) {
                            setDocument(elem);
                        }

                        // Make sure that attribute selectors are quoted
                        expr = expr.replace(rattributeQuotes, "='$1']");

                        if (support.matchesSelector && documentIsHTML &&
                            (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                            (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                            try {
                                var ret = matches.call(elem, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || support.disconnectedMatch ||
                                    // As well, disconnected nodes are said to be in a document
                                    // fragment in IE 9
                                    elem.document && elem.document.nodeType !== 11) {
                                    return ret;
                                }
                            } catch (e) {}
                        }

                        return Sizzle(expr, document, null, [elem]).length > 0;
                    };

                    Sizzle.contains = function(context, elem) {
                        // Set document vars if needed
                        if ((context.ownerDocument || context) !== document) {
                            setDocument(context);
                        }
                        return contains(context, elem);
                    };

                    Sizzle.attr = function(elem, name) {
                        // Set document vars if needed
                        if ((elem.ownerDocument || elem) !== document) {
                            setDocument(elem);
                        }

                        var fn = Expr.attrHandle[name.toLowerCase()],
                            // Don't get fooled by Object.prototype properties (jQuery #13807)
                            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                            fn(elem, name, !documentIsHTML) :
                            undefined;

                        return val !== undefined ?
                            val :
                            support.attributes || !documentIsHTML ?
                            elem.getAttribute(name) :
                            (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
                    };

                    Sizzle.error = function(msg) {
                        throw new Error("Syntax error, unrecognized expression: " + msg);
                    };

                    /**
                     * Document sorting and removing duplicates
                     * @param {ArrayLike} results
                     */
                    Sizzle.uniqueSort = function(results) {
                        var elem,
                            duplicates = [],
                            j = 0,
                            i = 0;

                        // Unless we *know* we can detect duplicates, assume their presence
                        hasDuplicate = !support.detectDuplicates;
                        sortInput = !support.sortStable && results.slice(0);
                        results.sort(sortOrder);

                        if (hasDuplicate) {
                            while ((elem = results[i++])) {
                                if (elem === results[i]) {
                                    j = duplicates.push(i);
                                }
                            }
                            while (j--) {
                                results.splice(duplicates[j], 1);
                            }
                        }

                        // Clear input after sorting to release objects
                        // See https://github.com/jquery/sizzle/pull/225
                        sortInput = null;

                        return results;
                    };

                    /**
                     * Utility function for retrieving the text value of an array of DOM nodes
                     * @param {Array|Element} elem
                     */
                    getText = Sizzle.getText = function(elem) {
                        var node,
                            ret = "",
                            i = 0,
                            nodeType = elem.nodeType;

                        if (!nodeType) {
                            // If no nodeType, this is expected to be an array
                            while ((node = elem[i++])) {
                                // Do not traverse comment nodes
                                ret += getText(node);
                            }
                        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                            // Use textContent for elements
                            // innerText usage removed for consistency of new lines (jQuery #11153)
                            if (typeof elem.textContent === "string") {
                                return elem.textContent;
                            } else {
                                // Traverse its children
                                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                    ret += getText(elem);
                                }
                            }
                        } else if (nodeType === 3 || nodeType === 4) {
                            return elem.nodeValue;
                        }
                        // Do not include comment or processing instruction nodes

                        return ret;
                    };

                    Expr = Sizzle.selectors = {

                        // Can be adjusted by the user
                        cacheLength: 50,

                        createPseudo: markFunction,

                        match: matchExpr,

                        attrHandle: {},

                        find: {},

                        relative: {
                            ">": {
                                dir: "parentNode",
                                first: true
                            },
                            " ": {
                                dir: "parentNode"
                            },
                            "+": {
                                dir: "previousSibling",
                                first: true
                            },
                            "~": {
                                dir: "previousSibling"
                            }
                        },

                        preFilter: {
                            "ATTR": function(match) {
                                match[1] = match[1].replace(runescape, funescape);

                                // Move the given value to match[3] whether quoted or unquoted
                                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                                if (match[2] === "~=") {
                                    match[3] = " " + match[3] + " ";
                                }

                                return match.slice(0, 4);
                            },

                            "CHILD": function(match) {
                                /* matches from matchExpr["CHILD"]
                                    1 type (only|nth|...)
                                    2 what (child|of-type)
                                    3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                                    4 xn-component of xn+y argument ([+-]?\d*n|)
                                    5 sign of xn-component
                                    6 x of xn-component
                                    7 sign of y-component
                                    8 y of y-component
                                */
                                match[1] = match[1].toLowerCase();

                                if (match[1].slice(0, 3) === "nth") {
                                    // nth-* requires argument
                                    if (!match[3]) {
                                        Sizzle.error(match[0]);
                                    }

                                    // numeric x and y parameters for Expr.filter.CHILD
                                    // remember that false/true cast respectively to 0/1
                                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                                    match[5] = +((match[7] + match[8]) || match[3] === "odd");

                                    // other types prohibit arguments
                                } else if (match[3]) {
                                    Sizzle.error(match[0]);
                                }

                                return match;
                            },

                            "PSEUDO": function(match) {
                                var excess,
                                    unquoted = !match[6] && match[2];

                                if (matchExpr["CHILD"].test(match[0])) {
                                    return null;
                                }

                                // Accept quoted arguments as-is
                                if (match[3]) {
                                    match[2] = match[4] || match[5] || "";

                                    // Strip excess characters from unquoted arguments
                                } else if (unquoted && rpseudo.test(unquoted) &&
                                    // Get excess from tokenize (recursively)
                                    (excess = tokenize(unquoted, true)) &&
                                    // advance to the next closing parenthesis
                                    (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                                    // excess is a negative index
                                    match[0] = match[0].slice(0, excess);
                                    match[2] = unquoted.slice(0, excess);
                                }

                                // Return only captures needed by the pseudo filter method (type and argument)
                                return match.slice(0, 3);
                            }
                        },

                        filter: {

                            "TAG": function(nodeNameSelector) {
                                var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                                return nodeNameSelector === "*" ?
                                    function() {
                                        return true;
                                    } :
                                    function(elem) {
                                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                    };
                            },

                            "CLASS": function(className) {
                                var pattern = classCache[className + " "];

                                return pattern ||
                                    (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                                    classCache(className, function(elem) {
                                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
                                    });
                            },

                            "ATTR": function(name, operator, check) {
                                return function(elem) {
                                    var result = Sizzle.attr(elem, name);

                                    if (result == null) {
                                        return operator === "!=";
                                    }
                                    if (!operator) {
                                        return true;
                                    }

                                    result += "";

                                    return operator === "=" ? result === check :
                                        operator === "!=" ? result !== check :
                                        operator === "^=" ? check && result.indexOf(check) === 0 :
                                        operator === "*=" ? check && result.indexOf(check) > -1 :
                                        operator === "$=" ? check && result.slice(-check.length) === check :
                                        operator === "~=" ? (" " + result + " ").indexOf(check) > -1 :
                                        operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                        false;
                                };
                            },

                            "CHILD": function(type, what, argument, first, last) {
                                var simple = type.slice(0, 3) !== "nth",
                                    forward = type.slice(-4) !== "last",
                                    ofType = what === "of-type";

                                return first === 1 && last === 0 ?

                                    // Shortcut for :nth-*(n)
                                    function(elem) {
                                        return !!elem.parentNode;
                                    } :

                                    function(elem, context, xml) {
                                        var cache, outerCache, node, diff, nodeIndex, start,
                                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                                            parent = elem.parentNode,
                                            name = ofType && elem.nodeName.toLowerCase(),
                                            useCache = !xml && !ofType;

                                        if (parent) {

                                            // :(first|last|only)-(child|of-type)
                                            if (simple) {
                                                while (dir) {
                                                    node = elem;
                                                    while ((node = node[dir])) {
                                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                            return false;
                                                        }
                                                    }
                                                    // Reverse direction for :only-* (if we haven't yet done so)
                                                    start = dir = type === "only" && !start && "nextSibling";
                                                }
                                                return true;
                                            }

                                            start = [forward ? parent.firstChild : parent.lastChild];

                                            // non-xml :nth-child(...) stores cache data on `parent`
                                            if (forward && useCache) {
                                                // Seek `elem` from a previously-cached index
                                                outerCache = parent[expando] || (parent[expando] = {});
                                                cache = outerCache[type] || [];
                                                nodeIndex = cache[0] === dirruns && cache[1];
                                                diff = cache[0] === dirruns && cache[2];
                                                node = nodeIndex && parent.childNodes[nodeIndex];

                                                while ((node = ++nodeIndex && node && node[dir] ||

                                                        // Fallback to seeking `elem` from the start
                                                        (diff = nodeIndex = 0) || start.pop())) {

                                                    // When found, cache indexes on `parent` and break
                                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                                        outerCache[type] = [dirruns, nodeIndex, diff];
                                                        break;
                                                    }
                                                }

                                                // Use previously-cached element index if available
                                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                                diff = cache[1];

                                                // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                            } else {
                                                // Use the same loop as above to seek `elem` from the start
                                                while ((node = ++nodeIndex && node && node[dir] ||
                                                        (diff = nodeIndex = 0) || start.pop())) {

                                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                        // Cache the index of each encountered element
                                                        if (useCache) {
                                                            (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                                                        }

                                                        if (node === elem) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }

                                            // Incorporate the offset, then check against cycle size
                                            diff -= last;
                                            return diff === first || (diff % first === 0 && diff / first >= 0);
                                        }
                                    };
                            },

                            "PSEUDO": function(pseudo, argument) {
                                // pseudo-class names are case-insensitive
                                // http://www.w3.org/TR/selectors/#pseudo-classes
                                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                // Remember that setFilters inherits from pseudos
                                var args,
                                    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                    Sizzle.error("unsupported pseudo: " + pseudo);

                                // The user may use createPseudo to indicate that
                                // arguments are needed to create the filter function
                                // just as Sizzle does
                                if (fn[expando]) {
                                    return fn(argument);
                                }

                                // But maintain support for old signatures
                                if (fn.length > 1) {
                                    args = [pseudo, pseudo, "", argument];
                                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                        markFunction(function(seed, matches) {
                                            var idx,
                                                matched = fn(seed, argument),
                                                i = matched.length;
                                            while (i--) {
                                                idx = indexOf.call(seed, matched[i]);
                                                seed[idx] = !(matches[idx] = matched[i]);
                                            }
                                        }) :
                                        function(elem) {
                                            return fn(elem, 0, args);
                                        };
                                }

                                return fn;
                            }
                        },

                        pseudos: {
                            // Potentially complex pseudos
                            "not": markFunction(function(selector) {
                                // Trim the selector passed to compile
                                // to avoid treating leading and trailing
                                // spaces as combinators
                                var input = [],
                                    results = [],
                                    matcher = compile(selector.replace(rtrim, "$1"));

                                return matcher[expando] ?
                                    markFunction(function(seed, matches, context, xml) {
                                        var elem,
                                            unmatched = matcher(seed, null, xml, []),
                                            i = seed.length;

                                        // Match elements unmatched by `matcher`
                                        while (i--) {
                                            if ((elem = unmatched[i])) {
                                                seed[i] = !(matches[i] = elem);
                                            }
                                        }
                                    }) :
                                    function(elem, context, xml) {
                                        input[0] = elem;
                                        matcher(input, null, xml, results);
                                        return !results.pop();
                                    };
                            }),

                            "has": markFunction(function(selector) {
                                return function(elem) {
                                    return Sizzle(selector, elem).length > 0;
                                };
                            }),

                            "contains": markFunction(function(text) {
                                return function(elem) {
                                    return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                                };
                            }),

                            // "Whether an element is represented by a :lang() selector
                            // is based solely on the element's language value
                            // being equal to the identifier C,
                            // or beginning with the identifier C immediately followed by "-".
                            // The matching of C against the element's language value is performed case-insensitively.
                            // The identifier C does not have to be a valid language name."
                            // http://www.w3.org/TR/selectors/#lang-pseudo
                            "lang": markFunction(function(lang) {
                                // lang value must be a valid identifier
                                if (!ridentifier.test(lang || "")) {
                                    Sizzle.error("unsupported lang: " + lang);
                                }
                                lang = lang.replace(runescape, funescape).toLowerCase();
                                return function(elem) {
                                    var elemLang;
                                    do {
                                        if ((elemLang = documentIsHTML ?
                                                elem.lang :
                                                elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                            elemLang = elemLang.toLowerCase();
                                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                        }
                                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                    return false;
                                };
                            }),

                            // Miscellaneous
                            "target": function(elem) {
                                var hash = window.location && window.location.hash;
                                return hash && hash.slice(1) === elem.id;
                            },

                            "root": function(elem) {
                                return elem === docElem;
                            },

                            "focus": function(elem) {
                                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                            },

                            // Boolean properties
                            "enabled": function(elem) {
                                return elem.disabled === false;
                            },

                            "disabled": function(elem) {
                                return elem.disabled === true;
                            },

                            "checked": function(elem) {
                                // In CSS3, :checked should return both checked and selected elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                var nodeName = elem.nodeName.toLowerCase();
                                return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                            },

                            "selected": function(elem) {
                                // Accessing this property makes selected-by-default
                                // options in Safari work properly
                                if (elem.parentNode) {
                                    elem.parentNode.selectedIndex;
                                }

                                return elem.selected === true;
                            },

                            // Contents
                            "empty": function(elem) {
                                // http://www.w3.org/TR/selectors/#empty-pseudo
                                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                //   but not by others (comment: 8; processing instruction: 7; etc.)
                                // nodeType < 6 works because attributes (2) do not appear as children
                                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                    if (elem.nodeType < 6) {
                                        return false;
                                    }
                                }
                                return true;
                            },

                            "parent": function(elem) {
                                return !Expr.pseudos["empty"](elem);
                            },

                            // Element/input types
                            "header": function(elem) {
                                return rheader.test(elem.nodeName);
                            },

                            "input": function(elem) {
                                return rinputs.test(elem.nodeName);
                            },

                            "button": function(elem) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === "button" || name === "button";
                            },

                            "text": function(elem) {
                                var attr;
                                return elem.nodeName.toLowerCase() === "input" &&
                                    elem.type === "text" &&

                                    // Support: IE<8
                                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                    ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                            },

                            // Position-in-collection
                            "first": createPositionalPseudo(function() {
                                return [0];
                            }),

                            "last": createPositionalPseudo(function(matchIndexes, length) {
                                return [length - 1];
                            }),

                            "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                                return [argument < 0 ? argument + length : argument];
                            }),

                            "even": createPositionalPseudo(function(matchIndexes, length) {
                                var i = 0;
                                for (; i < length; i += 2) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "odd": createPositionalPseudo(function(matchIndexes, length) {
                                var i = 1;
                                for (; i < length; i += 2) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for (; --i >= 0;) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for (; ++i < length;) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            })
                        }
                    };

                    Expr.pseudos["nth"] = Expr.pseudos["eq"];

                    // Add button/input type pseudos
                    for (i in {
                            radio: true,
                            checkbox: true,
                            file: true,
                            password: true,
                            image: true
                        }) {
                        Expr.pseudos[i] = createInputPseudo(i);
                    }
                    for (i in {
                            submit: true,
                            reset: true
                        }) {
                        Expr.pseudos[i] = createButtonPseudo(i);
                    }

                    // Easy API for creating new setFilters
                    function setFilters() {}
                    setFilters.prototype = Expr.filters = Expr.pseudos;
                    Expr.setFilters = new setFilters();

                    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                        var matched, match, tokens, type,
                            soFar, groups, preFilters,
                            cached = tokenCache[selector + " "];

                        if (cached) {
                            return parseOnly ? 0 : cached.slice(0);
                        }

                        soFar = selector;
                        groups = [];
                        preFilters = Expr.preFilter;

                        while (soFar) {

                            // Comma and first run
                            if (!matched || (match = rcomma.exec(soFar))) {
                                if (match) {
                                    // Don't consume trailing commas as valid
                                    soFar = soFar.slice(match[0].length) || soFar;
                                }
                                groups.push((tokens = []));
                            }

                            matched = false;

                            // Combinators
                            if ((match = rcombinators.exec(soFar))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    // Cast descendant combinators to space
                                    type: match[0].replace(rtrim, " ")
                                });
                                soFar = soFar.slice(matched.length);
                            }

                            // Filters
                            for (type in Expr.filter) {
                                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                                        (match = preFilters[type](match)))) {
                                    matched = match.shift();
                                    tokens.push({
                                        value: matched,
                                        type: type,
                                        matches: match
                                    });
                                    soFar = soFar.slice(matched.length);
                                }
                            }

                            if (!matched) {
                                break;
                            }
                        }

                        // Return the length of the invalid excess
                        // if we're just parsing
                        // Otherwise, throw an error or return tokens
                        return parseOnly ?
                            soFar.length :
                            soFar ?
                            Sizzle.error(selector) :
                            // Cache the tokens
                            tokenCache(selector, groups).slice(0);
                    };

                    function toSelector(tokens) {
                        var i = 0,
                            len = tokens.length,
                            selector = "";
                        for (; i < len; i++) {
                            selector += tokens[i].value;
                        }
                        return selector;
                    }

                    function addCombinator(matcher, combinator, base) {
                        var dir = combinator.dir,
                            checkNonElements = base && dir === "parentNode",
                            doneName = done++;

                        return combinator.first ?
                            // Check against closest ancestor/preceding element
                            function(elem, context, xml) {
                                while ((elem = elem[dir])) {
                                    if (elem.nodeType === 1 || checkNonElements) {
                                        return matcher(elem, context, xml);
                                    }
                                }
                            } :

                            // Check against all ancestor/preceding elements
                            function(elem, context, xml) {
                                var oldCache, outerCache,
                                    newCache = [dirruns, doneName];

                                // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                                if (xml) {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            if (matcher(elem, context, xml)) {
                                                return true;
                                            }
                                        }
                                    }
                                } else {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            outerCache = elem[expando] || (elem[expando] = {});
                                            if ((oldCache = outerCache[dir]) &&
                                                oldCache[0] === dirruns && oldCache[1] === doneName) {

                                                // Assign to newCache so results back-propagate to previous elements
                                                return (newCache[2] = oldCache[2]);
                                            } else {
                                                // Reuse newcache so results back-propagate to previous elements
                                                outerCache[dir] = newCache;

                                                // A match means we're done; a fail means we have to keep checking
                                                if ((newCache[2] = matcher(elem, context, xml))) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                    }

                    function elementMatcher(matchers) {
                        return matchers.length > 1 ?
                            function(elem, context, xml) {
                                var i = matchers.length;
                                while (i--) {
                                    if (!matchers[i](elem, context, xml)) {
                                        return false;
                                    }
                                }
                                return true;
                            } :
                            matchers[0];
                    }

                    function multipleContexts(selector, contexts, results) {
                        var i = 0,
                            len = contexts.length;
                        for (; i < len; i++) {
                            Sizzle(selector, contexts[i], results);
                        }
                        return results;
                    }

                    function condense(unmatched, map, filter, context, xml) {
                        var elem,
                            newUnmatched = [],
                            i = 0,
                            len = unmatched.length,
                            mapped = map != null;

                        for (; i < len; i++) {
                            if ((elem = unmatched[i])) {
                                if (!filter || filter(elem, context, xml)) {
                                    newUnmatched.push(elem);
                                    if (mapped) {
                                        map.push(i);
                                    }
                                }
                            }
                        }

                        return newUnmatched;
                    }

                    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                        if (postFilter && !postFilter[expando]) {
                            postFilter = setMatcher(postFilter);
                        }
                        if (postFinder && !postFinder[expando]) {
                            postFinder = setMatcher(postFinder, postSelector);
                        }
                        return markFunction(function(seed, results, context, xml) {
                            var temp, i, elem,
                                preMap = [],
                                postMap = [],
                                preexisting = results.length,

                                // Get initial elements from seed or context
                                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                matcherIn = preFilter && (seed || !selector) ?
                                condense(elems, preMap, preFilter, context, xml) :
                                elems,

                                matcherOut = matcher ?
                                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                postFinder || (seed ? preFilter : preexisting || postFilter) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                                matcherIn;

                            // Find primary matches
                            if (matcher) {
                                matcher(matcherIn, matcherOut, context, xml);
                            }

                            // Apply postFilter
                            if (postFilter) {
                                temp = condense(matcherOut, postMap);
                                postFilter(temp, [], context, xml);

                                // Un-match failing elements by moving them back to matcherIn
                                i = temp.length;
                                while (i--) {
                                    if ((elem = temp[i])) {
                                        matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                    }
                                }
                            }

                            if (seed) {
                                if (postFinder || preFilter) {
                                    if (postFinder) {
                                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                        temp = [];
                                        i = matcherOut.length;
                                        while (i--) {
                                            if ((elem = matcherOut[i])) {
                                                // Restore matcherIn since elem is not yet a final match
                                                temp.push((matcherIn[i] = elem));
                                            }
                                        }
                                        postFinder(null, (matcherOut = []), temp, xml);
                                    }

                                    // Move matched elements from seed to results to keep them synchronized
                                    i = matcherOut.length;
                                    while (i--) {
                                        if ((elem = matcherOut[i]) &&
                                            (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

                                            seed[temp] = !(results[temp] = elem);
                                        }
                                    }
                                }

                                // Add elements to results, through postFinder if defined
                            } else {
                                matcherOut = condense(
                                    matcherOut === results ?
                                    matcherOut.splice(preexisting, matcherOut.length) :
                                    matcherOut
                                );
                                if (postFinder) {
                                    postFinder(null, results, matcherOut, xml);
                                } else {
                                    push.apply(results, matcherOut);
                                }
                            }
                        });
                    }

                    function matcherFromTokens(tokens) {
                        var checkContext, matcher, j,
                            len = tokens.length,
                            leadingRelative = Expr.relative[tokens[0].type],
                            implicitRelative = leadingRelative || Expr.relative[" "],
                            i = leadingRelative ? 1 : 0,

                            // The foundational matcher ensures that elements are reachable from top-level context(s)
                            matchContext = addCombinator(function(elem) {
                                return elem === checkContext;
                            }, implicitRelative, true),
                            matchAnyContext = addCombinator(function(elem) {
                                return indexOf.call(checkContext, elem) > -1;
                            }, implicitRelative, true),
                            matchers = [function(elem, context, xml) {
                                return (!leadingRelative && (xml || context !== outermostContext)) || (
                                    (checkContext = context).nodeType ?
                                    matchContext(elem, context, xml) :
                                    matchAnyContext(elem, context, xml));
                            }];

                        for (; i < len; i++) {
                            if ((matcher = Expr.relative[tokens[i].type])) {
                                matchers = [addCombinator(elementMatcher(matchers), matcher)];
                            } else {
                                matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                                // Return special upon seeing a positional matcher
                                if (matcher[expando]) {
                                    // Find the next relative operator (if any) for proper handling
                                    j = ++i;
                                    for (; j < len; j++) {
                                        if (Expr.relative[tokens[j].type]) {
                                            break;
                                        }
                                    }
                                    return setMatcher(
                                        i > 1 && elementMatcher(matchers),
                                        i > 1 && toSelector(
                                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                            tokens.slice(0, i - 1).concat({
                                                value: tokens[i - 2].type === " " ? "*" : ""
                                            })
                                        ).replace(rtrim, "$1"),
                                        matcher,
                                        i < j && matcherFromTokens(tokens.slice(i, j)),
                                        j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                        j < len && toSelector(tokens)
                                    );
                                }
                                matchers.push(matcher);
                            }
                        }

                        return elementMatcher(matchers);
                    }

                    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                        var bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function(seed, context, xml, results, outermost) {
                                var elem, j, matcher,
                                    matchedCount = 0,
                                    i = "0",
                                    unmatched = seed && [],
                                    setMatched = [],
                                    contextBackup = outermostContext,
                                    // We must always have either seed elements or outermost context
                                    elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                                    // Use integer dirruns iff this is the outermost matcher
                                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                    len = elems.length;

                                if (outermost) {
                                    outermostContext = context !== document && context;
                                }

                                // Add elements passing elementMatchers directly to results
                                // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                                // Support: IE<9, Safari
                                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                for (; i !== len && (elem = elems[i]) != null; i++) {
                                    if (byElement && elem) {
                                        j = 0;
                                        while ((matcher = elementMatchers[j++])) {
                                            if (matcher(elem, context, xml)) {
                                                results.push(elem);
                                                break;
                                            }
                                        }
                                        if (outermost) {
                                            dirruns = dirrunsUnique;
                                        }
                                    }

                                    // Track unmatched elements for set filters
                                    if (bySet) {
                                        // They will have gone through all possible matchers
                                        if ((elem = !matcher && elem)) {
                                            matchedCount--;
                                        }

                                        // Lengthen the array for every element, matched or not
                                        if (seed) {
                                            unmatched.push(elem);
                                        }
                                    }
                                }

                                // Apply set filters to unmatched elements
                                matchedCount += i;
                                if (bySet && i !== matchedCount) {
                                    j = 0;
                                    while ((matcher = setMatchers[j++])) {
                                        matcher(unmatched, setMatched, context, xml);
                                    }

                                    if (seed) {
                                        // Reintegrate element matches to eliminate the need for sorting
                                        if (matchedCount > 0) {
                                            while (i--) {
                                                if (!(unmatched[i] || setMatched[i])) {
                                                    setMatched[i] = pop.call(results);
                                                }
                                            }
                                        }

                                        // Discard index placeholder values to get only actual matches
                                        setMatched = condense(setMatched);
                                    }

                                    // Add matches to results
                                    push.apply(results, setMatched);

                                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                    if (outermost && !seed && setMatched.length > 0 &&
                                        (matchedCount + setMatchers.length) > 1) {

                                        Sizzle.uniqueSort(results);
                                    }
                                }

                                // Override manipulation of globals by nested matchers
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                    outermostContext = contextBackup;
                                }

                                return unmatched;
                            };

                        return bySet ?
                            markFunction(superMatcher) :
                            superMatcher;
                    }

                    compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
                        var i,
                            setMatchers = [],
                            elementMatchers = [],
                            cached = compilerCache[selector + " "];

                        if (!cached) {
                            // Generate a function of recursive functions that can be used to check each element
                            if (!match) {
                                match = tokenize(selector);
                            }
                            i = match.length;
                            while (i--) {
                                cached = matcherFromTokens(match[i]);
                                if (cached[expando]) {
                                    setMatchers.push(cached);
                                } else {
                                    elementMatchers.push(cached);
                                }
                            }

                            // Cache the compiled function
                            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                            // Save selector and tokenization
                            cached.selector = selector;
                        }
                        return cached;
                    };

                    /**
                     * A low-level selection function that works with Sizzle's compiled
                     *  selector functions
                     * @param {String|Function} selector A selector or a pre-compiled
                     *  selector function built with Sizzle.compile
                     * @param {Element} context
                     * @param {Array} [results]
                     * @param {Array} [seed] A set of elements to match against
                     */
                    select = Sizzle.select = function(selector, context, results, seed) {
                        var i, tokens, token, type, find,
                            compiled = typeof selector === "function" && selector,
                            match = !seed && tokenize((selector = compiled.selector || selector));

                        results = results || [];

                        // Try to minimize operations if there is no seed and only one group
                        if (match.length === 1) {

                            // Take a shortcut and set the context if the root selector is an ID
                            tokens = match[0] = match[0].slice(0);
                            if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                support.getById && context.nodeType === 9 && documentIsHTML &&
                                Expr.relative[tokens[1].type]) {

                                context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                                if (!context) {
                                    return results;

                                    // Precompiled matchers will still verify ancestry, so step up a level
                                } else if (compiled) {
                                    context = context.parentNode;
                                }

                                selector = selector.slice(tokens.shift().value.length);
                            }

                            // Fetch a seed set for right-to-left matching
                            i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                            while (i--) {
                                token = tokens[i];

                                // Abort if we hit a combinator
                                if (Expr.relative[(type = token.type)]) {
                                    break;
                                }
                                if ((find = Expr.find[type])) {
                                    // Search, expanding context for leading sibling combinators
                                    if ((seed = find(
                                            token.matches[0].replace(runescape, funescape),
                                            rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                                        ))) {

                                        // If seed is empty or no tokens remain, we can return early
                                        tokens.splice(i, 1);
                                        selector = seed.length && toSelector(tokens);
                                        if (!selector) {
                                            push.apply(results, seed);
                                            return results;
                                        }

                                        break;
                                    }
                                }
                            }
                        }

                        // Compile and execute a filtering function if one is not provided
                        // Provide `match` to avoid retokenization if we modified the selector above
                        (compiled || compile(selector, match))(
                            seed,
                            context, !documentIsHTML,
                            results,
                            rsibling.test(selector) && testContext(context.parentNode) || context
                        );
                        return results;
                    };

                    // One-time assignments

                    // Sort stability
                    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

                    // Support: Chrome<14
                    // Always assume duplicates if they aren't passed to the comparison function
                    support.detectDuplicates = !!hasDuplicate;

                    // Initialize against the default document
                    setDocument();

                    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                    // Detached nodes confoundingly follow *each other*
                    support.sortDetached = assert(function(div1) {
                        // Should return 1, but returns 4 (following)
                        return div1.compareDocumentPosition(document.createElement("div")) & 1;
                    });

                    // Support: IE<8
                    // Prevent attribute/property "interpolation"
                    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                    if (!assert(function(div) {
                            div.innerHTML = "<a href='#'></a>";
                            return div.firstChild.getAttribute("href") === "#";
                        })) {
                        addHandle("type|href|height|width", function(elem, name, isXML) {
                            if (!isXML) {
                                return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                            }
                        });
                    }

                    // Support: IE<9
                    // Use defaultValue in place of getAttribute("value")
                    if (!support.attributes || !assert(function(div) {
                            div.innerHTML = "<input/>";
                            div.firstChild.setAttribute("value", "");
                            return div.firstChild.getAttribute("value") === "";
                        })) {
                        addHandle("value", function(elem, name, isXML) {
                            if (!isXML && elem.nodeName.toLowerCase() === "input") {
                                return elem.defaultValue;
                            }
                        });
                    }

                    // Support: IE<9
                    // Use getAttributeNode to fetch booleans when getAttribute lies
                    if (!assert(function(div) {
                            return div.getAttribute("disabled") == null;
                        })) {
                        addHandle(booleans, function(elem, name, isXML) {
                            var val;
                            if (!isXML) {
                                return elem[name] === true ? name.toLowerCase() :
                                    (val = elem.getAttributeNode(name)) && val.specified ?
                                    val.value :
                                    null;
                            }
                        });
                    }

                    return Sizzle;

                })(window);



            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;



            var rneedsContext = jQuery.expr.match.needsContext;

            var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



            var risSimple = /^.[^:#\[\.,]*$/;

            // Implement the identical functionality for filter and not
            function winnow(elements, qualifier, not) {
                if (jQuery.isFunction(qualifier)) {
                    return jQuery.grep(elements, function(elem, i) {
                        /* jshint -W018 */
                        return !!qualifier.call(elem, i, elem) !== not;
                    });

                }

                if (qualifier.nodeType) {
                    return jQuery.grep(elements, function(elem) {
                        return (elem === qualifier) !== not;
                    });

                }

                if (typeof qualifier === "string") {
                    if (risSimple.test(qualifier)) {
                        return jQuery.filter(qualifier, elements, not);
                    }

                    qualifier = jQuery.filter(qualifier, elements);
                }

                return jQuery.grep(elements, function(elem) {
                    return (jQuery.inArray(elem, qualifier) >= 0) !== not;
                });
            }

            jQuery.filter = function(expr, elems, not) {
                var elem = elems[0];

                if (not) {
                    expr = ":not(" + expr + ")";
                }

                return elems.length === 1 && elem.nodeType === 1 ?
                    jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
                    jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                        return elem.nodeType === 1;
                    }));
            };

            jQuery.fn.extend({
                find: function(selector) {
                    var i,
                        ret = [],
                        self = this,
                        len = self.length;

                    if (typeof selector !== "string") {
                        return this.pushStack(jQuery(selector).filter(function() {
                            for (i = 0; i < len; i++) {
                                if (jQuery.contains(self[i], this)) {
                                    return true;
                                }
                            }
                        }));
                    }

                    for (i = 0; i < len; i++) {
                        jQuery.find(selector, self[i], ret);
                    }

                    // Needed because $( selector, context ) becomes $( context ).find( selector )
                    ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                    ret.selector = this.selector ? this.selector + " " + selector : selector;
                    return ret;
                },
                filter: function(selector) {
                    return this.pushStack(winnow(this, selector || [], false));
                },
                not: function(selector) {
                    return this.pushStack(winnow(this, selector || [], true));
                },
                is: function(selector) {
                    return !!winnow(
                        this,

                        // If this is a positional/relative selector, check membership in the returned set
                        // so $("p:first").is("p:last") won't return true for a doc with two "p".
                        typeof selector === "string" && rneedsContext.test(selector) ?
                        jQuery(selector) :
                        selector || [],
                        false
                    ).length;
                }
            });


            // Initialize a jQuery object


            // A central reference to the root jQuery(document)
            var rootjQuery,

                // Use the correct document accordingly with window argument (sandbox)
                document = window.document,

                // A simple way to check for HTML strings
                // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                // Strict HTML recognition (#11290: must start with <)
                rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

                init = jQuery.fn.init = function(selector, context) {
                    var match, elem;

                    // HANDLE: $(""), $(null), $(undefined), $(false)
                    if (!selector) {
                        return this;
                    }

                    // Handle HTML strings
                    if (typeof selector === "string") {
                        if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                            // Assume that strings that start and end with <> are HTML and skip the regex check
                            match = [null, selector, null];

                        } else {
                            match = rquickExpr.exec(selector);
                        }

                        // Match html or make sure no context is specified for #id
                        if (match && (match[1] || !context)) {

                            // HANDLE: $(html) -> $(array)
                            if (match[1]) {
                                context = context instanceof jQuery ? context[0] : context;

                                // scripts is true for back-compat
                                // Intentionally let the error be thrown if parseHTML is not present
                                jQuery.merge(this, jQuery.parseHTML(
                                    match[1],
                                    context && context.nodeType ? context.ownerDocument || context : document,
                                    true
                                ));

                                // HANDLE: $(html, props)
                                if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                    for (match in context) {
                                        // Properties of context are called as methods if possible
                                        if (jQuery.isFunction(this[match])) {
                                            this[match](context[match]);

                                            // ...and otherwise set as attributes
                                        } else {
                                            this.attr(match, context[match]);
                                        }
                                    }
                                }

                                return this;

                                // HANDLE: $(#id)
                            } else {
                                elem = document.getElementById(match[2]);

                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if (elem && elem.parentNode) {
                                    // Handle the case where IE and Opera return items
                                    // by name instead of ID
                                    if (elem.id !== match[2]) {
                                        return rootjQuery.find(selector);
                                    }

                                    // Otherwise, we inject the element directly into the jQuery object
                                    this.length = 1;
                                    this[0] = elem;
                                }

                                this.context = document;
                                this.selector = selector;
                                return this;
                            }

                            // HANDLE: $(expr, $(...))
                        } else if (!context || context.jquery) {
                            return (context || rootjQuery).find(selector);

                            // HANDLE: $(expr, context)
                            // (which is just equivalent to: $(context).find(expr)
                        } else {
                            return this.constructor(context).find(selector);
                        }

                        // HANDLE: $(DOMElement)
                    } else if (selector.nodeType) {
                        this.context = this[0] = selector;
                        this.length = 1;
                        return this;

                        // HANDLE: $(function)
                        // Shortcut for document ready
                    } else if (jQuery.isFunction(selector)) {
                        return typeof rootjQuery.ready !== "undefined" ?
                            rootjQuery.ready(selector) :
                            // Execute immediately if ready is not present
                            selector(jQuery);
                    }

                    if (selector.selector !== undefined) {
                        this.selector = selector.selector;
                        this.context = selector.context;
                    }

                    return jQuery.makeArray(selector, this);
                };

            // Give the init function the jQuery prototype for later instantiation
            init.prototype = jQuery.fn;

            // Initialize central reference
            rootjQuery = jQuery(document);


            var rparentsprev = /^(?:parents|prev(?:Until|All))/,
                // methods guaranteed to produce a unique set when starting from a unique set
                guaranteedUnique = {
                    children: true,
                    contents: true,
                    next: true,
                    prev: true
                };

            jQuery.extend({
                dir: function(elem, dir, until) {
                    var matched = [],
                        cur = elem[dir];

                    while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                        if (cur.nodeType === 1) {
                            matched.push(cur);
                        }
                        cur = cur[dir];
                    }
                    return matched;
                },

                sibling: function(n, elem) {
                    var r = [];

                    for (; n; n = n.nextSibling) {
                        if (n.nodeType === 1 && n !== elem) {
                            r.push(n);
                        }
                    }

                    return r;
                }
            });

            jQuery.fn.extend({
                has: function(target) {
                    var i,
                        targets = jQuery(target, this),
                        len = targets.length;

                    return this.filter(function() {
                        for (i = 0; i < len; i++) {
                            if (jQuery.contains(this, targets[i])) {
                                return true;
                            }
                        }
                    });
                },

                closest: function(selectors, context) {
                    var cur,
                        i = 0,
                        l = this.length,
                        matched = [],
                        pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
                        jQuery(selectors, context || this.context) :
                        0;

                    for (; i < l; i++) {
                        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                            // Always skip document fragments
                            if (cur.nodeType < 11 && (pos ?
                                    pos.index(cur) > -1 :

                                    // Don't pass non-elements to Sizzle
                                    cur.nodeType === 1 &&
                                    jQuery.find.matchesSelector(cur, selectors))) {

                                matched.push(cur);
                                break;
                            }
                        }
                    }

                    return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
                },

                // Determine the position of an element within
                // the matched set of elements
                index: function(elem) {

                    // No argument, return index in parent
                    if (!elem) {
                        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
                    }

                    // index in selector
                    if (typeof elem === "string") {
                        return jQuery.inArray(this[0], jQuery(elem));
                    }

                    // Locate the position of the desired element
                    return jQuery.inArray(
                        // If it receives a jQuery object, the first element is used
                        elem.jquery ? elem[0] : elem, this);
                },

                add: function(selector, context) {
                    return this.pushStack(
                        jQuery.unique(
                            jQuery.merge(this.get(), jQuery(selector, context))
                        )
                    );
                },

                addBack: function(selector) {
                    return this.add(selector == null ?
                        this.prevObject : this.prevObject.filter(selector)
                    );
                }
            });

            function sibling(cur, dir) {
                do {
                    cur = cur[dir];
                } while (cur && cur.nodeType !== 1);

                return cur;
            }

            jQuery.each({
                parent: function(elem) {
                    var parent = elem.parentNode;
                    return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function(elem) {
                    return jQuery.dir(elem, "parentNode");
                },
                parentsUntil: function(elem, i, until) {
                    return jQuery.dir(elem, "parentNode", until);
                },
                next: function(elem) {
                    return sibling(elem, "nextSibling");
                },
                prev: function(elem) {
                    return sibling(elem, "previousSibling");
                },
                nextAll: function(elem) {
                    return jQuery.dir(elem, "nextSibling");
                },
                prevAll: function(elem) {
                    return jQuery.dir(elem, "previousSibling");
                },
                nextUntil: function(elem, i, until) {
                    return jQuery.dir(elem, "nextSibling", until);
                },
                prevUntil: function(elem, i, until) {
                    return jQuery.dir(elem, "previousSibling", until);
                },
                siblings: function(elem) {
                    return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
                },
                children: function(elem) {
                    return jQuery.sibling(elem.firstChild);
                },
                contents: function(elem) {
                    return jQuery.nodeName(elem, "iframe") ?
                        elem.contentDocument || elem.contentWindow.document :
                        jQuery.merge([], elem.childNodes);
                }
            }, function(name, fn) {
                jQuery.fn[name] = function(until, selector) {
                    var ret = jQuery.map(this, fn, until);

                    if (name.slice(-5) !== "Until") {
                        selector = until;
                    }

                    if (selector && typeof selector === "string") {
                        ret = jQuery.filter(selector, ret);
                    }

                    if (this.length > 1) {
                        // Remove duplicates
                        if (!guaranteedUnique[name]) {
                            ret = jQuery.unique(ret);
                        }

                        // Reverse order for parents* and prev-derivatives
                        if (rparentsprev.test(name)) {
                            ret = ret.reverse();
                        }
                    }

                    return this.pushStack(ret);
                };
            });
            var rnotwhite = (/\S+/g);



            // String to Object options format cache
            var optionsCache = {};

            // Convert String-formatted options into Object-formatted ones and store in cache
            function createOptions(options) {
                var object = optionsCache[options] = {};
                jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
                    object[flag] = true;
                });
                return object;
            }

            /*
             * Create a callback list using the following parameters:
             *
             *  options: an optional list of space-separated options that will change how
             *          the callback list behaves or a more traditional option object
             *
             * By default a callback list will act like an event callback list and can be
             * "fired" multiple times.
             *
             * Possible options:
             *
             *  once:           will ensure the callback list can only be fired once (like a Deferred)
             *
             *  memory:         will keep track of previous values and will call any callback added
             *                  after the list has been fired right away with the latest "memorized"
             *                  values (like a Deferred)
             *
             *  unique:         will ensure a callback can only be added once (no duplicate in the list)
             *
             *  stopOnFalse:    interrupt callings when a callback returns false
             *
             */
            jQuery.Callbacks = function(options) {

                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                options = typeof options === "string" ?
                    (optionsCache[options] || createOptions(options)) :
                    jQuery.extend({}, options);

                var // Flag to know if list is currently firing
                    firing,
                    // Last fire value (for non-forgettable lists)
                    memory,
                    // Flag to know if list was already fired
                    fired,
                    // End of the loop when firing
                    firingLength,
                    // Index of currently firing callback (modified by remove if needed)
                    firingIndex,
                    // First callback to fire (used internally by add and fireWith)
                    firingStart,
                    // Actual callback list
                    list = [],
                    // Stack of fire calls for repeatable lists
                    stack = !options.once && [],
                    // Fire callbacks
                    fire = function(data) {
                        memory = options.memory && data;
                        fired = true;
                        firingIndex = firingStart || 0;
                        firingStart = 0;
                        firingLength = list.length;
                        firing = true;
                        for (; list && firingIndex < firingLength; firingIndex++) {
                            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                                memory = false; // To prevent further calls using add
                                break;
                            }
                        }
                        firing = false;
                        if (list) {
                            if (stack) {
                                if (stack.length) {
                                    fire(stack.shift());
                                }
                            } else if (memory) {
                                list = [];
                            } else {
                                self.disable();
                            }
                        }
                    },
                    // Actual Callbacks object
                    self = {
                        // Add a callback or a collection of callbacks to the list
                        add: function() {
                            if (list) {
                                // First, we save the current length
                                var start = list.length;
                                (function add(args) {
                                    jQuery.each(args, function(_, arg) {
                                        var type = jQuery.type(arg);
                                        if (type === "function") {
                                            if (!options.unique || !self.has(arg)) {
                                                list.push(arg);
                                            }
                                        } else if (arg && arg.length && type !== "string") {
                                            // Inspect recursively
                                            add(arg);
                                        }
                                    });
                                })(arguments);
                                // Do we need to add the callbacks to the
                                // current firing batch?
                                if (firing) {
                                    firingLength = list.length;
                                    // With memory, if we're not firing then
                                    // we should call right away
                                } else if (memory) {
                                    firingStart = start;
                                    fire(memory);
                                }
                            }
                            return this;
                        },
                        // Remove a callback from the list
                        remove: function() {
                            if (list) {
                                jQuery.each(arguments, function(_, arg) {
                                    var index;
                                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                        list.splice(index, 1);
                                        // Handle firing indexes
                                        if (firing) {
                                            if (index <= firingLength) {
                                                firingLength--;
                                            }
                                            if (index <= firingIndex) {
                                                firingIndex--;
                                            }
                                        }
                                    }
                                });
                            }
                            return this;
                        },
                        // Check if a given callback is in the list.
                        // If no argument is given, return whether or not list has callbacks attached.
                        has: function(fn) {
                            return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                        },
                        // Remove all callbacks from the list
                        empty: function() {
                            list = [];
                            firingLength = 0;
                            return this;
                        },
                        // Have the list do nothing anymore
                        disable: function() {
                            list = stack = memory = undefined;
                            return this;
                        },
                        // Is it disabled?
                        disabled: function() {
                            return !list;
                        },
                        // Lock the list in its current state
                        lock: function() {
                            stack = undefined;
                            if (!memory) {
                                self.disable();
                            }
                            return this;
                        },
                        // Is it locked?
                        locked: function() {
                            return !stack;
                        },
                        // Call all callbacks with the given context and arguments
                        fireWith: function(context, args) {
                            if (list && (!fired || stack)) {
                                args = args || [];
                                args = [context, args.slice ? args.slice() : args];
                                if (firing) {
                                    stack.push(args);
                                } else {
                                    fire(args);
                                }
                            }
                            return this;
                        },
                        // Call all the callbacks with the given arguments
                        fire: function() {
                            self.fireWith(this, arguments);
                            return this;
                        },
                        // To know if the callbacks have already been called at least once
                        fired: function() {
                            return !!fired;
                        }
                    };

                return self;
            };


            jQuery.extend({

                Deferred: function(func) {
                    var tuples = [
                            // action, add listener, listener list, final state
                            ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                            ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                            ["notify", "progress", jQuery.Callbacks("memory")]
                        ],
                        state = "pending",
                        promise = {
                            state: function() {
                                return state;
                            },
                            always: function() {
                                deferred.done(arguments).fail(arguments);
                                return this;
                            },
                            then: function( /* fnDone, fnFail, fnProgress */ ) {
                                var fns = arguments;
                                return jQuery.Deferred(function(newDefer) {
                                    jQuery.each(tuples, function(i, tuple) {
                                        var fn = jQuery.isFunction(fns[i]) && fns[i];
                                        // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                        deferred[tuple[1]](function() {
                                            var returned = fn && fn.apply(this, arguments);
                                            if (returned && jQuery.isFunction(returned.promise)) {
                                                returned.promise()
                                                    .done(newDefer.resolve)
                                                    .fail(newDefer.reject)
                                                    .progress(newDefer.notify);
                                            } else {
                                                newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                            }
                                        });
                                    });
                                    fns = null;
                                }).promise();
                            },
                            // Get a promise for this deferred
                            // If obj is provided, the promise aspect is added to the object
                            promise: function(obj) {
                                return obj != null ? jQuery.extend(obj, promise) : promise;
                            }
                        },
                        deferred = {};

                    // Keep pipe for back-compat
                    promise.pipe = promise.then;

                    // Add list-specific methods
                    jQuery.each(tuples, function(i, tuple) {
                        var list = tuple[2],
                            stateString = tuple[3];

                        // promise[ done | fail | progress ] = list.add
                        promise[tuple[1]] = list.add;

                        // Handle state
                        if (stateString) {
                            list.add(function() {
                                // state = [ resolved | rejected ]
                                state = stateString;

                                // [ reject_list | resolve_list ].disable; progress_list.lock
                            }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                        }

                        // deferred[ resolve | reject | notify ]
                        deferred[tuple[0]] = function() {
                            deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                            return this;
                        };
                        deferred[tuple[0] + "With"] = list.fireWith;
                    });

                    // Make the deferred a promise
                    promise.promise(deferred);

                    // Call given func if any
                    if (func) {
                        func.call(deferred, deferred);
                    }

                    // All done!
                    return deferred;
                },

                // Deferred helper
                when: function(subordinate /* , ..., subordinateN */ ) {
                    var i = 0,
                        resolveValues = slice.call(arguments),
                        length = resolveValues.length,

                        // the count of uncompleted subordinates
                        remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

                        // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                        // Update function for both resolve and progress values
                        updateFunc = function(i, contexts, values) {
                            return function(value) {
                                contexts[i] = this;
                                values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                                if (values === progressValues) {
                                    deferred.notifyWith(contexts, values);

                                } else if (!(--remaining)) {
                                    deferred.resolveWith(contexts, values);
                                }
                            };
                        },

                        progressValues, progressContexts, resolveContexts;

                    // add listeners to Deferred subordinates; treat others as resolved
                    if (length > 1) {
                        progressValues = new Array(length);
                        progressContexts = new Array(length);
                        resolveContexts = new Array(length);
                        for (; i < length; i++) {
                            if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                                resolveValues[i].promise()
                                    .done(updateFunc(i, resolveContexts, resolveValues))
                                    .fail(deferred.reject)
                                    .progress(updateFunc(i, progressContexts, progressValues));
                            } else {
                                --remaining;
                            }
                        }
                    }

                    // if we're not waiting on anything, resolve the master
                    if (!remaining) {
                        deferred.resolveWith(resolveContexts, resolveValues);
                    }

                    return deferred.promise();
                }
            });


            // The deferred used on DOM ready
            var readyList;

            jQuery.fn.ready = function(fn) {
                // Add the callback
                jQuery.ready.promise().done(fn);

                return this;
            };

            jQuery.extend({
                // Is the DOM ready to be used? Set to true once it occurs.
                isReady: false,

                // A counter to track how many items to wait for before
                // the ready event fires. See #6781
                readyWait: 1,

                // Hold (or release) the ready event
                holdReady: function(hold) {
                    if (hold) {
                        jQuery.readyWait++;
                    } else {
                        jQuery.ready(true);
                    }
                },

                // Handle when the DOM is ready
                ready: function(wait) {

                    // Abort if there are pending holds or we're already ready
                    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                        return;
                    }

                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if (!document.body) {
                        return setTimeout(jQuery.ready);
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith(document, [jQuery]);

                    // Trigger any bound ready events
                    if (jQuery.fn.triggerHandler) {
                        jQuery(document).triggerHandler("ready");
                        jQuery(document).off("ready");
                    }
                }
            });

            /**
             * Clean-up method for dom ready events
             */
            function detach() {
                if (document.addEventListener) {
                    document.removeEventListener("DOMContentLoaded", completed, false);
                    window.removeEventListener("load", completed, false);

                } else {
                    document.detachEvent("onreadystatechange", completed);
                    window.detachEvent("onload", completed);
                }
            }

            /**
             * The ready event handler and self cleanup method
             */
            function completed() {
                // readyState === "complete" is good enough for us to call the dom ready in oldIE
                if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
                    detach();
                    jQuery.ready();
                }
            }

            jQuery.ready.promise = function(obj) {
                if (!readyList) {

                    readyList = jQuery.Deferred();

                    // Catch cases where $(document).ready() is called after the browser event has already occurred.
                    // we once tried to use readyState "interactive" here, but it caused issues like the one
                    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
                    if (document.readyState === "complete") {
                        // Handle it asynchronously to allow scripts the opportunity to delay ready
                        setTimeout(jQuery.ready);

                        // Standards-based browsers support DOMContentLoaded
                    } else if (document.addEventListener) {
                        // Use the handy event callback
                        document.addEventListener("DOMContentLoaded", completed, false);

                        // A fallback to window.onload, that will always work
                        window.addEventListener("load", completed, false);

                        // If IE event model is used
                    } else {
                        // Ensure firing before onload, maybe late but safe also for iframes
                        document.attachEvent("onreadystatechange", completed);

                        // A fallback to window.onload, that will always work
                        window.attachEvent("onload", completed);

                        // If IE and not a frame
                        // continually check to see if the document is ready
                        var top = false;

                        try {
                            top = window.frameElement == null && document.documentElement;
                        } catch (e) {}

                        if (top && top.doScroll) {
                            (function doScrollCheck() {
                                if (!jQuery.isReady) {

                                    try {
                                        // Use the trick by Diego Perini
                                        // http://javascript.nwbox.com/IEContentLoaded/
                                        top.doScroll("left");
                                    } catch (e) {
                                        return setTimeout(doScrollCheck, 50);
                                    }

                                    // detach all dom ready events
                                    detach();

                                    // and execute any waiting functions
                                    jQuery.ready();
                                }
                            })();
                        }
                    }
                }
                return readyList.promise(obj);
            };


            var strundefined = typeof undefined;



            // Support: IE<9
            // Iteration over object's inherited properties before its own
            var i;
            for (i in jQuery(support)) {
                break;
            }
            support.ownLast = i !== "0";

            // Note: most support tests are defined in their respective modules.
            // false until the test is run
            support.inlineBlockNeedsLayout = false;

            // Execute ASAP in case we need to set body.style.zoom
            jQuery(function() {
                // Minified: var a,b,c,d
                var val, div, body, container;

                body = document.getElementsByTagName("body")[0];
                if (!body || !body.style) {
                    // Return for frameset docs that don't have a body
                    return;
                }

                // Setup
                div = document.createElement("div");
                container = document.createElement("div");
                container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
                body.appendChild(container).appendChild(div);

                if (typeof div.style.zoom !== strundefined) {
                    // Support: IE<8
                    // Check if natively block-level elements act like inline-block
                    // elements when setting their display to 'inline' and giving
                    // them layout
                    div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

                    support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
                    if (val) {
                        // Prevent IE 6 from affecting layout for positioned elements #11048
                        // Prevent IE from shrinking the body in IE 7 mode #12869
                        // Support: IE<8
                        body.style.zoom = 1;
                    }
                }

                body.removeChild(container);
            });




            (function() {
                var div = document.createElement("div");

                // Execute the test only if not already executed in another module.
                if (support.deleteExpando == null) {
                    // Support: IE<9
                    support.deleteExpando = true;
                    try {
                        delete div.test;
                    } catch (e) {
                        support.deleteExpando = false;
                    }
                }

                // Null elements to avoid leaks in IE.
                div = null;
            })();


            /**
             * Determines whether an object can have data
             */
            jQuery.acceptData = function(elem) {
                var noData = jQuery.noData[(elem.nodeName + " ").toLowerCase()],
                    nodeType = +elem.nodeType || 1;

                // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
                return nodeType !== 1 && nodeType !== 9 ?
                    false :

                    // Nodes accept data unless otherwise specified; rejection can be conditional
                    !noData || noData !== true && elem.getAttribute("classid") === noData;
            };


            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                rmultiDash = /([A-Z])/g;

            function dataAttr(elem, key, data) {
                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if (data === undefined && elem.nodeType === 1) {

                    var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

                    data = elem.getAttribute(name);

                    if (typeof data === "string") {
                        try {
                            data = data === "true" ? true :
                                data === "false" ? false :
                                data === "null" ? null :
                                // Only convert to a number if it doesn't change the string
                                +data + "" === data ? +data :
                                rbrace.test(data) ? jQuery.parseJSON(data) :
                                data;
                        } catch (e) {}

                        // Make sure we set the data so it isn't changed later
                        jQuery.data(elem, key, data);

                    } else {
                        data = undefined;
                    }
                }

                return data;
            }

            // checks a cache object for emptiness
            function isEmptyDataObject(obj) {
                var name;
                for (name in obj) {

                    // if the public data object is empty, the private is still empty
                    if (name === "data" && jQuery.isEmptyObject(obj[name])) {
                        continue;
                    }
                    if (name !== "toJSON") {
                        return false;
                    }
                }

                return true;
            }

            function internalData(elem, name, data, pvt /* Internal Use Only */ ) {
                if (!jQuery.acceptData(elem)) {
                    return;
                }

                var ret, thisCache,
                    internalKey = jQuery.expando,

                    // We have to handle DOM nodes and JS objects differently because IE6-7
                    // can't GC object references properly across the DOM-JS boundary
                    isNode = elem.nodeType,

                    // Only DOM nodes need the global jQuery cache; JS object data is
                    // attached directly to the object so GC can occur automatically
                    cache = isNode ? jQuery.cache : elem,

                    // Only defining an ID for JS objects if its cache already exists allows
                    // the code to shortcut on the same path as a DOM node with no cache
                    id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

                // Avoid doing any more work than we need to when trying to get data on an
                // object that has no data at all
                if ((!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string") {
                    return;
                }

                if (!id) {
                    // Only DOM nodes need a new unique ID for each element since their data
                    // ends up in the global cache
                    if (isNode) {
                        id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
                    } else {
                        id = internalKey;
                    }
                }

                if (!cache[id]) {
                    // Avoid exposing jQuery metadata on plain JS objects when the object
                    // is serialized using JSON.stringify
                    cache[id] = isNode ? {} : {
                        toJSON: jQuery.noop
                    };
                }

                // An object can be passed to jQuery.data instead of a key/value pair; this gets
                // shallow copied over onto the existing cache
                if (typeof name === "object" || typeof name === "function") {
                    if (pvt) {
                        cache[id] = jQuery.extend(cache[id], name);
                    } else {
                        cache[id].data = jQuery.extend(cache[id].data, name);
                    }
                }

                thisCache = cache[id];

                // jQuery data() is stored in a separate object inside the object's internal data
                // cache in order to avoid key collisions between internal data and user-defined
                // data.
                if (!pvt) {
                    if (!thisCache.data) {
                        thisCache.data = {};
                    }

                    thisCache = thisCache.data;
                }

                if (data !== undefined) {
                    thisCache[jQuery.camelCase(name)] = data;
                }

                // Check for both converted-to-camel and non-converted data property names
                // If a data property was specified
                if (typeof name === "string") {

                    // First Try to find as-is property data
                    ret = thisCache[name];

                    // Test for null|undefined property data
                    if (ret == null) {

                        // Try to find the camelCased property
                        ret = thisCache[jQuery.camelCase(name)];
                    }
                } else {
                    ret = thisCache;
                }

                return ret;
            }

            function internalRemoveData(elem, name, pvt) {
                if (!jQuery.acceptData(elem)) {
                    return;
                }

                var thisCache, i,
                    isNode = elem.nodeType,

                    // See jQuery.data for more information
                    cache = isNode ? jQuery.cache : elem,
                    id = isNode ? elem[jQuery.expando] : jQuery.expando;

                // If there is already no cache entry for this object, there is no
                // purpose in continuing
                if (!cache[id]) {
                    return;
                }

                if (name) {

                    thisCache = pvt ? cache[id] : cache[id].data;

                    if (thisCache) {

                        // Support array or space separated string names for data keys
                        if (!jQuery.isArray(name)) {

                            // try the string as a key before any manipulation
                            if (name in thisCache) {
                                name = [name];
                            } else {

                                // split the camel cased version by spaces unless a key with the spaces exists
                                name = jQuery.camelCase(name);
                                if (name in thisCache) {
                                    name = [name];
                                } else {
                                    name = name.split(" ");
                                }
                            }
                        } else {
                            // If "name" is an array of keys...
                            // When data is initially created, via ("key", "val") signature,
                            // keys will be converted to camelCase.
                            // Since there is no way to tell _how_ a key was added, remove
                            // both plain key and camelCase key. #12786
                            // This will only penalize the array argument path.
                            name = name.concat(jQuery.map(name, jQuery.camelCase));
                        }

                        i = name.length;
                        while (i--) {
                            delete thisCache[name[i]];
                        }

                        // If there is no data left in the cache, we want to continue
                        // and let the cache object itself get destroyed
                        if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
                            return;
                        }
                    }
                }

                // See jQuery.data for more information
                if (!pvt) {
                    delete cache[id].data;

                    // Don't destroy the parent cache unless the internal data object
                    // had been the only thing left in it
                    if (!isEmptyDataObject(cache[id])) {
                        return;
                    }
                }

                // Destroy the cache
                if (isNode) {
                    jQuery.cleanData([elem], true);

                    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
                    /* jshint eqeqeq: false */
                } else if (support.deleteExpando || cache != cache.window) {
                    /* jshint eqeqeq: true */
                    delete cache[id];

                    // When all else fails, null
                } else {
                    cache[id] = null;
                }
            }

            jQuery.extend({
                cache: {},

                // The following elements (space-suffixed to avoid Object.prototype collisions)
                // throw uncatchable exceptions if you attempt to set expando properties
                noData: {
                    "applet ": true,
                    "embed ": true,
                    // ...but Flash objects (which have this classid) *can* handle expandos
                    "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                },

                hasData: function(elem) {
                    elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
                    return !!elem && !isEmptyDataObject(elem);
                },

                data: function(elem, name, data) {
                    return internalData(elem, name, data);
                },

                removeData: function(elem, name) {
                    return internalRemoveData(elem, name);
                },

                // For internal use only.
                _data: function(elem, name, data) {
                    return internalData(elem, name, data, true);
                },

                _removeData: function(elem, name) {
                    return internalRemoveData(elem, name, true);
                }
            });

            jQuery.fn.extend({
                data: function(key, value) {
                    var i, name, data,
                        elem = this[0],
                        attrs = elem && elem.attributes;

                    // Special expections of .data basically thwart jQuery.access,
                    // so implement the relevant behavior ourselves

                    // Gets all values
                    if (key === undefined) {
                        if (this.length) {
                            data = jQuery.data(elem);

                            if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
                                i = attrs.length;
                                while (i--) {

                                    // Support: IE11+
                                    // The attrs elements can be null (#14894)
                                    if (attrs[i]) {
                                        name = attrs[i].name;
                                        if (name.indexOf("data-") === 0) {
                                            name = jQuery.camelCase(name.slice(5));
                                            dataAttr(elem, name, data[name]);
                                        }
                                    }
                                }
                                jQuery._data(elem, "parsedAttrs", true);
                            }
                        }

                        return data;
                    }

                    // Sets multiple values
                    if (typeof key === "object") {
                        return this.each(function() {
                            jQuery.data(this, key);
                        });
                    }

                    return arguments.length > 1 ?

                        // Sets one value
                        this.each(function() {
                            jQuery.data(this, key, value);
                        }) :

                        // Gets one value
                        // Try to fetch any internally stored data first
                        elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
                },

                removeData: function(key) {
                    return this.each(function() {
                        jQuery.removeData(this, key);
                    });
                }
            });


            jQuery.extend({
                queue: function(elem, type, data) {
                    var queue;

                    if (elem) {
                        type = (type || "fx") + "queue";
                        queue = jQuery._data(elem, type);

                        // Speed up dequeue by getting out quickly if this is just a lookup
                        if (data) {
                            if (!queue || jQuery.isArray(data)) {
                                queue = jQuery._data(elem, type, jQuery.makeArray(data));
                            } else {
                                queue.push(data);
                            }
                        }
                        return queue || [];
                    }
                },

                dequeue: function(elem, type) {
                    type = type || "fx";

                    var queue = jQuery.queue(elem, type),
                        startLength = queue.length,
                        fn = queue.shift(),
                        hooks = jQuery._queueHooks(elem, type),
                        next = function() {
                            jQuery.dequeue(elem, type);
                        };

                    // If the fx queue is dequeued, always remove the progress sentinel
                    if (fn === "inprogress") {
                        fn = queue.shift();
                        startLength--;
                    }

                    if (fn) {

                        // Add a progress sentinel to prevent the fx queue from being
                        // automatically dequeued
                        if (type === "fx") {
                            queue.unshift("inprogress");
                        }

                        // clear up the last queue stop function
                        delete hooks.stop;
                        fn.call(elem, next, hooks);
                    }

                    if (!startLength && hooks) {
                        hooks.empty.fire();
                    }
                },

                // not intended for public consumption - generates a queueHooks object, or returns the current one
                _queueHooks: function(elem, type) {
                    var key = type + "queueHooks";
                    return jQuery._data(elem, key) || jQuery._data(elem, key, {
                        empty: jQuery.Callbacks("once memory").add(function() {
                            jQuery._removeData(elem, type + "queue");
                            jQuery._removeData(elem, key);
                        })
                    });
                }
            });

            jQuery.fn.extend({
                queue: function(type, data) {
                    var setter = 2;

                    if (typeof type !== "string") {
                        data = type;
                        type = "fx";
                        setter--;
                    }

                    if (arguments.length < setter) {
                        return jQuery.queue(this[0], type);
                    }

                    return data === undefined ?
                        this :
                        this.each(function() {
                            var queue = jQuery.queue(this, type, data);

                            // ensure a hooks for this queue
                            jQuery._queueHooks(this, type);

                            if (type === "fx" && queue[0] !== "inprogress") {
                                jQuery.dequeue(this, type);
                            }
                        });
                },
                dequeue: function(type) {
                    return this.each(function() {
                        jQuery.dequeue(this, type);
                    });
                },
                clearQueue: function(type) {
                    return this.queue(type || "fx", []);
                },
                // Get a promise resolved when queues of a certain type
                // are emptied (fx is the type by default)
                promise: function(type, obj) {
                    var tmp,
                        count = 1,
                        defer = jQuery.Deferred(),
                        elements = this,
                        i = this.length,
                        resolve = function() {
                            if (!(--count)) {
                                defer.resolveWith(elements, [elements]);
                            }
                        };

                    if (typeof type !== "string") {
                        obj = type;
                        type = undefined;
                    }
                    type = type || "fx";

                    while (i--) {
                        tmp = jQuery._data(elements[i], type + "queueHooks");
                        if (tmp && tmp.empty) {
                            count++;
                            tmp.empty.add(resolve);
                        }
                    }
                    resolve();
                    return defer.promise(obj);
                }
            });
            var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

            var cssExpand = ["Top", "Right", "Bottom", "Left"];

            var isHidden = function(elem, el) {
                // isHidden might be called from jQuery#filter function;
                // in that case, element will be second argument
                elem = el || elem;
                return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
            };



            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0,
                    length = elems.length,
                    bulk = key == null;

                // Sets many values
                if (jQuery.type(key) === "object") {
                    chainable = true;
                    for (i in key) {
                        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                    }

                    // Sets one value
                } else if (value !== undefined) {
                    chainable = true;

                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }

                    if (bulk) {
                        // Bulk operations run against the entire set
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;

                            // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function(elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }

                    if (fn) {
                        for (; i < length; i++) {
                            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                        }
                    }
                }

                return chainable ?
                    elems :

                    // Gets
                    bulk ?
                    fn.call(elems) :
                    length ? fn(elems[0], key) : emptyGet;
            };
            var rcheckableType = (/^(?:checkbox|radio)$/i);



            (function() {
                // Minified: var a,b,c
                var input = document.createElement("input"),
                    div = document.createElement("div"),
                    fragment = document.createDocumentFragment();

                // Setup
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

                // IE strips leading whitespace when .innerHTML is used
                support.leadingWhitespace = div.firstChild.nodeType === 3;

                // Make sure that tbody elements aren't automatically inserted
                // IE will insert them into empty tables
                support.tbody = !div.getElementsByTagName("tbody").length;

                // Make sure that link elements get serialized correctly by innerHTML
                // This requires a wrapper element in IE
                support.htmlSerialize = !!div.getElementsByTagName("link").length;

                // Makes sure cloning an html5 element does not cause problems
                // Where outerHTML is undefined, this still works
                support.html5Clone =
                    document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>";

                // Check if a disconnected checkbox will retain its checked
                // value of true after appended to the DOM (IE6/7)
                input.type = "checkbox";
                input.checked = true;
                fragment.appendChild(input);
                support.appendChecked = input.checked;

                // Make sure textarea (and checkbox) defaultValue is properly cloned
                // Support: IE6-IE11+
                div.innerHTML = "<textarea>x</textarea>";
                support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;

                // #11217 - WebKit loses check when the name is after the checked attribute
                fragment.appendChild(div);
                div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

                // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
                // old WebKit doesn't clone checked state correctly in fragments
                support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

                // Support: IE<9
                // Opera does not clone events (and typeof div.attachEvent === undefined).
                // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
                support.noCloneEvent = true;
                if (div.attachEvent) {
                    div.attachEvent("onclick", function() {
                        support.noCloneEvent = false;
                    });

                    div.cloneNode(true).click();
                }

                // Execute the test only if not already executed in another module.
                if (support.deleteExpando == null) {
                    // Support: IE<9
                    support.deleteExpando = true;
                    try {
                        delete div.test;
                    } catch (e) {
                        support.deleteExpando = false;
                    }
                }
            })();


            (function() {
                var i, eventName,
                    div = document.createElement("div");

                // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
                for (i in {
                        submit: true,
                        change: true,
                        focusin: true
                    }) {
                    eventName = "on" + i;

                    if (!(support[i + "Bubbles"] = eventName in window)) {
                        // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
                        div.setAttribute(eventName, "t");
                        support[i + "Bubbles"] = div.attributes[eventName].expando === false;
                    }
                }

                // Null elements to avoid leaks in IE.
                div = null;
            })();


            var rformElems = /^(?:input|select|textarea)$/i,
                rkeyEvent = /^key/,
                rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
                rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
                rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

            function returnTrue() {
                return true;
            }

            function returnFalse() {
                return false;
            }

            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch (err) {}
            }

            /*
             * Helper functions for managing events -- not part of the public interface.
             * Props to Dean Edwards' addEvent library for many of the ideas.
             */
            jQuery.event = {

                global: {},

                add: function(elem, types, handler, data, selector) {
                    var tmp, events, t, handleObjIn,
                        special, eventHandle, handleObj,
                        handlers, type, namespaces, origType,
                        elemData = jQuery._data(elem);

                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if (!elemData) {
                        return;
                    }

                    // Caller can pass in an object of custom data in lieu of the handler
                    if (handler.handler) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }

                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if (!handler.guid) {
                        handler.guid = jQuery.guid++;
                    }

                    // Init the element's event structure and main handler, if this is the first
                    if (!(events = elemData.events)) {
                        events = elemData.events = {};
                    }
                    if (!(eventHandle = elemData.handle)) {
                        eventHandle = elemData.handle = function(e) {
                            // Discard the second event of a jQuery.event.trigger() and
                            // when an event is called after a page has unloaded
                            return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
                                jQuery.event.dispatch.apply(eventHandle.elem, arguments) :
                                undefined;
                        };
                        // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                        eventHandle.elem = elem;
                    }

                    // Handle multiple events separated by a space
                    types = (types || "").match(rnotwhite) || [""];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || "").split(".").sort();

                        // There *must* be a type, no attaching namespace-only handlers
                        if (!type) {
                            continue;
                        }

                        // If event changes its type, use the special event handlers for the changed type
                        special = jQuery.event.special[type] || {};

                        // If selector defined, determine special event api type, otherwise given type
                        type = (selector ? special.delegateType : special.bindType) || type;

                        // Update special based on newly reset type
                        special = jQuery.event.special[type] || {};

                        // handleObj is passed to all event handlers
                        handleObj = jQuery.extend({
                            type: type,
                            origType: origType,
                            data: data,
                            handler: handler,
                            guid: handler.guid,
                            selector: selector,
                            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                            namespace: namespaces.join(".")
                        }, handleObjIn);

                        // Init the event handler queue if we're the first
                        if (!(handlers = events[type])) {
                            handlers = events[type] = [];
                            handlers.delegateCount = 0;

                            // Only use addEventListener/attachEvent if the special events handler returns false
                            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                                // Bind the global event handler to the element
                                if (elem.addEventListener) {
                                    elem.addEventListener(type, eventHandle, false);

                                } else if (elem.attachEvent) {
                                    elem.attachEvent("on" + type, eventHandle);
                                }
                            }
                        }

                        if (special.add) {
                            special.add.call(elem, handleObj);

                            if (!handleObj.handler.guid) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }

                        // Add to the element's handler list, delegates in front
                        if (selector) {
                            handlers.splice(handlers.delegateCount++, 0, handleObj);
                        } else {
                            handlers.push(handleObj);
                        }

                        // Keep track of which events have ever been used, for event optimization
                        jQuery.event.global[type] = true;
                    }

                    // Nullify elem to prevent memory leaks in IE
                    elem = null;
                },

                // Detach an event or set of events from an element
                remove: function(elem, types, handler, selector, mappedTypes) {
                    var j, handleObj, tmp,
                        origCount, t, events,
                        special, handlers, type,
                        namespaces, origType,
                        elemData = jQuery.hasData(elem) && jQuery._data(elem);

                    if (!elemData || !(events = elemData.events)) {
                        return;
                    }

                    // Once for each type.namespace in types; type may be omitted
                    types = (types || "").match(rnotwhite) || [""];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || "").split(".").sort();

                        // Unbind all events (on this namespace, if provided) for the element
                        if (!type) {
                            for (type in events) {
                                jQuery.event.remove(elem, type + types[t], handler, selector, true);
                            }
                            continue;
                        }

                        special = jQuery.event.special[type] || {};
                        type = (selector ? special.delegateType : special.bindType) || type;
                        handlers = events[type] || [];
                        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                        // Remove matching events
                        origCount = j = handlers.length;
                        while (j--) {
                            handleObj = handlers[j];

                            if ((mappedTypes || origType === handleObj.origType) &&
                                (!handler || handler.guid === handleObj.guid) &&
                                (!tmp || tmp.test(handleObj.namespace)) &&
                                (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                                handlers.splice(j, 1);

                                if (handleObj.selector) {
                                    handlers.delegateCount--;
                                }
                                if (special.remove) {
                                    special.remove.call(elem, handleObj);
                                }
                            }
                        }

                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if (origCount && !handlers.length) {
                            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                                jQuery.removeEvent(elem, type, elemData.handle);
                            }

                            delete events[type];
                        }
                    }

                    // Remove the expando if it's no longer used
                    if (jQuery.isEmptyObject(events)) {
                        delete elemData.handle;

                        // removeData also checks for emptiness and clears the expando if empty
                        // so use it instead of delete
                        jQuery._removeData(elem, "events");
                    }
                },

                trigger: function(event, data, elem, onlyHandlers) {
                    var handle, ontype, cur,
                        bubbleType, special, tmp, i,
                        eventPath = [elem || document],
                        type = hasOwn.call(event, "type") ? event.type : event,
                        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

                    cur = tmp = elem = elem || document;

                    // Don't do events on text and comment nodes
                    if (elem.nodeType === 3 || elem.nodeType === 8) {
                        return;
                    }

                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if (rfocusMorph.test(type + jQuery.event.triggered)) {
                        return;
                    }

                    if (type.indexOf(".") >= 0) {
                        // Namespaced trigger; create a regexp to match event type in handle()
                        namespaces = type.split(".");
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf(":") < 0 && "on" + type;

                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    event = event[jQuery.expando] ?
                        event :
                        new jQuery.Event(type, typeof event === "object" && event);

                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join(".");
                    event.namespace_re = event.namespace ?
                        new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                        null;

                    // Clean up the event in case it is being reused
                    event.result = undefined;
                    if (!event.target) {
                        event.target = elem;
                    }

                    // Clone any incoming data and prepend the event, creating the handler arg list
                    data = data == null ? [event] :
                        jQuery.makeArray(data, [event]);

                    // Allow special events to draw outside the lines
                    special = jQuery.event.special[type] || {};
                    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                        return;
                    }

                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                        bubbleType = special.delegateType || type;
                        if (!rfocusMorph.test(bubbleType + type)) {
                            cur = cur.parentNode;
                        }
                        for (; cur; cur = cur.parentNode) {
                            eventPath.push(cur);
                            tmp = cur;
                        }

                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if (tmp === (elem.ownerDocument || document)) {
                            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                        }
                    }

                    // Fire handlers on the event path
                    i = 0;
                    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                        event.type = i > 1 ?
                            bubbleType :
                            special.bindType || type;

                        // jQuery handler
                        handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");
                        if (handle) {
                            handle.apply(cur, data);
                        }

                        // Native handler
                        handle = ontype && cur[ontype];
                        if (handle && handle.apply && jQuery.acceptData(cur)) {
                            event.result = handle.apply(cur, data);
                            if (event.result === false) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;

                    // If nobody prevented the default action, do it now
                    if (!onlyHandlers && !event.isDefaultPrevented()) {

                        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &&
                            jQuery.acceptData(elem)) {

                            // Call a native DOM method on the target with the same name name as the event.
                            // Can't use an .isFunction() check here because IE6/7 fails that test.
                            // Don't do default actions on window, that's where global variables be (#6170)
                            if (ontype && elem[type] && !jQuery.isWindow(elem)) {

                                // Don't re-trigger an onFOO event when we call its FOO() method
                                tmp = elem[ontype];

                                if (tmp) {
                                    elem[ontype] = null;
                                }

                                // Prevent re-triggering of the same event, since we already bubbled it above
                                jQuery.event.triggered = type;
                                try {
                                    elem[type]();
                                } catch (e) {
                                    // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                                    // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                                }
                                jQuery.event.triggered = undefined;

                                if (tmp) {
                                    elem[ontype] = tmp;
                                }
                            }
                        }
                    }

                    return event.result;
                },

                dispatch: function(event) {

                    // Make a writable jQuery.Event from the native event object
                    event = jQuery.event.fix(event);

                    var i, ret, handleObj, matched, j,
                        handlerQueue = [],
                        args = slice.call(arguments),
                        handlers = (jQuery._data(this, "events") || {})[event.type] || [],
                        special = jQuery.event.special[event.type] || {};

                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    args[0] = event;
                    event.delegateTarget = this;

                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                        return;
                    }

                    // Determine handlers
                    handlerQueue = jQuery.event.handlers.call(this, event, handlers);

                    // Run delegates first; they may want to stop propagation beneath us
                    i = 0;
                    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                        event.currentTarget = matched.elem;

                        j = 0;
                        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

                            // Triggered event must either 1) have no namespace, or
                            // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                            if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

                                event.handleObj = handleObj;
                                event.data = handleObj.data;

                                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
                                    .apply(matched.elem, args);

                                if (ret !== undefined) {
                                    if ((event.result = ret) === false) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }

                    // Call the postDispatch hook for the mapped type
                    if (special.postDispatch) {
                        special.postDispatch.call(this, event);
                    }

                    return event.result;
                },

                handlers: function(event, handlers) {
                    var sel, handleObj, matches, i,
                        handlerQueue = [],
                        delegateCount = handlers.delegateCount,
                        cur = event.target;

                    // Find delegate handlers
                    // Black-hole SVG <use> instance trees (#13180)
                    // Avoid non-left-click bubbling in Firefox (#3861)
                    if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

                        /* jshint eqeqeq: false */
                        for (; cur != this; cur = cur.parentNode || this) {
                            /* jshint eqeqeq: true */

                            // Don't check non-elements (#13208)
                            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                            if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
                                matches = [];
                                for (i = 0; i < delegateCount; i++) {
                                    handleObj = handlers[i];

                                    // Don't conflict with Object.prototype properties (#13203)
                                    sel = handleObj.selector + " ";

                                    if (matches[sel] === undefined) {
                                        matches[sel] = handleObj.needsContext ?
                                            jQuery(sel, this).index(cur) >= 0 :
                                            jQuery.find(sel, this, null, [cur]).length;
                                    }
                                    if (matches[sel]) {
                                        matches.push(handleObj);
                                    }
                                }
                                if (matches.length) {
                                    handlerQueue.push({
                                        elem: cur,
                                        handlers: matches
                                    });
                                }
                            }
                        }
                    }

                    // Add the remaining (directly-bound) handlers
                    if (delegateCount < handlers.length) {
                        handlerQueue.push({
                            elem: this,
                            handlers: handlers.slice(delegateCount)
                        });
                    }

                    return handlerQueue;
                },

                fix: function(event) {
                    if (event[jQuery.expando]) {
                        return event;
                    }

                    // Create a writable copy of the event object and normalize some properties
                    var i, prop, copy,
                        type = event.type,
                        originalEvent = event,
                        fixHook = this.fixHooks[type];

                    if (!fixHook) {
                        this.fixHooks[type] = fixHook =
                            rmouseEvent.test(type) ? this.mouseHooks :
                            rkeyEvent.test(type) ? this.keyHooks : {};
                    }
                    copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

                    event = new jQuery.Event(originalEvent);

                    i = copy.length;
                    while (i--) {
                        prop = copy[i];
                        event[prop] = originalEvent[prop];
                    }

                    // Support: IE<9
                    // Fix target property (#1925)
                    if (!event.target) {
                        event.target = originalEvent.srcElement || document;
                    }

                    // Support: Chrome 23+, Safari?
                    // Target should not be a text node (#504, #13143)
                    if (event.target.nodeType === 3) {
                        event.target = event.target.parentNode;
                    }

                    // Support: IE<9
                    // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
                    event.metaKey = !!event.metaKey;

                    return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
                },

                // Includes some event props shared by KeyEvent and MouseEvent
                props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

                fixHooks: {},

                keyHooks: {
                    props: "char charCode key keyCode".split(" "),
                    filter: function(event, original) {

                        // Add which for key events
                        if (event.which == null) {
                            event.which = original.charCode != null ? original.charCode : original.keyCode;
                        }

                        return event;
                    }
                },

                mouseHooks: {
                    props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                    filter: function(event, original) {
                        var body, eventDoc, doc,
                            button = original.button,
                            fromElement = original.fromElement;

                        // Calculate pageX/Y if missing and clientX/Y available
                        if (event.pageX == null && original.clientX != null) {
                            eventDoc = event.target.ownerDocument || document;
                            doc = eventDoc.documentElement;
                            body = eventDoc.body;

                            event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                            event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                        }

                        // Add relatedTarget, if necessary
                        if (!event.relatedTarget && fromElement) {
                            event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                        }

                        // Add which for click: 1 === left; 2 === middle; 3 === right
                        // Note: button is not normalized, so don't use it
                        if (!event.which && button !== undefined) {
                            event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                        }

                        return event;
                    }
                },

                special: {
                    load: {
                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: true
                    },
                    focus: {
                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function() {
                            if (this !== safeActiveElement() && this.focus) {
                                try {
                                    this.focus();
                                    return false;
                                } catch (e) {
                                    // Support: IE<9
                                    // If we error on focus to hidden element (#1486, #12518),
                                    // let .trigger() run the handlers
                                }
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if (this === safeActiveElement() && this.blur) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        // For checkbox, fire native event so checked state will be right
                        trigger: function() {
                            if (jQuery.nodeName(this, "input") && this.type === "checkbox" && this.click) {
                                this.click();
                                return false;
                            }
                        },

                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function(event) {
                            return jQuery.nodeName(event.target, "a");
                        }
                    },

                    beforeunload: {
                        postDispatch: function(event) {

                            // Support: Firefox 20+
                            // Firefox doesn't alert if the returnValue field is not set.
                            if (event.result !== undefined && event.originalEvent) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                },

                simulate: function(type, elem, event, bubble) {
                    // Piggyback on a donor event to simulate a different one.
                    // Fake originalEvent to avoid donor's stopPropagation, but if the
                    // simulated event prevents default then we do the same on the donor.
                    var e = jQuery.extend(
                        new jQuery.Event(),
                        event, {
                            type: type,
                            isSimulated: true,
                            originalEvent: {}
                        }
                    );
                    if (bubble) {
                        jQuery.event.trigger(e, null, elem);
                    } else {
                        jQuery.event.dispatch.call(elem, e);
                    }
                    if (e.isDefaultPrevented()) {
                        event.preventDefault();
                    }
                }
            };

            jQuery.removeEvent = document.removeEventListener ?
                function(elem, type, handle) {
                    if (elem.removeEventListener) {
                        elem.removeEventListener(type, handle, false);
                    }
                } :
                function(elem, type, handle) {
                    var name = "on" + type;

                    if (elem.detachEvent) {

                        // #8545, #7054, preventing memory leaks for custom events in IE6-8
                        // detachEvent needed property on element, by name of that event, to properly expose it to GC
                        if (typeof elem[name] === strundefined) {
                            elem[name] = null;
                        }

                        elem.detachEvent(name, handle);
                    }
                };

            jQuery.Event = function(src, props) {
                // Allow instantiation without the 'new' keyword
                if (!(this instanceof jQuery.Event)) {
                    return new jQuery.Event(src, props);
                }

                // Event object
                if (src && src.type) {
                    this.originalEvent = src;
                    this.type = src.type;

                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = src.defaultPrevented ||
                        src.defaultPrevented === undefined &&
                        // Support: IE < 9, Android < 4.0
                        src.returnValue === false ?
                        returnTrue :
                        returnFalse;

                    // Event type
                } else {
                    this.type = src;
                }

                // Put explicitly provided properties onto the event object
                if (props) {
                    jQuery.extend(this, props);
                }

                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = src && src.timeStamp || jQuery.now();

                // Mark it as fixed
                this[jQuery.expando] = true;
            };

            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
            // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            jQuery.Event.prototype = {
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,

                preventDefault: function() {
                    var e = this.originalEvent;

                    this.isDefaultPrevented = returnTrue;
                    if (!e) {
                        return;
                    }

                    // If preventDefault exists, run it on the original event
                    if (e.preventDefault) {
                        e.preventDefault();

                        // Support: IE
                        // Otherwise set the returnValue property of the original event to false
                    } else {
                        e.returnValue = false;
                    }
                },
                stopPropagation: function() {
                    var e = this.originalEvent;

                    this.isPropagationStopped = returnTrue;
                    if (!e) {
                        return;
                    }
                    // If stopPropagation exists, run it on the original event
                    if (e.stopPropagation) {
                        e.stopPropagation();
                    }

                    // Support: IE
                    // Set the cancelBubble property of the original event to true
                    e.cancelBubble = true;
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;

                    this.isImmediatePropagationStopped = returnTrue;

                    if (e && e.stopImmediatePropagation) {
                        e.stopImmediatePropagation();
                    }

                    this.stopPropagation();
                }
            };

            // Create mouseenter/leave events using mouseover/out and event-time checks
            jQuery.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(orig, fix) {
                jQuery.event.special[orig] = {
                    delegateType: fix,
                    bindType: fix,

                    handle: function(event) {
                        var ret,
                            target = this,
                            related = event.relatedTarget,
                            handleObj = event.handleObj;

                        // For mousenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if (!related || (related !== target && !jQuery.contains(target, related))) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply(this, arguments);
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            });

            // IE submit delegation
            if (!support.submitBubbles) {

                jQuery.event.special.submit = {
                    setup: function() {
                        // Only need this for delegated form submit events
                        if (jQuery.nodeName(this, "form")) {
                            return false;
                        }

                        // Lazy-add a submit handler when a descendant form may potentially be submitted
                        jQuery.event.add(this, "click._submit keypress._submit", function(e) {
                            // Node name check avoids a VML-related crash in IE (#9807)
                            var elem = e.target,
                                form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;
                            if (form && !jQuery._data(form, "submitBubbles")) {
                                jQuery.event.add(form, "submit._submit", function(event) {
                                    event._submit_bubble = true;
                                });
                                jQuery._data(form, "submitBubbles", true);
                            }
                        });
                        // return undefined since we don't need an event listener
                    },

                    postDispatch: function(event) {
                        // If form was submitted by the user, bubble the event up the tree
                        if (event._submit_bubble) {
                            delete event._submit_bubble;
                            if (this.parentNode && !event.isTrigger) {
                                jQuery.event.simulate("submit", this.parentNode, event, true);
                            }
                        }
                    },

                    teardown: function() {
                        // Only need this for delegated form submit events
                        if (jQuery.nodeName(this, "form")) {
                            return false;
                        }

                        // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                        jQuery.event.remove(this, "._submit");
                    }
                };
            }

            // IE change delegation and checkbox/radio fix
            if (!support.changeBubbles) {

                jQuery.event.special.change = {

                    setup: function() {

                        if (rformElems.test(this.nodeName)) {
                            // IE doesn't fire change on a check/radio until blur; trigger it on click
                            // after a propertychange. Eat the blur-change in special.change.handle.
                            // This still fires onchange a second time for check/radio after blur.
                            if (this.type === "checkbox" || this.type === "radio") {
                                jQuery.event.add(this, "propertychange._change", function(event) {
                                    if (event.originalEvent.propertyName === "checked") {
                                        this._just_changed = true;
                                    }
                                });
                                jQuery.event.add(this, "click._change", function(event) {
                                    if (this._just_changed && !event.isTrigger) {
                                        this._just_changed = false;
                                    }
                                    // Allow triggered, simulated change events (#11500)
                                    jQuery.event.simulate("change", this, event, true);
                                });
                            }
                            return false;
                        }
                        // Delegated event; lazy-add a change handler on descendant inputs
                        jQuery.event.add(this, "beforeactivate._change", function(e) {
                            var elem = e.target;

                            if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "changeBubbles")) {
                                jQuery.event.add(elem, "change._change", function(event) {
                                    if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                        jQuery.event.simulate("change", this.parentNode, event, true);
                                    }
                                });
                                jQuery._data(elem, "changeBubbles", true);
                            }
                        });
                    },

                    handle: function(event) {
                        var elem = event.target;

                        // Swallow native change events from checkbox/radio, we already triggered them above
                        if (this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox")) {
                            return event.handleObj.handler.apply(this, arguments);
                        }
                    },

                    teardown: function() {
                        jQuery.event.remove(this, "._change");

                        return !rformElems.test(this.nodeName);
                    }
                };
            }

            // Create "bubbling" focus and blur events
            if (!support.focusinBubbles) {
                jQuery.each({
                    focus: "focusin",
                    blur: "focusout"
                }, function(orig, fix) {

                    // Attach a single capturing handler on the document while someone wants focusin/focusout
                    var handler = function(event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                    };

                    jQuery.event.special[fix] = {
                        setup: function() {
                            var doc = this.ownerDocument || this,
                                attaches = jQuery._data(doc, fix);

                            if (!attaches) {
                                doc.addEventListener(orig, handler, true);
                            }
                            jQuery._data(doc, fix, (attaches || 0) + 1);
                        },
                        teardown: function() {
                            var doc = this.ownerDocument || this,
                                attaches = jQuery._data(doc, fix) - 1;

                            if (!attaches) {
                                doc.removeEventListener(orig, handler, true);
                                jQuery._removeData(doc, fix);
                            } else {
                                jQuery._data(doc, fix, attaches);
                            }
                        }
                    };
                });
            }

            jQuery.fn.extend({

                on: function(types, selector, data, fn, /*INTERNAL*/ one) {
                    var type, origFn;

                    // Types can be a map of types/handlers
                    if (typeof types === "object") {
                        // ( types-Object, selector, data )
                        if (typeof selector !== "string") {
                            // ( types-Object, data )
                            data = data || selector;
                            selector = undefined;
                        }
                        for (type in types) {
                            this.on(type, selector, data, types[type], one);
                        }
                        return this;
                    }

                    if (data == null && fn == null) {
                        // ( types, fn )
                        fn = selector;
                        data = selector = undefined;
                    } else if (fn == null) {
                        if (typeof selector === "string") {
                            // ( types, selector, fn )
                            fn = data;
                            data = undefined;
                        } else {
                            // ( types, data, fn )
                            fn = data;
                            data = selector;
                            selector = undefined;
                        }
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    } else if (!fn) {
                        return this;
                    }

                    if (one === 1) {
                        origFn = fn;
                        fn = function(event) {
                            // Can use an empty set, since event contains the info
                            jQuery().off(event);
                            return origFn.apply(this, arguments);
                        };
                        // Use same guid so caller can remove using origFn
                        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                    }
                    return this.each(function() {
                        jQuery.event.add(this, types, fn, data, selector);
                    });
                },
                one: function(types, selector, data, fn) {
                    return this.on(types, selector, data, fn, 1);
                },
                off: function(types, selector, fn) {
                    var handleObj, type;
                    if (types && types.preventDefault && types.handleObj) {
                        // ( event )  dispatched jQuery.Event
                        handleObj = types.handleObj;
                        jQuery(types.delegateTarget).off(
                            handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                            handleObj.selector,
                            handleObj.handler
                        );
                        return this;
                    }
                    if (typeof types === "object") {
                        // ( types-object [, selector] )
                        for (type in types) {
                            this.off(type, selector, types[type]);
                        }
                        return this;
                    }
                    if (selector === false || typeof selector === "function") {
                        // ( types [, fn] )
                        fn = selector;
                        selector = undefined;
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    }
                    return this.each(function() {
                        jQuery.event.remove(this, types, fn, selector);
                    });
                },

                trigger: function(type, data) {
                    return this.each(function() {
                        jQuery.event.trigger(type, data, this);
                    });
                },
                triggerHandler: function(type, data) {
                    var elem = this[0];
                    if (elem) {
                        return jQuery.event.trigger(type, data, elem, true);
                    }
                }
            });


            function createSafeFragment(document) {
                var list = nodeNames.split("|"),
                    safeFrag = document.createDocumentFragment();

                if (safeFrag.createElement) {
                    while (list.length) {
                        safeFrag.createElement(
                            list.pop()
                        );
                    }
                }
                return safeFrag;
            }

            var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
                "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
                rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
                rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
                rleadingWhitespace = /^\s+/,
                rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
                rtagName = /<([\w:]+)/,
                rtbody = /<tbody/i,
                rhtml = /<|&#?\w+;/,
                rnoInnerhtml = /<(?:script|style|link)/i,
                // checked="checked" or checked
                rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                rscriptType = /^$|\/(?:java|ecma)script/i,
                rscriptTypeMasked = /^true\/(.*)/,
                rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

                // We have to close these tags to support XHTML (#13200)
                wrapMap = {
                    option: [1, "<select multiple='multiple'>", "</select>"],
                    legend: [1, "<fieldset>", "</fieldset>"],
                    area: [1, "<map>", "</map>"],
                    param: [1, "<object>", "</object>"],
                    thead: [1, "<table>", "</table>"],
                    tr: [2, "<table><tbody>", "</tbody></table>"],
                    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
                    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

                    // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
                    // unless wrapped in a div with non-breaking characters in front of it.
                    _default: support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
                },
                safeFragment = createSafeFragment(document),
                fragmentDiv = safeFragment.appendChild(document.createElement("div"));

            wrapMap.optgroup = wrapMap.option;
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;

            function getAll(context, tag) {
                var elems, elem,
                    i = 0,
                    found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || "*") :
                    typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || "*") :
                    undefined;

                if (!found) {
                    for (found = [], elems = context.childNodes || context;
                        (elem = elems[i]) != null; i++) {
                        if (!tag || jQuery.nodeName(elem, tag)) {
                            found.push(elem);
                        } else {
                            jQuery.merge(found, getAll(elem, tag));
                        }
                    }
                }

                return tag === undefined || tag && jQuery.nodeName(context, tag) ?
                    jQuery.merge([context], found) :
                    found;
            }

            // Used in buildFragment, fixes the defaultChecked property
            function fixDefaultChecked(elem) {
                if (rcheckableType.test(elem.type)) {
                    elem.defaultChecked = elem.checked;
                }
            }

            // Support: IE<8
            // Manipulating tables requires a tbody
            function manipulationTarget(elem, content) {
                return jQuery.nodeName(elem, "table") &&
                    jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?

                    elem.getElementsByTagName("tbody")[0] ||
                    elem.appendChild(elem.ownerDocument.createElement("tbody")) :
                    elem;
            }

            // Replace/restore the type attribute of script elements for safe DOM manipulation
            function disableScript(elem) {
                elem.type = (jQuery.find.attr(elem, "type") !== null) + "/" + elem.type;
                return elem;
            }

            function restoreScript(elem) {
                var match = rscriptTypeMasked.exec(elem.type);
                if (match) {
                    elem.type = match[1];
                } else {
                    elem.removeAttribute("type");
                }
                return elem;
            }

            // Mark scripts as having already been evaluated
            function setGlobalEval(elems, refElements) {
                var elem,
                    i = 0;
                for (;
                    (elem = elems[i]) != null; i++) {
                    jQuery._data(elem, "globalEval", !refElements || jQuery._data(refElements[i], "globalEval"));
                }
            }

            function cloneCopyEvent(src, dest) {

                if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
                    return;
                }

                var type, i, l,
                    oldData = jQuery._data(src),
                    curData = jQuery._data(dest, oldData),
                    events = oldData.events;

                if (events) {
                    delete curData.handle;
                    curData.events = {};

                    for (type in events) {
                        for (i = 0, l = events[type].length; i < l; i++) {
                            jQuery.event.add(dest, type, events[type][i]);
                        }
                    }
                }

                // make the cloned public data object a copy from the original
                if (curData.data) {
                    curData.data = jQuery.extend({}, curData.data);
                }
            }

            function fixCloneNodeIssues(src, dest) {
                var nodeName, e, data;

                // We do not need to do anything for non-Elements
                if (dest.nodeType !== 1) {
                    return;
                }

                nodeName = dest.nodeName.toLowerCase();

                // IE6-8 copies events bound via attachEvent when using cloneNode.
                if (!support.noCloneEvent && dest[jQuery.expando]) {
                    data = jQuery._data(dest);

                    for (e in data.events) {
                        jQuery.removeEvent(dest, e, data.handle);
                    }

                    // Event data gets referenced instead of copied if the expando gets copied too
                    dest.removeAttribute(jQuery.expando);
                }

                // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
                if (nodeName === "script" && dest.text !== src.text) {
                    disableScript(dest).text = src.text;
                    restoreScript(dest);

                    // IE6-10 improperly clones children of object elements using classid.
                    // IE10 throws NoModificationAllowedError if parent is null, #12132.
                } else if (nodeName === "object") {
                    if (dest.parentNode) {
                        dest.outerHTML = src.outerHTML;
                    }

                    // This path appears unavoidable for IE9. When cloning an object
                    // element in IE9, the outerHTML strategy above is not sufficient.
                    // If the src has innerHTML and the destination does not,
                    // copy the src.innerHTML into the dest.innerHTML. #10324
                    if (support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
                        dest.innerHTML = src.innerHTML;
                    }

                } else if (nodeName === "input" && rcheckableType.test(src.type)) {
                    // IE6-8 fails to persist the checked state of a cloned checkbox
                    // or radio button. Worse, IE6-7 fail to give the cloned element
                    // a checked appearance if the defaultChecked value isn't also set

                    dest.defaultChecked = dest.checked = src.checked;

                    // IE6-7 get confused and end up setting the value of a cloned
                    // checkbox/radio button to an empty string instead of "on"
                    if (dest.value !== src.value) {
                        dest.value = src.value;
                    }

                    // IE6-8 fails to return the selected option to the default selected
                    // state when cloning options
                } else if (nodeName === "option") {
                    dest.defaultSelected = dest.selected = src.defaultSelected;

                    // IE6-8 fails to set the defaultValue to the correct value when
                    // cloning other types of input fields
                } else if (nodeName === "input" || nodeName === "textarea") {
                    dest.defaultValue = src.defaultValue;
                }
            }

            jQuery.extend({
                clone: function(elem, dataAndEvents, deepDataAndEvents) {
                    var destElements, node, clone, i, srcElements,
                        inPage = jQuery.contains(elem.ownerDocument, elem);

                    if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
                        clone = elem.cloneNode(true);

                        // IE<=8 does not properly clone detached, unknown element nodes
                    } else {
                        fragmentDiv.innerHTML = elem.outerHTML;
                        fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
                    }

                    if ((!support.noCloneEvent || !support.noCloneChecked) &&
                        (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

                        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                        destElements = getAll(clone);
                        srcElements = getAll(elem);

                        // Fix all IE cloning issues
                        for (i = 0;
                            (node = srcElements[i]) != null; ++i) {
                            // Ensure that the destination node is not null; Fixes #9587
                            if (destElements[i]) {
                                fixCloneNodeIssues(node, destElements[i]);
                            }
                        }
                    }

                    // Copy the events from the original to the clone
                    if (dataAndEvents) {
                        if (deepDataAndEvents) {
                            srcElements = srcElements || getAll(elem);
                            destElements = destElements || getAll(clone);

                            for (i = 0;
                                (node = srcElements[i]) != null; i++) {
                                cloneCopyEvent(node, destElements[i]);
                            }
                        } else {
                            cloneCopyEvent(elem, clone);
                        }
                    }

                    // Preserve script evaluation history
                    destElements = getAll(clone, "script");
                    if (destElements.length > 0) {
                        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                    }

                    destElements = srcElements = node = null;

                    // Return the cloned set
                    return clone;
                },

                buildFragment: function(elems, context, scripts, selection) {
                    var j, elem, contains,
                        tmp, tag, tbody, wrap,
                        l = elems.length,

                        // Ensure a safe fragment
                        safe = createSafeFragment(context),

                        nodes = [],
                        i = 0;

                    for (; i < l; i++) {
                        elem = elems[i];

                        if (elem || elem === 0) {

                            // Add nodes directly
                            if (jQuery.type(elem) === "object") {
                                jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                                // Convert non-html into a text node
                            } else if (!rhtml.test(elem)) {
                                nodes.push(context.createTextNode(elem));

                                // Convert html into DOM nodes
                            } else {
                                tmp = tmp || safe.appendChild(context.createElement("div"));

                                // Deserialize a standard representation
                                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                                wrap = wrapMap[tag] || wrapMap._default;

                                tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];

                                // Descend through wrappers to the right content
                                j = wrap[0];
                                while (j--) {
                                    tmp = tmp.lastChild;
                                }

                                // Manually add leading whitespace removed by IE
                                if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                                    nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
                                }

                                // Remove IE's autoinserted <tbody> from table fragments
                                if (!support.tbody) {

                                    // String was a <table>, *may* have spurious <tbody>
                                    elem = tag === "table" && !rtbody.test(elem) ?
                                        tmp.firstChild :

                                        // String was a bare <thead> or <tfoot>
                                        wrap[1] === "<table>" && !rtbody.test(elem) ?
                                        tmp :
                                        0;

                                    j = elem && elem.childNodes.length;
                                    while (j--) {
                                        if (jQuery.nodeName((tbody = elem.childNodes[j]), "tbody") && !tbody.childNodes.length) {
                                            elem.removeChild(tbody);
                                        }
                                    }
                                }

                                jQuery.merge(nodes, tmp.childNodes);

                                // Fix #12392 for WebKit and IE > 9
                                tmp.textContent = "";

                                // Fix #12392 for oldIE
                                while (tmp.firstChild) {
                                    tmp.removeChild(tmp.firstChild);
                                }

                                // Remember the top-level container for proper cleanup
                                tmp = safe.lastChild;
                            }
                        }
                    }

                    // Fix #11356: Clear elements from fragment
                    if (tmp) {
                        safe.removeChild(tmp);
                    }

                    // Reset defaultChecked for any radios and checkboxes
                    // about to be appended to the DOM in IE 6/7 (#8060)
                    if (!support.appendChecked) {
                        jQuery.grep(getAll(nodes, "input"), fixDefaultChecked);
                    }

                    i = 0;
                    while ((elem = nodes[i++])) {

                        // #4087 - If origin and destination elements are the same, and this is
                        // that element, do not do anything
                        if (selection && jQuery.inArray(elem, selection) !== -1) {
                            continue;
                        }

                        contains = jQuery.contains(elem.ownerDocument, elem);

                        // Append to fragment
                        tmp = getAll(safe.appendChild(elem), "script");

                        // Preserve script evaluation history
                        if (contains) {
                            setGlobalEval(tmp);
                        }

                        // Capture executables
                        if (scripts) {
                            j = 0;
                            while ((elem = tmp[j++])) {
                                if (rscriptType.test(elem.type || "")) {
                                    scripts.push(elem);
                                }
                            }
                        }
                    }

                    tmp = null;

                    return safe;
                },

                cleanData: function(elems, /* internal */ acceptData) {
                    var elem, type, id, data,
                        i = 0,
                        internalKey = jQuery.expando,
                        cache = jQuery.cache,
                        deleteExpando = support.deleteExpando,
                        special = jQuery.event.special;

                    for (;
                        (elem = elems[i]) != null; i++) {
                        if (acceptData || jQuery.acceptData(elem)) {

                            id = elem[internalKey];
                            data = id && cache[id];

                            if (data) {
                                if (data.events) {
                                    for (type in data.events) {
                                        if (special[type]) {
                                            jQuery.event.remove(elem, type);

                                            // This is a shortcut to avoid jQuery.event.remove's overhead
                                        } else {
                                            jQuery.removeEvent(elem, type, data.handle);
                                        }
                                    }
                                }

                                // Remove cache only if it was not already removed by jQuery.event.remove
                                if (cache[id]) {

                                    delete cache[id];

                                    // IE does not allow us to delete expando properties from nodes,
                                    // nor does it have a removeAttribute function on Document nodes;
                                    // we must handle all of these cases
                                    if (deleteExpando) {
                                        delete elem[internalKey];

                                    } else if (typeof elem.removeAttribute !== strundefined) {
                                        elem.removeAttribute(internalKey);

                                    } else {
                                        elem[internalKey] = null;
                                    }

                                    deletedIds.push(id);
                                }
                            }
                        }
                    }
                }
            });

            jQuery.fn.extend({
                text: function(value) {
                    return access(this, function(value) {
                        return value === undefined ?
                            jQuery.text(this) :
                            this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
                    }, null, value, arguments.length);
                },

                append: function() {
                    return this.domManip(arguments, function(elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.appendChild(elem);
                        }
                    });
                },

                prepend: function() {
                    return this.domManip(arguments, function(elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.insertBefore(elem, target.firstChild);
                        }
                    });
                },

                before: function() {
                    return this.domManip(arguments, function(elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this);
                        }
                    });
                },

                after: function() {
                    return this.domManip(arguments, function(elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this.nextSibling);
                        }
                    });
                },

                remove: function(selector, keepData /* Internal Use Only */ ) {
                    var elem,
                        elems = selector ? jQuery.filter(selector, this) : this,
                        i = 0;

                    for (;
                        (elem = elems[i]) != null; i++) {

                        if (!keepData && elem.nodeType === 1) {
                            jQuery.cleanData(getAll(elem));
                        }

                        if (elem.parentNode) {
                            if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                                setGlobalEval(getAll(elem, "script"));
                            }
                            elem.parentNode.removeChild(elem);
                        }
                    }

                    return this;
                },

                empty: function() {
                    var elem,
                        i = 0;

                    for (;
                        (elem = this[i]) != null; i++) {
                        // Remove element nodes and prevent memory leaks
                        if (elem.nodeType === 1) {
                            jQuery.cleanData(getAll(elem, false));
                        }

                        // Remove any remaining nodes
                        while (elem.firstChild) {
                            elem.removeChild(elem.firstChild);
                        }

                        // If this is a select, ensure that it displays empty (#12336)
                        // Support: IE<9
                        if (elem.options && jQuery.nodeName(elem, "select")) {
                            elem.options.length = 0;
                        }
                    }

                    return this;
                },

                clone: function(dataAndEvents, deepDataAndEvents) {
                    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                    return this.map(function() {
                        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                    });
                },

                html: function(value) {
                    return access(this, function(value) {
                        var elem = this[0] || {},
                            i = 0,
                            l = this.length;

                        if (value === undefined) {
                            return elem.nodeType === 1 ?
                                elem.innerHTML.replace(rinlinejQuery, "") :
                                undefined;
                        }

                        // See if we can take a shortcut and just use innerHTML
                        if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                            (support.htmlSerialize || !rnoshimcache.test(value)) &&
                            (support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
                            !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                            value = value.replace(rxhtmlTag, "<$1></$2>");

                            try {
                                for (; i < l; i++) {
                                    // Remove element nodes and prevent memory leaks
                                    elem = this[i] || {};
                                    if (elem.nodeType === 1) {
                                        jQuery.cleanData(getAll(elem, false));
                                        elem.innerHTML = value;
                                    }
                                }

                                elem = 0;

                                // If using innerHTML throws an exception, use the fallback method
                            } catch (e) {}
                        }

                        if (elem) {
                            this.empty().append(value);
                        }
                    }, null, value, arguments.length);
                },

                replaceWith: function() {
                    var arg = arguments[0];

                    // Make the changes, replacing each context element with the new content
                    this.domManip(arguments, function(elem) {
                        arg = this.parentNode;

                        jQuery.cleanData(getAll(this));

                        if (arg) {
                            arg.replaceChild(elem, this);
                        }
                    });

                    // Force removal if there was no new content (e.g., from empty arguments)
                    return arg && (arg.length || arg.nodeType) ? this : this.remove();
                },

                detach: function(selector) {
                    return this.remove(selector, true);
                },

                domManip: function(args, callback) {

                    // Flatten any nested arrays
                    args = concat.apply([], args);

                    var first, node, hasScripts,
                        scripts, doc, fragment,
                        i = 0,
                        l = this.length,
                        set = this,
                        iNoClone = l - 1,
                        value = args[0],
                        isFunction = jQuery.isFunction(value);

                    // We can't cloneNode fragments that contain checked, in WebKit
                    if (isFunction ||
                        (l > 1 && typeof value === "string" &&
                            !support.checkClone && rchecked.test(value))) {
                        return this.each(function(index) {
                            var self = set.eq(index);
                            if (isFunction) {
                                args[0] = value.call(this, index, self.html());
                            }
                            self.domManip(args, callback);
                        });
                    }

                    if (l) {
                        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                        first = fragment.firstChild;

                        if (fragment.childNodes.length === 1) {
                            fragment = first;
                        }

                        if (first) {
                            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                            hasScripts = scripts.length;

                            // Use the original fragment for the last item instead of the first because it can end up
                            // being emptied incorrectly in certain situations (#8070).
                            for (; i < l; i++) {
                                node = fragment;

                                if (i !== iNoClone) {
                                    node = jQuery.clone(node, true, true);

                                    // Keep references to cloned scripts for later restoration
                                    if (hasScripts) {
                                        jQuery.merge(scripts, getAll(node, "script"));
                                    }
                                }

                                callback.call(this[i], node, i);
                            }

                            if (hasScripts) {
                                doc = scripts[scripts.length - 1].ownerDocument;

                                // Reenable scripts
                                jQuery.map(scripts, restoreScript);

                                // Evaluate executable scripts on first document insertion
                                for (i = 0; i < hasScripts; i++) {
                                    node = scripts[i];
                                    if (rscriptType.test(node.type || "") &&
                                        !jQuery._data(node, "globalEval") && jQuery.contains(doc, node)) {

                                        if (node.src) {
                                            // Optional AJAX dependency, but won't run scripts if not present
                                            if (jQuery._evalUrl) {
                                                jQuery._evalUrl(node.src);
                                            }
                                        } else {
                                            jQuery.globalEval((node.text || node.textContent || node.innerHTML || "").replace(rcleanScript, ""));
                                        }
                                    }
                                }
                            }

                            // Fix #11809: Avoid leaking memory
                            fragment = first = null;
                        }
                    }

                    return this;
                }
            });

            jQuery.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(name, original) {
                jQuery.fn[name] = function(selector) {
                    var elems,
                        i = 0,
                        ret = [],
                        insert = jQuery(selector),
                        last = insert.length - 1;

                    for (; i <= last; i++) {
                        elems = i === last ? this : this.clone(true);
                        jQuery(insert[i])[original](elems);

                        // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
                        push.apply(ret, elems.get());
                    }

                    return this.pushStack(ret);
                };
            });


            var iframe,
                elemdisplay = {};

            /**
             * Retrieve the actual display of a element
             * @param {String} name nodeName of the element
             * @param {Object} doc Document object
             */
            // Called only from within defaultDisplay
            function actualDisplay(name, doc) {
                var style,
                    elem = jQuery(doc.createElement(name)).appendTo(doc.body),

                    // getDefaultComputedStyle might be reliably used only on attached element
                    display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ?

                    // Use of this method is a temporary fix (more like optmization) until something better comes along,
                    // since it was removed from specification and supported only in FF
                    style.display : jQuery.css(elem[0], "display");

                // We don't have any data stored on the element,
                // so use "detach" method as fast way to get rid of the element
                elem.detach();

                return display;
            }

            /**
             * Try to determine the default display value of an element
             * @param {String} nodeName
             */
            function defaultDisplay(nodeName) {
                var doc = document,
                    display = elemdisplay[nodeName];

                if (!display) {
                    display = actualDisplay(nodeName, doc);

                    // If the simple way fails, read from inside an iframe
                    if (display === "none" || !display) {

                        // Use the already-created iframe if possible
                        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

                        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;

                        // Support: IE
                        doc.write();
                        doc.close();

                        display = actualDisplay(nodeName, doc);
                        iframe.detach();
                    }

                    // Store the correct default display
                    elemdisplay[nodeName] = display;
                }

                return display;
            }


            (function() {
                var shrinkWrapBlocksVal;

                support.shrinkWrapBlocks = function() {
                    if (shrinkWrapBlocksVal != null) {
                        return shrinkWrapBlocksVal;
                    }

                    // Will be changed later if needed.
                    shrinkWrapBlocksVal = false;

                    // Minified: var b,c,d
                    var div, body, container;

                    body = document.getElementsByTagName("body")[0];
                    if (!body || !body.style) {
                        // Test fired too early or in an unsupported environment, exit.
                        return;
                    }

                    // Setup
                    div = document.createElement("div");
                    container = document.createElement("div");
                    container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
                    body.appendChild(container).appendChild(div);

                    // Support: IE6
                    // Check if elements with layout shrink-wrap their children
                    if (typeof div.style.zoom !== strundefined) {
                        // Reset CSS: box-sizing; display; margin; border
                        div.style.cssText =
                            // Support: Firefox<29, Android 2.3
                            // Vendor-prefix box-sizing
                            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                            "box-sizing:content-box;display:block;margin:0;border:0;" +
                            "padding:1px;width:1px;zoom:1";
                        div.appendChild(document.createElement("div")).style.width = "5px";
                        shrinkWrapBlocksVal = div.offsetWidth !== 3;
                    }

                    body.removeChild(container);

                    return shrinkWrapBlocksVal;
                };

            })();
            var rmargin = (/^margin/);

            var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");



            var getStyles, curCSS,
                rposition = /^(top|right|bottom|left)$/;

            if (window.getComputedStyle) {
                getStyles = function(elem) {
                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
                };

                curCSS = function(elem, name, computed) {
                    var width, minWidth, maxWidth, ret,
                        style = elem.style;

                    computed = computed || getStyles(elem);

                    // getPropertyValue is only needed for .css('filter') in IE9, see #12537
                    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

                    if (computed) {

                        if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                            ret = jQuery.style(elem, name);
                        }

                        // A tribute to the "awesome hack by Dean Edwards"
                        // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
                        // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                        if (rnumnonpx.test(ret) && rmargin.test(name)) {

                            // Remember the original values
                            width = style.width;
                            minWidth = style.minWidth;
                            maxWidth = style.maxWidth;

                            // Put in the new values to get a computed value out
                            style.minWidth = style.maxWidth = style.width = ret;
                            ret = computed.width;

                            // Revert the changed values
                            style.width = width;
                            style.minWidth = minWidth;
                            style.maxWidth = maxWidth;
                        }
                    }

                    // Support: IE
                    // IE returns zIndex value as an integer.
                    return ret === undefined ?
                        ret :
                        ret + "";
                };
            } else if (document.documentElement.currentStyle) {
                getStyles = function(elem) {
                    return elem.currentStyle;
                };

                curCSS = function(elem, name, computed) {
                    var left, rs, rsLeft, ret,
                        style = elem.style;

                    computed = computed || getStyles(elem);
                    ret = computed ? computed[name] : undefined;

                    // Avoid setting ret to empty string here
                    // so we don't default to auto
                    if (ret == null && style && style[name]) {
                        ret = style[name];
                    }

                    // From the awesome hack by Dean Edwards
                    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

                    // If we're not dealing with a regular pixel number
                    // but a number that has a weird ending, we need to convert it to pixels
                    // but not position css attributes, as those are proportional to the parent element instead
                    // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
                    if (rnumnonpx.test(ret) && !rposition.test(name)) {

                        // Remember the original values
                        left = style.left;
                        rs = elem.runtimeStyle;
                        rsLeft = rs && rs.left;

                        // Put in the new values to get a computed value out
                        if (rsLeft) {
                            rs.left = elem.currentStyle.left;
                        }
                        style.left = name === "fontSize" ? "1em" : ret;
                        ret = style.pixelLeft + "px";

                        // Revert the changed values
                        style.left = left;
                        if (rsLeft) {
                            rs.left = rsLeft;
                        }
                    }

                    // Support: IE
                    // IE returns zIndex value as an integer.
                    return ret === undefined ?
                        ret :
                        ret + "" || "auto";
                };
            }




            function addGetHookIf(conditionFn, hookFn) {
                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function() {
                        var condition = conditionFn();

                        if (condition == null) {
                            // The test was not ready at this point; screw the hook this time
                            // but check again when needed next time.
                            return;
                        }

                        if (condition) {
                            // Hook not needed (or it's not possible to use it due to missing dependency),
                            // remove it.
                            // Since there are no other hooks for marginRight, remove the whole object.
                            delete this.get;
                            return;
                        }

                        // Hook needed; redefine it so that the support test is not executed again.

                        return (this.get = hookFn).apply(this, arguments);
                    }
                };
            }


            (function() {
                // Minified: var b,c,d,e,f,g, h,i
                var div, style, a, pixelPositionVal, boxSizingReliableVal,
                    reliableHiddenOffsetsVal, reliableMarginRightVal;

                // Setup
                div = document.createElement("div");
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
                a = div.getElementsByTagName("a")[0];
                style = a && a.style;

                // Finish early in limited (non-browser) environments
                if (!style) {
                    return;
                }

                style.cssText = "float:left;opacity:.5";

                // Support: IE<9
                // Make sure that element opacity exists (as opposed to filter)
                support.opacity = style.opacity === "0.5";

                // Verify style float existence
                // (IE uses styleFloat instead of cssFloat)
                support.cssFloat = !!style.cssFloat;

                div.style.backgroundClip = "content-box";
                div.cloneNode(true).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";

                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
                    style.WebkitBoxSizing === "";

                jQuery.extend(support, {
                    reliableHiddenOffsets: function() {
                        if (reliableHiddenOffsetsVal == null) {
                            computeStyleTests();
                        }
                        return reliableHiddenOffsetsVal;
                    },

                    boxSizingReliable: function() {
                        if (boxSizingReliableVal == null) {
                            computeStyleTests();
                        }
                        return boxSizingReliableVal;
                    },

                    pixelPosition: function() {
                        if (pixelPositionVal == null) {
                            computeStyleTests();
                        }
                        return pixelPositionVal;
                    },

                    // Support: Android 2.3
                    reliableMarginRight: function() {
                        if (reliableMarginRightVal == null) {
                            computeStyleTests();
                        }
                        return reliableMarginRightVal;
                    }
                });

                function computeStyleTests() {
                    // Minified: var b,c,d,j
                    var div, body, container, contents;

                    body = document.getElementsByTagName("body")[0];
                    if (!body || !body.style) {
                        // Test fired too early or in an unsupported environment, exit.
                        return;
                    }

                    // Setup
                    div = document.createElement("div");
                    container = document.createElement("div");
                    container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
                    body.appendChild(container).appendChild(div);

                    div.style.cssText =
                        // Support: Firefox<29, Android 2.3
                        // Vendor-prefix box-sizing
                        "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
                        "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
                        "border:1px;padding:1px;width:4px;position:absolute";

                    // Support: IE<9
                    // Assume reasonable values in the absence of getComputedStyle
                    pixelPositionVal = boxSizingReliableVal = false;
                    reliableMarginRightVal = true;

                    // Check for getComputedStyle so that this code is not run in IE<9.
                    if (window.getComputedStyle) {
                        pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== "1%";
                        boxSizingReliableVal =
                            (window.getComputedStyle(div, null) || {
                                width: "4px"
                            }).width === "4px";

                        // Support: Android 2.3
                        // Div with explicit width and no margin-right incorrectly
                        // gets computed margin-right based on width of container (#3333)
                        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                        contents = div.appendChild(document.createElement("div"));

                        // Reset CSS: box-sizing; display; margin; border; padding
                        contents.style.cssText = div.style.cssText =
                            // Support: Firefox<29, Android 2.3
                            // Vendor-prefix box-sizing
                            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                            "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                        contents.style.marginRight = contents.style.width = "0";
                        div.style.width = "1px";

                        reliableMarginRightVal = !parseFloat((window.getComputedStyle(contents, null) || {}).marginRight);
                    }

                    // Support: IE8
                    // Check if table cells still have offsetWidth/Height when they are set
                    // to display:none and there are still other visible table cells in a
                    // table row; if so, offsetWidth/Height are not reliable for use when
                    // determining if an element has been hidden directly using
                    // display:none (it is still safe to use offsets if a parent element is
                    // hidden; don safety goggles and see bug #4512 for more information).
                    div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
                    contents = div.getElementsByTagName("td");
                    contents[0].style.cssText = "margin:0;border:0;padding:0;display:none";
                    reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
                    if (reliableHiddenOffsetsVal) {
                        contents[0].style.display = "";
                        contents[1].style.display = "none";
                        reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
                    }

                    body.removeChild(container);
                }

            })();


            // A method for quickly swapping in/out CSS properties to get correct calculations.
            jQuery.swap = function(elem, options, callback, args) {
                var ret, name,
                    old = {};

                // Remember the old values, and insert the new ones
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }

                ret = callback.apply(elem, args || []);

                // Revert the old values
                for (name in options) {
                    elem.style[name] = old[name];
                }

                return ret;
            };


            var
                ralpha = /alpha\([^)]*\)/i,
                ropacity = /opacity\s*=\s*([^)]*)/,

                // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
                // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
                rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),

                cssShow = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                },
                cssNormalTransform = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },

                cssPrefixes = ["Webkit", "O", "Moz", "ms"];


            // return a css property mapped to a potentially vendor prefixed property
            function vendorPropName(style, name) {

                // shortcut for names that are not vendor prefixed
                if (name in style) {
                    return name;
                }

                // check for vendor prefixed names
                var capName = name.charAt(0).toUpperCase() + name.slice(1),
                    origName = name,
                    i = cssPrefixes.length;

                while (i--) {
                    name = cssPrefixes[i] + capName;
                    if (name in style) {
                        return name;
                    }
                }

                return origName;
            }

            function showHide(elements, show) {
                var display, elem, hidden,
                    values = [],
                    index = 0,
                    length = elements.length;

                for (; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }

                    values[index] = jQuery._data(elem, "olddisplay");
                    display = elem.style.display;
                    if (show) {
                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if (!values[index] && display === "none") {
                            elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if (elem.style.display === "" && isHidden(elem)) {
                            values[index] = jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                        }
                    } else {
                        hidden = isHidden(elem);

                        if (display && display !== "none" || !hidden) {
                            jQuery._data(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (index = 0; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }
                    if (!show || elem.style.display === "none" || elem.style.display === "") {
                        elem.style.display = show ? values[index] || "" : "none";
                    }
                }

                return elements;
            }

            function setPositiveNumber(elem, value, subtract) {
                var matches = rnumsplit.exec(value);
                return matches ?
                    // Guard against undefined "subtract", e.g., when used as in cssHooks
                    Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
                    value;
            }

            function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                var i = extra === (isBorderBox ? "border" : "content") ?
                    // If we already have the right measurement, avoid augmentation
                    4 :
                    // Otherwise initialize for horizontal or vertical properties
                    name === "width" ? 1 : 0,

                    val = 0;

                for (; i < 4; i += 2) {
                    // both box models exclude margin, so add it if we want it
                    if (extra === "margin") {
                        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                    }

                    if (isBorderBox) {
                        // border-box includes padding, so remove it if we want content
                        if (extra === "content") {
                            val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                        }

                        // at this point, extra isn't border nor margin, so remove border
                        if (extra !== "margin") {
                            val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    } else {
                        // at this point, extra isn't content, so add padding
                        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                        // at this point, extra isn't content nor padding, so add border
                        if (extra !== "padding") {
                            val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    }
                }

                return val;
            }

            function getWidthOrHeight(elem, name, extra) {

                // Start with offset property, which is equivalent to the border-box value
                var valueIsBorderBox = true,
                    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                    styles = getStyles(elem),
                    isBorderBox = support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box";

                // some non-html elements return undefined for offsetWidth, so check for null/undefined
                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                if (val <= 0 || val == null) {
                    // Fall back to computed then uncomputed css if necessary
                    val = curCSS(elem, name, styles);
                    if (val < 0 || val == null) {
                        val = elem.style[name];
                    }

                    // Computed unit is not pixels. Stop here and return.
                    if (rnumnonpx.test(val)) {
                        return val;
                    }

                    // we need the check for style in case a browser which returns unreliable values
                    // for getComputedStyle silently falls back to the reliable elem.style
                    valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

                    // Normalize "", auto, and prepare for extra
                    val = parseFloat(val) || 0;
                }

                // use the active box-sizing model to add/subtract irrelevant styles
                return (val +
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra || (isBorderBox ? "border" : "content"),
                        valueIsBorderBox,
                        styles
                    )
                ) + "px";
            }

            jQuery.extend({
                // Add in style property hooks for overriding the default
                // behavior of getting and setting a style property
                cssHooks: {
                    opacity: {
                        get: function(elem, computed) {
                            if (computed) {
                                // We should always get a number back from opacity
                                var ret = curCSS(elem, "opacity");
                                return ret === "" ? "1" : ret;
                            }
                        }
                    }
                },

                // Don't automatically add "px" to these possibly-unitless properties
                cssNumber: {
                    "columnCount": true,
                    "fillOpacity": true,
                    "flexGrow": true,
                    "flexShrink": true,
                    "fontWeight": true,
                    "lineHeight": true,
                    "opacity": true,
                    "order": true,
                    "orphans": true,
                    "widows": true,
                    "zIndex": true,
                    "zoom": true
                },

                // Add in properties whose names you wish to fix before
                // setting or getting the value
                cssProps: {
                    // normalize float css property
                    "float": support.cssFloat ? "cssFloat" : "styleFloat"
                },

                // Get and set the style property on a DOM Node
                style: function(elem, name, value, extra) {
                    // Don't set styles on text and comment nodes
                    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                        return;
                    }

                    // Make sure that we're working with the right name
                    var ret, type, hooks,
                        origName = jQuery.camelCase(name),
                        style = elem.style;

                    name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));

                    // gets hook for the prefixed version
                    // followed by the unprefixed version
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                    // Check if we're setting a value
                    if (value !== undefined) {
                        type = typeof value;

                        // convert relative number strings (+= or -=) to relative numbers. #7345
                        if (type === "string" && (ret = rrelNum.exec(value))) {
                            value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                            // Fixes bug #9237
                            type = "number";
                        }

                        // Make sure that null and NaN values aren't set. See: #7116
                        if (value == null || value !== value) {
                            return;
                        }

                        // If a number was passed in, add 'px' to the (except for certain CSS properties)
                        if (type === "number" && !jQuery.cssNumber[origName]) {
                            value += "px";
                        }

                        // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
                        // but it would mean to define eight (for every problematic property) identical functions
                        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                            style[name] = "inherit";
                        }

                        // If a hook was provided, use that value, otherwise just set the specified value
                        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

                            // Support: IE
                            // Swallow errors from 'invalid' CSS values (#5509)
                            try {
                                style[name] = value;
                            } catch (e) {}
                        }

                    } else {
                        // If a hook was provided get the non-computed value from there
                        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                            return ret;
                        }

                        // Otherwise just get the value from the style object
                        return style[name];
                    }
                },

                css: function(elem, name, extra, styles) {
                    var num, val, hooks,
                        origName = jQuery.camelCase(name);

                    // Make sure that we're working with the right name
                    name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));

                    // gets hook for the prefixed version
                    // followed by the unprefixed version
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                    // If a hook was provided get the computed value from there
                    if (hooks && "get" in hooks) {
                        val = hooks.get(elem, true, extra);
                    }

                    // Otherwise, if a way to get the computed value exists, use that
                    if (val === undefined) {
                        val = curCSS(elem, name, styles);
                    }

                    //convert "normal" to computed value
                    if (val === "normal" && name in cssNormalTransform) {
                        val = cssNormalTransform[name];
                    }

                    // Return, converting to number if forced or a qualifier was provided and val looks numeric
                    if (extra === "" || extra) {
                        num = parseFloat(val);
                        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
                    }
                    return val;
                }
            });

            jQuery.each(["height", "width"], function(i, name) {
                jQuery.cssHooks[name] = {
                    get: function(elem, computed, extra) {
                        if (computed) {
                            // certain elements can have dimension info if we invisibly show them
                            // however, it must have a current display style that would benefit from this
                            return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ?
                                jQuery.swap(elem, cssShow, function() {
                                    return getWidthOrHeight(elem, name, extra);
                                }) :
                                getWidthOrHeight(elem, name, extra);
                        }
                    },

                    set: function(elem, value, extra) {
                        var styles = extra && getStyles(elem);
                        return setPositiveNumber(elem, value, extra ?
                            augmentWidthOrHeight(
                                elem,
                                name,
                                extra,
                                support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                                styles
                            ) : 0
                        );
                    }
                };
            });

            if (!support.opacity) {
                jQuery.cssHooks.opacity = {
                    get: function(elem, computed) {
                        // IE uses filters for opacity
                        return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
                            (0.01 * parseFloat(RegExp.$1)) + "" :
                            computed ? "1" : "";
                    },

                    set: function(elem, value) {
                        var style = elem.style,
                            currentStyle = elem.currentStyle,
                            opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
                            filter = currentStyle && currentStyle.filter || style.filter || "";

                        // IE has trouble with opacity if it does not have layout
                        // Force it by setting the zoom level
                        style.zoom = 1;

                        // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                        // if value === "", then remove inline opacity #12685
                        if ((value >= 1 || value === "") &&
                            jQuery.trim(filter.replace(ralpha, "")) === "" &&
                            style.removeAttribute) {

                            // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                            // if "filter:" is present at all, clearType is disabled, we want to avoid this
                            // style.removeAttribute is IE Only, but so apparently is this code path...
                            style.removeAttribute("filter");

                            // if there is no filter style applied in a css rule or unset inline opacity, we are done
                            if (value === "" || currentStyle && !currentStyle.filter) {
                                return;
                            }
                        }

                        // otherwise, set new filter values
                        style.filter = ralpha.test(filter) ?
                            filter.replace(ralpha, opacity) :
                            filter + " " + opacity;
                    }
                };
            }

            jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
                function(elem, computed) {
                    if (computed) {
                        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                        // Work around by temporarily setting element display to inline-block
                        return jQuery.swap(elem, {
                                "display": "inline-block"
                            },
                            curCSS, [elem, "marginRight"]);
                    }
                }
            );

            // These hooks are used by animate to expand properties
            jQuery.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                    expand: function(value) {
                        var i = 0,
                            expanded = {},

                            // assumes a single number if not a string
                            parts = typeof value === "string" ? value.split(" ") : [value];

                        for (; i < 4; i++) {
                            expanded[prefix + cssExpand[i] + suffix] =
                                parts[i] || parts[i - 2] || parts[0];
                        }

                        return expanded;
                    }
                };

                if (!rmargin.test(prefix)) {
                    jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
                }
            });

            jQuery.fn.extend({
                css: function(name, value) {
                    return access(this, function(elem, name, value) {
                        var styles, len,
                            map = {},
                            i = 0;

                        if (jQuery.isArray(name)) {
                            styles = getStyles(elem);
                            len = name.length;

                            for (; i < len; i++) {
                                map[name[i]] = jQuery.css(elem, name[i], false, styles);
                            }

                            return map;
                        }

                        return value !== undefined ?
                            jQuery.style(elem, name, value) :
                            jQuery.css(elem, name);
                    }, name, value, arguments.length > 1);
                },
                show: function() {
                    return showHide(this, true);
                },
                hide: function() {
                    return showHide(this);
                },
                toggle: function(state) {
                    if (typeof state === "boolean") {
                        return state ? this.show() : this.hide();
                    }

                    return this.each(function() {
                        if (isHidden(this)) {
                            jQuery(this).show();
                        } else {
                            jQuery(this).hide();
                        }
                    });
                }
            });


            function Tween(elem, options, prop, end, easing) {
                return new Tween.prototype.init(elem, options, prop, end, easing);
            }
            jQuery.Tween = Tween;

            Tween.prototype = {
                constructor: Tween,
                init: function(elem, options, prop, end, easing, unit) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || "swing";
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
                },
                cur: function() {
                    var hooks = Tween.propHooks[this.prop];

                    return hooks && hooks.get ?
                        hooks.get(this) :
                        Tween.propHooks._default.get(this);
                },
                run: function(percent) {
                    var eased,
                        hooks = Tween.propHooks[this.prop];

                    if (this.options.duration) {
                        this.pos = eased = jQuery.easing[this.easing](
                            percent, this.options.duration * percent, 0, 1, this.options.duration
                        );
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = (this.end - this.start) * eased + this.start;

                    if (this.options.step) {
                        this.options.step.call(this.elem, this.now, this);
                    }

                    if (hooks && hooks.set) {
                        hooks.set(this);
                    } else {
                        Tween.propHooks._default.set(this);
                    }
                    return this;
                }
            };

            Tween.prototype.init.prototype = Tween.prototype;

            Tween.propHooks = {
                _default: {
                    get: function(tween) {
                        var result;

                        if (tween.elem[tween.prop] != null &&
                            (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                            return tween.elem[tween.prop];
                        }

                        // passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails
                        // so, simple values such as "10px" are parsed to Float.
                        // complex values such as "rotate(1rad)" are returned as is.
                        result = jQuery.css(tween.elem, tween.prop, "");
                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !result || result === "auto" ? 0 : result;
                    },
                    set: function(tween) {
                        // use step hook for back compat - use cssHook if its there - use .style if its
                        // available and use plain properties where available
                        if (jQuery.fx.step[tween.prop]) {
                            jQuery.fx.step[tween.prop](tween);
                        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                        } else {
                            tween.elem[tween.prop] = tween.now;
                        }
                    }
                }
            };

            // Support: IE <=9
            // Panic based approach to setting things on disconnected nodes

            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function(tween) {
                    if (tween.elem.nodeType && tween.elem.parentNode) {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            };

            jQuery.easing = {
                linear: function(p) {
                    return p;
                },
                swing: function(p) {
                    return 0.5 - Math.cos(p * Math.PI) / 2;
                }
            };

            jQuery.fx = Tween.prototype.init;

            // Back Compat <1.8 extension point
            jQuery.fx.step = {};




            var
                fxNow, timerId,
                rfxtypes = /^(?:toggle|show|hide)$/,
                rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
                rrun = /queueHooks$/,
                animationPrefilters = [defaultPrefilter],
                tweeners = {
                    "*": [function(prop, value) {
                        var tween = this.createTween(prop, value),
                            target = tween.cur(),
                            parts = rfxnum.exec(value),
                            unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

                            // Starting value computation is required for potential unit mismatches
                            start = (jQuery.cssNumber[prop] || unit !== "px" && +target) &&
                            rfxnum.exec(jQuery.css(tween.elem, prop)),
                            scale = 1,
                            maxIterations = 20;

                        if (start && start[3] !== unit) {
                            // Trust units reported by jQuery.css
                            unit = unit || start[3];

                            // Make sure we update the tween properties later on
                            parts = parts || [];

                            // Iteratively approximate from a nonzero starting point
                            start = +target || 1;

                            do {
                                // If previous iteration zeroed out, double until we get *something*
                                // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                                scale = scale || ".5";

                                // Adjust and apply
                                start = start / scale;
                                jQuery.style(tween.elem, prop, start + unit);

                                // Update scale, tolerating zero or NaN from tween.cur()
                                // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                        }

                        // Update tween properties
                        if (parts) {
                            start = tween.start = +start || +target || 0;
                            tween.unit = unit;
                            // If a +=/-= token was provided, we're doing a relative animation
                            tween.end = parts[1] ?
                                start + (parts[1] + 1) * parts[2] :
                                +parts[2];
                        }

                        return tween;
                    }]
                };

            // Animations created synchronously will run synchronously
            function createFxNow() {
                setTimeout(function() {
                    fxNow = undefined;
                });
                return (fxNow = jQuery.now());
            }

            // Generate parameters to create a standard animation
            function genFx(type, includeWidth) {
                var which,
                    attrs = {
                        height: type
                    },
                    i = 0;

                // if we include width, step value is 1 to do all cssExpand values,
                // if we don't include width, step value is 2 to skip over Left and Right
                includeWidth = includeWidth ? 1 : 0;
                for (; i < 4; i += 2 - includeWidth) {
                    which = cssExpand[i];
                    attrs["margin" + which] = attrs["padding" + which] = type;
                }

                if (includeWidth) {
                    attrs.opacity = attrs.width = type;
                }

                return attrs;
            }

            function createTween(value, prop, animation) {
                var tween,
                    collection = (tweeners[prop] || []).concat(tweeners["*"]),
                    index = 0,
                    length = collection.length;
                for (; index < length; index++) {
                    if ((tween = collection[index].call(animation, prop, value))) {

                        // we're done with this property
                        return tween;
                    }
                }
            }

            function defaultPrefilter(elem, props, opts) {
                /* jshint validthis: true */
                var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
                    anim = this,
                    orig = {},
                    style = elem.style,
                    hidden = elem.nodeType && isHidden(elem),
                    dataShow = jQuery._data(elem, "fxshow");

                // handle queue: false promises
                if (!opts.queue) {
                    hooks = jQuery._queueHooks(elem, "fx");
                    if (hooks.unqueued == null) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function() {
                            if (!hooks.unqueued) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;

                    anim.always(function() {
                        // doing this makes sure that the complete handler will be called
                        // before this completes
                        anim.always(function() {
                            hooks.unqueued--;
                            if (!jQuery.queue(elem, "fx").length) {
                                hooks.empty.fire();
                            }
                        });
                    });
                }

                // height/width overflow pass
                if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
                    // Make sure that nothing sneaks out
                    // Record all 3 overflow attributes because IE does not
                    // change the overflow attribute when overflowX and
                    // overflowY are set to the same value
                    opts.overflow = [style.overflow, style.overflowX, style.overflowY];

                    // Set display property to inline-block for height/width
                    // animations on inline elements that are having width/height animated
                    display = jQuery.css(elem, "display");

                    // Test default display if display is currently "none"
                    checkDisplay = display === "none" ?
                        jQuery._data(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

                    if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {

                        // inline-level elements accept inline-block;
                        // block-level elements need to be inline with layout
                        if (!support.inlineBlockNeedsLayout || defaultDisplay(elem.nodeName) === "inline") {
                            style.display = "inline-block";
                        } else {
                            style.zoom = 1;
                        }
                    }
                }

                if (opts.overflow) {
                    style.overflow = "hidden";
                    if (!support.shrinkWrapBlocks()) {
                        anim.always(function() {
                            style.overflow = opts.overflow[0];
                            style.overflowX = opts.overflow[1];
                            style.overflowY = opts.overflow[2];
                        });
                    }
                }

                // show/hide pass
                for (prop in props) {
                    value = props[prop];
                    if (rfxtypes.exec(value)) {
                        delete props[prop];
                        toggle = toggle || value === "toggle";
                        if (value === (hidden ? "hide" : "show")) {

                            // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                                hidden = true;
                            } else {
                                continue;
                            }
                        }
                        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

                        // Any non-fx value stops us from restoring the original display value
                    } else {
                        display = undefined;
                    }
                }

                if (!jQuery.isEmptyObject(orig)) {
                    if (dataShow) {
                        if ("hidden" in dataShow) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = jQuery._data(elem, "fxshow", {});
                    }

                    // store state if its toggle - enables .stop().toggle() to "reverse"
                    if (toggle) {
                        dataShow.hidden = !hidden;
                    }
                    if (hidden) {
                        jQuery(elem).show();
                    } else {
                        anim.done(function() {
                            jQuery(elem).hide();
                        });
                    }
                    anim.done(function() {
                        var prop;
                        jQuery._removeData(elem, "fxshow");
                        for (prop in orig) {
                            jQuery.style(elem, prop, orig[prop]);
                        }
                    });
                    for (prop in orig) {
                        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

                        if (!(prop in dataShow)) {
                            dataShow[prop] = tween.start;
                            if (hidden) {
                                tween.end = tween.start;
                                tween.start = prop === "width" || prop === "height" ? 1 : 0;
                            }
                        }
                    }

                    // If this is a noop like .hide().hide(), restore an overwritten display value
                } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
                    style.display = display;
                }
            }

            function propFilter(props, specialEasing) {
                var index, name, easing, value, hooks;

                // camelCase, specialEasing and expand cssHook pass
                for (index in props) {
                    name = jQuery.camelCase(index);
                    easing = specialEasing[name];
                    value = props[index];
                    if (jQuery.isArray(value)) {
                        easing = value[1];
                        value = props[index] = value[0];
                    }

                    if (index !== name) {
                        props[name] = value;
                        delete props[index];
                    }

                    hooks = jQuery.cssHooks[name];
                    if (hooks && "expand" in hooks) {
                        value = hooks.expand(value);
                        delete props[name];

                        // not quite $.extend, this wont overwrite keys already present.
                        // also - reusing 'index' from above because we have the correct "name"
                        for (index in value) {
                            if (!(index in props)) {
                                props[index] = value[index];
                                specialEasing[index] = easing;
                            }
                        }
                    } else {
                        specialEasing[name] = easing;
                    }
                }
            }

            function Animation(elem, properties, options) {
                var result,
                    stopped,
                    index = 0,
                    length = animationPrefilters.length,
                    deferred = jQuery.Deferred().always(function() {
                        // don't match elem in the :animated selector
                        delete tick.elem;
                    }),
                    tick = function() {
                        if (stopped) {
                            return false;
                        }
                        var currentTime = fxNow || createFxNow(),
                            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                            // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                            temp = remaining / animation.duration || 0,
                            percent = 1 - temp,
                            index = 0,
                            length = animation.tweens.length;

                        for (; index < length; index++) {
                            animation.tweens[index].run(percent);
                        }

                        deferred.notifyWith(elem, [animation, percent, remaining]);

                        if (percent < 1 && length) {
                            return remaining;
                        } else {
                            deferred.resolveWith(elem, [animation]);
                            return false;
                        }
                    },
                    animation = deferred.promise({
                        elem: elem,
                        props: jQuery.extend({}, properties),
                        opts: jQuery.extend(true, {
                            specialEasing: {}
                        }, options),
                        originalProperties: properties,
                        originalOptions: options,
                        startTime: fxNow || createFxNow(),
                        duration: options.duration,
                        tweens: [],
                        createTween: function(prop, end) {
                            var tween = jQuery.Tween(elem, animation.opts, prop, end,
                                animation.opts.specialEasing[prop] || animation.opts.easing);
                            animation.tweens.push(tween);
                            return tween;
                        },
                        stop: function(gotoEnd) {
                            var index = 0,
                                // if we are going to the end, we want to run all the tweens
                                // otherwise we skip this part
                                length = gotoEnd ? animation.tweens.length : 0;
                            if (stopped) {
                                return this;
                            }
                            stopped = true;
                            for (; index < length; index++) {
                                animation.tweens[index].run(1);
                            }

                            // resolve when we played the last frame
                            // otherwise, reject
                            if (gotoEnd) {
                                deferred.resolveWith(elem, [animation, gotoEnd]);
                            } else {
                                deferred.rejectWith(elem, [animation, gotoEnd]);
                            }
                            return this;
                        }
                    }),
                    props = animation.props;

                propFilter(props, animation.opts.specialEasing);

                for (; index < length; index++) {
                    result = animationPrefilters[index].call(animation, elem, props, animation.opts);
                    if (result) {
                        return result;
                    }
                }

                jQuery.map(props, createTween, animation);

                if (jQuery.isFunction(animation.opts.start)) {
                    animation.opts.start.call(elem, animation);
                }

                jQuery.fx.timer(
                    jQuery.extend(tick, {
                        elem: elem,
                        anim: animation,
                        queue: animation.opts.queue
                    })
                );

                // attach callbacks from options
                return animation.progress(animation.opts.progress)
                    .done(animation.opts.done, animation.opts.complete)
                    .fail(animation.opts.fail)
                    .always(animation.opts.always);
            }

            jQuery.Animation = jQuery.extend(Animation, {
                tweener: function(props, callback) {
                    if (jQuery.isFunction(props)) {
                        callback = props;
                        props = ["*"];
                    } else {
                        props = props.split(" ");
                    }

                    var prop,
                        index = 0,
                        length = props.length;

                    for (; index < length; index++) {
                        prop = props[index];
                        tweeners[prop] = tweeners[prop] || [];
                        tweeners[prop].unshift(callback);
                    }
                },

                prefilter: function(callback, prepend) {
                    if (prepend) {
                        animationPrefilters.unshift(callback);
                    } else {
                        animationPrefilters.push(callback);
                    }
                }
            });

            jQuery.speed = function(speed, easing, fn) {
                var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing ||
                        jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };

                opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                    opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

                // normalize opt.queue - true/undefined/null -> "fx"
                if (opt.queue == null || opt.queue === true) {
                    opt.queue = "fx";
                }

                // Queueing
                opt.old = opt.complete;

                opt.complete = function() {
                    if (jQuery.isFunction(opt.old)) {
                        opt.old.call(this);
                    }

                    if (opt.queue) {
                        jQuery.dequeue(this, opt.queue);
                    }
                };

                return opt;
            };

            jQuery.fn.extend({
                fadeTo: function(speed, to, easing, callback) {

                    // show any hidden elements after setting opacity to 0
                    return this.filter(isHidden).css("opacity", 0).show()

                        // animate to the value specified
                        .end().animate({
                            opacity: to
                        }, speed, easing, callback);
                },
                animate: function(prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop),
                        optall = jQuery.speed(speed, easing, callback),
                        doAnimation = function() {
                            // Operate on a copy of prop so per-property easing won't be lost
                            var anim = Animation(this, jQuery.extend({}, prop), optall);

                            // Empty animations, or finishing resolves immediately
                            if (empty || jQuery._data(this, "finish")) {
                                anim.stop(true);
                            }
                        };
                    doAnimation.finish = doAnimation;

                    return empty || optall.queue === false ?
                        this.each(doAnimation) :
                        this.queue(optall.queue, doAnimation);
                },
                stop: function(type, clearQueue, gotoEnd) {
                    var stopQueue = function(hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop;
                        stop(gotoEnd);
                    };

                    if (typeof type !== "string") {
                        gotoEnd = clearQueue;
                        clearQueue = type;
                        type = undefined;
                    }
                    if (clearQueue && type !== false) {
                        this.queue(type || "fx", []);
                    }

                    return this.each(function() {
                        var dequeue = true,
                            index = type != null && type + "queueHooks",
                            timers = jQuery.timers,
                            data = jQuery._data(this);

                        if (index) {
                            if (data[index] && data[index].stop) {
                                stopQueue(data[index]);
                            }
                        } else {
                            for (index in data) {
                                if (data[index] && data[index].stop && rrun.test(index)) {
                                    stopQueue(data[index]);
                                }
                            }
                        }

                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                                timers[index].anim.stop(gotoEnd);
                                dequeue = false;
                                timers.splice(index, 1);
                            }
                        }

                        // start the next in the queue if the last step wasn't forced
                        // timers currently will call their complete callbacks, which will dequeue
                        // but only if they were gotoEnd
                        if (dequeue || !gotoEnd) {
                            jQuery.dequeue(this, type);
                        }
                    });
                },
                finish: function(type) {
                    if (type !== false) {
                        type = type || "fx";
                    }
                    return this.each(function() {
                        var index,
                            data = jQuery._data(this),
                            queue = data[type + "queue"],
                            hooks = data[type + "queueHooks"],
                            timers = jQuery.timers,
                            length = queue ? queue.length : 0;

                        // enable finishing flag on private data
                        data.finish = true;

                        // empty the queue first
                        jQuery.queue(this, type, []);

                        if (hooks && hooks.stop) {
                            hooks.stop.call(this, true);
                        }

                        // look for any active animations, and finish them
                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this && timers[index].queue === type) {
                                timers[index].anim.stop(true);
                                timers.splice(index, 1);
                            }
                        }

                        // look for any animations in the old queue and finish them
                        for (index = 0; index < length; index++) {
                            if (queue[index] && queue[index].finish) {
                                queue[index].finish.call(this);
                            }
                        }

                        // turn off finishing flag
                        delete data.finish;
                    });
                }
            });

            jQuery.each(["toggle", "show", "hide"], function(i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function(speed, easing, callback) {
                    return speed == null || typeof speed === "boolean" ?
                        cssFn.apply(this, arguments) :
                        this.animate(genFx(name, true), speed, easing, callback);
                };
            });

            // Generate shortcuts for custom animations
            jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(name, props) {
                jQuery.fn[name] = function(speed, easing, callback) {
                    return this.animate(props, speed, easing, callback);
                };
            });

            jQuery.timers = [];
            jQuery.fx.tick = function() {
                var timer,
                    timers = jQuery.timers,
                    i = 0;

                fxNow = jQuery.now();

                for (; i < timers.length; i++) {
                    timer = timers[i];
                    // Checks the timer has not already been removed
                    if (!timer() && timers[i] === timer) {
                        timers.splice(i--, 1);
                    }
                }

                if (!timers.length) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };

            jQuery.fx.timer = function(timer) {
                jQuery.timers.push(timer);
                if (timer()) {
                    jQuery.fx.start();
                } else {
                    jQuery.timers.pop();
                }
            };

            jQuery.fx.interval = 13;

            jQuery.fx.start = function() {
                if (!timerId) {
                    timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
                }
            };

            jQuery.fx.stop = function() {
                clearInterval(timerId);
                timerId = null;
            };

            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,
                // Default speed
                _default: 400
            };


            // Based off of the plugin by Clint Helfers, with permission.
            // http://blindsignals.com/index.php/2009/07/jquery-delay/
            jQuery.fn.delay = function(time, type) {
                time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                type = type || "fx";

                return this.queue(type, function(next, hooks) {
                    var timeout = setTimeout(next, time);
                    hooks.stop = function() {
                        clearTimeout(timeout);
                    };
                });
            };


            (function() {
                // Minified: var a,b,c,d,e
                var input, div, select, a, opt;

                // Setup
                div = document.createElement("div");
                div.setAttribute("className", "t");
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
                a = div.getElementsByTagName("a")[0];

                // First batch of tests.
                select = document.createElement("select");
                opt = select.appendChild(document.createElement("option"));
                input = div.getElementsByTagName("input")[0];

                a.style.cssText = "top:1px";

                // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
                support.getSetAttribute = div.className !== "t";

                // Get the style information from getAttribute
                // (IE uses .cssText instead)
                support.style = /top/.test(a.getAttribute("style"));

                // Make sure that URLs aren't manipulated
                // (IE normalizes it by default)
                support.hrefNormalized = a.getAttribute("href") === "/a";

                // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
                support.checkOn = !!input.value;

                // Make sure that a selected-by-default option has a working selected property.
                // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
                support.optSelected = opt.selected;

                // Tests for enctype support on a form (#6743)
                support.enctype = !!document.createElement("form").enctype;

                // Make sure that the options inside disabled selects aren't marked as disabled
                // (WebKit marks them as disabled)
                select.disabled = true;
                support.optDisabled = !opt.disabled;

                // Support: IE8 only
                // Check if we can trust getAttribute("value")
                input = document.createElement("input");
                input.setAttribute("value", "");
                support.input = input.getAttribute("value") === "";

                // Check if an input maintains its value after becoming a radio
                input.value = "t";
                input.setAttribute("type", "radio");
                support.radioValue = input.value === "t";
            })();


            var rreturn = /\r/g;

            jQuery.fn.extend({
                val: function(value) {
                    var hooks, ret, isFunction,
                        elem = this[0];

                    if (!arguments.length) {
                        if (elem) {
                            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                                return ret;
                            }

                            ret = elem.value;

                            return typeof ret === "string" ?
                                // handle most common string cases
                                ret.replace(rreturn, "") :
                                // handle cases where value is null/undef or number
                                ret == null ? "" : ret;
                        }

                        return;
                    }

                    isFunction = jQuery.isFunction(value);

                    return this.each(function(i) {
                        var val;

                        if (this.nodeType !== 1) {
                            return;
                        }

                        if (isFunction) {
                            val = value.call(this, i, jQuery(this).val());
                        } else {
                            val = value;
                        }

                        // Treat null/undefined as ""; convert numbers to string
                        if (val == null) {
                            val = "";
                        } else if (typeof val === "number") {
                            val += "";
                        } else if (jQuery.isArray(val)) {
                            val = jQuery.map(val, function(value) {
                                return value == null ? "" : value + "";
                            });
                        }

                        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                        // If set returns undefined, fall back to normal setting
                        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                            this.value = val;
                        }
                    });
                }
            });

            jQuery.extend({
                valHooks: {
                    option: {
                        get: function(elem) {
                            var val = jQuery.find.attr(elem, "value");
                            return val != null ?
                                val :
                                // Support: IE10-11+
                                // option.text throws exceptions (#14686, #14858)
                                jQuery.trim(jQuery.text(elem));
                        }
                    },
                    select: {
                        get: function(elem) {
                            var value, option,
                                options = elem.options,
                                index = elem.selectedIndex,
                                one = elem.type === "select-one" || index < 0,
                                values = one ? null : [],
                                max = one ? index + 1 : options.length,
                                i = index < 0 ?
                                max :
                                one ? index : 0;

                            // Loop through all the selected options
                            for (; i < max; i++) {
                                option = options[i];

                                // oldIE doesn't update selected after form reset (#2551)
                                if ((option.selected || i === index) &&
                                    // Don't return options that are disabled or in a disabled optgroup
                                    (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                                    (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                                    // Get the specific value for the option
                                    value = jQuery(option).val();

                                    // We don't need an array for one selects
                                    if (one) {
                                        return value;
                                    }

                                    // Multi-Selects return an array
                                    values.push(value);
                                }
                            }

                            return values;
                        },

                        set: function(elem, value) {
                            var optionSet, option,
                                options = elem.options,
                                values = jQuery.makeArray(value),
                                i = options.length;

                            while (i--) {
                                option = options[i];

                                if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {

                                    // Support: IE6
                                    // When new option element is added to select box we need to
                                    // force reflow of newly added node in order to workaround delay
                                    // of initialization properties
                                    try {
                                        option.selected = optionSet = true;

                                    } catch (_) {

                                        // Will be executed only in IE6
                                        option.scrollHeight;
                                    }

                                } else {
                                    option.selected = false;
                                }
                            }

                            // Force browsers to behave consistently when non-matching value is set
                            if (!optionSet) {
                                elem.selectedIndex = -1;
                            }

                            return options;
                        }
                    }
                }
            });

            // Radios and checkboxes getter/setter
            jQuery.each(["radio", "checkbox"], function() {
                jQuery.valHooks[this] = {
                    set: function(elem, value) {
                        if (jQuery.isArray(value)) {
                            return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                        }
                    }
                };
                if (!support.checkOn) {
                    jQuery.valHooks[this].get = function(elem) {
                        // Support: Webkit
                        // "" is returned instead of "on" if a value isn't specified
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    };
                }
            });




            var nodeHook, boolHook,
                attrHandle = jQuery.expr.attrHandle,
                ruseDefault = /^(?:checked|selected)$/i,
                getSetAttribute = support.getSetAttribute,
                getSetInput = support.input;

            jQuery.fn.extend({
                attr: function(name, value) {
                    return access(this, jQuery.attr, name, value, arguments.length > 1);
                },

                removeAttr: function(name) {
                    return this.each(function() {
                        jQuery.removeAttr(this, name);
                    });
                }
            });

            jQuery.extend({
                attr: function(elem, name, value) {
                    var hooks, ret,
                        nType = elem.nodeType;

                    // don't get/set attributes on text, comment and attribute nodes
                    if (!elem || nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }

                    // Fallback to prop when attributes are not supported
                    if (typeof elem.getAttribute === strundefined) {
                        return jQuery.prop(elem, name, value);
                    }

                    // All attributes are lowercase
                    // Grab necessary hook if one is defined
                    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                        name = name.toLowerCase();
                        hooks = jQuery.attrHooks[name] ||
                            (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
                    }

                    if (value !== undefined) {

                        if (value === null) {
                            jQuery.removeAttr(elem, name);

                        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                            return ret;

                        } else {
                            elem.setAttribute(name, value + "");
                            return value;
                        }

                    } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                        return ret;

                    } else {
                        ret = jQuery.find.attr(elem, name);

                        // Non-existent attributes return null, we normalize to undefined
                        return ret == null ?
                            undefined :
                            ret;
                    }
                },

                removeAttr: function(elem, value) {
                    var name, propName,
                        i = 0,
                        attrNames = value && value.match(rnotwhite);

                    if (attrNames && elem.nodeType === 1) {
                        while ((name = attrNames[i++])) {
                            propName = jQuery.propFix[name] || name;

                            // Boolean attributes get special treatment (#10870)
                            if (jQuery.expr.match.bool.test(name)) {
                                // Set corresponding property to false
                                if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                                    elem[propName] = false;
                                    // Support: IE<9
                                    // Also clear defaultChecked/defaultSelected (if appropriate)
                                } else {
                                    elem[jQuery.camelCase("default-" + name)] =
                                        elem[propName] = false;
                                }

                                // See #9699 for explanation of this approach (setting first, then removal)
                            } else {
                                jQuery.attr(elem, name, "");
                            }

                            elem.removeAttribute(getSetAttribute ? name : propName);
                        }
                    }
                },

                attrHooks: {
                    type: {
                        set: function(elem, value) {
                            if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                                // Setting the type on a radio button after the value resets the value in IE6-9
                                // Reset value to default in case type is set after value during creation
                                var val = elem.value;
                                elem.setAttribute("type", value);
                                if (val) {
                                    elem.value = val;
                                }
                                return value;
                            }
                        }
                    }
                }
            });

            // Hook for boolean attributes
            boolHook = {
                set: function(elem, value, name) {
                    if (value === false) {
                        // Remove boolean attributes when set to false
                        jQuery.removeAttr(elem, name);
                    } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                        // IE<8 needs the *property* name
                        elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);

                        // Use defaultChecked and defaultSelected for oldIE
                    } else {
                        elem[jQuery.camelCase("default-" + name)] = elem[name] = true;
                    }

                    return name;
                }
            };

            // Retrieve booleans specially
            jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {

                var getter = attrHandle[name] || jQuery.find.attr;

                attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ?
                    function(elem, name, isXML) {
                        var ret, handle;
                        if (!isXML) {
                            // Avoid an infinite loop by temporarily removing this function from the getter
                            handle = attrHandle[name];
                            attrHandle[name] = ret;
                            ret = getter(elem, name, isXML) != null ?
                                name.toLowerCase() :
                                null;
                            attrHandle[name] = handle;
                        }
                        return ret;
                    } :
                    function(elem, name, isXML) {
                        if (!isXML) {
                            return elem[jQuery.camelCase("default-" + name)] ?
                                name.toLowerCase() :
                                null;
                        }
                    };
            });

            // fix oldIE attroperties
            if (!getSetInput || !getSetAttribute) {
                jQuery.attrHooks.value = {
                    set: function(elem, value, name) {
                        if (jQuery.nodeName(elem, "input")) {
                            // Does not return so that setAttribute is also used
                            elem.defaultValue = value;
                        } else {
                            // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                            return nodeHook && nodeHook.set(elem, value, name);
                        }
                    }
                };
            }

            // IE6/7 do not support getting/setting some attributes with get/setAttribute
            if (!getSetAttribute) {

                // Use this for any attribute in IE6/7
                // This fixes almost every IE6/7 issue
                nodeHook = {
                    set: function(elem, value, name) {
                        // Set the existing or create a new attribute node
                        var ret = elem.getAttributeNode(name);
                        if (!ret) {
                            elem.setAttributeNode(
                                (ret = elem.ownerDocument.createAttribute(name))
                            );
                        }

                        ret.value = value += "";

                        // Break association with cloned elements by also using setAttribute (#9646)
                        if (name === "value" || value === elem.getAttribute(name)) {
                            return value;
                        }
                    }
                };

                // Some attributes are constructed with empty-string values when not defined
                attrHandle.id = attrHandle.name = attrHandle.coords =
                    function(elem, name, isXML) {
                        var ret;
                        if (!isXML) {
                            return (ret = elem.getAttributeNode(name)) && ret.value !== "" ?
                                ret.value :
                                null;
                        }
                    };

                // Fixing value retrieval on a button requires this module
                jQuery.valHooks.button = {
                    get: function(elem, name) {
                        var ret = elem.getAttributeNode(name);
                        if (ret && ret.specified) {
                            return ret.value;
                        }
                    },
                    set: nodeHook.set
                };

                // Set contenteditable to false on removals(#10429)
                // Setting to empty string throws an error as an invalid value
                jQuery.attrHooks.contenteditable = {
                    set: function(elem, value, name) {
                        nodeHook.set(elem, value === "" ? false : value, name);
                    }
                };

                // Set width and height to auto instead of 0 on empty string( Bug #8150 )
                // This is for removals
                jQuery.each(["width", "height"], function(i, name) {
                    jQuery.attrHooks[name] = {
                        set: function(elem, value) {
                            if (value === "") {
                                elem.setAttribute(name, "auto");
                                return value;
                            }
                        }
                    };
                });
            }

            if (!support.style) {
                jQuery.attrHooks.style = {
                    get: function(elem) {
                        // Return undefined in the case of empty string
                        // Note: IE uppercases css property names, but if we were to .toLowerCase()
                        // .cssText, that would destroy case senstitivity in URL's, like in "background"
                        return elem.style.cssText || undefined;
                    },
                    set: function(elem, value) {
                        return (elem.style.cssText = value + "");
                    }
                };
            }




            var rfocusable = /^(?:input|select|textarea|button|object)$/i,
                rclickable = /^(?:a|area)$/i;

            jQuery.fn.extend({
                prop: function(name, value) {
                    return access(this, jQuery.prop, name, value, arguments.length > 1);
                },

                removeProp: function(name) {
                    name = jQuery.propFix[name] || name;
                    return this.each(function() {
                        // try/catch handles cases where IE balks (such as removing a property on window)
                        try {
                            this[name] = undefined;
                            delete this[name];
                        } catch (e) {}
                    });
                }
            });

            jQuery.extend({
                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                },

                prop: function(elem, name, value) {
                    var ret, hooks, notxml,
                        nType = elem.nodeType;

                    // don't get/set properties on text, comment and attribute nodes
                    if (!elem || nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }

                    notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

                    if (notxml) {
                        // Fix name and attach hooks
                        name = jQuery.propFix[name] || name;
                        hooks = jQuery.propHooks[name];
                    }

                    if (value !== undefined) {
                        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ?
                            ret :
                            (elem[name] = value);

                    } else {
                        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ?
                            ret :
                            elem[name];
                    }
                },

                propHooks: {
                    tabIndex: {
                        get: function(elem) {
                            // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                            // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                            // Use proper attribute retrieval(#12072)
                            var tabindex = jQuery.find.attr(elem, "tabindex");

                            return tabindex ?
                                parseInt(tabindex, 10) :
                                rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
                                0 :
                                -1;
                        }
                    }
                }
            });

            // Some attributes require a special call on IE
            // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if (!support.hrefNormalized) {
                // href/src property should get the full normalized URL (#10299/#12915)
                jQuery.each(["href", "src"], function(i, name) {
                    jQuery.propHooks[name] = {
                        get: function(elem) {
                            return elem.getAttribute(name, 4);
                        }
                    };
                });
            }

            // Support: Safari, IE9+
            // mis-reports the default selected property of an option
            // Accessing the parent's selectedIndex property fixes it
            if (!support.optSelected) {
                jQuery.propHooks.selected = {
                    get: function(elem) {
                        var parent = elem.parentNode;

                        if (parent) {
                            parent.selectedIndex;

                            // Make sure that it also works with optgroups, see #5701
                            if (parent.parentNode) {
                                parent.parentNode.selectedIndex;
                            }
                        }
                        return null;
                    }
                };
            }

            jQuery.each([
                "tabIndex",
                "readOnly",
                "maxLength",
                "cellSpacing",
                "cellPadding",
                "rowSpan",
                "colSpan",
                "useMap",
                "frameBorder",
                "contentEditable"
            ], function() {
                jQuery.propFix[this.toLowerCase()] = this;
            });

            // IE6/7 call enctype encoding
            if (!support.enctype) {
                jQuery.propFix.enctype = "encoding";
            }




            var rclass = /[\t\r\n\f]/g;

            jQuery.fn.extend({
                addClass: function(value) {
                    var classes, elem, cur, clazz, j, finalValue,
                        i = 0,
                        len = this.length,
                        proceed = typeof value === "string" && value;

                    if (jQuery.isFunction(value)) {
                        return this.each(function(j) {
                            jQuery(this).addClass(value.call(this, j, this.className));
                        });
                    }

                    if (proceed) {
                        // The disjunction here is for better compressibility (see removeClass)
                        classes = (value || "").match(rnotwhite) || [];

                        for (; i < len; i++) {
                            elem = this[i];
                            cur = elem.nodeType === 1 && (elem.className ?
                                (" " + elem.className + " ").replace(rclass, " ") :
                                " "
                            );

                            if (cur) {
                                j = 0;
                                while ((clazz = classes[j++])) {
                                    if (cur.indexOf(" " + clazz + " ") < 0) {
                                        cur += clazz + " ";
                                    }
                                }

                                // only assign if different to avoid unneeded rendering.
                                finalValue = jQuery.trim(cur);
                                if (elem.className !== finalValue) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function(value) {
                    var classes, elem, cur, clazz, j, finalValue,
                        i = 0,
                        len = this.length,
                        proceed = arguments.length === 0 || typeof value === "string" && value;

                    if (jQuery.isFunction(value)) {
                        return this.each(function(j) {
                            jQuery(this).removeClass(value.call(this, j, this.className));
                        });
                    }
                    if (proceed) {
                        classes = (value || "").match(rnotwhite) || [];

                        for (; i < len; i++) {
                            elem = this[i];
                            // This expression is here for better compressibility (see addClass)
                            cur = elem.nodeType === 1 && (elem.className ?
                                (" " + elem.className + " ").replace(rclass, " ") :
                                ""
                            );

                            if (cur) {
                                j = 0;
                                while ((clazz = classes[j++])) {
                                    // Remove *all* instances
                                    while (cur.indexOf(" " + clazz + " ") >= 0) {
                                        cur = cur.replace(" " + clazz + " ", " ");
                                    }
                                }

                                // only assign if different to avoid unneeded rendering.
                                finalValue = value ? jQuery.trim(cur) : "";
                                if (elem.className !== finalValue) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                toggleClass: function(value, stateVal) {
                    var type = typeof value;

                    if (typeof stateVal === "boolean" && type === "string") {
                        return stateVal ? this.addClass(value) : this.removeClass(value);
                    }

                    if (jQuery.isFunction(value)) {
                        return this.each(function(i) {
                            jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                        });
                    }

                    return this.each(function() {
                        if (type === "string") {
                            // toggle individual class names
                            var className,
                                i = 0,
                                self = jQuery(this),
                                classNames = value.match(rnotwhite) || [];

                            while ((className = classNames[i++])) {
                                // check each className given, space separated list
                                if (self.hasClass(className)) {
                                    self.removeClass(className);
                                } else {
                                    self.addClass(className);
                                }
                            }

                            // Toggle whole class name
                        } else if (type === strundefined || type === "boolean") {
                            if (this.className) {
                                // store className if set
                                jQuery._data(this, "__className__", this.className);
                            }

                            // If the element has a class name or if we're passed "false",
                            // then remove the whole classname (if there was one, the above saved it).
                            // Otherwise bring back whatever was previously saved (if anything),
                            // falling back to the empty string if nothing was stored.
                            this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                        }
                    });
                },

                hasClass: function(selector) {
                    var className = " " + selector + " ",
                        i = 0,
                        l = this.length;
                    for (; i < l; i++) {
                        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                            return true;
                        }
                    }

                    return false;
                }
            });




            // Return jQuery for attributes-only inclusion


            jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
                "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {

                // Handle event binding
                jQuery.fn[name] = function(data, fn) {
                    return arguments.length > 0 ?
                        this.on(name, null, data, fn) :
                        this.trigger(name);
                };
            });

            jQuery.fn.extend({
                hover: function(fnOver, fnOut) {
                    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                },

                bind: function(types, data, fn) {
                    return this.on(types, null, data, fn);
                },
                unbind: function(types, fn) {
                    return this.off(types, null, fn);
                },

                delegate: function(selector, types, data, fn) {
                    return this.on(types, selector, data, fn);
                },
                undelegate: function(selector, types, fn) {
                    // ( namespace ) or ( selector, types [, fn] )
                    return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
                }
            });


            var nonce = jQuery.now();

            var rquery = (/\?/);



            var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

            jQuery.parseJSON = function(data) {
                // Attempt to parse using the native JSON parser first
                if (window.JSON && window.JSON.parse) {
                    // Support: Android 2.3
                    // Workaround failure to string-cast null input
                    return window.JSON.parse(data + "");
                }

                var requireNonComma,
                    depth = null,
                    str = jQuery.trim(data + "");

                // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
                // after removing valid tokens
                return str && !jQuery.trim(str.replace(rvalidtokens, function(token, comma, open, close) {

                        // Force termination if we see a misplaced comma
                        if (requireNonComma && comma) {
                            depth = 0;
                        }

                        // Perform no more replacements after returning to outermost depth
                        if (depth === 0) {
                            return token;
                        }

                        // Commas must not follow "[", "{", or ","
                        requireNonComma = open || comma;

                        // Determine new depth
                        // array/object open ("[" or "{"): depth += true - false (increment)
                        // array/object close ("]" or "}"): depth += false - true (decrement)
                        // other cases ("," or primitive): depth += true - true (numeric cast)
                        depth += !close - !open;

                        // Remove this token
                        return "";
                    })) ?
                    (Function("return " + str))() :
                    jQuery.error("Invalid JSON: " + data);
            };


            // Cross-browser xml parsing
            jQuery.parseXML = function(data) {
                var xml, tmp;
                if (!data || typeof data !== "string") {
                    return null;
                }
                try {
                    if (window.DOMParser) { // Standard
                        tmp = new DOMParser();
                        xml = tmp.parseFromString(data, "text/xml");
                    } else { // IE
                        xml = new ActiveXObject("Microsoft.XMLDOM");
                        xml.async = "false";
                        xml.loadXML(data);
                    }
                } catch (e) {
                    xml = undefined;
                }
                if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                    jQuery.error("Invalid XML: " + data);
                }
                return xml;
            };


            var
                // Document location
                ajaxLocParts,
                ajaxLocation,

                rhash = /#.*$/,
                rts = /([?&])_=[^&]*/,
                rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
                // #7653, #8125, #8152: local protocol detection
                rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                rnoContent = /^(?:GET|HEAD)$/,
                rprotocol = /^\/\//,
                rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

                /* Prefilters
                 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
                 * 2) These are called:
                 *    - BEFORE asking for a transport
                 *    - AFTER param serialization (s.data is a string if s.processData is true)
                 * 3) key is the dataType
                 * 4) the catchall symbol "*" can be used
                 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
                 */
                prefilters = {},

                /* Transports bindings
                 * 1) key is the dataType
                 * 2) the catchall symbol "*" can be used
                 * 3) selection will start with transport dataType and THEN go to "*" if needed
                 */
                transports = {},

                // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                allTypes = "*/".concat("*");

            // #8138, IE may throw an exception when accessing
            // a field from window.location if document.domain has been set
            try {
                ajaxLocation = location.href;
            } catch (e) {
                // Use the href attribute of an A element
                // since IE will modify it given document.location
                ajaxLocation = document.createElement("a");
                ajaxLocation.href = "";
                ajaxLocation = ajaxLocation.href;
            }

            // Segment location into parts
            ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

            // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function addToPrefiltersOrTransports(structure) {

                // dataTypeExpression is optional and defaults to "*"
                return function(dataTypeExpression, func) {

                    if (typeof dataTypeExpression !== "string") {
                        func = dataTypeExpression;
                        dataTypeExpression = "*";
                    }

                    var dataType,
                        i = 0,
                        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

                    if (jQuery.isFunction(func)) {
                        // For each dataType in the dataTypeExpression
                        while ((dataType = dataTypes[i++])) {
                            // Prepend if requested
                            if (dataType.charAt(0) === "+") {
                                dataType = dataType.slice(1) || "*";
                                (structure[dataType] = structure[dataType] || []).unshift(func);

                                // Otherwise append
                            } else {
                                (structure[dataType] = structure[dataType] || []).push(func);
                            }
                        }
                    }
                };
            }

            // Base inspection function for prefilters and transports
            function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

                var inspected = {},
                    seekingTransport = (structure === transports);

                function inspect(dataType) {
                    var selected;
                    inspected[dataType] = true;
                    jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                            options.dataTypes.unshift(dataTypeOrTransport);
                            inspect(dataTypeOrTransport);
                            return false;
                        } else if (seekingTransport) {
                            return !(selected = dataTypeOrTransport);
                        }
                    });
                    return selected;
                }

                return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
            }

            // A special extend for ajax options
            // that takes "flat" options (not to be deep extended)
            // Fixes #9887
            function ajaxExtend(target, src) {
                var deep, key,
                    flatOptions = jQuery.ajaxSettings.flatOptions || {};

                for (key in src) {
                    if (src[key] !== undefined) {
                        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
                    }
                }
                if (deep) {
                    jQuery.extend(true, target, deep);
                }

                return target;
            }

            /* Handles responses to an ajax request:
             * - finds the right dataType (mediates between content-type and expected dataType)
             * - returns the corresponding response
             */
            function ajaxHandleResponses(s, jqXHR, responses) {
                var firstDataType, ct, finalDataType, type,
                    contents = s.contents,
                    dataTypes = s.dataTypes;

                // Remove auto dataType and get content-type in the process
                while (dataTypes[0] === "*") {
                    dataTypes.shift();
                    if (ct === undefined) {
                        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                    }
                }

                // Check if we're dealing with a known content-type
                if (ct) {
                    for (type in contents) {
                        if (contents[type] && contents[type].test(ct)) {
                            dataTypes.unshift(type);
                            break;
                        }
                    }
                }

                // Check to see if we have a response for the expected dataType
                if (dataTypes[0] in responses) {
                    finalDataType = dataTypes[0];
                } else {
                    // Try convertible dataTypes
                    for (type in responses) {
                        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                            finalDataType = type;
                            break;
                        }
                        if (!firstDataType) {
                            firstDataType = type;
                        }
                    }
                    // Or just use first one
                    finalDataType = finalDataType || firstDataType;
                }

                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if (finalDataType) {
                    if (finalDataType !== dataTypes[0]) {
                        dataTypes.unshift(finalDataType);
                    }
                    return responses[finalDataType];
                }
            }

            /* Chain conversions given the request and the original response
             * Also sets the responseXXX fields on the jqXHR instance
             */
            function ajaxConvert(s, response, jqXHR, isSuccess) {
                var conv2, current, conv, tmp, prev,
                    converters = {},
                    // Work with a copy of dataTypes in case we need to modify it for conversion
                    dataTypes = s.dataTypes.slice();

                // Create converters map with lowercased keys
                if (dataTypes[1]) {
                    for (conv in s.converters) {
                        converters[conv.toLowerCase()] = s.converters[conv];
                    }
                }

                current = dataTypes.shift();

                // Convert to each sequential dataType
                while (current) {

                    if (s.responseFields[current]) {
                        jqXHR[s.responseFields[current]] = response;
                    }

                    // Apply the dataFilter if provided
                    if (!prev && isSuccess && s.dataFilter) {
                        response = s.dataFilter(response, s.dataType);
                    }

                    prev = current;
                    current = dataTypes.shift();

                    if (current) {

                        // There's only work to do if current dataType is non-auto
                        if (current === "*") {

                            current = prev;

                            // Convert response if prev dataType is non-auto and differs from current
                        } else if (prev !== "*" && prev !== current) {

                            // Seek a direct converter
                            conv = converters[prev + " " + current] || converters["* " + current];

                            // If none found, seek a pair
                            if (!conv) {
                                for (conv2 in converters) {

                                    // If conv2 outputs current
                                    tmp = conv2.split(" ");
                                    if (tmp[1] === current) {

                                        // If prev can be converted to accepted input
                                        conv = converters[prev + " " + tmp[0]] ||
                                            converters["* " + tmp[0]];
                                        if (conv) {
                                            // Condense equivalence converters
                                            if (conv === true) {
                                                conv = converters[conv2];

                                                // Otherwise, insert the intermediate dataType
                                            } else if (converters[conv2] !== true) {
                                                current = tmp[0];
                                                dataTypes.unshift(tmp[1]);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }

                            // Apply converter (if not an equivalence)
                            if (conv !== true) {

                                // Unless errors are allowed to bubble, catch and return them
                                if (conv && s["throws"]) {
                                    response = conv(response);
                                } else {
                                    try {
                                        response = conv(response);
                                    } catch (e) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

                return {
                    state: "success",
                    data: response
                };
            }

            jQuery.extend({

                // Counter for holding the number of active queries
                active: 0,

                // Last-Modified header cache for next request
                lastModified: {},
                etag: {},

                ajaxSettings: {
                    url: ajaxLocation,
                    type: "GET",
                    isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                    global: true,
                    processData: true,
                    async: true,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    /*
                    timeout: 0,
                    data: null,
                    dataType: null,
                    username: null,
                    password: null,
                    cache: null,
                    throws: false,
                    traditional: false,
                    headers: {},
                    */

                    accepts: {
                        "*": allTypes,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },

                    contents: {
                        xml: /xml/,
                        html: /html/,
                        json: /json/
                    },

                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },

                    // Data converters
                    // Keys separate source (or catchall "*") and destination types with a single space
                    converters: {

                        // Convert anything to text
                        "* text": String,

                        // Text to html (true = no transformation)
                        "text html": true,

                        // Evaluate text as a json expression
                        "text json": jQuery.parseJSON,

                        // Parse text as xml
                        "text xml": jQuery.parseXML
                    },

                    // For options that shouldn't be deep extended:
                    // you can add your own custom options here if
                    // and when you create one that shouldn't be
                    // deep extended (see ajaxExtend)
                    flatOptions: {
                        url: true,
                        context: true
                    }
                },

                // Creates a full fledged settings object into target
                // with both ajaxSettings and settings fields.
                // If target is omitted, writes into ajaxSettings.
                ajaxSetup: function(target, settings) {
                    return settings ?

                        // Building a settings object
                        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                        // Extending ajaxSettings
                        ajaxExtend(jQuery.ajaxSettings, target);
                },

                ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                ajaxTransport: addToPrefiltersOrTransports(transports),

                // Main method
                ajax: function(url, options) {

                    // If url is an object, simulate pre-1.5 signature
                    if (typeof url === "object") {
                        options = url;
                        url = undefined;
                    }

                    // Force options to be an object
                    options = options || {};

                    var // Cross-domain detection vars
                        parts,
                        // Loop variable
                        i,
                        // URL without anti-cache param
                        cacheURL,
                        // Response headers as string
                        responseHeadersString,
                        // timeout handle
                        timeoutTimer,

                        // To know if global events are to be dispatched
                        fireGlobals,

                        transport,
                        // Response headers
                        responseHeaders,
                        // Create the final options object
                        s = jQuery.ajaxSetup({}, options),
                        // Callbacks context
                        callbackContext = s.context || s,
                        // Context for global events is callbackContext if it is a DOM node or jQuery collection
                        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ?
                        jQuery(callbackContext) :
                        jQuery.event,
                        // Deferreds
                        deferred = jQuery.Deferred(),
                        completeDeferred = jQuery.Callbacks("once memory"),
                        // Status-dependent callbacks
                        statusCode = s.statusCode || {},
                        // Headers (they are sent all at once)
                        requestHeaders = {},
                        requestHeadersNames = {},
                        // The jqXHR state
                        state = 0,
                        // Default abort message
                        strAbort = "canceled",
                        // Fake xhr
                        jqXHR = {
                            readyState: 0,

                            // Builds headers hashtable if needed
                            getResponseHeader: function(key) {
                                var match;
                                if (state === 2) {
                                    if (!responseHeaders) {
                                        responseHeaders = {};
                                        while ((match = rheaders.exec(responseHeadersString))) {
                                            responseHeaders[match[1].toLowerCase()] = match[2];
                                        }
                                    }
                                    match = responseHeaders[key.toLowerCase()];
                                }
                                return match == null ? null : match;
                            },

                            // Raw string
                            getAllResponseHeaders: function() {
                                return state === 2 ? responseHeadersString : null;
                            },

                            // Caches the header
                            setRequestHeader: function(name, value) {
                                var lname = name.toLowerCase();
                                if (!state) {
                                    name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                    requestHeaders[name] = value;
                                }
                                return this;
                            },

                            // Overrides response content-type header
                            overrideMimeType: function(type) {
                                if (!state) {
                                    s.mimeType = type;
                                }
                                return this;
                            },

                            // Status-dependent callbacks
                            statusCode: function(map) {
                                var code;
                                if (map) {
                                    if (state < 2) {
                                        for (code in map) {
                                            // Lazy-add the new callback in a way that preserves old ones
                                            statusCode[code] = [statusCode[code], map[code]];
                                        }
                                    } else {
                                        // Execute the appropriate callbacks
                                        jqXHR.always(map[jqXHR.status]);
                                    }
                                }
                                return this;
                            },

                            // Cancel the request
                            abort: function(statusText) {
                                var finalText = statusText || strAbort;
                                if (transport) {
                                    transport.abort(finalText);
                                }
                                done(0, finalText);
                                return this;
                            }
                        };

                    // Attach deferreds
                    deferred.promise(jqXHR).complete = completeDeferred.add;
                    jqXHR.success = jqXHR.done;
                    jqXHR.error = jqXHR.fail;

                    // Remove hash character (#7531: and string promotion)
                    // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
                    // Handle falsy url in the settings object (#10093: consistency with old signature)
                    // We also use the url parameter if available
                    s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

                    // Alias method option to type as per ticket #12004
                    s.type = options.method || options.type || s.method || s.type;

                    // Extract dataTypes list
                    s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

                    // A cross-domain request is in order when we have a protocol:host:port mismatch
                    if (s.crossDomain == null) {
                        parts = rurl.exec(s.url.toLowerCase());
                        s.crossDomain = !!(parts &&
                            (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
                                (parts[3] || (parts[1] === "http:" ? "80" : "443")) !==
                                (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443")))
                        );
                    }

                    // Convert data if not already a string
                    if (s.data && s.processData && typeof s.data !== "string") {
                        s.data = jQuery.param(s.data, s.traditional);
                    }

                    // Apply prefilters
                    inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

                    // If request was aborted inside a prefilter, stop there
                    if (state === 2) {
                        return jqXHR;
                    }

                    // We can fire global events as of now if asked to
                    fireGlobals = s.global;

                    // Watch for a new set of requests
                    if (fireGlobals && jQuery.active++ === 0) {
                        jQuery.event.trigger("ajaxStart");
                    }

                    // Uppercase the type
                    s.type = s.type.toUpperCase();

                    // Determine if request has content
                    s.hasContent = !rnoContent.test(s.type);

                    // Save the URL in case we're toying with the If-Modified-Since
                    // and/or If-None-Match header later on
                    cacheURL = s.url;

                    // More options handling for requests with no content
                    if (!s.hasContent) {

                        // If data is available, append data to url
                        if (s.data) {
                            cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
                            // #9682: remove data so that it's not used in an eventual retry
                            delete s.data;
                        }

                        // Add anti-cache in url if needed
                        if (s.cache === false) {
                            s.url = rts.test(cacheURL) ?

                                // If there is already a '_' parameter, set its value
                                cacheURL.replace(rts, "$1_=" + nonce++) :

                                // Otherwise add one to the end
                                cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                        }
                    }

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        if (jQuery.lastModified[cacheURL]) {
                            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                        }
                        if (jQuery.etag[cacheURL]) {
                            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                        }
                    }

                    // Set the correct header, if data is being sent
                    if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                        jqXHR.setRequestHeader("Content-Type", s.contentType);
                    }

                    // Set the Accepts header for the server, depending on the dataType
                    jqXHR.setRequestHeader(
                        "Accept",
                        s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                        s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                        s.accepts["*"]
                    );

                    // Check for headers option
                    for (i in s.headers) {
                        jqXHR.setRequestHeader(i, s.headers[i]);
                    }

                    // Allow custom headers/mimetypes and early abort
                    if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                        // Abort if not done already and return
                        return jqXHR.abort();
                    }

                    // aborting is no longer a cancellation
                    strAbort = "abort";

                    // Install callbacks on deferreds
                    for (i in {
                            success: 1,
                            error: 1,
                            complete: 1
                        }) {
                        jqXHR[i](s[i]);
                    }

                    // Get transport
                    transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

                    // If no transport, we auto-abort
                    if (!transport) {
                        done(-1, "No Transport");
                    } else {
                        jqXHR.readyState = 1;

                        // Send global event
                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                        }
                        // Timeout
                        if (s.async && s.timeout > 0) {
                            timeoutTimer = setTimeout(function() {
                                jqXHR.abort("timeout");
                            }, s.timeout);
                        }

                        try {
                            state = 1;
                            transport.send(requestHeaders, done);
                        } catch (e) {
                            // Propagate exception as error if not done
                            if (state < 2) {
                                done(-1, e);
                                // Simply rethrow otherwise
                            } else {
                                throw e;
                            }
                        }
                    }

                    // Callback for when everything is done
                    function done(status, nativeStatusText, responses, headers) {
                        var isSuccess, success, error, response, modified,
                            statusText = nativeStatusText;

                        // Called once
                        if (state === 2) {
                            return;
                        }

                        // State is "done" now
                        state = 2;

                        // Clear timeout if it exists
                        if (timeoutTimer) {
                            clearTimeout(timeoutTimer);
                        }

                        // Dereference transport for early garbage collection
                        // (no matter how long the jqXHR object will be used)
                        transport = undefined;

                        // Cache response headers
                        responseHeadersString = headers || "";

                        // Set readyState
                        jqXHR.readyState = status > 0 ? 4 : 0;

                        // Determine if successful
                        isSuccess = status >= 200 && status < 300 || status === 304;

                        // Get response data
                        if (responses) {
                            response = ajaxHandleResponses(s, jqXHR, responses);
                        }

                        // Convert no matter what (that way responseXXX fields are always set)
                        response = ajaxConvert(s, response, jqXHR, isSuccess);

                        // If successful, handle type chaining
                        if (isSuccess) {

                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if (s.ifModified) {
                                modified = jqXHR.getResponseHeader("Last-Modified");
                                if (modified) {
                                    jQuery.lastModified[cacheURL] = modified;
                                }
                                modified = jqXHR.getResponseHeader("etag");
                                if (modified) {
                                    jQuery.etag[cacheURL] = modified;
                                }
                            }

                            // if no content
                            if (status === 204 || s.type === "HEAD") {
                                statusText = "nocontent";

                                // if not modified
                            } else if (status === 304) {
                                statusText = "notmodified";

                                // If we have data, let's convert it
                            } else {
                                statusText = response.state;
                                success = response.data;
                                error = response.error;
                                isSuccess = !error;
                            }
                        } else {
                            // We extract error from statusText
                            // then normalize statusText and status for non-aborts
                            error = statusText;
                            if (status || !statusText) {
                                statusText = "error";
                                if (status < 0) {
                                    status = 0;
                                }
                            }
                        }

                        // Set data for the fake xhr object
                        jqXHR.status = status;
                        jqXHR.statusText = (nativeStatusText || statusText) + "";

                        // Success/Error
                        if (isSuccess) {
                            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                        } else {
                            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                        }

                        // Status-dependent callbacks
                        jqXHR.statusCode(statusCode);
                        statusCode = undefined;

                        if (fireGlobals) {
                            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                        }

                        // Complete
                        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                            // Handle the global AJAX counter
                            if (!(--jQuery.active)) {
                                jQuery.event.trigger("ajaxStop");
                            }
                        }
                    }

                    return jqXHR;
                },

                getJSON: function(url, data, callback) {
                    return jQuery.get(url, data, callback, "json");
                },

                getScript: function(url, callback) {
                    return jQuery.get(url, undefined, callback, "script");
                }
            });

            jQuery.each(["get", "post"], function(i, method) {
                jQuery[method] = function(url, data, callback, type) {
                    // shift arguments if data argument was omitted
                    if (jQuery.isFunction(data)) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }

                    return jQuery.ajax({
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    });
                };
            });

            // Attach a bunch of functions for handling common AJAX events
            jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
                jQuery.fn[type] = function(fn) {
                    return this.on(type, fn);
                };
            });


            jQuery._evalUrl = function(url) {
                return jQuery.ajax({
                    url: url,
                    type: "GET",
                    dataType: "script",
                    async: false,
                    global: false,
                    "throws": true
                });
            };


            jQuery.fn.extend({
                wrapAll: function(html) {
                    if (jQuery.isFunction(html)) {
                        return this.each(function(i) {
                            jQuery(this).wrapAll(html.call(this, i));
                        });
                    }

                    if (this[0]) {
                        // The elements to wrap the target around
                        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                        if (this[0].parentNode) {
                            wrap.insertBefore(this[0]);
                        }

                        wrap.map(function() {
                            var elem = this;

                            while (elem.firstChild && elem.firstChild.nodeType === 1) {
                                elem = elem.firstChild;
                            }

                            return elem;
                        }).append(this);
                    }

                    return this;
                },

                wrapInner: function(html) {
                    if (jQuery.isFunction(html)) {
                        return this.each(function(i) {
                            jQuery(this).wrapInner(html.call(this, i));
                        });
                    }

                    return this.each(function() {
                        var self = jQuery(this),
                            contents = self.contents();

                        if (contents.length) {
                            contents.wrapAll(html);

                        } else {
                            self.append(html);
                        }
                    });
                },

                wrap: function(html) {
                    var isFunction = jQuery.isFunction(html);

                    return this.each(function(i) {
                        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                    });
                },

                unwrap: function() {
                    return this.parent().each(function() {
                        if (!jQuery.nodeName(this, "body")) {
                            jQuery(this).replaceWith(this.childNodes);
                        }
                    }).end();
                }
            });


            jQuery.expr.filters.hidden = function(elem) {
                // Support: Opera <= 12.12
                // Opera reports offsetWidths and offsetHeights less than zero on some elements
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
                    (!support.reliableHiddenOffsets() &&
                        ((elem.style && elem.style.display) || jQuery.css(elem, "display")) === "none");
            };

            jQuery.expr.filters.visible = function(elem) {
                return !jQuery.expr.filters.hidden(elem);
            };




            var r20 = /%20/g,
                rbracket = /\[\]$/,
                rCRLF = /\r?\n/g,
                rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                rsubmittable = /^(?:input|select|textarea|keygen)/i;

            function buildParams(prefix, obj, traditional, add) {
                var name;

                if (jQuery.isArray(obj)) {
                    // Serialize array item.
                    jQuery.each(obj, function(i, v) {
                        if (traditional || rbracket.test(prefix)) {
                            // Treat each array item as a scalar.
                            add(prefix, v);

                        } else {
                            // Item is non-scalar (array or object), encode its numeric index.
                            buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                        }
                    });

                } else if (!traditional && jQuery.type(obj) === "object") {
                    // Serialize object item.
                    for (name in obj) {
                        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                    }

                } else {
                    // Serialize scalar item.
                    add(prefix, obj);
                }
            }

            // Serialize an array of form elements or a set of
            // key/values into a query string
            jQuery.param = function(a, traditional) {
                var prefix,
                    s = [],
                    add = function(key, value) {
                        // If value is a function, invoke it and return its value
                        value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
                        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                    };

                // Set traditional to true for jQuery <= 1.3.2 behavior.
                if (traditional === undefined) {
                    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                }

                // If an array was passed in, assume that it is an array of form elements.
                if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                    // Serialize the form elements
                    jQuery.each(a, function() {
                        add(this.name, this.value);
                    });

                } else {
                    // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for (prefix in a) {
                        buildParams(prefix, a[prefix], traditional, add);
                    }
                }

                // Return the resulting serialization
                return s.join("&").replace(r20, "+");
            };

            jQuery.fn.extend({
                serialize: function() {
                    return jQuery.param(this.serializeArray());
                },
                serializeArray: function() {
                    return this.map(function() {
                            // Can add propHook for "elements" to filter or add form elements
                            var elements = jQuery.prop(this, "elements");
                            return elements ? jQuery.makeArray(elements) : this;
                        })
                        .filter(function() {
                            var type = this.type;
                            // Use .is(":disabled") so that fieldset[disabled] works
                            return this.name && !jQuery(this).is(":disabled") &&
                                rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                                (this.checked || !rcheckableType.test(type));
                        })
                        .map(function(i, elem) {
                            var val = jQuery(this).val();

                            return val == null ?
                                null :
                                jQuery.isArray(val) ?
                                jQuery.map(val, function(val) {
                                    return {
                                        name: elem.name,
                                        value: val.replace(rCRLF, "\r\n")
                                    };
                                }) : {
                                    name: elem.name,
                                    value: val.replace(rCRLF, "\r\n")
                                };
                        }).get();
                }
            });


            // Create the request object
            // (This is still attached to ajaxSettings for backward compatibility)
            jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
                // Support: IE6+
                function() {

                    // XHR cannot access local files, always use ActiveX for that case
                    return !this.isLocal &&

                        // Support: IE7-8
                        // oldIE XHR does not support non-RFC2616 methods (#13240)
                        // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
                        // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
                        // Although this check for six methods instead of eight
                        // since IE also does not support "trace" and "connect"
                        /^(get|post|head|put|delete|options)$/i.test(this.type) &&

                        createStandardXHR() || createActiveXHR();
                } :
                // For all other browsers, use the standard XMLHttpRequest object
                createStandardXHR;

            var xhrId = 0,
                xhrCallbacks = {},
                xhrSupported = jQuery.ajaxSettings.xhr();

            // Support: IE<10
            // Open requests must be manually aborted on unload (#5280)
            if (window.ActiveXObject) {
                jQuery(window).on("unload", function() {
                    for (var key in xhrCallbacks) {
                        xhrCallbacks[key](undefined, true);
                    }
                });
            }

            // Determine support properties
            support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
            xhrSupported = support.ajax = !!xhrSupported;

            // Create transport if the browser can provide an xhr
            if (xhrSupported) {

                jQuery.ajaxTransport(function(options) {
                    // Cross domain only allowed if supported through XMLHttpRequest
                    if (!options.crossDomain || support.cors) {

                        var callback;

                        return {
                            send: function(headers, complete) {
                                var i,
                                    xhr = options.xhr(),
                                    id = ++xhrId;

                                // Open the socket
                                xhr.open(options.type, options.url, options.async, options.username, options.password);

                                // Apply custom fields if provided
                                if (options.xhrFields) {
                                    for (i in options.xhrFields) {
                                        xhr[i] = options.xhrFields[i];
                                    }
                                }

                                // Override mime type if needed
                                if (options.mimeType && xhr.overrideMimeType) {
                                    xhr.overrideMimeType(options.mimeType);
                                }

                                // X-Requested-With header
                                // For cross-domain requests, seeing as conditions for a preflight are
                                // akin to a jigsaw puzzle, we simply never set it to be sure.
                                // (it can always be set on a per-request basis or even using ajaxSetup)
                                // For same-domain requests, won't change header if already provided.
                                if (!options.crossDomain && !headers["X-Requested-With"]) {
                                    headers["X-Requested-With"] = "XMLHttpRequest";
                                }

                                // Set headers
                                for (i in headers) {
                                    // Support: IE<9
                                    // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                                    // request header to a null-value.
                                    //
                                    // To keep consistent with other XHR implementations, cast the value
                                    // to string and ignore `undefined`.
                                    if (headers[i] !== undefined) {
                                        xhr.setRequestHeader(i, headers[i] + "");
                                    }
                                }

                                // Do send the request
                                // This may raise an exception which is actually
                                // handled in jQuery.ajax (so no try/catch here)
                                xhr.send((options.hasContent && options.data) || null);

                                // Listener
                                callback = function(_, isAbort) {
                                    var status, statusText, responses;

                                    // Was never called and is aborted or complete
                                    if (callback && (isAbort || xhr.readyState === 4)) {
                                        // Clean up
                                        delete xhrCallbacks[id];
                                        callback = undefined;
                                        xhr.onreadystatechange = jQuery.noop;

                                        // Abort manually if needed
                                        if (isAbort) {
                                            if (xhr.readyState !== 4) {
                                                xhr.abort();
                                            }
                                        } else {
                                            responses = {};
                                            status = xhr.status;

                                            // Support: IE<10
                                            // Accessing binary-data responseText throws an exception
                                            // (#11426)
                                            if (typeof xhr.responseText === "string") {
                                                responses.text = xhr.responseText;
                                            }

                                            // Firefox throws an exception when accessing
                                            // statusText for faulty cross-domain requests
                                            try {
                                                statusText = xhr.statusText;
                                            } catch (e) {
                                                // We normalize with Webkit giving an empty statusText
                                                statusText = "";
                                            }

                                            // Filter status for non standard behaviors

                                            // If the request is local and we have data: assume a success
                                            // (success with no data won't get notified, that's the best we
                                            // can do given current implementations)
                                            if (!status && options.isLocal && !options.crossDomain) {
                                                status = responses.text ? 200 : 404;
                                                // IE - #1450: sometimes returns 1223 when it should be 204
                                            } else if (status === 1223) {
                                                status = 204;
                                            }
                                        }
                                    }

                                    // Call complete if needed
                                    if (responses) {
                                        complete(status, statusText, responses, xhr.getAllResponseHeaders());
                                    }
                                };

                                if (!options.async) {
                                    // if we're in sync mode we fire the callback
                                    callback();
                                } else if (xhr.readyState === 4) {
                                    // (IE6 & IE7) if it's in cache and has been
                                    // retrieved directly we need to fire the callback
                                    setTimeout(callback);
                                } else {
                                    // Add to the list of active xhr callbacks
                                    xhr.onreadystatechange = xhrCallbacks[id] = callback;
                                }
                            },

                            abort: function() {
                                if (callback) {
                                    callback(undefined, true);
                                }
                            }
                        };
                    }
                });
            }

            // Functions to create xhrs
            function createStandardXHR() {
                try {
                    return new window.XMLHttpRequest();
                } catch (e) {}
            }

            function createActiveXHR() {
                try {
                    return new window.ActiveXObject("Microsoft.XMLHTTP");
                } catch (e) {}
            }




            // Install script dataType
            jQuery.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /(?:java|ecma)script/
                },
                converters: {
                    "text script": function(text) {
                        jQuery.globalEval(text);
                        return text;
                    }
                }
            });

            // Handle cache's special case and global
            jQuery.ajaxPrefilter("script", function(s) {
                if (s.cache === undefined) {
                    s.cache = false;
                }
                if (s.crossDomain) {
                    s.type = "GET";
                    s.global = false;
                }
            });

            // Bind script tag hack transport
            jQuery.ajaxTransport("script", function(s) {

                // This transport only deals with cross domain requests
                if (s.crossDomain) {

                    var script,
                        head = document.head || jQuery("head")[0] || document.documentElement;

                    return {

                        send: function(_, callback) {

                            script = document.createElement("script");

                            script.async = true;

                            if (s.scriptCharset) {
                                script.charset = s.scriptCharset;
                            }

                            script.src = s.url;

                            // Attach handlers for all browsers
                            script.onload = script.onreadystatechange = function(_, isAbort) {

                                if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

                                    // Handle memory leak in IE
                                    script.onload = script.onreadystatechange = null;

                                    // Remove the script
                                    if (script.parentNode) {
                                        script.parentNode.removeChild(script);
                                    }

                                    // Dereference the script
                                    script = null;

                                    // Callback if not abort
                                    if (!isAbort) {
                                        callback(200, "success");
                                    }
                                }
                            };

                            // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                            // Use native DOM manipulation to avoid our domManip AJAX trickery
                            head.insertBefore(script, head.firstChild);
                        },

                        abort: function() {
                            if (script) {
                                script.onload(undefined, true);
                            }
                        }
                    };
                }
            });




            var oldCallbacks = [],
                rjsonp = /(=)\?(?=&|$)|\?\?/;

            // Default jsonp settings
            jQuery.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
                    this[callback] = true;
                    return callback;
                }
            });

            // Detect, normalize options and install callbacks for jsonp requests
            jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

                var callbackName, overwritten, responseContainer,
                    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                        "url" :
                        typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"
                    );

                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if (jsonProp || s.dataTypes[0] === "jsonp") {

                    // Get callback name, remembering preexisting value associated with it
                    callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                        s.jsonpCallback() :
                        s.jsonpCallback;

                    // Insert callback into url or form data
                    if (jsonProp) {
                        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                    } else if (s.jsonp !== false) {
                        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                    }

                    // Use data converter to retrieve json after script execution
                    s.converters["script json"] = function() {
                        if (!responseContainer) {
                            jQuery.error(callbackName + " was not called");
                        }
                        return responseContainer[0];
                    };

                    // force json dataType
                    s.dataTypes[0] = "json";

                    // Install callback
                    overwritten = window[callbackName];
                    window[callbackName] = function() {
                        responseContainer = arguments;
                    };

                    // Clean-up function (fires after converters)
                    jqXHR.always(function() {
                        // Restore preexisting value
                        window[callbackName] = overwritten;

                        // Save back as free
                        if (s[callbackName]) {
                            // make sure that re-using the options doesn't screw things around
                            s.jsonpCallback = originalSettings.jsonpCallback;

                            // save the callback name for future use
                            oldCallbacks.push(callbackName);
                        }

                        // Call if it was a function and we have a response
                        if (responseContainer && jQuery.isFunction(overwritten)) {
                            overwritten(responseContainer[0]);
                        }

                        responseContainer = overwritten = undefined;
                    });

                    // Delegate to script
                    return "script";
                }
            });




            // data: string of html
            // context (optional): If specified, the fragment will be created in this context, defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            jQuery.parseHTML = function(data, context, keepScripts) {
                if (!data || typeof data !== "string") {
                    return null;
                }
                if (typeof context === "boolean") {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;

                var parsed = rsingleTag.exec(data),
                    scripts = !keepScripts && [];

                // Single tag
                if (parsed) {
                    return [context.createElement(parsed[1])];
                }

                parsed = jQuery.buildFragment([data], context, scripts);

                if (scripts && scripts.length) {
                    jQuery(scripts).remove();
                }

                return jQuery.merge([], parsed.childNodes);
            };


            // Keep a copy of the old load method
            var _load = jQuery.fn.load;

            /**
             * Load a url into a page
             */
            jQuery.fn.load = function(url, params, callback) {
                if (typeof url !== "string" && _load) {
                    return _load.apply(this, arguments);
                }

                var selector, response, type,
                    self = this,
                    off = url.indexOf(" ");

                if (off >= 0) {
                    selector = jQuery.trim(url.slice(off, url.length));
                    url = url.slice(0, off);
                }

                // If it's a function
                if (jQuery.isFunction(params)) {

                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if (params && typeof params === "object") {
                    type = "POST";
                }

                // If we have elements to modify, make the request
                if (self.length > 0) {
                    jQuery.ajax({
                        url: url,

                        // if "type" variable is undefined, then "GET" method will be used
                        type: type,
                        dataType: "html",
                        data: params
                    }).done(function(responseText) {

                        // Save response for use in complete callback
                        response = arguments;

                        self.html(selector ?

                            // If a selector was specified, locate the right elements in a dummy div
                            // Exclude scripts to avoid IE 'Permission Denied' errors
                            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                            // Otherwise use the full result
                            responseText);

                    }).complete(callback && function(jqXHR, status) {
                        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
                    });
                }

                return this;
            };




            jQuery.expr.filters.animated = function(elem) {
                return jQuery.grep(jQuery.timers, function(fn) {
                    return elem === fn.elem;
                }).length;
            };




            var docElem = window.document.documentElement;

            /**
             * Gets a window from an element
             */
            function getWindow(elem) {
                return jQuery.isWindow(elem) ?
                    elem :
                    elem.nodeType === 9 ?
                    elem.defaultView || elem.parentWindow :
                    false;
            }

            jQuery.offset = {
                setOffset: function(elem, options, i) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                        position = jQuery.css(elem, "position"),
                        curElem = jQuery(elem),
                        props = {};

                    // set position first, in-case top/left are set even on static elem
                    if (position === "static") {
                        elem.style.position = "relative";
                    }

                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css(elem, "top");
                    curCSSLeft = jQuery.css(elem, "left");
                    calculatePosition = (position === "absolute" || position === "fixed") &&
                        jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1;

                    // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
                    if (calculatePosition) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;
                    } else {
                        curTop = parseFloat(curCSSTop) || 0;
                        curLeft = parseFloat(curCSSLeft) || 0;
                    }

                    if (jQuery.isFunction(options)) {
                        options = options.call(elem, i, curOffset);
                    }

                    if (options.top != null) {
                        props.top = (options.top - curOffset.top) + curTop;
                    }
                    if (options.left != null) {
                        props.left = (options.left - curOffset.left) + curLeft;
                    }

                    if ("using" in options) {
                        options.using.call(elem, props);
                    } else {
                        curElem.css(props);
                    }
                }
            };

            jQuery.fn.extend({
                offset: function(options) {
                    if (arguments.length) {
                        return options === undefined ?
                            this :
                            this.each(function(i) {
                                jQuery.offset.setOffset(this, options, i);
                            });
                    }

                    var docElem, win,
                        box = {
                            top: 0,
                            left: 0
                        },
                        elem = this[0],
                        doc = elem && elem.ownerDocument;

                    if (!doc) {
                        return;
                    }

                    docElem = doc.documentElement;

                    // Make sure it's not a disconnected DOM node
                    if (!jQuery.contains(docElem, elem)) {
                        return box;
                    }

                    // If we don't have gBCR, just use 0,0 rather than error
                    // BlackBerry 5, iOS 3 (original iPhone)
                    if (typeof elem.getBoundingClientRect !== strundefined) {
                        box = elem.getBoundingClientRect();
                    }
                    win = getWindow(doc);
                    return {
                        top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
                    };
                },

                position: function() {
                    if (!this[0]) {
                        return;
                    }

                    var offsetParent, offset,
                        parentOffset = {
                            top: 0,
                            left: 0
                        },
                        elem = this[0];

                    // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
                    if (jQuery.css(elem, "position") === "fixed") {
                        // we assume that getBoundingClientRect is available when computed position is fixed
                        offset = elem.getBoundingClientRect();
                    } else {
                        // Get *real* offsetParent
                        offsetParent = this.offsetParent();

                        // Get correct offsets
                        offset = this.offset();
                        if (!jQuery.nodeName(offsetParent[0], "html")) {
                            parentOffset = offsetParent.offset();
                        }

                        // Add offsetParent borders
                        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
                    }

                    // Subtract parent offsets and element margins
                    // note: when an element has margin: auto the offsetLeft and marginLeft
                    // are the same in Safari causing offset.left to incorrectly be 0
                    return {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
                    };
                },

                offsetParent: function() {
                    return this.map(function() {
                        var offsetParent = this.offsetParent || docElem;

                        while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                            offsetParent = offsetParent.offsetParent;
                        }
                        return offsetParent || docElem;
                    });
                }
            });

            // Create scrollLeft and scrollTop methods
            jQuery.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(method, prop) {
                var top = /Y/.test(prop);

                jQuery.fn[method] = function(val) {
                    return access(this, function(elem, method, val) {
                        var win = getWindow(elem);

                        if (val === undefined) {
                            return win ? (prop in win) ? win[prop] :
                                win.document.documentElement[method] :
                                elem[method];
                        }

                        if (win) {
                            win.scrollTo(!top ? val : jQuery(win).scrollLeft(),
                                top ? val : jQuery(win).scrollTop()
                            );

                        } else {
                            elem[method] = val;
                        }
                    }, method, val, arguments.length, null);
                };
            });

            // Add the top/left cssHooks using jQuery.fn.position
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // getComputedStyle returns percent when specified for top/left/bottom/right
            // rather than make the css module depend on the offset module, we just check for it here
            jQuery.each(["top", "left"], function(i, prop) {
                jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
                    function(elem, computed) {
                        if (computed) {
                            computed = curCSS(elem, prop);
                            // if curCSS returns percentage, fallback to offset
                            return rnumnonpx.test(computed) ?
                                jQuery(elem).position()[prop] + "px" :
                                computed;
                        }
                    }
                );
            });


            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            jQuery.each({
                Height: "height",
                Width: "width"
            }, function(name, type) {
                jQuery.each({
                    padding: "inner" + name,
                    content: type,
                    "": "outer" + name
                }, function(defaultExtra, funcName) {
                    // margin is only for outerHeight, outerWidth
                    jQuery.fn[funcName] = function(margin, value) {
                        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                        return access(this, function(elem, type, value) {
                            var doc;

                            if (jQuery.isWindow(elem)) {
                                // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                // isn't a whole lot we can do. See pull request at this URL for discussion:
                                // https://github.com/jquery/jquery/pull/764
                                return elem.document.documentElement["client" + name];
                            }

                            // Get document width or height
                            if (elem.nodeType === 9) {
                                doc = elem.documentElement;

                                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                                // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                                return Math.max(
                                    elem.body["scroll" + name], doc["scroll" + name],
                                    elem.body["offset" + name], doc["offset" + name],
                                    doc["client" + name]
                                );
                            }

                            return value === undefined ?
                                // Get width or height on the element, requesting but not forcing parseFloat
                                jQuery.css(elem, type, extra) :

                                // Set width or height on the element
                                jQuery.style(elem, type, value, extra);
                        }, type, chainable ? margin : undefined, chainable, null);
                    };
                });
            });


            // The number of elements contained in the matched element set
            jQuery.fn.size = function() {
                return this.length;
            };

            jQuery.fn.andSelf = jQuery.fn.addBack;




            // Register as a named AMD module, since jQuery can be concatenated with other
            // files that may use define, but not via a proper concatenation script that
            // understands anonymous AMD modules. A named AMD is safest and most robust
            // way to register. Lowercase jquery is used because AMD module names are
            // derived from file names, and jQuery is normally delivered in a lowercase
            // file name. Do this after creating the global so that if an AMD module wants
            // to call noConflict to hide this version of jQuery, it will work.

            // Note that for maximum portability, libraries that are not jQuery should
            // declare themselves as anonymous modules, and avoid setting a global if an
            // AMD loader is present. jQuery is a special case. For more information, see
            // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return jQuery;
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }




            var
                // Map over jQuery in case of overwrite
                _jQuery = window.jQuery,

                // Map over the $ in case of overwrite
                _$ = window.$;

            jQuery.noConflict = function(deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            };

            // Expose jQuery and $ identifiers, even in
            // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
            // and CommonJS for browser emulators (#13566)
            if (typeof noGlobal === strundefined) {
                window.jQuery = window.$ = jQuery;
            }




            return jQuery;

        }));


        /***/
    }),
    /* 3 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*
         Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
         (c) 2010-2013, Vladimir Agafonkin
         (c) 2010-2011, CloudMade
        */
        (function(window, document, undefined) {
            var oldL = window.L,
                L = {};

            L.version = '0.7.7';

            // define Leaflet for Node module pattern loaders, including Browserify
            if (typeof module === 'object' && typeof module.exports === 'object') {
                module.exports = L;

                // define Leaflet as an AMD module
            } else if (true) {
                !(__WEBPACK_AMD_DEFINE_FACTORY__ = (L),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
                        __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }

            // define Leaflet as a global L variable, saving the original L to restore later if needed

            L.noConflict = function() {
                window.L = oldL;
                return this;
            };

            window.L = L;


            /*
             * L.Util contains various utility functions used throughout Leaflet code.
             */

            L.Util = {
                extend: function(dest) { // (Object[, Object, ...]) ->
                    var sources = Array.prototype.slice.call(arguments, 1),
                        i, j, len, src;

                    for (j = 0, len = sources.length; j < len; j++) {
                        src = sources[j] || {};
                        for (i in src) {
                            if (src.hasOwnProperty(i)) {
                                dest[i] = src[i];
                            }
                        }
                    }
                    return dest;
                },

                bind: function(fn, obj) { // (Function, Object) -> Function
                    var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
                    return function() {
                        return fn.apply(obj, args || arguments);
                    };
                },

                stamp: (function() {
                    var lastId = 0,
                        key = '_leaflet_id';
                    return function(obj) {
                        obj[key] = obj[key] || ++lastId;
                        return obj[key];
                    };
                }()),

                invokeEach: function(obj, method, context) {
                    var i, args;

                    if (typeof obj === 'object') {
                        args = Array.prototype.slice.call(arguments, 3);

                        for (i in obj) {
                            method.apply(context, [i, obj[i]].concat(args));
                        }
                        return true;
                    }

                    return false;
                },

                limitExecByInterval: function(fn, time, context) {
                    var lock, execOnUnlock;

                    return function wrapperFn() {
                        var args = arguments;

                        if (lock) {
                            execOnUnlock = true;
                            return;
                        }

                        lock = true;

                        setTimeout(function() {
                            lock = false;

                            if (execOnUnlock) {
                                wrapperFn.apply(context, args);
                                execOnUnlock = false;
                            }
                        }, time);

                        fn.apply(context, args);
                    };
                },

                falseFn: function() {
                    return false;
                },

                formatNum: function(num, digits) {
                    var pow = Math.pow(10, digits || 5);
                    return Math.round(num * pow) / pow;
                },

                trim: function(str) {
                    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
                },

                splitWords: function(str) {
                    return L.Util.trim(str).split(/\s+/);
                },

                setOptions: function(obj, options) {
                    obj.options = L.extend({}, obj.options, options);
                    return obj.options;
                },

                getParamString: function(obj, existingUrl, uppercase) {
                    var params = [];
                    for (var i in obj) {
                        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
                    }
                    return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
                },
                template: function(str, data) {
                    return str.replace(/\{ *([\w_]+) *\}/g, function(str, key) {
                        var value = data[key];
                        if (value === undefined) {
                            throw new Error('No value provided for variable ' + str);
                        } else if (typeof value === 'function') {
                            value = value(data);
                        }
                        return value;
                    });
                },

                isArray: Array.isArray || function(obj) {
                    return (Object.prototype.toString.call(obj) === '[object Array]');
                },

                emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
            };

            (function() {

                // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

                function getPrefixed(name) {
                    var i, fn,
                        prefixes = ['webkit', 'moz', 'o', 'ms'];

                    for (i = 0; i < prefixes.length && !fn; i++) {
                        fn = window[prefixes[i] + name];
                    }

                    return fn;
                }

                var lastTime = 0;

                function timeoutDefer(fn) {
                    var time = +new Date(),
                        timeToCall = Math.max(0, 16 - (time - lastTime));

                    lastTime = time + timeToCall;
                    return window.setTimeout(fn, timeToCall);
                }

                var requestFn = window.requestAnimationFrame ||
                    getPrefixed('RequestAnimationFrame') || timeoutDefer;

                var cancelFn = window.cancelAnimationFrame ||
                    getPrefixed('CancelAnimationFrame') ||
                    getPrefixed('CancelRequestAnimationFrame') ||
                    function(id) {
                        window.clearTimeout(id);
                    };


                L.Util.requestAnimFrame = function(fn, context, immediate, element) {
                    fn = L.bind(fn, context);

                    if (immediate && requestFn === timeoutDefer) {
                        fn();
                    } else {
                        return requestFn.call(window, fn, element);
                    }
                };

                L.Util.cancelAnimFrame = function(id) {
                    if (id) {
                        cancelFn.call(window, id);
                    }
                };

            }());

            // shortcuts for most used utility functions
            L.extend = L.Util.extend;
            L.bind = L.Util.bind;
            L.stamp = L.Util.stamp;
            L.setOptions = L.Util.setOptions;


            /*
             * L.Class powers the OOP facilities of the library.
             * Thanks to John Resig and Dean Edwards for inspiration!
             */

            L.Class = function() {};

            L.Class.extend = function(props) {

                // extended class with the new prototype
                var NewClass = function() {

                    // call the constructor
                    if (this.initialize) {
                        this.initialize.apply(this, arguments);
                    }

                    // call all constructor hooks
                    if (this._initHooks) {
                        this.callInitHooks();
                    }
                };

                // instantiate class without calling constructor
                var F = function() {};
                F.prototype = this.prototype;

                var proto = new F();
                proto.constructor = NewClass;

                NewClass.prototype = proto;

                //inherit parent's statics
                for (var i in this) {
                    if (this.hasOwnProperty(i) && i !== 'prototype') {
                        NewClass[i] = this[i];
                    }
                }

                // mix static properties into the class
                if (props.statics) {
                    L.extend(NewClass, props.statics);
                    delete props.statics;
                }

                // mix includes into the prototype
                if (props.includes) {
                    L.Util.extend.apply(null, [proto].concat(props.includes));
                    delete props.includes;
                }

                // merge options
                if (props.options && proto.options) {
                    props.options = L.extend({}, proto.options, props.options);
                }

                // mix given properties into the prototype
                L.extend(proto, props);

                proto._initHooks = [];

                var parent = this;
                // jshint camelcase: false
                NewClass.__super__ = parent.prototype;

                // add method for calling all hooks
                proto.callInitHooks = function() {

                    if (this._initHooksCalled) {
                        return;
                    }

                    if (parent.prototype.callInitHooks) {
                        parent.prototype.callInitHooks.call(this);
                    }

                    this._initHooksCalled = true;

                    for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                        proto._initHooks[i].call(this);
                    }
                };

                return NewClass;
            };


            // method for adding properties to prototype
            L.Class.include = function(props) {
                L.extend(this.prototype, props);
            };

            // merge new default options to the Class
            L.Class.mergeOptions = function(options) {
                L.extend(this.prototype.options, options);
            };

            // add a constructor hook
            L.Class.addInitHook = function(fn) { // (Function) || (String, args...)
                var args = Array.prototype.slice.call(arguments, 1);

                var init = typeof fn === 'function' ? fn : function() {
                    this[fn].apply(this, args);
                };

                this.prototype._initHooks = this.prototype._initHooks || [];
                this.prototype._initHooks.push(init);
            };


            /*
             * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
             */

            var eventsKey = '_leaflet_events';

            L.Mixin = {};

            L.Mixin.Events = {

                addEventListener: function(types, fn, context) { // (String, Function[, Object]) or (Object[, Object])

                    // types can be a map of types/handlers
                    if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) {
                        return this;
                    }

                    var events = this[eventsKey] = this[eventsKey] || {},
                        contextId = context && context !== this && L.stamp(context),
                        i, len, event, type, indexKey, indexLenKey, typeIndex;

                    // types can be a string of space-separated words
                    types = L.Util.splitWords(types);

                    for (i = 0, len = types.length; i < len; i++) {
                        event = {
                            action: fn,
                            context: context || this
                        };
                        type = types[i];

                        if (contextId) {
                            // store listeners of a particular context in a separate hash (if it has an id)
                            // gives a major performance boost when removing thousands of map layers

                            indexKey = type + '_idx';
                            indexLenKey = indexKey + '_len';

                            typeIndex = events[indexKey] = events[indexKey] || {};

                            if (!typeIndex[contextId]) {
                                typeIndex[contextId] = [];

                                // keep track of the number of keys in the index to quickly check if it's empty
                                events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                            }

                            typeIndex[contextId].push(event);


                        } else {
                            events[type] = events[type] || [];
                            events[type].push(event);
                        }
                    }

                    return this;
                },

                hasEventListeners: function(type) { // (String) -> Boolean
                    var events = this[eventsKey];
                    return !!events && ((type in events && events[type].length > 0) ||
                        (type + '_idx' in events && events[type + '_idx_len'] > 0));
                },

                removeEventListener: function(types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

                    if (!this[eventsKey]) {
                        return this;
                    }

                    if (!types) {
                        return this.clearAllEventListeners();
                    }

                    if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) {
                        return this;
                    }

                    var events = this[eventsKey],
                        contextId = context && context !== this && L.stamp(context),
                        i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

                    types = L.Util.splitWords(types);

                    for (i = 0, len = types.length; i < len; i++) {
                        type = types[i];
                        indexKey = type + '_idx';
                        indexLenKey = indexKey + '_len';

                        typeIndex = events[indexKey];

                        if (!fn) {
                            // clear all listeners for a type if function isn't specified
                            delete events[type];
                            delete events[indexKey];
                            delete events[indexLenKey];

                        } else {
                            listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

                            if (listeners) {
                                for (j = listeners.length - 1; j >= 0; j--) {
                                    if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
                                        removed = listeners.splice(j, 1);
                                        // set the old action to a no-op, because it is possible
                                        // that the listener is being iterated over as part of a dispatch
                                        removed[0].action = L.Util.falseFn;
                                    }
                                }

                                if (context && typeIndex && (listeners.length === 0)) {
                                    delete typeIndex[contextId];
                                    events[indexLenKey]--;
                                }
                            }
                        }
                    }

                    return this;
                },

                clearAllEventListeners: function() {
                    delete this[eventsKey];
                    return this;
                },

                fireEvent: function(type, data) { // (String[, Object])
                    if (!this.hasEventListeners(type)) {
                        return this;
                    }

                    var event = L.Util.extend({}, data, {
                        type: type,
                        target: this
                    });

                    var events = this[eventsKey],
                        listeners, i, len, typeIndex, contextId;

                    if (events[type]) {
                        // make sure adding/removing listeners inside other listeners won't cause infinite loop
                        listeners = events[type].slice();

                        for (i = 0, len = listeners.length; i < len; i++) {
                            listeners[i].action.call(listeners[i].context, event);
                        }
                    }

                    // fire event for the context-indexed listeners as well
                    typeIndex = events[type + '_idx'];

                    for (contextId in typeIndex) {
                        listeners = typeIndex[contextId].slice();

                        if (listeners) {
                            for (i = 0, len = listeners.length; i < len; i++) {
                                listeners[i].action.call(listeners[i].context, event);
                            }
                        }
                    }

                    return this;
                },

                addOneTimeEventListener: function(types, fn, context) {

                    if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) {
                        return this;
                    }

                    var handler = L.bind(function() {
                        this
                            .removeEventListener(types, fn, context)
                            .removeEventListener(types, handler, context);
                    }, this);

                    return this
                        .addEventListener(types, fn, context)
                        .addEventListener(types, handler, context);
                }
            };

            L.Mixin.Events.on = L.Mixin.Events.addEventListener;
            L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
            L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
            L.Mixin.Events.fire = L.Mixin.Events.fireEvent;


            /*
             * L.Browser handles different browser and feature detections for internal Leaflet use.
             */

            (function() {

                var ie = 'ActiveXObject' in window,
                    ielt9 = ie && !document.addEventListener,

                    // terrible browser detection to work around Safari / iOS / Android browser bugs
                    ua = navigator.userAgent.toLowerCase(),
                    webkit = ua.indexOf('webkit') !== -1,
                    chrome = ua.indexOf('chrome') !== -1,
                    phantomjs = ua.indexOf('phantom') !== -1,
                    android = ua.indexOf('android') !== -1,
                    android23 = ua.search('android [23]') !== -1,
                    gecko = ua.indexOf('gecko') !== -1,

                    mobile = typeof orientation !== undefined + '',
                    msPointer = !window.PointerEvent && window.MSPointerEvent,
                    pointer = (window.PointerEvent && window.navigator.pointerEnabled) ||
                    msPointer,
                    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
                    ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
                        window.matchMedia('(min-resolution:144dpi)').matches),

                    doc = document.documentElement,
                    ie3d = ie && ('transition' in doc.style),
                    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
                    gecko3d = 'MozPerspective' in doc.style,
                    opera3d = 'OTransition' in doc.style,
                    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;

                var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||
                    (window.DocumentTouch && document instanceof window.DocumentTouch));

                L.Browser = {
                    ie: ie,
                    ielt9: ielt9,
                    webkit: webkit,
                    gecko: gecko && !webkit && !window.opera && !ie,

                    android: android,
                    android23: android23,

                    chrome: chrome,

                    ie3d: ie3d,
                    webkit3d: webkit3d,
                    gecko3d: gecko3d,
                    opera3d: opera3d,
                    any3d: any3d,

                    mobile: mobile,
                    mobileWebkit: mobile && webkit,
                    mobileWebkit3d: mobile && webkit3d,
                    mobileOpera: mobile && window.opera,

                    touch: touch,
                    msPointer: msPointer,
                    pointer: pointer,

                    retina: retina
                };

            }());


            /*
             * L.Point represents a point with x and y coordinates.
             */

            L.Point = function( /*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
                this.x = (round ? Math.round(x) : x);
                this.y = (round ? Math.round(y) : y);
            };

            L.Point.prototype = {

                clone: function() {
                    return new L.Point(this.x, this.y);
                },

                // non-destructive, returns a new point
                add: function(point) {
                    return this.clone()._add(L.point(point));
                },

                // destructive, used directly for performance in situations where it's safe to modify existing point
                _add: function(point) {
                    this.x += point.x;
                    this.y += point.y;
                    return this;
                },

                subtract: function(point) {
                    return this.clone()._subtract(L.point(point));
                },

                _subtract: function(point) {
                    this.x -= point.x;
                    this.y -= point.y;
                    return this;
                },

                divideBy: function(num) {
                    return this.clone()._divideBy(num);
                },

                _divideBy: function(num) {
                    this.x /= num;
                    this.y /= num;
                    return this;
                },

                multiplyBy: function(num) {
                    return this.clone()._multiplyBy(num);
                },

                _multiplyBy: function(num) {
                    this.x *= num;
                    this.y *= num;
                    return this;
                },

                round: function() {
                    return this.clone()._round();
                },

                _round: function() {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    return this;
                },

                floor: function() {
                    return this.clone()._floor();
                },

                _floor: function() {
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    return this;
                },

                distanceTo: function(point) {
                    point = L.point(point);

                    var x = point.x - this.x,
                        y = point.y - this.y;

                    return Math.sqrt(x * x + y * y);
                },

                equals: function(point) {
                    point = L.point(point);

                    return point.x === this.x &&
                        point.y === this.y;
                },

                contains: function(point) {
                    point = L.point(point);

                    return Math.abs(point.x) <= Math.abs(this.x) &&
                        Math.abs(point.y) <= Math.abs(this.y);
                },

                toString: function() {
                    return 'Point(' +
                        L.Util.formatNum(this.x) + ', ' +
                        L.Util.formatNum(this.y) + ')';
                }
            };

            L.point = function(x, y, round) {
                if (x instanceof L.Point) {
                    return x;
                }
                if (L.Util.isArray(x)) {
                    return new L.Point(x[0], x[1]);
                }
                if (x === undefined || x === null) {
                    return x;
                }
                return new L.Point(x, y, round);
            };


            /*
             * L.Bounds represents a rectangular area on the screen in pixel coordinates.
             */

            L.Bounds = function(a, b) { //(Point, Point) or Point[]
                if (!a) {
                    return;
                }

                var points = b ? [a, b] : a;

                for (var i = 0, len = points.length; i < len; i++) {
                    this.extend(points[i]);
                }
            };

            L.Bounds.prototype = {
                // extend the bounds to contain the given point
                extend: function(point) { // (Point)
                    point = L.point(point);

                    if (!this.min && !this.max) {
                        this.min = point.clone();
                        this.max = point.clone();
                    } else {
                        this.min.x = Math.min(point.x, this.min.x);
                        this.max.x = Math.max(point.x, this.max.x);
                        this.min.y = Math.min(point.y, this.min.y);
                        this.max.y = Math.max(point.y, this.max.y);
                    }
                    return this;
                },

                getCenter: function(round) { // (Boolean) -> Point
                    return new L.Point(
                        (this.min.x + this.max.x) / 2,
                        (this.min.y + this.max.y) / 2, round);
                },

                getBottomLeft: function() { // -> Point
                    return new L.Point(this.min.x, this.max.y);
                },

                getTopRight: function() { // -> Point
                    return new L.Point(this.max.x, this.min.y);
                },

                getSize: function() {
                    return this.max.subtract(this.min);
                },

                contains: function(obj) { // (Bounds) or (Point) -> Boolean
                    var min, max;

                    if (typeof obj[0] === 'number' || obj instanceof L.Point) {
                        obj = L.point(obj);
                    } else {
                        obj = L.bounds(obj);
                    }

                    if (obj instanceof L.Bounds) {
                        min = obj.min;
                        max = obj.max;
                    } else {
                        min = max = obj;
                    }

                    return (min.x >= this.min.x) &&
                        (max.x <= this.max.x) &&
                        (min.y >= this.min.y) &&
                        (max.y <= this.max.y);
                },

                intersects: function(bounds) { // (Bounds) -> Boolean
                    bounds = L.bounds(bounds);

                    var min = this.min,
                        max = this.max,
                        min2 = bounds.min,
                        max2 = bounds.max,
                        xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
                        yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

                    return xIntersects && yIntersects;
                },

                isValid: function() {
                    return !!(this.min && this.max);
                }
            };

            L.bounds = function(a, b) { // (Bounds) or (Point, Point) or (Point[])
                if (!a || a instanceof L.Bounds) {
                    return a;
                }
                return new L.Bounds(a, b);
            };


            /*
             * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
             */

            L.Transformation = function(a, b, c, d) {
                this._a = a;
                this._b = b;
                this._c = c;
                this._d = d;
            };

            L.Transformation.prototype = {
                transform: function(point, scale) { // (Point, Number) -> Point
                    return this._transform(point.clone(), scale);
                },

                // destructive transform (faster)
                _transform: function(point, scale) {
                    scale = scale || 1;
                    point.x = scale * (this._a * point.x + this._b);
                    point.y = scale * (this._c * point.y + this._d);
                    return point;
                },

                untransform: function(point, scale) {
                    scale = scale || 1;
                    return new L.Point(
                        (point.x / scale - this._b) / this._a,
                        (point.y / scale - this._d) / this._c);
                }
            };


            /*
             * L.DomUtil contains various utility functions for working with DOM.
             */

            L.DomUtil = {
                get: function(id) {
                    return (typeof id === 'string' ? document.getElementById(id) : id);
                },

                getStyle: function(el, style) {

                    var value = el.style[style];

                    if (!value && el.currentStyle) {
                        value = el.currentStyle[style];
                    }

                    if ((!value || value === 'auto') && document.defaultView) {
                        var css = document.defaultView.getComputedStyle(el, null);
                        value = css ? css[style] : null;
                    }

                    return value === 'auto' ? null : value;
                },

                getViewportOffset: function(element) {

                    var top = 0,
                        left = 0,
                        el = element,
                        docBody = document.body,
                        docEl = document.documentElement,
                        pos;

                    do {
                        top += el.offsetTop || 0;
                        left += el.offsetLeft || 0;

                        //add borders
                        top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
                        left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

                        pos = L.DomUtil.getStyle(el, 'position');

                        if (el.offsetParent === docBody && pos === 'absolute') {
                            break;
                        }

                        if (pos === 'fixed') {
                            top += docBody.scrollTop || docEl.scrollTop || 0;
                            left += docBody.scrollLeft || docEl.scrollLeft || 0;
                            break;
                        }

                        if (pos === 'relative' && !el.offsetLeft) {
                            var width = L.DomUtil.getStyle(el, 'width'),
                                maxWidth = L.DomUtil.getStyle(el, 'max-width'),
                                r = el.getBoundingClientRect();

                            if (width !== 'none' || maxWidth !== 'none') {
                                left += r.left + el.clientLeft;
                            }

                            //calculate full y offset since we're breaking out of the loop
                            top += r.top + (docBody.scrollTop || docEl.scrollTop || 0);

                            break;
                        }

                        el = el.offsetParent;

                    } while (el);

                    el = element;

                    do {
                        if (el === docBody) {
                            break;
                        }

                        top -= el.scrollTop || 0;
                        left -= el.scrollLeft || 0;

                        el = el.parentNode;
                    } while (el);

                    return new L.Point(left, top);
                },

                documentIsLtr: function() {
                    if (!L.DomUtil._docIsLtrCached) {
                        L.DomUtil._docIsLtrCached = true;
                        L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
                    }
                    return L.DomUtil._docIsLtr;
                },

                create: function(tagName, className, container) {

                    var el = document.createElement(tagName);
                    el.className = className;

                    if (container) {
                        container.appendChild(el);
                    }

                    return el;
                },

                hasClass: function(el, name) {
                    if (el.classList !== undefined) {
                        return el.classList.contains(name);
                    }
                    var className = L.DomUtil._getClass(el);
                    return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
                },

                addClass: function(el, name) {
                    if (el.classList !== undefined) {
                        var classes = L.Util.splitWords(name);
                        for (var i = 0, len = classes.length; i < len; i++) {
                            el.classList.add(classes[i]);
                        }
                    } else if (!L.DomUtil.hasClass(el, name)) {
                        var className = L.DomUtil._getClass(el);
                        L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
                    }
                },

                removeClass: function(el, name) {
                    if (el.classList !== undefined) {
                        el.classList.remove(name);
                    } else {
                        L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
                    }
                },

                _setClass: function(el, name) {
                    if (el.className.baseVal === undefined) {
                        el.className = name;
                    } else {
                        // in case of SVG element
                        el.className.baseVal = name;
                    }
                },

                _getClass: function(el) {
                    return el.className.baseVal === undefined ? el.className : el.className.baseVal;
                },

                setOpacity: function(el, value) {

                    if ('opacity' in el.style) {
                        el.style.opacity = value;

                    } else if ('filter' in el.style) {

                        var filter = false,
                            filterName = 'DXImageTransform.Microsoft.Alpha';

                        // filters collection throws an error if we try to retrieve a filter that doesn't exist
                        try {
                            filter = el.filters.item(filterName);
                        } catch (e) {
                            // don't set opacity to 1 if we haven't already set an opacity,
                            // it isn't needed and breaks transparent pngs.
                            if (value === 1) {
                                return;
                            }
                        }

                        value = Math.round(value * 100);

                        if (filter) {
                            filter.Enabled = (value !== 100);
                            filter.Opacity = value;
                        } else {
                            el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
                        }
                    }
                },

                testProp: function(props) {

                    var style = document.documentElement.style;

                    for (var i = 0; i < props.length; i++) {
                        if (props[i] in style) {
                            return props[i];
                        }
                    }
                    return false;
                },

                getTranslateString: function(point) {
                    // on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
                    // makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
                    // (same speed either way), Opera 12 doesn't support translate3d

                    var is3d = L.Browser.webkit3d,
                        open = 'translate' + (is3d ? '3d' : '') + '(',
                        close = (is3d ? ',0' : '') + ')';

                    return open + point.x + 'px,' + point.y + 'px' + close;
                },

                getScaleString: function(scale, origin) {

                    var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
                        scaleStr = ' scale(' + scale + ') ';

                    return preTranslateStr + scaleStr;
                },

                setPosition: function(el, point, disable3D) { // (HTMLElement, Point[, Boolean])

                    // jshint camelcase: false
                    el._leaflet_pos = point;

                    if (!disable3D && L.Browser.any3d) {
                        el.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(point);
                    } else {
                        el.style.left = point.x + 'px';
                        el.style.top = point.y + 'px';
                    }
                },

                getPosition: function(el) {
                    // this method is only used for elements previously positioned using setPosition,
                    // so it's safe to cache the position for performance

                    // jshint camelcase: false
                    return el._leaflet_pos;
                }
            };


            // prefix style property names

            L.DomUtil.TRANSFORM = L.DomUtil.testProp(
                ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

            // webkitTransition comes first because some browser versions that drop vendor prefix don't do
            // the same for the transitionend event, in particular the Android 4.1 stock browser

            L.DomUtil.TRANSITION = L.DomUtil.testProp(
                ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

            L.DomUtil.TRANSITION_END =
                L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?
                L.DomUtil.TRANSITION + 'End' : 'transitionend';

            (function() {
                if ('onselectstart' in document) {
                    L.extend(L.DomUtil, {
                        disableTextSelection: function() {
                            L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
                        },

                        enableTextSelection: function() {
                            L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
                        }
                    });
                } else {
                    var userSelectProperty = L.DomUtil.testProp(
                        ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

                    L.extend(L.DomUtil, {
                        disableTextSelection: function() {
                            if (userSelectProperty) {
                                var style = document.documentElement.style;
                                this._userSelect = style[userSelectProperty];
                                style[userSelectProperty] = 'none';
                            }
                        },

                        enableTextSelection: function() {
                            if (userSelectProperty) {
                                document.documentElement.style[userSelectProperty] = this._userSelect;
                                delete this._userSelect;
                            }
                        }
                    });
                }

                L.extend(L.DomUtil, {
                    disableImageDrag: function() {
                        L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
                    },

                    enableImageDrag: function() {
                        L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
                    }
                });
            })();


            /*
             * L.LatLng represents a geographical point with latitude and longitude coordinates.
             */

            L.LatLng = function(lat, lng, alt) { // (Number, Number, Number)
                lat = parseFloat(lat);
                lng = parseFloat(lng);

                if (isNaN(lat) || isNaN(lng)) {
                    throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
                }

                this.lat = lat;
                this.lng = lng;

                if (alt !== undefined) {
                    this.alt = parseFloat(alt);
                }
            };

            L.extend(L.LatLng, {
                DEG_TO_RAD: Math.PI / 180,
                RAD_TO_DEG: 180 / Math.PI,
                MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
            });

            L.LatLng.prototype = {
                equals: function(obj) { // (LatLng) -> Boolean
                    if (!obj) {
                        return false;
                    }

                    obj = L.latLng(obj);

                    var margin = Math.max(
                        Math.abs(this.lat - obj.lat),
                        Math.abs(this.lng - obj.lng));

                    return margin <= L.LatLng.MAX_MARGIN;
                },

                toString: function(precision) { // (Number) -> String
                    return 'LatLng(' +
                        L.Util.formatNum(this.lat, precision) + ', ' +
                        L.Util.formatNum(this.lng, precision) + ')';
                },

                // Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
                // TODO move to projection code, LatLng shouldn't know about Earth
                distanceTo: function(other) { // (LatLng) -> Number
                    other = L.latLng(other);

                    var R = 6378137, // earth radius in meters
                        d2r = L.LatLng.DEG_TO_RAD,
                        dLat = (other.lat - this.lat) * d2r,
                        dLon = (other.lng - this.lng) * d2r,
                        lat1 = this.lat * d2r,
                        lat2 = other.lat * d2r,
                        sin1 = Math.sin(dLat / 2),
                        sin2 = Math.sin(dLon / 2);

                    var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

                    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                },

                wrap: function(a, b) { // (Number, Number) -> LatLng
                    var lng = this.lng;

                    a = a || -180;
                    b = b || 180;

                    lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);

                    return new L.LatLng(this.lat, lng);
                }
            };

            L.latLng = function(a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)
                if (a instanceof L.LatLng) {
                    return a;
                }
                if (L.Util.isArray(a)) {
                    if (typeof a[0] === 'number' || typeof a[0] === 'string') {
                        return new L.LatLng(a[0], a[1], a[2]);
                    } else {
                        return null;
                    }
                }
                if (a === undefined || a === null) {
                    return a;
                }
                if (typeof a === 'object' && 'lat' in a) {
                    return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
                }
                if (b === undefined) {
                    return null;
                }
                return new L.LatLng(a, b);
            };



            /*
             * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
             */

            L.LatLngBounds = function(southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
                if (!southWest) {
                    return;
                }

                var latlngs = northEast ? [southWest, northEast] : southWest;

                for (var i = 0, len = latlngs.length; i < len; i++) {
                    this.extend(latlngs[i]);
                }
            };

            L.LatLngBounds.prototype = {
                // extend the bounds to contain the given point or bounds
                extend: function(obj) { // (LatLng) or (LatLngBounds)
                    if (!obj) {
                        return this;
                    }

                    var latLng = L.latLng(obj);
                    if (latLng !== null) {
                        obj = latLng;
                    } else {
                        obj = L.latLngBounds(obj);
                    }

                    if (obj instanceof L.LatLng) {
                        if (!this._southWest && !this._northEast) {
                            this._southWest = new L.LatLng(obj.lat, obj.lng);
                            this._northEast = new L.LatLng(obj.lat, obj.lng);
                        } else {
                            this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
                            this._southWest.lng = Math.min(obj.lng, this._southWest.lng);

                            this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
                            this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
                        }
                    } else if (obj instanceof L.LatLngBounds) {
                        this.extend(obj._southWest);
                        this.extend(obj._northEast);
                    }
                    return this;
                },

                // extend the bounds by a percentage
                pad: function(bufferRatio) { // (Number) -> LatLngBounds
                    var sw = this._southWest,
                        ne = this._northEast,
                        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
                        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

                    return new L.LatLngBounds(
                        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
                        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
                },

                getCenter: function() { // -> LatLng
                    return new L.LatLng(
                        (this._southWest.lat + this._northEast.lat) / 2,
                        (this._southWest.lng + this._northEast.lng) / 2);
                },

                getSouthWest: function() {
                    return this._southWest;
                },

                getNorthEast: function() {
                    return this._northEast;
                },

                getNorthWest: function() {
                    return new L.LatLng(this.getNorth(), this.getWest());
                },

                getSouthEast: function() {
                    return new L.LatLng(this.getSouth(), this.getEast());
                },

                getWest: function() {
                    return this._southWest.lng;
                },

                getSouth: function() {
                    return this._southWest.lat;
                },

                getEast: function() {
                    return this._northEast.lng;
                },

                getNorth: function() {
                    return this._northEast.lat;
                },

                contains: function(obj) { // (LatLngBounds) or (LatLng) -> Boolean
                    if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
                        obj = L.latLng(obj);
                    } else {
                        obj = L.latLngBounds(obj);
                    }

                    var sw = this._southWest,
                        ne = this._northEast,
                        sw2, ne2;

                    if (obj instanceof L.LatLngBounds) {
                        sw2 = obj.getSouthWest();
                        ne2 = obj.getNorthEast();
                    } else {
                        sw2 = ne2 = obj;
                    }

                    return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
                        (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
                },

                intersects: function(bounds) { // (LatLngBounds)
                    bounds = L.latLngBounds(bounds);

                    var sw = this._southWest,
                        ne = this._northEast,
                        sw2 = bounds.getSouthWest(),
                        ne2 = bounds.getNorthEast(),

                        latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
                        lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

                    return latIntersects && lngIntersects;
                },

                toBBoxString: function() {
                    return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
                },

                equals: function(bounds) { // (LatLngBounds)
                    if (!bounds) {
                        return false;
                    }

                    bounds = L.latLngBounds(bounds);

                    return this._southWest.equals(bounds.getSouthWest()) &&
                        this._northEast.equals(bounds.getNorthEast());
                },

                isValid: function() {
                    return !!(this._southWest && this._northEast);
                }
            };

            //TODO International date line?

            L.latLngBounds = function(a, b) { // (LatLngBounds) or (LatLng, LatLng)
                if (!a || a instanceof L.LatLngBounds) {
                    return a;
                }
                return new L.LatLngBounds(a, b);
            };


            /*
             * L.Projection contains various geographical projections used by CRS classes.
             */

            L.Projection = {};


            /*
             * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
             */

            L.Projection.SphericalMercator = {
                MAX_LATITUDE: 85.0511287798,

                project: function(latlng) { // (LatLng) -> Point
                    var d = L.LatLng.DEG_TO_RAD,
                        max = this.MAX_LATITUDE,
                        lat = Math.max(Math.min(max, latlng.lat), -max),
                        x = latlng.lng * d,
                        y = lat * d;

                    y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

                    return new L.Point(x, y);
                },

                unproject: function(point) { // (Point, Boolean) -> LatLng
                    var d = L.LatLng.RAD_TO_DEG,
                        lng = point.x * d,
                        lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;

                    return new L.LatLng(lat, lng);
                }
            };


            /*
             * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
             */

            L.Projection.LonLat = {
                project: function(latlng) {
                    return new L.Point(latlng.lng, latlng.lat);
                },

                unproject: function(point) {
                    return new L.LatLng(point.y, point.x);
                }
            };


            /*
             * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
             */

            L.CRS = {
                latLngToPoint: function(latlng, zoom) { // (LatLng, Number) -> Point
                    var projectedPoint = this.projection.project(latlng),
                        scale = this.scale(zoom);

                    return this.transformation._transform(projectedPoint, scale);
                },

                pointToLatLng: function(point, zoom) { // (Point, Number[, Boolean]) -> LatLng
                    var scale = this.scale(zoom),
                        untransformedPoint = this.transformation.untransform(point, scale);

                    return this.projection.unproject(untransformedPoint);
                },

                project: function(latlng) {
                    return this.projection.project(latlng);
                },

                scale: function(zoom) {
                    return 256 * Math.pow(2, zoom);
                },

                getSize: function(zoom) {
                    var s = this.scale(zoom);
                    return L.point(s, s);
                }
            };


            /*
             * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
             */

            L.CRS.Simple = L.extend({}, L.CRS, {
                projection: L.Projection.LonLat,
                transformation: new L.Transformation(1, 0, -1, 0),

                scale: function(zoom) {
                    return Math.pow(2, zoom);
                }
            });


            /*
             * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
             * and is used by Leaflet by default.
             */

            L.CRS.EPSG3857 = L.extend({}, L.CRS, {
                code: 'EPSG:3857',

                projection: L.Projection.SphericalMercator,
                transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),

                project: function(latlng) { // (LatLng) -> Point
                    var projectedPoint = this.projection.project(latlng),
                        earthRadius = 6378137;
                    return projectedPoint.multiplyBy(earthRadius);
                }
            });

            L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
                code: 'EPSG:900913'
            });


            /*
             * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
             */

            L.CRS.EPSG4326 = L.extend({}, L.CRS, {
                code: 'EPSG:4326',

                projection: L.Projection.LonLat,
                transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
            });


            /*
             * L.Map is the central class of the API - it is used to create a map.
             */

            L.Map = L.Class.extend({

                includes: L.Mixin.Events,

                options: {
                    crs: L.CRS.EPSG3857,

                    /*
                    center: LatLng,
                    zoom: Number,
                    layers: Array,
                    */

                    fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
                    trackResize: true,
                    markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
                },

                initialize: function(id, options) { // (HTMLElement or String, Object)
                    options = L.setOptions(this, options);


                    this._initContainer(id);
                    this._initLayout();

                    // hack for https://github.com/Leaflet/Leaflet/issues/1980
                    this._onResize = L.bind(this._onResize, this);

                    this._initEvents();

                    if (options.maxBounds) {
                        this.setMaxBounds(options.maxBounds);
                    }

                    if (options.center && options.zoom !== undefined) {
                        this.setView(L.latLng(options.center), options.zoom, {
                            reset: true
                        });
                    }

                    this._handlers = [];

                    this._layers = {};
                    this._zoomBoundLayers = {};
                    this._tileLayersNum = 0;

                    this.callInitHooks();

                    this._addLayers(options.layers);
                },


                // public methods that modify map state

                // replaced by animation-powered implementation in Map.PanAnimation.js
                setView: function(center, zoom) {
                    zoom = zoom === undefined ? this.getZoom() : zoom;
                    this._resetView(L.latLng(center), this._limitZoom(zoom));
                    return this;
                },

                setZoom: function(zoom, options) {
                    if (!this._loaded) {
                        this._zoom = this._limitZoom(zoom);
                        return this;
                    }
                    return this.setView(this.getCenter(), zoom, {
                        zoom: options
                    });
                },

                zoomIn: function(delta, options) {
                    return this.setZoom(this._zoom + (delta || 1), options);
                },

                zoomOut: function(delta, options) {
                    return this.setZoom(this._zoom - (delta || 1), options);
                },

                setZoomAround: function(latlng, zoom, options) {
                    var scale = this.getZoomScale(zoom),
                        viewHalf = this.getSize().divideBy(2),
                        containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

                        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
                        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

                    return this.setView(newCenter, zoom, {
                        zoom: options
                    });
                },

                fitBounds: function(bounds, options) {

                    options = options || {};
                    bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

                    var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
                        paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

                        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

                    zoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;

                    var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

                        swPoint = this.project(bounds.getSouthWest(), zoom),
                        nePoint = this.project(bounds.getNorthEast(), zoom),
                        center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

                    return this.setView(center, zoom, options);
                },

                fitWorld: function(options) {
                    return this.fitBounds([
                        [-90, -180],
                        [90, 180]
                    ], options);
                },

                panTo: function(center, options) { // (LatLng)
                    return this.setView(center, this._zoom, {
                        pan: options
                    });
                },

                panBy: function(offset) { // (Point)
                    // replaced with animated panBy in Map.PanAnimation.js
                    this.fire('movestart');

                    this._rawPanBy(L.point(offset));

                    this.fire('move');
                    return this.fire('moveend');
                },

                setMaxBounds: function(bounds) {
                    bounds = L.latLngBounds(bounds);

                    this.options.maxBounds = bounds;

                    if (!bounds) {
                        return this.off('moveend', this._panInsideMaxBounds, this);
                    }

                    if (this._loaded) {
                        this._panInsideMaxBounds();
                    }

                    return this.on('moveend', this._panInsideMaxBounds, this);
                },

                panInsideBounds: function(bounds, options) {
                    var center = this.getCenter(),
                        newCenter = this._limitCenter(center, this._zoom, bounds);

                    if (center.equals(newCenter)) {
                        return this;
                    }

                    return this.panTo(newCenter, options);
                },

                addLayer: function(layer) {
                    // TODO method is too big, refactor

                    var id = L.stamp(layer);

                    if (this._layers[id]) {
                        return this;
                    }

                    this._layers[id] = layer;

                    // TODO getMaxZoom, getMinZoom in ILayer (instead of options)
                    if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
                        this._zoomBoundLayers[id] = layer;
                        this._updateZoomLevels();
                    }

                    // TODO looks ugly, refactor!!!
                    if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
                        this._tileLayersNum++;
                        this._tileLayersToLoad++;
                        layer.on('load', this._onTileLayerLoad, this);
                    }

                    if (this._loaded) {
                        this._layerAdd(layer);
                    }

                    return this;
                },

                removeLayer: function(layer) {
                    var id = L.stamp(layer);

                    if (!this._layers[id]) {
                        return this;
                    }

                    if (this._loaded) {
                        layer.onRemove(this);
                    }

                    delete this._layers[id];

                    if (this._loaded) {
                        this.fire('layerremove', {
                            layer: layer
                        });
                    }

                    if (this._zoomBoundLayers[id]) {
                        delete this._zoomBoundLayers[id];
                        this._updateZoomLevels();
                    }

                    // TODO looks ugly, refactor
                    if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
                        this._tileLayersNum--;
                        this._tileLayersToLoad--;
                        layer.off('load', this._onTileLayerLoad, this);
                    }

                    return this;
                },

                hasLayer: function(layer) {
                    if (!layer) {
                        return false;
                    }

                    return (L.stamp(layer) in this._layers);
                },

                eachLayer: function(method, context) {
                    for (var i in this._layers) {
                        method.call(context, this._layers[i]);
                    }
                    return this;
                },

                invalidateSize: function(options) {
                    if (!this._loaded) {
                        return this;
                    }

                    options = L.extend({
                        animate: false,
                        pan: true
                    }, options === true ? {
                        animate: true
                    } : options);

                    var oldSize = this.getSize();
                    this._sizeChanged = true;
                    this._initialCenter = null;

                    var newSize = this.getSize(),
                        oldCenter = oldSize.divideBy(2).round(),
                        newCenter = newSize.divideBy(2).round(),
                        offset = oldCenter.subtract(newCenter);

                    if (!offset.x && !offset.y) {
                        return this;
                    }

                    if (options.animate && options.pan) {
                        this.panBy(offset);

                    } else {
                        if (options.pan) {
                            this._rawPanBy(offset);
                        }

                        this.fire('move');

                        if (options.debounceMoveend) {
                            clearTimeout(this._sizeTimer);
                            this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
                        } else {
                            this.fire('moveend');
                        }
                    }

                    return this.fire('resize', {
                        oldSize: oldSize,
                        newSize: newSize
                    });
                },

                // TODO handler.addTo
                addHandler: function(name, HandlerClass) {
                    if (!HandlerClass) {
                        return this;
                    }

                    var handler = this[name] = new HandlerClass(this);

                    this._handlers.push(handler);

                    if (this.options[name]) {
                        handler.enable();
                    }

                    return this;
                },

                remove: function() {
                    if (this._loaded) {
                        this.fire('unload');
                    }

                    this._initEvents('off');

                    try {
                        // throws error in IE6-8
                        delete this._container._leaflet;
                    } catch (e) {
                        this._container._leaflet = undefined;
                    }

                    this._clearPanes();
                    if (this._clearControlPos) {
                        this._clearControlPos();
                    }

                    this._clearHandlers();

                    return this;
                },


                // public methods for getting map state

                getCenter: function() { // (Boolean) -> LatLng
                    this._checkIfLoaded();

                    if (this._initialCenter && !this._moved()) {
                        return this._initialCenter;
                    }
                    return this.layerPointToLatLng(this._getCenterLayerPoint());
                },

                getZoom: function() {
                    return this._zoom;
                },

                getBounds: function() {
                    var bounds = this.getPixelBounds(),
                        sw = this.unproject(bounds.getBottomLeft()),
                        ne = this.unproject(bounds.getTopRight());

                    return new L.LatLngBounds(sw, ne);
                },

                getMinZoom: function() {
                    return this.options.minZoom === undefined ?
                        (this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :
                        this.options.minZoom;
                },

                getMaxZoom: function() {
                    return this.options.maxZoom === undefined ?
                        (this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
                        this.options.maxZoom;
                },

                getBoundsZoom: function(bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
                    bounds = L.latLngBounds(bounds);

                    var zoom = this.getMinZoom() - (inside ? 1 : 0),
                        maxZoom = this.getMaxZoom(),
                        size = this.getSize(),

                        nw = bounds.getNorthWest(),
                        se = bounds.getSouthEast(),

                        zoomNotFound = true,
                        boundsSize;

                    padding = L.point(padding || [0, 0]);

                    do {
                        zoom++;
                        boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
                        zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

                    } while (zoomNotFound && zoom <= maxZoom);

                    if (zoomNotFound && inside) {
                        return null;
                    }

                    return inside ? zoom : zoom - 1;
                },

                getSize: function() {
                    if (!this._size || this._sizeChanged) {
                        this._size = new L.Point(
                            this._container.clientWidth,
                            this._container.clientHeight);

                        this._sizeChanged = false;
                    }
                    return this._size.clone();
                },

                getPixelBounds: function() {
                    var topLeftPoint = this._getTopLeftPoint();
                    return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
                },

                getPixelOrigin: function() {
                    this._checkIfLoaded();
                    return this._initialTopLeftPoint;
                },

                getPanes: function() {
                    return this._panes;
                },

                getContainer: function() {
                    return this._container;
                },


                // TODO replace with universal implementation after refactoring projections

                getZoomScale: function(toZoom) {
                    var crs = this.options.crs;
                    return crs.scale(toZoom) / crs.scale(this._zoom);
                },

                getScaleZoom: function(scale) {
                    return this._zoom + (Math.log(scale) / Math.LN2);
                },


                // conversion methods

                project: function(latlng, zoom) { // (LatLng[, Number]) -> Point
                    zoom = zoom === undefined ? this._zoom : zoom;
                    return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
                },

                unproject: function(point, zoom) { // (Point[, Number]) -> LatLng
                    zoom = zoom === undefined ? this._zoom : zoom;
                    return this.options.crs.pointToLatLng(L.point(point), zoom);
                },

                layerPointToLatLng: function(point) { // (Point)
                    var projectedPoint = L.point(point).add(this.getPixelOrigin());
                    return this.unproject(projectedPoint);
                },

                latLngToLayerPoint: function(latlng) { // (LatLng)
                    var projectedPoint = this.project(L.latLng(latlng))._round();
                    return projectedPoint._subtract(this.getPixelOrigin());
                },

                containerPointToLayerPoint: function(point) { // (Point)
                    return L.point(point).subtract(this._getMapPanePos());
                },

                layerPointToContainerPoint: function(point) { // (Point)
                    return L.point(point).add(this._getMapPanePos());
                },

                containerPointToLatLng: function(point) {
                    var layerPoint = this.containerPointToLayerPoint(L.point(point));
                    return this.layerPointToLatLng(layerPoint);
                },

                latLngToContainerPoint: function(latlng) {
                    return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
                },

                mouseEventToContainerPoint: function(e) { // (MouseEvent)
                    return L.DomEvent.getMousePosition(e, this._container);
                },

                mouseEventToLayerPoint: function(e) { // (MouseEvent)
                    return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
                },

                mouseEventToLatLng: function(e) { // (MouseEvent)
                    return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
                },


                // map initialization methods

                _initContainer: function(id) {
                    var container = this._container = L.DomUtil.get(id);

                    if (!container) {
                        throw new Error('Map container not found.');
                    } else if (container._leaflet) {
                        throw new Error('Map container is already initialized.');
                    }

                    container._leaflet = true;
                },

                _initLayout: function() {
                    var container = this._container;

                    L.DomUtil.addClass(container, 'leaflet-container' +
                        (L.Browser.touch ? ' leaflet-touch' : '') +
                        (L.Browser.retina ? ' leaflet-retina' : '') +
                        (L.Browser.ielt9 ? ' leaflet-oldie' : '') +
                        (this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));

                    var position = L.DomUtil.getStyle(container, 'position');

                    if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
                        container.style.position = 'relative';
                    }

                    this._initPanes();

                    if (this._initControlPos) {
                        this._initControlPos();
                    }
                },

                _initPanes: function() {
                    var panes = this._panes = {};

                    this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);

                    this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
                    panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
                    panes.shadowPane = this._createPane('leaflet-shadow-pane');
                    panes.overlayPane = this._createPane('leaflet-overlay-pane');
                    panes.markerPane = this._createPane('leaflet-marker-pane');
                    panes.popupPane = this._createPane('leaflet-popup-pane');

                    var zoomHide = ' leaflet-zoom-hide';

                    if (!this.options.markerZoomAnimation) {
                        L.DomUtil.addClass(panes.markerPane, zoomHide);
                        L.DomUtil.addClass(panes.shadowPane, zoomHide);
                        L.DomUtil.addClass(panes.popupPane, zoomHide);
                    }
                },

                _createPane: function(className, container) {
                    return L.DomUtil.create('div', className, container || this._panes.objectsPane);
                },

                _clearPanes: function() {
                    this._container.removeChild(this._mapPane);
                },

                _addLayers: function(layers) {
                    layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

                    for (var i = 0, len = layers.length; i < len; i++) {
                        this.addLayer(layers[i]);
                    }
                },


                // private methods that modify map state

                _resetView: function(center, zoom, preserveMapOffset, afterZoomAnim) {

                    var zoomChanged = (this._zoom !== zoom);

                    if (!afterZoomAnim) {
                        this.fire('movestart');

                        if (zoomChanged) {
                            this.fire('zoomstart');
                        }
                    }

                    this._zoom = zoom;
                    this._initialCenter = center;

                    this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

                    if (!preserveMapOffset) {
                        L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
                    } else {
                        this._initialTopLeftPoint._add(this._getMapPanePos());
                    }

                    this._tileLayersToLoad = this._tileLayersNum;

                    var loading = !this._loaded;
                    this._loaded = true;

                    this.fire('viewreset', {
                        hard: !preserveMapOffset
                    });

                    if (loading) {
                        this.fire('load');
                        this.eachLayer(this._layerAdd, this);
                    }

                    this.fire('move');

                    if (zoomChanged || afterZoomAnim) {
                        this.fire('zoomend');
                    }

                    this.fire('moveend', {
                        hard: !preserveMapOffset
                    });
                },

                _rawPanBy: function(offset) {
                    L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
                },

                _getZoomSpan: function() {
                    return this.getMaxZoom() - this.getMinZoom();
                },

                _updateZoomLevels: function() {
                    var i,
                        minZoom = Infinity,
                        maxZoom = -Infinity,
                        oldZoomSpan = this._getZoomSpan();

                    for (i in this._zoomBoundLayers) {
                        var layer = this._zoomBoundLayers[i];
                        if (!isNaN(layer.options.minZoom)) {
                            minZoom = Math.min(minZoom, layer.options.minZoom);
                        }
                        if (!isNaN(layer.options.maxZoom)) {
                            maxZoom = Math.max(maxZoom, layer.options.maxZoom);
                        }
                    }

                    if (i === undefined) { // we have no tilelayers
                        this._layersMaxZoom = this._layersMinZoom = undefined;
                    } else {
                        this._layersMaxZoom = maxZoom;
                        this._layersMinZoom = minZoom;
                    }

                    if (oldZoomSpan !== this._getZoomSpan()) {
                        this.fire('zoomlevelschange');
                    }
                },

                _panInsideMaxBounds: function() {
                    this.panInsideBounds(this.options.maxBounds);
                },

                _checkIfLoaded: function() {
                    if (!this._loaded) {
                        throw new Error('Set map center and zoom first.');
                    }
                },

                // map events

                _initEvents: function(onOff) {
                    if (!L.DomEvent) {
                        return;
                    }

                    onOff = onOff || 'on';

                    L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

                    var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
                            'mouseleave', 'mousemove', 'contextmenu'
                        ],
                        i, len;

                    for (i = 0, len = events.length; i < len; i++) {
                        L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
                    }

                    if (this.options.trackResize) {
                        L.DomEvent[onOff](window, 'resize', this._onResize, this);
                    }
                },

                _onResize: function() {
                    L.Util.cancelAnimFrame(this._resizeRequest);
                    this._resizeRequest = L.Util.requestAnimFrame(
                        function() {
                            this.invalidateSize({
                                debounceMoveend: true
                            });
                        }, this, false, this._container);
                },

                _onMouseClick: function(e) {
                    if (!this._loaded || (!e._simulated &&
                            ((this.dragging && this.dragging.moved()) ||
                                (this.boxZoom && this.boxZoom.moved()))) ||
                        L.DomEvent._skipped(e)) {
                        return;
                    }

                    this.fire('preclick');
                    this._fireMouseEvent(e);
                },

                _fireMouseEvent: function(e) {
                    if (!this._loaded || L.DomEvent._skipped(e)) {
                        return;
                    }

                    var type = e.type;

                    type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

                    if (!this.hasEventListeners(type)) {
                        return;
                    }

                    if (type === 'contextmenu') {
                        L.DomEvent.preventDefault(e);
                    }

                    var containerPoint = this.mouseEventToContainerPoint(e),
                        layerPoint = this.containerPointToLayerPoint(containerPoint),
                        latlng = this.layerPointToLatLng(layerPoint);

                    this.fire(type, {
                        latlng: latlng,
                        layerPoint: layerPoint,
                        containerPoint: containerPoint,
                        originalEvent: e
                    });
                },

                _onTileLayerLoad: function() {
                    this._tileLayersToLoad--;
                    if (this._tileLayersNum && !this._tileLayersToLoad) {
                        this.fire('tilelayersload');
                    }
                },

                _clearHandlers: function() {
                    for (var i = 0, len = this._handlers.length; i < len; i++) {
                        this._handlers[i].disable();
                    }
                },

                whenReady: function(callback, context) {
                    if (this._loaded) {
                        callback.call(context || this, this);
                    } else {
                        this.on('load', callback, context);
                    }
                    return this;
                },

                _layerAdd: function(layer) {
                    layer.onAdd(this);
                    this.fire('layeradd', {
                        layer: layer
                    });
                },


                // private methods for getting map state

                _getMapPanePos: function() {
                    return L.DomUtil.getPosition(this._mapPane);
                },

                _moved: function() {
                    var pos = this._getMapPanePos();
                    return pos && !pos.equals([0, 0]);
                },

                _getTopLeftPoint: function() {
                    return this.getPixelOrigin().subtract(this._getMapPanePos());
                },

                _getNewTopLeftPoint: function(center, zoom) {
                    var viewHalf = this.getSize()._divideBy(2);
                    // TODO round on display, not calculation to increase precision?
                    return this.project(center, zoom)._subtract(viewHalf)._round();
                },

                _latLngToNewLayerPoint: function(latlng, newZoom, newCenter) {
                    var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
                    return this.project(latlng, newZoom)._subtract(topLeft);
                },

                // layer point of the current center
                _getCenterLayerPoint: function() {
                    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
                },

                // offset of the specified place to the current center in pixels
                _getCenterOffset: function(latlng) {
                    return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
                },

                // adjust center for view to get inside bounds
                _limitCenter: function(center, zoom, bounds) {

                    if (!bounds) {
                        return center;
                    }

                    var centerPoint = this.project(center, zoom),
                        viewHalf = this.getSize().divideBy(2),
                        viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
                        offset = this._getBoundsOffset(viewBounds, bounds, zoom);

                    return this.unproject(centerPoint.add(offset), zoom);
                },

                // adjust offset for view to get inside bounds
                _limitOffset: function(offset, bounds) {
                    if (!bounds) {
                        return offset;
                    }

                    var viewBounds = this.getPixelBounds(),
                        newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

                    return offset.add(this._getBoundsOffset(newBounds, bounds));
                },

                // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
                _getBoundsOffset: function(pxBounds, maxBounds, zoom) {
                    var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
                        seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

                        dx = this._rebound(nwOffset.x, -seOffset.x),
                        dy = this._rebound(nwOffset.y, -seOffset.y);

                    return new L.Point(dx, dy);
                },

                _rebound: function(left, right) {
                    return left + right > 0 ?
                        Math.round(left - right) / 2 :
                        Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
                },

                _limitZoom: function(zoom) {
                    var min = this.getMinZoom(),
                        max = this.getMaxZoom();

                    return Math.max(min, Math.min(max, zoom));
                }
            });

            L.map = function(id, options) {
                return new L.Map(id, options);
            };


            /*
             * Mercator projection that takes into account that the Earth is not a perfect sphere.
             * Less popular than spherical mercator; used by projections like EPSG:3395.
             */

            L.Projection.Mercator = {
                MAX_LATITUDE: 85.0840591556,

                R_MINOR: 6356752.314245179,
                R_MAJOR: 6378137,

                project: function(latlng) { // (LatLng) -> Point
                    var d = L.LatLng.DEG_TO_RAD,
                        max = this.MAX_LATITUDE,
                        lat = Math.max(Math.min(max, latlng.lat), -max),
                        r = this.R_MAJOR,
                        r2 = this.R_MINOR,
                        x = latlng.lng * d * r,
                        y = lat * d,
                        tmp = r2 / r,
                        eccent = Math.sqrt(1.0 - tmp * tmp),
                        con = eccent * Math.sin(y);

                    con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

                    var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
                    y = -r * Math.log(ts);

                    return new L.Point(x, y);
                },

                unproject: function(point) { // (Point, Boolean) -> LatLng
                    var d = L.LatLng.RAD_TO_DEG,
                        r = this.R_MAJOR,
                        r2 = this.R_MINOR,
                        lng = point.x * d / r,
                        tmp = r2 / r,
                        eccent = Math.sqrt(1 - (tmp * tmp)),
                        ts = Math.exp(-point.y / r),
                        phi = (Math.PI / 2) - 2 * Math.atan(ts),
                        numIter = 15,
                        tol = 1e-7,
                        i = numIter,
                        dphi = 0.1,
                        con;

                    while ((Math.abs(dphi) > tol) && (--i > 0)) {
                        con = eccent * Math.sin(phi);
                        dphi = (Math.PI / 2) - 2 * Math.atan(ts *
                            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
                        phi += dphi;
                    }

                    return new L.LatLng(phi * d, lng);
                }
            };



            L.CRS.EPSG3395 = L.extend({}, L.CRS, {
                code: 'EPSG:3395',

                projection: L.Projection.Mercator,

                transformation: (function() {
                    var m = L.Projection.Mercator,
                        r = m.R_MAJOR,
                        scale = 0.5 / (Math.PI * r);

                    return new L.Transformation(scale, 0.5, -scale, 0.5);
                }())
            });


            /*
             * L.TileLayer is used for standard xyz-numbered tile layers.
             */

            L.TileLayer = L.Class.extend({
                includes: L.Mixin.Events,

                options: {
                    minZoom: 0,
                    maxZoom: 18,
                    tileSize: 256,
                    subdomains: 'abc',
                    errorTileUrl: '',
                    attribution: '',
                    zoomOffset: 0,
                    opacity: 1,
                    /*
                    maxNativeZoom: null,
                    zIndex: null,
                    tms: false,
                    continuousWorld: false,
                    noWrap: false,
                    zoomReverse: false,
                    detectRetina: false,
                    reuseTiles: false,
                    bounds: false,
                    */
                    unloadInvisibleTiles: L.Browser.mobile,
                    updateWhenIdle: L.Browser.mobile
                },

                initialize: function(url, options) {
                    options = L.setOptions(this, options);

                    // detecting retina displays, adjusting tileSize and zoom levels
                    if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

                        options.tileSize = Math.floor(options.tileSize / 2);
                        options.zoomOffset++;

                        if (options.minZoom > 0) {
                            options.minZoom--;
                        }
                        this.options.maxZoom--;
                    }

                    if (options.bounds) {
                        options.bounds = L.latLngBounds(options.bounds);
                    }

                    this._url = url;

                    var subdomains = this.options.subdomains;

                    if (typeof subdomains === 'string') {
                        this.options.subdomains = subdomains.split('');
                    }
                },

                onAdd: function(map) {
                    this._map = map;
                    this._animated = map._zoomAnimated;

                    // create a container div for tiles
                    this._initContainer();

                    // set up events
                    map.on({
                        'viewreset': this._reset,
                        'moveend': this._update
                    }, this);

                    if (this._animated) {
                        map.on({
                            'zoomanim': this._animateZoom,
                            'zoomend': this._endZoomAnim
                        }, this);
                    }

                    if (!this.options.updateWhenIdle) {
                        this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
                        map.on('move', this._limitedUpdate, this);
                    }

                    this._reset();
                    this._update();
                },

                addTo: function(map) {
                    map.addLayer(this);
                    return this;
                },

                onRemove: function(map) {
                    this._container.parentNode.removeChild(this._container);

                    map.off({
                        'viewreset': this._reset,
                        'moveend': this._update
                    }, this);

                    if (this._animated) {
                        map.off({
                            'zoomanim': this._animateZoom,
                            'zoomend': this._endZoomAnim
                        }, this);
                    }

                    if (!this.options.updateWhenIdle) {
                        map.off('move', this._limitedUpdate, this);
                    }

                    this._container = null;
                    this._map = null;
                },

                bringToFront: function() {
                    var pane = this._map._panes.tilePane;

                    if (this._container) {
                        pane.appendChild(this._container);
                        this._setAutoZIndex(pane, Math.max);
                    }

                    return this;
                },

                bringToBack: function() {
                    var pane = this._map._panes.tilePane;

                    if (this._container) {
                        pane.insertBefore(this._container, pane.firstChild);
                        this._setAutoZIndex(pane, Math.min);
                    }

                    return this;
                },

                getAttribution: function() {
                    return this.options.attribution;
                },

                getContainer: function() {
                    return this._container;
                },

                setOpacity: function(opacity) {
                    this.options.opacity = opacity;

                    if (this._map) {
                        this._updateOpacity();
                    }

                    return this;
                },

                setZIndex: function(zIndex) {
                    this.options.zIndex = zIndex;
                    this._updateZIndex();

                    return this;
                },

                setUrl: function(url, noRedraw) {
                    this._url = url;

                    if (!noRedraw) {
                        this.redraw();
                    }

                    return this;
                },

                redraw: function() {
                    if (this._map) {
                        this._reset({
                            hard: true
                        });
                        this._update();
                    }
                    return this;
                },

                _updateZIndex: function() {
                    if (this._container && this.options.zIndex !== undefined) {
                        this._container.style.zIndex = this.options.zIndex;
                    }
                },

                _setAutoZIndex: function(pane, compare) {

                    var layers = pane.children,
                        edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
                        zIndex, i, len;

                    for (i = 0, len = layers.length; i < len; i++) {

                        if (layers[i] !== this._container) {
                            zIndex = parseInt(layers[i].style.zIndex, 10);

                            if (!isNaN(zIndex)) {
                                edgeZIndex = compare(edgeZIndex, zIndex);
                            }
                        }
                    }

                    this.options.zIndex = this._container.style.zIndex =
                        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
                },

                _updateOpacity: function() {
                    var i,
                        tiles = this._tiles;

                    if (L.Browser.ielt9) {
                        for (i in tiles) {
                            L.DomUtil.setOpacity(tiles[i], this.options.opacity);
                        }
                    } else {
                        L.DomUtil.setOpacity(this._container, this.options.opacity);
                    }
                },

                _initContainer: function() {
                    var tilePane = this._map._panes.tilePane;

                    if (!this._container) {
                        this._container = L.DomUtil.create('div', 'leaflet-layer');

                        this._updateZIndex();

                        if (this._animated) {
                            var className = 'leaflet-tile-container';

                            this._bgBuffer = L.DomUtil.create('div', className, this._container);
                            this._tileContainer = L.DomUtil.create('div', className, this._container);

                        } else {
                            this._tileContainer = this._container;
                        }

                        tilePane.appendChild(this._container);

                        if (this.options.opacity < 1) {
                            this._updateOpacity();
                        }
                    }
                },

                _reset: function(e) {
                    for (var key in this._tiles) {
                        this.fire('tileunload', {
                            tile: this._tiles[key]
                        });
                    }

                    this._tiles = {};
                    this._tilesToLoad = 0;

                    if (this.options.reuseTiles) {
                        this._unusedTiles = [];
                    }

                    this._tileContainer.innerHTML = '';

                    if (this._animated && e && e.hard) {
                        this._clearBgBuffer();
                    }

                    this._initContainer();
                },

                _getTileSize: function() {
                    var map = this._map,
                        zoom = map.getZoom() + this.options.zoomOffset,
                        zoomN = this.options.maxNativeZoom,
                        tileSize = this.options.tileSize;

                    if (zoomN && zoom > zoomN) {
                        tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
                    }

                    return tileSize;
                },

                _update: function() {

                    if (!this._map) {
                        return;
                    }

                    var map = this._map,
                        bounds = map.getPixelBounds(),
                        zoom = map.getZoom(),
                        tileSize = this._getTileSize();

                    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                        return;
                    }

                    var tileBounds = L.bounds(
                        bounds.min.divideBy(tileSize)._floor(),
                        bounds.max.divideBy(tileSize)._floor());

                    this._addTilesFromCenterOut(tileBounds);

                    if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
                        this._removeOtherTiles(tileBounds);
                    }
                },

                _addTilesFromCenterOut: function(bounds) {
                    var queue = [],
                        center = bounds.getCenter();

                    var j, i, point;

                    for (j = bounds.min.y; j <= bounds.max.y; j++) {
                        for (i = bounds.min.x; i <= bounds.max.x; i++) {
                            point = new L.Point(i, j);

                            if (this._tileShouldBeLoaded(point)) {
                                queue.push(point);
                            }
                        }
                    }

                    var tilesToLoad = queue.length;

                    if (tilesToLoad === 0) {
                        return;
                    }

                    // load tiles in order of their distance to center
                    queue.sort(function(a, b) {
                        return a.distanceTo(center) - b.distanceTo(center);
                    });

                    var fragment = document.createDocumentFragment();

                    // if its the first batch of tiles to load
                    if (!this._tilesToLoad) {
                        this.fire('loading');
                    }

                    this._tilesToLoad += tilesToLoad;

                    for (i = 0; i < tilesToLoad; i++) {
                        this._addTile(queue[i], fragment);
                    }

                    this._tileContainer.appendChild(fragment);
                },

                _tileShouldBeLoaded: function(tilePoint) {
                    if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
                        return false; // already loaded
                    }

                    var options = this.options;

                    if (!options.continuousWorld) {
                        var limit = this._getWrapTileNum();

                        // don't load if exceeds world bounds
                        if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
                            tilePoint.y < 0 || tilePoint.y >= limit.y) {
                            return false;
                        }
                    }

                    if (options.bounds) {
                        var tileSize = this._getTileSize(),
                            nwPoint = tilePoint.multiplyBy(tileSize),
                            sePoint = nwPoint.add([tileSize, tileSize]),
                            nw = this._map.unproject(nwPoint),
                            se = this._map.unproject(sePoint);

                        // TODO temporary hack, will be removed after refactoring projections
                        // https://github.com/Leaflet/Leaflet/issues/1618
                        if (!options.continuousWorld && !options.noWrap) {
                            nw = nw.wrap();
                            se = se.wrap();
                        }

                        if (!options.bounds.intersects([nw, se])) {
                            return false;
                        }
                    }

                    return true;
                },

                _removeOtherTiles: function(bounds) {
                    var kArr, x, y, key;

                    for (key in this._tiles) {
                        kArr = key.split(':');
                        x = parseInt(kArr[0], 10);
                        y = parseInt(kArr[1], 10);

                        // remove tile if it's out of bounds
                        if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
                            this._removeTile(key);
                        }
                    }
                },

                _removeTile: function(key) {
                    var tile = this._tiles[key];

                    this.fire('tileunload', {
                        tile: tile,
                        url: tile.src
                    });

                    if (this.options.reuseTiles) {
                        L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
                        this._unusedTiles.push(tile);

                    } else if (tile.parentNode === this._tileContainer) {
                        this._tileContainer.removeChild(tile);
                    }

                    // for https://github.com/CloudMade/Leaflet/issues/137
                    if (!L.Browser.android) {
                        tile.onload = null;
                        tile.src = L.Util.emptyImageUrl;
                    }

                    delete this._tiles[key];
                },

                _addTile: function(tilePoint, container) {
                    var tilePos = this._getTilePos(tilePoint);

                    // get unused tile - or create a new tile
                    var tile = this._getTile();

                    /*
                    Chrome 20 layouts much faster with top/left (verify with timeline, frames)
                    Android 4 browser has display issues with top/left and requires transform instead
                    (other browsers don't currently care) - see debug/hacks/jitter.html for an example
                    */
                    L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

                    this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

                    this._loadTile(tile, tilePoint);

                    if (tile.parentNode !== this._tileContainer) {
                        container.appendChild(tile);
                    }
                },

                _getZoomForUrl: function() {

                    var options = this.options,
                        zoom = this._map.getZoom();

                    if (options.zoomReverse) {
                        zoom = options.maxZoom - zoom;
                    }

                    zoom += options.zoomOffset;

                    return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
                },

                _getTilePos: function(tilePoint) {
                    var origin = this._map.getPixelOrigin(),
                        tileSize = this._getTileSize();

                    return tilePoint.multiplyBy(tileSize).subtract(origin);
                },

                // image-specific code (override to implement e.g. Canvas or SVG tile layer)

                getTileUrl: function(tilePoint) {
                    return L.Util.template(this._url, L.extend({
                        s: this._getSubdomain(tilePoint),
                        z: tilePoint.z,
                        x: tilePoint.x,
                        y: tilePoint.y
                    }, this.options));
                },

                _getWrapTileNum: function() {
                    var crs = this._map.options.crs,
                        size = crs.getSize(this._map.getZoom());
                    return size.divideBy(this._getTileSize())._floor();
                },

                _adjustTilePoint: function(tilePoint) {

                    var limit = this._getWrapTileNum();

                    // wrap tile coordinates
                    if (!this.options.continuousWorld && !this.options.noWrap) {
                        tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
                    }

                    if (this.options.tms) {
                        tilePoint.y = limit.y - tilePoint.y - 1;
                    }

                    tilePoint.z = this._getZoomForUrl();
                },

                _getSubdomain: function(tilePoint) {
                    var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
                    return this.options.subdomains[index];
                },

                _getTile: function() {
                    if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                        var tile = this._unusedTiles.pop();
                        this._resetTile(tile);
                        return tile;
                    }
                    return this._createTile();
                },

                // Override if data stored on a tile needs to be cleaned up before reuse
                _resetTile: function( /*tile*/ ) {},

                _createTile: function() {
                    var tile = L.DomUtil.create('img', 'leaflet-tile');
                    tile.style.width = tile.style.height = this._getTileSize() + 'px';
                    tile.galleryimg = 'no';

                    tile.onselectstart = tile.onmousemove = L.Util.falseFn;

                    if (L.Browser.ielt9 && this.options.opacity !== undefined) {
                        L.DomUtil.setOpacity(tile, this.options.opacity);
                    }
                    // without this hack, tiles disappear after zoom on Chrome for Android
                    // https://github.com/Leaflet/Leaflet/issues/2078
                    if (L.Browser.mobileWebkit3d) {
                        tile.style.WebkitBackfaceVisibility = 'hidden';
                    }
                    return tile;
                },

                _loadTile: function(tile, tilePoint) {
                    tile._layer = this;
                    tile.onload = this._tileOnLoad;
                    tile.onerror = this._tileOnError;

                    this._adjustTilePoint(tilePoint);
                    tile.src = this.getTileUrl(tilePoint);

                    this.fire('tileloadstart', {
                        tile: tile,
                        url: tile.src
                    });
                },

                _tileLoaded: function() {
                    this._tilesToLoad--;

                    if (this._animated) {
                        L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
                    }

                    if (!this._tilesToLoad) {
                        this.fire('load');

                        if (this._animated) {
                            // clear scaled tiles after all new tiles are loaded (for performance)
                            clearTimeout(this._clearBgBufferTimer);
                            this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
                        }
                    }
                },

                _tileOnLoad: function() {
                    var layer = this._layer;

                    //Only if we are loading an actual image
                    if (this.src !== L.Util.emptyImageUrl) {
                        L.DomUtil.addClass(this, 'leaflet-tile-loaded');

                        layer.fire('tileload', {
                            tile: this,
                            url: this.src
                        });
                    }

                    layer._tileLoaded();
                },

                _tileOnError: function() {
                    var layer = this._layer;

                    layer.fire('tileerror', {
                        tile: this,
                        url: this.src
                    });

                    var newUrl = layer.options.errorTileUrl;
                    if (newUrl) {
                        this.src = newUrl;
                    }

                    layer._tileLoaded();
                }
            });

            L.tileLayer = function(url, options) {
                return new L.TileLayer(url, options);
            };


            /*
             * L.TileLayer.WMS is used for putting WMS tile layers on the map.
             */

            L.TileLayer.WMS = L.TileLayer.extend({

                defaultWmsParams: {
                    service: 'WMS',
                    request: 'GetMap',
                    version: '1.1.1',
                    layers: '',
                    styles: '',
                    format: 'image/jpeg',
                    transparent: false
                },

                initialize: function(url, options) { // (String, Object)

                    this._url = url;

                    var wmsParams = L.extend({}, this.defaultWmsParams),
                        tileSize = options.tileSize || this.options.tileSize;

                    if (options.detectRetina && L.Browser.retina) {
                        wmsParams.width = wmsParams.height = tileSize * 2;
                    } else {
                        wmsParams.width = wmsParams.height = tileSize;
                    }

                    for (var i in options) {
                        // all keys that are not TileLayer options go to WMS params
                        if (!this.options.hasOwnProperty(i) && i !== 'crs') {
                            wmsParams[i] = options[i];
                        }
                    }

                    this.wmsParams = wmsParams;

                    L.setOptions(this, options);
                },

                onAdd: function(map) {

                    this._crs = this.options.crs || map.options.crs;

                    this._wmsVersion = parseFloat(this.wmsParams.version);

                    var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
                    this.wmsParams[projectionKey] = this._crs.code;

                    L.TileLayer.prototype.onAdd.call(this, map);
                },

                getTileUrl: function(tilePoint) { // (Point, Number) -> String

                    var map = this._map,
                        tileSize = this.options.tileSize,

                        nwPoint = tilePoint.multiplyBy(tileSize),
                        sePoint = nwPoint.add([tileSize, tileSize]),

                        nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
                        se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
                        bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ? [se.y, nw.x, nw.y, se.x].join(',') : [nw.x, se.y, se.x, nw.y].join(','),

                        url = L.Util.template(this._url, {
                            s: this._getSubdomain(tilePoint)
                        });

                    return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
                },

                setParams: function(params, noRedraw) {

                    L.extend(this.wmsParams, params);

                    if (!noRedraw) {
                        this.redraw();
                    }

                    return this;
                }
            });

            L.tileLayer.wms = function(url, options) {
                return new L.TileLayer.WMS(url, options);
            };


            /*
             * L.TileLayer.Canvas is a class that you can use as a base for creating
             * dynamically drawn Canvas-based tile layers.
             */

            L.TileLayer.Canvas = L.TileLayer.extend({
                options: {
                    async: false
                },

                initialize: function(options) {
                    L.setOptions(this, options);
                },

                redraw: function() {
                    if (this._map) {
                        this._reset({
                            hard: true
                        });
                        this._update();
                    }

                    for (var i in this._tiles) {
                        this._redrawTile(this._tiles[i]);
                    }
                    return this;
                },

                _redrawTile: function(tile) {
                    this.drawTile(tile, tile._tilePoint, this._map._zoom);
                },

                _createTile: function() {
                    var tile = L.DomUtil.create('canvas', 'leaflet-tile');
                    tile.width = tile.height = this.options.tileSize;
                    tile.onselectstart = tile.onmousemove = L.Util.falseFn;
                    return tile;
                },

                _loadTile: function(tile, tilePoint) {
                    tile._layer = this;
                    tile._tilePoint = tilePoint;

                    this._redrawTile(tile);

                    if (!this.options.async) {
                        this.tileDrawn(tile);
                    }
                },

                drawTile: function( /*tile, tilePoint*/ ) {
                    // override with rendering code
                },

                tileDrawn: function(tile) {
                    this._tileOnLoad.call(tile);
                }
            });


            L.tileLayer.canvas = function(options) {
                return new L.TileLayer.Canvas(options);
            };


            /*
             * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
             */

            L.ImageOverlay = L.Class.extend({
                includes: L.Mixin.Events,

                options: {
                    opacity: 1
                },

                initialize: function(url, bounds, options) { // (String, LatLngBounds, Object)
                    this._url = url;
                    this._bounds = L.latLngBounds(bounds);

                    L.setOptions(this, options);
                },

                onAdd: function(map) {
                    this._map = map;

                    if (!this._image) {
                        this._initImage();
                    }

                    map._panes.overlayPane.appendChild(this._image);

                    map.on('viewreset', this._reset, this);

                    if (map.options.zoomAnimation && L.Browser.any3d) {
                        map.on('zoomanim', this._animateZoom, this);
                    }

                    this._reset();
                },

                onRemove: function(map) {
                    map.getPanes().overlayPane.removeChild(this._image);

                    map.off('viewreset', this._reset, this);

                    if (map.options.zoomAnimation) {
                        map.off('zoomanim', this._animateZoom, this);
                    }
                },

                addTo: function(map) {
                    map.addLayer(this);
                    return this;
                },

                setOpacity: function(opacity) {
                    this.options.opacity = opacity;
                    this._updateOpacity();
                    return this;
                },

                // TODO remove bringToFront/bringToBack duplication from TileLayer/Path
                bringToFront: function() {
                    if (this._image) {
                        this._map._panes.overlayPane.appendChild(this._image);
                    }
                    return this;
                },

                bringToBack: function() {
                    var pane = this._map._panes.overlayPane;
                    if (this._image) {
                        pane.insertBefore(this._image, pane.firstChild);
                    }
                    return this;
                },

                setUrl: function(url) {
                    this._url = url;
                    this._image.src = this._url;
                },

                getAttribution: function() {
                    return this.options.attribution;
                },

                _initImage: function() {
                    this._image = L.DomUtil.create('img', 'leaflet-image-layer');

                    if (this._map.options.zoomAnimation && L.Browser.any3d) {
                        L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
                    } else {
                        L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
                    }

                    this._updateOpacity();

                    //TODO createImage util method to remove duplication
                    L.extend(this._image, {
                        galleryimg: 'no',
                        onselectstart: L.Util.falseFn,
                        onmousemove: L.Util.falseFn,
                        onload: L.bind(this._onImageLoad, this),
                        src: this._url
                    });
                },

                _animateZoom: function(e) {
                    var map = this._map,
                        image = this._image,
                        scale = map.getZoomScale(e.zoom),
                        nw = this._bounds.getNorthWest(),
                        se = this._bounds.getSouthEast(),

                        topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
                        size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
                        origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

                    image.style[L.DomUtil.TRANSFORM] =
                        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
                },

                _reset: function() {
                    var image = this._image,
                        topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                        size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);

                    L.DomUtil.setPosition(image, topLeft);

                    image.style.width = size.x + 'px';
                    image.style.height = size.y + 'px';
                },

                _onImageLoad: function() {
                    this.fire('load');
                },

                _updateOpacity: function() {
                    L.DomUtil.setOpacity(this._image, this.options.opacity);
                }
            });

            L.imageOverlay = function(url, bounds, options) {
                return new L.ImageOverlay(url, bounds, options);
            };


            /*
             * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
             */

            L.Icon = L.Class.extend({
                options: {
                    /*
                    iconUrl: (String) (required)
                    iconRetinaUrl: (String) (optional, used for retina devices if detected)
                    iconSize: (Point) (can be set through CSS)
                    iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
                    popupAnchor: (Point) (if not specified, popup opens in the anchor point)
                    shadowUrl: (String) (no shadow by default)
                    shadowRetinaUrl: (String) (optional, used for retina devices if detected)
                    shadowSize: (Point)
                    shadowAnchor: (Point)
                    */
                    className: ''
                },

                initialize: function(options) {
                    L.setOptions(this, options);
                },

                createIcon: function(oldIcon) {
                    return this._createIcon('icon', oldIcon);
                },

                createShadow: function(oldIcon) {
                    return this._createIcon('shadow', oldIcon);
                },

                _createIcon: function(name, oldIcon) {
                    var src = this._getIconUrl(name);

                    if (!src) {
                        if (name === 'icon') {
                            throw new Error('iconUrl not set in Icon options (see the docs).');
                        }
                        return null;
                    }

                    var img;
                    if (!oldIcon || oldIcon.tagName !== 'IMG') {
                        img = this._createImg(src);
                    } else {
                        img = this._createImg(src, oldIcon);
                    }
                    this._setIconStyles(img, name);

                    return img;
                },

                _setIconStyles: function(img, name) {
                    var options = this.options,
                        size = L.point(options[name + 'Size']),
                        anchor;

                    if (name === 'shadow') {
                        anchor = L.point(options.shadowAnchor || options.iconAnchor);
                    } else {
                        anchor = L.point(options.iconAnchor);
                    }

                    if (!anchor && size) {
                        anchor = size.divideBy(2, true);
                    }

                    img.className = 'leaflet-marker-' + name + ' ' + options.className;

                    if (anchor) {
                        img.style.marginLeft = (-anchor.x) + 'px';
                        img.style.marginTop = (-anchor.y) + 'px';
                    }

                    if (size) {
                        img.style.width = size.x + 'px';
                        img.style.height = size.y + 'px';
                    }
                },

                _createImg: function(src, el) {
                    el = el || document.createElement('img');
                    el.src = src;
                    return el;
                },

                _getIconUrl: function(name) {
                    if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
                        return this.options[name + 'RetinaUrl'];
                    }
                    return this.options[name + 'Url'];
                }
            });

            L.icon = function(options) {
                return new L.Icon(options);
            };


            /*
             * L.Icon.Default is the blue marker icon used by default in Leaflet.
             */

            L.Icon.Default = L.Icon.extend({

                options: {
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],

                    shadowSize: [41, 41]
                },

                _getIconUrl: function(name) {
                    var key = name + 'Url';

                    if (this.options[key]) {
                        return this.options[key];
                    }

                    if (L.Browser.retina && name === 'icon') {
                        name += '-2x';
                    }

                    var path = L.Icon.Default.imagePath;

                    if (!path) {
                        throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
                    }

                    return path + '/marker-' + name + '.png';
                }
            });

            L.Icon.Default.imagePath = (function() {
                var scripts = document.getElementsByTagName('script'),
                    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

                var i, len, src, matches, path;

                for (i = 0, len = scripts.length; i < len; i++) {
                    src = scripts[i].src;
                    matches = src.match(leafletRe);

                    if (matches) {
                        path = src.split(leafletRe)[0];
                        return (path ? path + '/' : '') + 'images';
                    }
                }
            }());


            /*
             * L.Marker is used to display clickable/draggable icons on the map.
             */

            L.Marker = L.Class.extend({

                includes: L.Mixin.Events,

                options: {
                    icon: new L.Icon.Default(),
                    title: '',
                    alt: '',
                    clickable: true,
                    draggable: false,
                    keyboard: true,
                    zIndexOffset: 0,
                    opacity: 1,
                    riseOnHover: false,
                    riseOffset: 250
                },

                initialize: function(latlng, options) {
                    L.setOptions(this, options);
                    this._latlng = L.latLng(latlng);
                },

                onAdd: function(map) {
                    this._map = map;

                    map.on('viewreset', this.update, this);

                    this._initIcon();
                    this.update();
                    this.fire('add');

                    if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
                        map.on('zoomanim', this._animateZoom, this);
                    }
                },

                addTo: function(map) {
                    map.addLayer(this);
                    return this;
                },

                onRemove: function(map) {
                    if (this.dragging) {
                        this.dragging.disable();
                    }

                    this._removeIcon();
                    this._removeShadow();

                    this.fire('remove');

                    map.off({
                        'viewreset': this.update,
                        'zoomanim': this._animateZoom
                    }, this);

                    this._map = null;
                },

                getLatLng: function() {
                    return this._latlng;
                },

                setLatLng: function(latlng) {
                    this._latlng = L.latLng(latlng);

                    this.update();

                    return this.fire('move', {
                        latlng: this._latlng
                    });
                },

                setZIndexOffset: function(offset) {
                    this.options.zIndexOffset = offset;
                    this.update();

                    return this;
                },

                setIcon: function(icon) {

                    this.options.icon = icon;

                    if (this._map) {
                        this._initIcon();
                        this.update();
                    }

                    if (this._popup) {
                        this.bindPopup(this._popup);
                    }

                    return this;
                },

                update: function() {
                    if (this._icon) {
                        this._setPos(this._map.latLngToLayerPoint(this._latlng).round());
                    }
                    return this;
                },

                _initIcon: function() {
                    var options = this.options,
                        map = this._map,
                        animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
                        classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

                    var icon = options.icon.createIcon(this._icon),
                        addIcon = false;

                    // if we're not reusing the icon, remove the old one and init new one
                    if (icon !== this._icon) {
                        if (this._icon) {
                            this._removeIcon();
                        }
                        addIcon = true;

                        if (options.title) {
                            icon.title = options.title;
                        }

                        if (options.alt) {
                            icon.alt = options.alt;
                        }
                    }

                    L.DomUtil.addClass(icon, classToAdd);

                    if (options.keyboard) {
                        icon.tabIndex = '0';
                    }

                    this._icon = icon;

                    this._initInteraction();

                    if (options.riseOnHover) {
                        L.DomEvent
                            .on(icon, 'mouseover', this._bringToFront, this)
                            .on(icon, 'mouseout', this._resetZIndex, this);
                    }

                    var newShadow = options.icon.createShadow(this._shadow),
                        addShadow = false;

                    if (newShadow !== this._shadow) {
                        this._removeShadow();
                        addShadow = true;
                    }

                    if (newShadow) {
                        L.DomUtil.addClass(newShadow, classToAdd);
                    }
                    this._shadow = newShadow;


                    if (options.opacity < 1) {
                        this._updateOpacity();
                    }


                    var panes = this._map._panes;

                    if (addIcon) {
                        panes.markerPane.appendChild(this._icon);
                    }

                    if (newShadow && addShadow) {
                        panes.shadowPane.appendChild(this._shadow);
                    }
                },

                _removeIcon: function() {
                    if (this.options.riseOnHover) {
                        L.DomEvent
                            .off(this._icon, 'mouseover', this._bringToFront)
                            .off(this._icon, 'mouseout', this._resetZIndex);
                    }

                    this._map._panes.markerPane.removeChild(this._icon);

                    this._icon = null;
                },

                _removeShadow: function() {
                    if (this._shadow) {
                        this._map._panes.shadowPane.removeChild(this._shadow);
                    }
                    this._shadow = null;
                },

                _setPos: function(pos) {
                    L.DomUtil.setPosition(this._icon, pos);

                    if (this._shadow) {
                        L.DomUtil.setPosition(this._shadow, pos);
                    }

                    this._zIndex = pos.y + this.options.zIndexOffset;

                    this._resetZIndex();
                },

                _updateZIndex: function(offset) {
                    this._icon.style.zIndex = this._zIndex + offset;
                },

                _animateZoom: function(opt) {
                    var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

                    this._setPos(pos);
                },

                _initInteraction: function() {

                    if (!this.options.clickable) {
                        return;
                    }

                    // TODO refactor into something shared with Map/Path/etc. to DRY it up

                    var icon = this._icon,
                        events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];

                    L.DomUtil.addClass(icon, 'leaflet-clickable');
                    L.DomEvent.on(icon, 'click', this._onMouseClick, this);
                    L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);

                    for (var i = 0; i < events.length; i++) {
                        L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
                    }

                    if (L.Handler.MarkerDrag) {
                        this.dragging = new L.Handler.MarkerDrag(this);

                        if (this.options.draggable) {
                            this.dragging.enable();
                        }
                    }
                },

                _onMouseClick: function(e) {
                    var wasDragged = this.dragging && this.dragging.moved();

                    if (this.hasEventListeners(e.type) || wasDragged) {
                        L.DomEvent.stopPropagation(e);
                    }

                    if (wasDragged) {
                        return;
                    }

                    if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) {
                        return;
                    }

                    this.fire(e.type, {
                        originalEvent: e,
                        latlng: this._latlng
                    });
                },

                _onKeyPress: function(e) {
                    if (e.keyCode === 13) {
                        this.fire('click', {
                            originalEvent: e,
                            latlng: this._latlng
                        });
                    }
                },

                _fireMouseEvent: function(e) {

                    this.fire(e.type, {
                        originalEvent: e,
                        latlng: this._latlng
                    });

                    // TODO proper custom event propagation
                    // this line will always be called if marker is in a FeatureGroup
                    if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
                        L.DomEvent.preventDefault(e);
                    }
                    if (e.type !== 'mousedown') {
                        L.DomEvent.stopPropagation(e);
                    } else {
                        L.DomEvent.preventDefault(e);
                    }
                },

                setOpacity: function(opacity) {
                    this.options.opacity = opacity;
                    if (this._map) {
                        this._updateOpacity();
                    }

                    return this;
                },

                _updateOpacity: function() {
                    L.DomUtil.setOpacity(this._icon, this.options.opacity);
                    if (this._shadow) {
                        L.DomUtil.setOpacity(this._shadow, this.options.opacity);
                    }
                },

                _bringToFront: function() {
                    this._updateZIndex(this.options.riseOffset);
                },

                _resetZIndex: function() {
                    this._updateZIndex(0);
                }
            });

            L.marker = function(latlng, options) {
                return new L.Marker(latlng, options);
            };


            /*
             * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
             * to use with L.Marker.
             */

            L.DivIcon = L.Icon.extend({
                options: {
                    iconSize: [12, 12], // also can be set through CSS
                    /*
                    iconAnchor: (Point)
                    popupAnchor: (Point)
                    html: (String)
                    bgPos: (Point)
                    */
                    className: 'leaflet-div-icon',
                    html: false
                },

                createIcon: function(oldIcon) {
                    var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
                        options = this.options;

                    if (options.html !== false) {
                        div.innerHTML = options.html;
                    } else {
                        div.innerHTML = '';
                    }

                    if (options.bgPos) {
                        div.style.backgroundPosition =
                            (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
                    }

                    this._setIconStyles(div, 'icon');
                    return div;
                },

                createShadow: function() {
                    return null;
                }
            });

            L.divIcon = function(options) {
                return new L.DivIcon(options);
            };


            /*
             * L.Popup is used for displaying popups on the map.
             */

            L.Map.mergeOptions({
                closePopupOnClick: true
            });

            L.Popup = L.Class.extend({
                includes: L.Mixin.Events,

                options: {
                    minWidth: 50,
                    maxWidth: 300,
                    // maxHeight: null,
                    autoPan: true,
                    closeButton: true,
                    offset: [0, 7],
                    autoPanPadding: [5, 5],
                    // autoPanPaddingTopLeft: null,
                    // autoPanPaddingBottomRight: null,
                    keepInView: false,
                    className: '',
                    zoomAnimation: true
                },

                initialize: function(options, source) {
                    L.setOptions(this, options);

                    this._source = source;
                    this._animated = L.Browser.any3d && this.options.zoomAnimation;
                    this._isOpen = false;
                },

                onAdd: function(map) {
                    this._map = map;

                    if (!this._container) {
                        this._initLayout();
                    }

                    var animFade = map.options.fadeAnimation;

                    if (animFade) {
                        L.DomUtil.setOpacity(this._container, 0);
                    }
                    map._panes.popupPane.appendChild(this._container);

                    map.on(this._getEvents(), this);

                    this.update();

                    if (animFade) {
                        L.DomUtil.setOpacity(this._container, 1);
                    }

                    this.fire('open');

                    map.fire('popupopen', {
                        popup: this
                    });

                    if (this._source) {
                        this._source.fire('popupopen', {
                            popup: this
                        });
                    }
                },

                addTo: function(map) {
                    map.addLayer(this);
                    return this;
                },

                openOn: function(map) {
                    map.openPopup(this);
                    return this;
                },

                onRemove: function(map) {
                    map._panes.popupPane.removeChild(this._container);

                    L.Util.falseFn(this._container.offsetWidth); // force reflow

                    map.off(this._getEvents(), this);

                    if (map.options.fadeAnimation) {
                        L.DomUtil.setOpacity(this._container, 0);
                    }

                    this._map = null;

                    this.fire('close');

                    map.fire('popupclose', {
                        popup: this
                    });

                    if (this._source) {
                        this._source.fire('popupclose', {
                            popup: this
                        });
                    }
                },

                getLatLng: function() {
                    return this._latlng;
                },

                setLatLng: function(latlng) {
                    this._latlng = L.latLng(latlng);
                    if (this._map) {
                        this._updatePosition();
                        this._adjustPan();
                    }
                    return this;
                },

                getContent: function() {
                    return this._content;
                },

                setContent: function(content) {
                    this._content = content;
                    this.update();
                    return this;
                },

                update: function() {
                    if (!this._map) {
                        return;
                    }

                    this._container.style.visibility = 'hidden';

                    this._updateContent();
                    this._updateLayout();
                    this._updatePosition();

                    this._container.style.visibility = '';

                    this._adjustPan();
                },

                _getEvents: function() {
                    var events = {
                        viewreset: this._updatePosition
                    };

                    if (this._animated) {
                        events.zoomanim = this._zoomAnimation;
                    }
                    if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
                        events.preclick = this._close;
                    }
                    if (this.options.keepInView) {
                        events.moveend = this._adjustPan;
                    }

                    return events;
                },

                _close: function() {
                    if (this._map) {
                        this._map.closePopup(this);
                    }
                },

                _initLayout: function() {
                    var prefix = 'leaflet-popup',
                        containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +
                        (this._animated ? 'animated' : 'hide'),
                        container = this._container = L.DomUtil.create('div', containerClass),
                        closeButton;

                    if (this.options.closeButton) {
                        closeButton = this._closeButton =
                            L.DomUtil.create('a', prefix + '-close-button', container);
                        closeButton.href = '#close';
                        closeButton.innerHTML = '&#215;';
                        L.DomEvent.disableClickPropagation(closeButton);

                        L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
                    }

                    var wrapper = this._wrapper =
                        L.DomUtil.create('div', prefix + '-content-wrapper', container);
                    L.DomEvent.disableClickPropagation(wrapper);

                    this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

                    L.DomEvent.disableScrollPropagation(this._contentNode);
                    L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

                    this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
                    this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
                },

                _updateContent: function() {
                    if (!this._content) {
                        return;
                    }

                    if (typeof this._content === 'string') {
                        this._contentNode.innerHTML = this._content;
                    } else {
                        while (this._contentNode.hasChildNodes()) {
                            this._contentNode.removeChild(this._contentNode.firstChild);
                        }
                        this._contentNode.appendChild(this._content);
                    }
                    this.fire('contentupdate');
                },

                _updateLayout: function() {
                    var container = this._contentNode,
                        style = container.style;

                    style.width = '';
                    style.whiteSpace = 'nowrap';

                    var width = container.offsetWidth;
                    width = Math.min(width, this.options.maxWidth);
                    width = Math.max(width, this.options.minWidth);

                    style.width = (width + 1) + 'px';
                    style.whiteSpace = '';

                    style.height = '';

                    var height = container.offsetHeight,
                        maxHeight = this.options.maxHeight,
                        scrolledClass = 'leaflet-popup-scrolled';

                    if (maxHeight && height > maxHeight) {
                        style.height = maxHeight + 'px';
                        L.DomUtil.addClass(container, scrolledClass);
                    } else {
                        L.DomUtil.removeClass(container, scrolledClass);
                    }

                    this._containerWidth = this._container.offsetWidth;
                },

                _updatePosition: function() {
                    if (!this._map) {
                        return;
                    }

                    var pos = this._map.latLngToLayerPoint(this._latlng),
                        animated = this._animated,
                        offset = L.point(this.options.offset);

                    if (animated) {
                        L.DomUtil.setPosition(this._container, pos);
                    }

                    this._containerBottom = -offset.y - (animated ? 0 : pos.y);
                    this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);

                    // bottom position the popup in case the height of the popup changes (images loading etc)
                    this._container.style.bottom = this._containerBottom + 'px';
                    this._container.style.left = this._containerLeft + 'px';
                },

                _zoomAnimation: function(opt) {
                    var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);

                    L.DomUtil.setPosition(this._container, pos);
                },

                _adjustPan: function() {
                    if (!this.options.autoPan) {
                        return;
                    }

                    var map = this._map,
                        containerHeight = this._container.offsetHeight,
                        containerWidth = this._containerWidth,

                        layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

                    if (this._animated) {
                        layerPos._add(L.DomUtil.getPosition(this._container));
                    }

                    var containerPos = map.layerPointToContainerPoint(layerPos),
                        padding = L.point(this.options.autoPanPadding),
                        paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
                        paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
                        size = map.getSize(),
                        dx = 0,
                        dy = 0;

                    if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
                        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
                    }
                    if (containerPos.x - dx - paddingTL.x < 0) { // left
                        dx = containerPos.x - paddingTL.x;
                    }
                    if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
                        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
                    }
                    if (containerPos.y - dy - paddingTL.y < 0) { // top
                        dy = containerPos.y - paddingTL.y;
                    }

                    if (dx || dy) {
                        map
                            .fire('autopanstart')
                            .panBy([dx, dy]);
                    }
                },

                _onCloseButtonClick: function(e) {
                    this._close();
                    L.DomEvent.stop(e);
                }
            });

            L.popup = function(options, source) {
                return new L.Popup(options, source);
            };


            L.Map.include({
                openPopup: function(popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
                    this.closePopup();

                    if (!(popup instanceof L.Popup)) {
                        var content = popup;

                        popup = new L.Popup(options)
                            .setLatLng(latlng)
                            .setContent(content);
                    }
                    popup._isOpen = true;

                    this._popup = popup;
                    return this.addLayer(popup);
                },

                closePopup: function(popup) {
                    if (!popup || popup === this._popup) {
                        popup = this._popup;
                        this._popup = null;
                    }
                    if (popup) {
                        this.removeLayer(popup);
                        popup._isOpen = false;
                    }
                    return this;
                }
            });


            /*
             * Popup extension to L.Marker, adding popup-related methods.
             */

            L.Marker.include({
                openPopup: function() {
                    if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
                        this._popup.setLatLng(this._latlng);
                        this._map.openPopup(this._popup);
                    }

                    return this;
                },

                closePopup: function() {
                    if (this._popup) {
                        this._popup._close();
                    }
                    return this;
                },

                togglePopup: function() {
                    if (this._popup) {
                        if (this._popup._isOpen) {
                            this.closePopup();
                        } else {
                            this.openPopup();
                        }
                    }
                    return this;
                },

                bindPopup: function(content, options) {
                    var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);

                    anchor = anchor.add(L.Popup.prototype.options.offset);

                    if (options && options.offset) {
                        anchor = anchor.add(options.offset);
                    }

                    options = L.extend({
                        offset: anchor
                    }, options);

                    if (!this._popupHandlersAdded) {
                        this
                            .on('click', this.togglePopup, this)
                            .on('remove', this.closePopup, this)
                            .on('move', this._movePopup, this);
                        this._popupHandlersAdded = true;
                    }

                    if (content instanceof L.Popup) {
                        L.setOptions(content, options);
                        this._popup = content;
                        content._source = this;
                    } else {
                        this._popup = new L.Popup(options, this)
                            .setContent(content);
                    }

                    return this;
                },

                setPopupContent: function(content) {
                    if (this._popup) {
                        this._popup.setContent(content);
                    }
                    return this;
                },

                unbindPopup: function() {
                    if (this._popup) {
                        this._popup = null;
                        this
                            .off('click', this.togglePopup, this)
                            .off('remove', this.closePopup, this)
                            .off('move', this._movePopup, this);
                        this._popupHandlersAdded = false;
                    }
                    return this;
                },

                getPopup: function() {
                    return this._popup;
                },

                _movePopup: function(e) {
                    this._popup.setLatLng(e.latlng);
                }
            });


            /*
             * L.LayerGroup is a class to combine several layers into one so that
             * you can manipulate the group (e.g. add/remove it) as one layer.
             */

            L.LayerGroup = L.Class.extend({
                initialize: function(layers) {
                    this._layers = {};

                    var i, len;

                    if (layers) {
                        for (i = 0, len = layers.length; i < len; i++) {
                            this.addLayer(layers[i]);
                        }
                    }
                },

                addLayer: function(layer) {
                    var id = this.getLayerId(layer);

                    this._layers[id] = layer;

                    if (this._map) {
                        this._map.addLayer(layer);
                    }

                    return this;
                },

                removeLayer: function(layer) {
                    var id = layer in this._layers ? layer : this.getLayerId(layer);

                    if (this._map && this._layers[id]) {
                        this._map.removeLayer(this._layers[id]);
                    }

                    delete this._layers[id];

                    return this;
                },

                hasLayer: function(layer) {
                    if (!layer) {
                        return false;
                    }

                    return (layer in this._layers || this.getLayerId(layer) in this._layers);
                },

                clearLayers: function() {
                    this.eachLayer(this.removeLayer, this);
                    return this;
                },

                invoke: function(methodName) {
                    var args = Array.prototype.slice.call(arguments, 1),
                        i, layer;

                    for (i in this._layers) {
                        layer = this._layers[i];

                        if (layer[methodName]) {
                            layer[methodName].apply(layer, args);
                        }
                    }

                    return this;
                },

                onAdd: function(map) {
                    this._map = map;
                    this.eachLayer(map.addLayer, map);
                },

                onRemove: function(map) {
                    this.eachLayer(map.removeLayer, map);
                    this._map = null;
                },

                addTo: function(map) {
                    map.addLayer(this);
                    return this;
                },

                eachLayer: function(method, context) {
                    for (var i in this._layers) {
                        method.call(context, this._layers[i]);
                    }
                    return this;
                },

                getLayer: function(id) {
                    return this._layers[id];
                },

                getLayers: function() {
                    var layers = [];

                    for (var i in this._layers) {
                        layers.push(this._layers[i]);
                    }
                    return layers;
                },

                setZIndex: function(zIndex) {
                    return this.invoke('setZIndex', zIndex);
                },

                getLayerId: function(layer) {
                    return L.stamp(layer);
                }
            });

            L.layerGroup = function(layers) {
                return new L.LayerGroup(layers);
            };


            /*
             * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
             * shared between a group of interactive layers (like vectors or markers).
             */

            L.FeatureGroup = L.LayerGroup.extend({
                includes: L.Mixin.Events,

                statics: {
                    EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'
                },

                addLayer: function(layer) {
                    if (this.hasLayer(layer)) {
                        return this;
                    }

                    if ('on' in layer) {
                        layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
                    }

                    L.LayerGroup.prototype.addLayer.call(this, layer);

                    if (this._popupContent && layer.bindPopup) {
                        layer.bindPopup(this._popupContent, this._popupOptions);
                    }

                    return this.fire('layeradd', {
                        layer: layer
                    });
                },

                removeLayer: function(layer) {
                    if (!this.hasLayer(layer)) {
                        return this;
                    }
                    if (layer in this._layers) {
                        layer = this._layers[layer];
                    }

                    if ('off' in layer) {
                        layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);
                    }

                    L.LayerGroup.prototype.removeLayer.call(this, layer);

                    if (this._popupContent) {
                        this.invoke('unbindPopup');
                    }

                    return this.fire('layerremove', {
                        layer: layer
                    });
                },

                bindPopup: function(content, options) {
                    this._popupContent = content;
                    this._popupOptions = options;
                    return this.invoke('bindPopup', content, options);
                },

                openPopup: function(latlng) {
                    // open popup on the first layer
                    for (var id in this._layers) {
                        this._layers[id].openPopup(latlng);
                        break;
                    }
                    return this;
                },

                setStyle: function(style) {
                    return this.invoke('setStyle', style);
                },

                bringToFront: function() {
                    return this.invoke('bringToFront');
                },

                bringToBack: function() {
                    return this.invoke('bringToBack');
                },

                getBounds: function() {
                    var bounds = new L.LatLngBounds();

                    this.eachLayer(function(layer) {
                        bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
                    });

                    return bounds;
                },

                _propagateEvent: function(e) {
                    e = L.extend({
                        layer: e.target,
                        target: this
                    }, e);
                    this.fire(e.type, e);
                }
            });

            L.featureGroup = function(layers) {
                return new L.FeatureGroup(layers);
            };


            /*
             * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
             */

            L.Path = L.Class.extend({
                includes: [L.Mixin.Events],

                statics: {
                    // how much to extend the clip area around the map view
                    // (relative to its size, e.g. 0.5 is half the screen in each direction)
                    // set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
                    CLIP_PADDING: (function() {
                        var max = L.Browser.mobile ? 1280 : 2000,
                            target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
                        return Math.max(0, Math.min(0.5, target));
                    })()
                },

                options: {
                    stroke: true,
                    color: '#0033ff',
                    dashArray: null,
                    lineCap: null,
                    lineJoin: null,
                    weight: 5,
                    opacity: 0.5,

                    fill: false,
                    fillColor: null, //same as color by default
                    fillOpacity: 0.2,

                    clickable: true
                },

                initialize: function(options) {
                    L.setOptions(this, options);
                },

                onAdd: function(map) {
                    this._map = map;

                    if (!this._container) {
                        this._initElements();
                        this._initEvents();
                    }

                    this.projectLatlngs();
                    this._updatePath();

                    if (this._container) {
                        this._map._pathRoot.appendChild(this._container);
                    }

                    this.fire('add');

                    map.on({
                        'viewreset': this.projectLatlngs,
                        'moveend': this._updatePath
                    }, this);
                },

                addTo: function(map) {
                    map.addLayer(this);
                    return this;
                },

                onRemove: function(map) {
                    map._pathRoot.removeChild(this._container);

                    // Need to fire remove event before we set _map to null as the event hooks might need the object
                    this.fire('remove');
                    this._map = null;

                    if (L.Browser.vml) {
                        this._container = null;
                        this._stroke = null;
                        this._fill = null;
                    }

                    map.off({
                        'viewreset': this.projectLatlngs,
                        'moveend': this._updatePath
                    }, this);
                },

                projectLatlngs: function() {
                    // do all projection stuff here
                },

                setStyle: function(style) {
                    L.setOptions(this, style);

                    if (this._container) {
                        this._updateStyle();
                    }

                    return this;
                },

                redraw: function() {
                    if (this._map) {
                        this.projectLatlngs();
                        this._updatePath();
                    }
                    return this;
                }
            });

            L.Map.include({
                _updatePathViewport: function() {
                    var p = L.Path.CLIP_PADDING,
                        size = this.getSize(),
                        panePos = L.DomUtil.getPosition(this._mapPane),
                        min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
                        max = min.add(size.multiplyBy(1 + p * 2)._round());

                    this._pathViewport = new L.Bounds(min, max);
                }
            });


            /*
             * Extends L.Path with SVG-specific rendering code.
             */

            L.Path.SVG_NS = 'http://www.w3.org/2000/svg';

            L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);

            L.Path = L.Path.extend({
                statics: {
                    SVG: L.Browser.svg
                },

                bringToFront: function() {
                    var root = this._map._pathRoot,
                        path = this._container;

                    if (path && root.lastChild !== path) {
                        root.appendChild(path);
                    }
                    return this;
                },

                bringToBack: function() {
                    var root = this._map._pathRoot,
                        path = this._container,
                        first = root.firstChild;

                    if (path && first !== path) {
                        root.insertBefore(path, first);
                    }
                    return this;
                },

                getPathString: function() {
                    // form path string here
                },

                _createElement: function(name) {
                    return document.createElementNS(L.Path.SVG_NS, name);
                },

                _initElements: function() {
                    this._map._initPathRoot();
                    this._initPath();
                    this._initStyle();
                },

                _initPath: function() {
                    this._container = this._createElement('g');

                    this._path = this._createElement('path');

                    if (this.options.className) {
                        L.DomUtil.addClass(this._path, this.options.className);
                    }

                    this._container.appendChild(this._path);
                },

                _initStyle: function() {
                    if (this.options.stroke) {
                        this._path.setAttribute('stroke-linejoin', 'round');
                        this._path.setAttribute('stroke-linecap', 'round');
                    }
                    if (this.options.fill) {
                        this._path.setAttribute('fill-rule', 'evenodd');
                    }
                    if (this.options.pointerEvents) {
                        this._path.setAttribute('pointer-events', this.options.pointerEvents);
                    }
                    if (!this.options.clickable && !this.options.pointerEvents) {
                        this._path.setAttribute('pointer-events', 'none');
                    }
                    this._updateStyle();
                },

                _updateStyle: function() {
                    if (this.options.stroke) {
                        this._path.setAttribute('stroke', this.options.color);
                        this._path.setAttribute('stroke-opacity', this.options.opacity);
                        this._path.setAttribute('stroke-width', this.options.weight);
                        if (this.options.dashArray) {
                            this._path.setAttribute('stroke-dasharray', this.options.dashArray);
                        } else {
                            this._path.removeAttribute('stroke-dasharray');
                        }
                        if (this.options.lineCap) {
                            this._path.setAttribute('stroke-linecap', this.options.lineCap);
                        }
                        if (this.options.lineJoin) {
                            this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
                        }
                    } else {
                        this._path.setAttribute('stroke', 'none');
                    }
                    if (this.options.fill) {
                        this._path.setAttribute('fill', this.options.fillColor || this.options.color);
                        this._path.setAttribute('fill-opacity', this.options.fillOpacity);
                    } else {
                        this._path.setAttribute('fill', 'none');
                    }
                },

                _updatePath: function() {
                    var str = this.getPathString();
                    if (!str) {
                        // fix webkit empty string parsing bug
                        str = 'M0 0';
                    }
                    this._path.setAttribute('d', str);
                },

                // TODO remove duplication with L.Map
                _initEvents: function() {
                    if (this.options.clickable) {
                        if (L.Browser.svg || !L.Browser.vml) {
                            L.DomUtil.addClass(this._path, 'leaflet-clickable');
                        }

                        L.DomEvent.on(this._container, 'click', this._onMouseClick, this);

                        var events = ['dblclick', 'mousedown', 'mouseover',
                            'mouseout', 'mousemove', 'contextmenu'
                        ];
                        for (var i = 0; i < events.length; i++) {
                            L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
                        }
                    }
                },

                _onMouseClick: function(e) {
                    if (this._map.dragging && this._map.dragging.moved()) {
                        return;
                    }

                    this._fireMouseEvent(e);
                },

                _fireMouseEvent: function(e) {
                    if (!this._map || !this.hasEventListeners(e.type)) {
                        return;
                    }

                    var map = this._map,
                        containerPoint = map.mouseEventToContainerPoint(e),
                        layerPoint = map.containerPointToLayerPoint(containerPoint),
                        latlng = map.layerPointToLatLng(layerPoint);

                    this.fire(e.type, {
                        latlng: latlng,
                        layerPoint: layerPoint,
                        containerPoint: containerPoint,
                        originalEvent: e
                    });

                    if (e.type === 'contextmenu') {
                        L.DomEvent.preventDefault(e);
                    }
                    if (e.type !== 'mousemove') {
                        L.DomEvent.stopPropagation(e);
                    }
                }
            });

            L.Map.include({
                _initPathRoot: function() {
                    if (!this._pathRoot) {
                        this._pathRoot = L.Path.prototype._createElement('svg');
                        this._panes.overlayPane.appendChild(this._pathRoot);

                        if (this.options.zoomAnimation && L.Browser.any3d) {
                            L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');

                            this.on({
                                'zoomanim': this._animatePathZoom,
                                'zoomend': this._endPathZoom
                            });
                        } else {
                            L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
                        }

                        this.on('moveend', this._updateSvgViewport);
                        this._updateSvgViewport();
                    }
                },

                _animatePathZoom: function(e) {
                    var scale = this.getZoomScale(e.zoom),
                        offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);

                    this._pathRoot.style[L.DomUtil.TRANSFORM] =
                        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';

                    this._pathZooming = true;
                },

                _endPathZoom: function() {
                    this._pathZooming = false;
                },

                _updateSvgViewport: function() {

                    if (this._pathZooming) {
                        // Do not update SVGs while a zoom animation is going on otherwise the animation will break.
                        // When the zoom animation ends we will be updated again anyway
                        // This fixes the case where you do a momentum move and zoom while the move is still ongoing.
                        return;
                    }

                    this._updatePathViewport();

                    var vp = this._pathViewport,
                        min = vp.min,
                        max = vp.max,
                        width = max.x - min.x,
                        height = max.y - min.y,
                        root = this._pathRoot,
                        pane = this._panes.overlayPane;

                    // Hack to make flicker on drag end on mobile webkit less irritating
                    if (L.Browser.mobileWebkit) {
                        pane.removeChild(root);
                    }

                    L.DomUtil.setPosition(root, min);
                    root.setAttribute('width', width);
                    root.setAttribute('height', height);
                    root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));

                    if (L.Browser.mobileWebkit) {
                        pane.appendChild(root);
                    }
                }
            });


            /*
             * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
             */

            L.Path.include({

                bindPopup: function(content, options) {

                    if (content instanceof L.Popup) {
                        this._popup = content;
                    } else {
                        if (!this._popup || options) {
                            this._popup = new L.Popup(options, this);
                        }
                        this._popup.setContent(content);
                    }

                    if (!this._popupHandlersAdded) {
                        this
                            .on('click', this._openPopup, this)
                            .on('remove', this.closePopup, this);

                        this._popupHandlersAdded = true;
                    }

                    return this;
                },

                unbindPopup: function() {
                    if (this._popup) {
                        this._popup = null;
                        this
                            .off('click', this._openPopup)
                            .off('remove', this.closePopup);

                        this._popupHandlersAdded = false;
                    }
                    return this;
                },

                openPopup: function(latlng) {

                    if (this._popup) {
                        // open the popup from one of the path's points if not specified
                        latlng = latlng || this._latlng ||
                            this._latlngs[Math.floor(this._latlngs.length / 2)];

                        this._openPopup({
                            latlng: latlng
                        });
                    }

                    return this;
                },

                closePopup: function() {
                    if (this._popup) {
                        this._popup._close();
                    }
                    return this;
                },

                _openPopup: function(e) {
                    this._popup.setLatLng(e.latlng);
                    this._map.openPopup(this._popup);
                }
            });


            /*
             * Vector rendering for IE6-8 through VML.
             * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
             */

            L.Browser.vml = !L.Browser.svg && (function() {
                try {
                    var div = document.createElement('div');
                    div.innerHTML = '<v:shape adj="1"/>';

                    var shape = div.firstChild;
                    shape.style.behavior = 'url(#default#VML)';

                    return shape && (typeof shape.adj === 'object');

                } catch (e) {
                    return false;
                }
            }());

            L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
                statics: {
                    VML: true,
                    CLIP_PADDING: 0.02
                },

                _createElement: (function() {
                    try {
                        document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
                        return function(name) {
                            return document.createElement('<lvml:' + name + ' class="lvml">');
                        };
                    } catch (e) {
                        return function(name) {
                            return document.createElement(
                                '<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                        };
                    }
                }()),

                _initPath: function() {
                    var container = this._container = this._createElement('shape');

                    L.DomUtil.addClass(container, 'leaflet-vml-shape' +
                        (this.options.className ? ' ' + this.options.className : ''));

                    if (this.options.clickable) {
                        L.DomUtil.addClass(container, 'leaflet-clickable');
                    }

                    container.coordsize = '1 1';

                    this._path = this._createElement('path');
                    container.appendChild(this._path);

                    this._map._pathRoot.appendChild(container);
                },

                _initStyle: function() {
                    this._updateStyle();
                },

                _updateStyle: function() {
                    var stroke = this._stroke,
                        fill = this._fill,
                        options = this.options,
                        container = this._container;

                    container.stroked = options.stroke;
                    container.filled = options.fill;

                    if (options.stroke) {
                        if (!stroke) {
                            stroke = this._stroke = this._createElement('stroke');
                            stroke.endcap = 'round';
                            container.appendChild(stroke);
                        }
                        stroke.weight = options.weight + 'px';
                        stroke.color = options.color;
                        stroke.opacity = options.opacity;

                        if (options.dashArray) {
                            stroke.dashStyle = L.Util.isArray(options.dashArray) ?
                                options.dashArray.join(' ') :
                                options.dashArray.replace(/( *, *)/g, ' ');
                        } else {
                            stroke.dashStyle = '';
                        }
                        if (options.lineCap) {
                            stroke.endcap = options.lineCap.replace('butt', 'flat');
                        }
                        if (options.lineJoin) {
                            stroke.joinstyle = options.lineJoin;
                        }

                    } else if (stroke) {
                        container.removeChild(stroke);
                        this._stroke = null;
                    }

                    if (options.fill) {
                        if (!fill) {
                            fill = this._fill = this._createElement('fill');
                            container.appendChild(fill);
                        }
                        fill.color = options.fillColor || options.color;
                        fill.opacity = options.fillOpacity;

                    } else if (fill) {
                        container.removeChild(fill);
                        this._fill = null;
                    }
                },

                _updatePath: function() {
                    var style = this._container.style;

                    style.display = 'none';
                    this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug
                    style.display = '';
                }
            });

            L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
                _initPathRoot: function() {
                    if (this._pathRoot) {
                        return;
                    }

                    var root = this._pathRoot = document.createElement('div');
                    root.className = 'leaflet-vml-container';
                    this._panes.overlayPane.appendChild(root);

                    this.on('moveend', this._updatePathViewport);
                    this._updatePathViewport();
                }
            });


            /*
             * Vector rendering for all browsers that support canvas.
             */

            L.Browser.canvas = (function() {
                return !!document.createElement('canvas').getContext;
            }());

            L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
                statics: {
                    //CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
                    CANVAS: true,
                    SVG: false
                },

                redraw: function() {
                    if (this._map) {
                        this.projectLatlngs();
                        this._requestUpdate();
                    }
                    return this;
                },

                setStyle: function(style) {
                    L.setOptions(this, style);

                    if (this._map) {
                        this._updateStyle();
                        this._requestUpdate();
                    }
                    return this;
                },

                onRemove: function(map) {
                    map
                        .off('viewreset', this.projectLatlngs, this)
                        .off('moveend', this._updatePath, this);

                    if (this.options.clickable) {
                        this._map.off('click', this._onClick, this);
                        this._map.off('mousemove', this._onMouseMove, this);
                    }

                    this._requestUpdate();

                    this.fire('remove');
                    this._map = null;
                },

                _requestUpdate: function() {
                    if (this._map && !L.Path._updateRequest) {
                        L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
                    }
                },

                _fireMapMoveEnd: function() {
                    L.Path._updateRequest = null;
                    this.fire('moveend');
                },

                _initElements: function() {
                    this._map._initPathRoot();
                    this._ctx = this._map._canvasCtx;
                },

                _updateStyle: function() {
                    var options = this.options;

                    if (options.stroke) {
                        this._ctx.lineWidth = options.weight;
                        this._ctx.strokeStyle = options.color;
                    }
                    if (options.fill) {
                        this._ctx.fillStyle = options.fillColor || options.color;
                    }

                    if (options.lineCap) {
                        this._ctx.lineCap = options.lineCap;
                    }
                    if (options.lineJoin) {
                        this._ctx.lineJoin = options.lineJoin;
                    }
                },

                _drawPath: function() {
                    var i, j, len, len2, point, drawMethod;

                    this._ctx.beginPath();

                    for (i = 0, len = this._parts.length; i < len; i++) {
                        for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
                            point = this._parts[i][j];
                            drawMethod = (j === 0 ? 'move' : 'line') + 'To';

                            this._ctx[drawMethod](point.x, point.y);
                        }
                        // TODO refactor ugly hack
                        if (this instanceof L.Polygon) {
                            this._ctx.closePath();
                        }
                    }
                },

                _checkIfEmpty: function() {
                    return !this._parts.length;
                },

                _updatePath: function() {
                    if (this._checkIfEmpty()) {
                        return;
                    }

                    var ctx = this._ctx,
                        options = this.options;

                    this._drawPath();
                    ctx.save();
                    this._updateStyle();

                    if (options.fill) {
                        ctx.globalAlpha = options.fillOpacity;
                        ctx.fill(options.fillRule || 'evenodd');
                    }

                    if (options.stroke) {
                        ctx.globalAlpha = options.opacity;
                        ctx.stroke();
                    }

                    ctx.restore();

                    // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
                },

                _initEvents: function() {
                    if (this.options.clickable) {
                        this._map.on('mousemove', this._onMouseMove, this);
                        this._map.on('click dblclick contextmenu', this._fireMouseEvent, this);
                    }
                },

                _fireMouseEvent: function(e) {
                    if (this._containsPoint(e.layerPoint)) {
                        this.fire(e.type, e);
                    }
                },

                _onMouseMove: function(e) {
                    if (!this._map || this._map._animatingZoom) {
                        return;
                    }

                    // TODO don't do on each move
                    if (this._containsPoint(e.layerPoint)) {
                        this._ctx.canvas.style.cursor = 'pointer';
                        this._mouseInside = true;
                        this.fire('mouseover', e);

                    } else if (this._mouseInside) {
                        this._ctx.canvas.style.cursor = '';
                        this._mouseInside = false;
                        this.fire('mouseout', e);
                    }
                }
            });

            L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
                _initPathRoot: function() {
                    var root = this._pathRoot,
                        ctx;

                    if (!root) {
                        root = this._pathRoot = document.createElement('canvas');
                        root.style.position = 'absolute';
                        ctx = this._canvasCtx = root.getContext('2d');

                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        this._panes.overlayPane.appendChild(root);

                        if (this.options.zoomAnimation) {
                            this._pathRoot.className = 'leaflet-zoom-animated';
                            this.on('zoomanim', this._animatePathZoom);
                            this.on('zoomend', this._endPathZoom);
                        }
                        this.on('moveend', this._updateCanvasViewport);
                        this._updateCanvasViewport();
                    }
                },

                _updateCanvasViewport: function() {
                    // don't redraw while zooming. See _updateSvgViewport for more details
                    if (this._pathZooming) {
                        return;
                    }
                    this._updatePathViewport();

                    var vp = this._pathViewport,
                        min = vp.min,
                        size = vp.max.subtract(min),
                        root = this._pathRoot;

                    //TODO check if this works properly on mobile webkit
                    L.DomUtil.setPosition(root, min);
                    root.width = size.x;
                    root.height = size.y;
                    root.getContext('2d').translate(-min.x, -min.y);
                }
            });


            /*
             * L.LineUtil contains different utility functions for line segments
             * and polylines (clipping, simplification, distances, etc.)
             */

            /*jshint bitwise:false */ // allow bitwise operations for this file

            L.LineUtil = {

                // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
                // Improves rendering performance dramatically by lessening the number of points to draw.

                simplify: function( /*Point[]*/ points, /*Number*/ tolerance) {
                    if (!tolerance || !points.length) {
                        return points.slice();
                    }

                    var sqTolerance = tolerance * tolerance;

                    // stage 1: vertex reduction
                    points = this._reducePoints(points, sqTolerance);

                    // stage 2: Douglas-Peucker simplification
                    points = this._simplifyDP(points, sqTolerance);

                    return points;
                },

                // distance from a point to a segment between two points
                pointToSegmentDistance: function( /*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
                    return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
                },

                closestPointOnSegment: function( /*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
                    return this._sqClosestPointOnSegment(p, p1, p2);
                },

                // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
                _simplifyDP: function(points, sqTolerance) {

                    var len = points.length,
                        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
                        markers = new ArrayConstructor(len);

                    markers[0] = markers[len - 1] = 1;

                    this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

                    var i,
                        newPoints = [];

                    for (i = 0; i < len; i++) {
                        if (markers[i]) {
                            newPoints.push(points[i]);
                        }
                    }

                    return newPoints;
                },

                _simplifyDPStep: function(points, markers, sqTolerance, first, last) {

                    var maxSqDist = 0,
                        index, i, sqDist;

                    for (i = first + 1; i <= last - 1; i++) {
                        sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

                        if (sqDist > maxSqDist) {
                            index = i;
                            maxSqDist = sqDist;
                        }
                    }

                    if (maxSqDist > sqTolerance) {
                        markers[index] = 1;

                        this._simplifyDPStep(points, markers, sqTolerance, first, index);
                        this._simplifyDPStep(points, markers, sqTolerance, index, last);
                    }
                },

                // reduce points that are too close to each other to a single point
                _reducePoints: function(points, sqTolerance) {
                    var reducedPoints = [points[0]];

                    for (var i = 1, prev = 0, len = points.length; i < len; i++) {
                        if (this._sqDist(points[i], points[prev]) > sqTolerance) {
                            reducedPoints.push(points[i]);
                            prev = i;
                        }
                    }
                    if (prev < len - 1) {
                        reducedPoints.push(points[len - 1]);
                    }
                    return reducedPoints;
                },

                // Cohen-Sutherland line clipping algorithm.
                // Used to avoid rendering parts of a polyline that are not currently visible.

                clipSegment: function(a, b, bounds, useLastCode) {
                    var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
                        codeB = this._getBitCode(b, bounds),

                        codeOut, p, newCode;

                    // save 2nd code to avoid calculating it on the next segment
                    this._lastCode = codeB;

                    while (true) {
                        // if a,b is inside the clip window (trivial accept)
                        if (!(codeA | codeB)) {
                            return [a, b];
                            // if a,b is outside the clip window (trivial reject)
                        } else if (codeA & codeB) {
                            return false;
                            // other cases
                        } else {
                            codeOut = codeA || codeB;
                            p = this._getEdgeIntersection(a, b, codeOut, bounds);
                            newCode = this._getBitCode(p, bounds);

                            if (codeOut === codeA) {
                                a = p;
                                codeA = newCode;
                            } else {
                                b = p;
                                codeB = newCode;
                            }
                        }
                    }
                },

                _getEdgeIntersection: function(a, b, code, bounds) {
                    var dx = b.x - a.x,
                        dy = b.y - a.y,
                        min = bounds.min,
                        max = bounds.max;

                    if (code & 8) { // top
                        return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
                    } else if (code & 4) { // bottom
                        return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
                    } else if (code & 2) { // right
                        return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
                    } else if (code & 1) { // left
                        return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
                    }
                },

                _getBitCode: function( /*Point*/ p, bounds) {
                    var code = 0;

                    if (p.x < bounds.min.x) { // left
                        code |= 1;
                    } else if (p.x > bounds.max.x) { // right
                        code |= 2;
                    }
                    if (p.y < bounds.min.y) { // bottom
                        code |= 4;
                    } else if (p.y > bounds.max.y) { // top
                        code |= 8;
                    }

                    return code;
                },

                // square distance (to avoid unnecessary Math.sqrt calls)
                _sqDist: function(p1, p2) {
                    var dx = p2.x - p1.x,
                        dy = p2.y - p1.y;
                    return dx * dx + dy * dy;
                },

                // return closest point on segment or distance to that point
                _sqClosestPointOnSegment: function(p, p1, p2, sqDist) {
                    var x = p1.x,
                        y = p1.y,
                        dx = p2.x - x,
                        dy = p2.y - y,
                        dot = dx * dx + dy * dy,
                        t;

                    if (dot > 0) {
                        t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

                        if (t > 1) {
                            x = p2.x;
                            y = p2.y;
                        } else if (t > 0) {
                            x += dx * t;
                            y += dy * t;
                        }
                    }

                    dx = p.x - x;
                    dy = p.y - y;

                    return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
                }
            };


            /*
             * L.Polyline is used to display polylines on a map.
             */

            L.Polyline = L.Path.extend({
                initialize: function(latlngs, options) {
                    L.Path.prototype.initialize.call(this, options);

                    this._latlngs = this._convertLatLngs(latlngs);
                },

                options: {
                    // how much to simplify the polyline on each zoom level
                    // more = better performance and smoother look, less = more accurate
                    smoothFactor: 1.0,
                    noClip: false
                },

                projectLatlngs: function() {
                    this._originalPoints = [];

                    for (var i = 0, len = this._latlngs.length; i < len; i++) {
                        this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
                    }
                },

                getPathString: function() {
                    for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {
                        str += this._getPathPartStr(this._parts[i]);
                    }
                    return str;
                },

                getLatLngs: function() {
                    return this._latlngs;
                },

                setLatLngs: function(latlngs) {
                    this._latlngs = this._convertLatLngs(latlngs);
                    return this.redraw();
                },

                addLatLng: function(latlng) {
                    this._latlngs.push(L.latLng(latlng));
                    return this.redraw();
                },

                spliceLatLngs: function() { // (Number index, Number howMany)
                    var removed = [].splice.apply(this._latlngs, arguments);
                    this._convertLatLngs(this._latlngs, true);
                    this.redraw();
                    return removed;
                },

                closestLayerPoint: function(p) {
                    var minDistance = Infinity,
                        parts = this._parts,
                        p1, p2, minPoint = null;

                    for (var j = 0, jLen = parts.length; j < jLen; j++) {
                        var points = parts[j];
                        for (var i = 1, len = points.length; i < len; i++) {
                            p1 = points[i - 1];
                            p2 = points[i];
                            var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
                            if (sqDist < minDistance) {
                                minDistance = sqDist;
                                minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
                            }
                        }
                    }
                    if (minPoint) {
                        minPoint.distance = Math.sqrt(minDistance);
                    }
                    return minPoint;
                },

                getBounds: function() {
                    return new L.LatLngBounds(this.getLatLngs());
                },

                _convertLatLngs: function(latlngs, overwrite) {
                    var i, len, target = overwrite ? latlngs : [];

                    for (i = 0, len = latlngs.length; i < len; i++) {
                        if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
                            return;
                        }
                        target[i] = L.latLng(latlngs[i]);
                    }
                    return target;
                },

                _initEvents: function() {
                    L.Path.prototype._initEvents.call(this);
                },

                _getPathPartStr: function(points) {
                    var round = L.Path.VML;

                    for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {
                        p = points[j];
                        if (round) {
                            p._round();
                        }
                        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
                    }
                    return str;
                },

                _clipPoints: function() {
                    var points = this._originalPoints,
                        len = points.length,
                        i, k, segment;

                    if (this.options.noClip) {
                        this._parts = [points];
                        return;
                    }

                    this._parts = [];

                    var parts = this._parts,
                        vp = this._map._pathViewport,
                        lu = L.LineUtil;

                    for (i = 0, k = 0; i < len - 1; i++) {
                        segment = lu.clipSegment(points[i], points[i + 1], vp, i);
                        if (!segment) {
                            continue;
                        }

                        parts[k] = parts[k] || [];
                        parts[k].push(segment[0]);

                        // if segment goes out of screen, or it's the last one, it's the end of the line part
                        if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
                            parts[k].push(segment[1]);
                            k++;
                        }
                    }
                },

                // simplify each clipped part of the polyline
                _simplifyPoints: function() {
                    var parts = this._parts,
                        lu = L.LineUtil;

                    for (var i = 0, len = parts.length; i < len; i++) {
                        parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
                    }
                },

                _updatePath: function() {
                    if (!this._map) {
                        return;
                    }

                    this._clipPoints();
                    this._simplifyPoints();

                    L.Path.prototype._updatePath.call(this);
                }
            });

            L.polyline = function(latlngs, options) {
                return new L.Polyline(latlngs, options);
            };


            /*
             * L.PolyUtil contains utility functions for polygons (clipping, etc.).
             */

            /*jshint bitwise:false */ // allow bitwise operations here

            L.PolyUtil = {};

            /*
             * Sutherland-Hodgeman polygon clipping algorithm.
             * Used to avoid rendering parts of a polygon that are not currently visible.
             */
            L.PolyUtil.clipPolygon = function(points, bounds) {
                var clippedPoints,
                    edges = [1, 4, 2, 8],
                    i, j, k,
                    a, b,
                    len, edge, p,
                    lu = L.LineUtil;

                for (i = 0, len = points.length; i < len; i++) {
                    points[i]._code = lu._getBitCode(points[i], bounds);
                }

                // for each edge (left, bottom, right, top)
                for (k = 0; k < 4; k++) {
                    edge = edges[k];
                    clippedPoints = [];

                    for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                        a = points[i];
                        b = points[j];

                        // if a is inside the clip window
                        if (!(a._code & edge)) {
                            // if b is outside the clip window (a->b goes out of screen)
                            if (b._code & edge) {
                                p = lu._getEdgeIntersection(b, a, edge, bounds);
                                p._code = lu._getBitCode(p, bounds);
                                clippedPoints.push(p);
                            }
                            clippedPoints.push(a);

                            // else if b is inside the clip window (a->b enters the screen)
                        } else if (!(b._code & edge)) {
                            p = lu._getEdgeIntersection(b, a, edge, bounds);
                            p._code = lu._getBitCode(p, bounds);
                            clippedPoints.push(p);
                        }
                    }
                    points = clippedPoints;
                }

                return points;
            };


            /*
             * L.Polygon is used to display polygons on a map.
             */

            L.Polygon = L.Polyline.extend({
                options: {
                    fill: true
                },

                initialize: function(latlngs, options) {
                    L.Polyline.prototype.initialize.call(this, latlngs, options);
                    this._initWithHoles(latlngs);
                },

                _initWithHoles: function(latlngs) {
                    var i, len, hole;
                    if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
                        this._latlngs = this._convertLatLngs(latlngs[0]);
                        this._holes = latlngs.slice(1);

                        for (i = 0, len = this._holes.length; i < len; i++) {
                            hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
                            if (hole[0].equals(hole[hole.length - 1])) {
                                hole.pop();
                            }
                        }
                    }

                    // filter out last point if its equal to the first one
                    latlngs = this._latlngs;

                    if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
                        latlngs.pop();
                    }
                },

                projectLatlngs: function() {
                    L.Polyline.prototype.projectLatlngs.call(this);

                    // project polygon holes points
                    // TODO move this logic to Polyline to get rid of duplication
                    this._holePoints = [];

                    if (!this._holes) {
                        return;
                    }

                    var i, j, len, len2;

                    for (i = 0, len = this._holes.length; i < len; i++) {
                        this._holePoints[i] = [];

                        for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
                            this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
                        }
                    }
                },

                setLatLngs: function(latlngs) {
                    if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
                        this._initWithHoles(latlngs);
                        return this.redraw();
                    } else {
                        return L.Polyline.prototype.setLatLngs.call(this, latlngs);
                    }
                },

                _clipPoints: function() {
                    var points = this._originalPoints,
                        newParts = [];

                    this._parts = [points].concat(this._holePoints);

                    if (this.options.noClip) {
                        return;
                    }

                    for (var i = 0, len = this._parts.length; i < len; i++) {
                        var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
                        if (clipped.length) {
                            newParts.push(clipped);
                        }
                    }

                    this._parts = newParts;
                },

                _getPathPartStr: function(points) {
                    var str = L.Polyline.prototype._getPathPartStr.call(this, points);
                    return str + (L.Browser.svg ? 'z' : 'x');
                }
            });

            L.polygon = function(latlngs, options) {
                return new L.Polygon(latlngs, options);
            };


            /*
             * Contains L.MultiPolyline and L.MultiPolygon layers.
             */

            (function() {
                function createMulti(Klass) {

                    return L.FeatureGroup.extend({

                        initialize: function(latlngs, options) {
                            this._layers = {};
                            this._options = options;
                            this.setLatLngs(latlngs);
                        },

                        setLatLngs: function(latlngs) {
                            var i = 0,
                                len = latlngs.length;

                            this.eachLayer(function(layer) {
                                if (i < len) {
                                    layer.setLatLngs(latlngs[i++]);
                                } else {
                                    this.removeLayer(layer);
                                }
                            }, this);

                            while (i < len) {
                                this.addLayer(new Klass(latlngs[i++], this._options));
                            }

                            return this;
                        },

                        getLatLngs: function() {
                            var latlngs = [];

                            this.eachLayer(function(layer) {
                                latlngs.push(layer.getLatLngs());
                            });

                            return latlngs;
                        }
                    });
                }

                L.MultiPolyline = createMulti(L.Polyline);
                L.MultiPolygon = createMulti(L.Polygon);

                L.multiPolyline = function(latlngs, options) {
                    return new L.MultiPolyline(latlngs, options);
                };

                L.multiPolygon = function(latlngs, options) {
                    return new L.MultiPolygon(latlngs, options);
                };
            }());


            /*
             * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
             */

            L.Rectangle = L.Polygon.extend({
                initialize: function(latLngBounds, options) {
                    L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
                },

                setBounds: function(latLngBounds) {
                    this.setLatLngs(this._boundsToLatLngs(latLngBounds));
                },

                _boundsToLatLngs: function(latLngBounds) {
                    latLngBounds = L.latLngBounds(latLngBounds);
                    return [
                        latLngBounds.getSouthWest(),
                        latLngBounds.getNorthWest(),
                        latLngBounds.getNorthEast(),
                        latLngBounds.getSouthEast()
                    ];
                }
            });

            L.rectangle = function(latLngBounds, options) {
                return new L.Rectangle(latLngBounds, options);
            };


            /*
             * L.Circle is a circle overlay (with a certain radius in meters).
             */

            L.Circle = L.Path.extend({
                initialize: function(latlng, radius, options) {
                    L.Path.prototype.initialize.call(this, options);

                    this._latlng = L.latLng(latlng);
                    this._mRadius = radius;
                },

                options: {
                    fill: true
                },

                setLatLng: function(latlng) {
                    this._latlng = L.latLng(latlng);
                    return this.redraw();
                },

                setRadius: function(radius) {
                    this._mRadius = radius;
                    return this.redraw();
                },

                projectLatlngs: function() {
                    var lngRadius = this._getLngRadius(),
                        latlng = this._latlng,
                        pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);

                    this._point = this._map.latLngToLayerPoint(latlng);
                    this._radius = Math.max(this._point.x - pointLeft.x, 1);
                },

                getBounds: function() {
                    var lngRadius = this._getLngRadius(),
                        latRadius = (this._mRadius / 40075017) * 360,
                        latlng = this._latlng;

                    return new L.LatLngBounds(
                        [latlng.lat - latRadius, latlng.lng - lngRadius], [latlng.lat + latRadius, latlng.lng + lngRadius]);
                },

                getLatLng: function() {
                    return this._latlng;
                },

                getPathString: function() {
                    var p = this._point,
                        r = this._radius;

                    if (this._checkIfEmpty()) {
                        return '';
                    }

                    if (L.Browser.svg) {
                        return 'M' + p.x + ',' + (p.y - r) +
                            'A' + r + ',' + r + ',0,1,1,' +
                            (p.x - 0.1) + ',' + (p.y - r) + ' z';
                    } else {
                        p._round();
                        r = Math.round(r);
                        return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
                    }
                },

                getRadius: function() {
                    return this._mRadius;
                },

                // TODO Earth hardcoded, move into projection code!

                _getLatRadius: function() {
                    return (this._mRadius / 40075017) * 360;
                },

                _getLngRadius: function() {
                    return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
                },

                _checkIfEmpty: function() {
                    if (!this._map) {
                        return false;
                    }
                    var vp = this._map._pathViewport,
                        r = this._radius,
                        p = this._point;

                    return p.x - r > vp.max.x || p.y - r > vp.max.y ||
                        p.x + r < vp.min.x || p.y + r < vp.min.y;
                }
            });

            L.circle = function(latlng, radius, options) {
                return new L.Circle(latlng, radius, options);
            };


            /*
             * L.CircleMarker is a circle overlay with a permanent pixel radius.
             */

            L.CircleMarker = L.Circle.extend({
                options: {
                    radius: 10,
                    weight: 2
                },

                initialize: function(latlng, options) {
                    L.Circle.prototype.initialize.call(this, latlng, null, options);
                    this._radius = this.options.radius;
                },

                projectLatlngs: function() {
                    this._point = this._map.latLngToLayerPoint(this._latlng);
                },

                _updateStyle: function() {
                    L.Circle.prototype._updateStyle.call(this);
                    this.setRadius(this.options.radius);
                },

                setLatLng: function(latlng) {
                    L.Circle.prototype.setLatLng.call(this, latlng);
                    if (this._popup && this._popup._isOpen) {
                        this._popup.setLatLng(latlng);
                    }
                    return this;
                },

                setRadius: function(radius) {
                    this.options.radius = this._radius = radius;
                    return this.redraw();
                },

                getRadius: function() {
                    return this._radius;
                }
            });

            L.circleMarker = function(latlng, options) {
                return new L.CircleMarker(latlng, options);
            };


            /*
             * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
             */

            L.Polyline.include(!L.Path.CANVAS ? {} : {
                _containsPoint: function(p, closed) {
                    var i, j, k, len, len2, dist, part,
                        w = this.options.weight / 2;

                    if (L.Browser.touch) {
                        w += 10; // polyline click tolerance on touch devices
                    }

                    for (i = 0, len = this._parts.length; i < len; i++) {
                        part = this._parts[i];
                        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                            if (!closed && (j === 0)) {
                                continue;
                            }

                            dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

                            if (dist <= w) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
            });


            /*
             * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
             */

            L.Polygon.include(!L.Path.CANVAS ? {} : {
                _containsPoint: function(p) {
                    var inside = false,
                        part, p1, p2,
                        i, j, k,
                        len, len2;

                    // TODO optimization: check if within bounds first

                    if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
                        // click on polygon border
                        return true;
                    }

                    // ray casting algorithm for detecting if point is in polygon

                    for (i = 0, len = this._parts.length; i < len; i++) {
                        part = this._parts[i];

                        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                            p1 = part[j];
                            p2 = part[k];

                            if (((p1.y > p.y) !== (p2.y > p.y)) &&
                                (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                                inside = !inside;
                            }
                        }
                    }

                    return inside;
                }
            });


            /*
             * Extends L.Circle with Canvas-specific code.
             */

            L.Circle.include(!L.Path.CANVAS ? {} : {
                _drawPath: function() {
                    var p = this._point;
                    this._ctx.beginPath();
                    this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
                },

                _containsPoint: function(p) {
                    var center = this._point,
                        w2 = this.options.stroke ? this.options.weight / 2 : 0;

                    return (p.distanceTo(center) <= this._radius + w2);
                }
            });


            /*
             * CircleMarker canvas specific drawing parts.
             */

            L.CircleMarker.include(!L.Path.CANVAS ? {} : {
                _updateStyle: function() {
                    L.Path.prototype._updateStyle.call(this);
                }
            });


            /*
             * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
             */

            L.GeoJSON = L.FeatureGroup.extend({

                initialize: function(geojson, options) {
                    L.setOptions(this, options);

                    this._layers = {};

                    if (geojson) {
                        this.addData(geojson);
                    }
                },

                addData: function(geojson) {
                    var features = L.Util.isArray(geojson) ? geojson : geojson.features,
                        i, len, feature;

                    if (features) {
                        for (i = 0, len = features.length; i < len; i++) {
                            // Only add this if geometry or geometries are set and not null
                            feature = features[i];
                            if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                                this.addData(features[i]);
                            }
                        }
                        return this;
                    }

                    var options = this.options;

                    if (options.filter && !options.filter(geojson)) {
                        return;
                    }

                    var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
                    layer.feature = L.GeoJSON.asFeature(geojson);

                    layer.defaultOptions = layer.options;
                    this.resetStyle(layer);

                    if (options.onEachFeature) {
                        options.onEachFeature(geojson, layer);
                    }

                    return this.addLayer(layer);
                },

                resetStyle: function(layer) {
                    var style = this.options.style;
                    if (style) {
                        // reset any custom styles
                        L.Util.extend(layer.options, layer.defaultOptions);

                        this._setLayerStyle(layer, style);
                    }
                },

                setStyle: function(style) {
                    this.eachLayer(function(layer) {
                        this._setLayerStyle(layer, style);
                    }, this);
                },

                _setLayerStyle: function(layer, style) {
                    if (typeof style === 'function') {
                        style = style(layer.feature);
                    }
                    if (layer.setStyle) {
                        layer.setStyle(style);
                    }
                }
            });

            L.extend(L.GeoJSON, {
                geometryToLayer: function(geojson, pointToLayer, coordsToLatLng, vectorOptions) {
                    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
                        coords = geometry.coordinates,
                        layers = [],
                        latlng, latlngs, i, len;

                    coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

                    switch (geometry.type) {
                        case 'Point':
                            latlng = coordsToLatLng(coords);
                            return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

                        case 'MultiPoint':
                            for (i = 0, len = coords.length; i < len; i++) {
                                latlng = coordsToLatLng(coords[i]);
                                layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
                            }
                            return new L.FeatureGroup(layers);

                        case 'LineString':
                            latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
                            return new L.Polyline(latlngs, vectorOptions);

                        case 'Polygon':
                            if (coords.length === 2 && !coords[1].length) {
                                throw new Error('Invalid GeoJSON object.');
                            }
                            latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                            return new L.Polygon(latlngs, vectorOptions);

                        case 'MultiLineString':
                            latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                            return new L.MultiPolyline(latlngs, vectorOptions);

                        case 'MultiPolygon':
                            latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
                            return new L.MultiPolygon(latlngs, vectorOptions);

                        case 'GeometryCollection':
                            for (i = 0, len = geometry.geometries.length; i < len; i++) {

                                layers.push(this.geometryToLayer({
                                    geometry: geometry.geometries[i],
                                    type: 'Feature',
                                    properties: geojson.properties
                                }, pointToLayer, coordsToLatLng, vectorOptions));
                            }
                            return new L.FeatureGroup(layers);

                        default:
                            throw new Error('Invalid GeoJSON object.');
                    }
                },

                coordsToLatLng: function(coords) { // (Array[, Boolean]) -> LatLng
                    return new L.LatLng(coords[1], coords[0], coords[2]);
                },

                coordsToLatLngs: function(coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
                    var latlng, i, len,
                        latlngs = [];

                    for (i = 0, len = coords.length; i < len; i++) {
                        latlng = levelsDeep ?
                            this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
                            (coordsToLatLng || this.coordsToLatLng)(coords[i]);

                        latlngs.push(latlng);
                    }

                    return latlngs;
                },

                latLngToCoords: function(latlng) {
                    var coords = [latlng.lng, latlng.lat];

                    if (latlng.alt !== undefined) {
                        coords.push(latlng.alt);
                    }
                    return coords;
                },

                latLngsToCoords: function(latLngs) {
                    var coords = [];

                    for (var i = 0, len = latLngs.length; i < len; i++) {
                        coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
                    }

                    return coords;
                },

                getFeature: function(layer, newGeometry) {
                    return layer.feature ? L.extend({}, layer.feature, {
                        geometry: newGeometry
                    }) : L.GeoJSON.asFeature(newGeometry);
                },

                asFeature: function(geoJSON) {
                    if (geoJSON.type === 'Feature') {
                        return geoJSON;
                    }

                    return {
                        type: 'Feature',
                        properties: {},
                        geometry: geoJSON
                    };
                }
            });

            var PointToGeoJSON = {
                toGeoJSON: function() {
                    return L.GeoJSON.getFeature(this, {
                        type: 'Point',
                        coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
                    });
                }
            };

            L.Marker.include(PointToGeoJSON);
            L.Circle.include(PointToGeoJSON);
            L.CircleMarker.include(PointToGeoJSON);

            L.Polyline.include({
                toGeoJSON: function() {
                    return L.GeoJSON.getFeature(this, {
                        type: 'LineString',
                        coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
                    });
                }
            });

            L.Polygon.include({
                toGeoJSON: function() {
                    var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
                        i, len, hole;

                    coords[0].push(coords[0][0]);

                    if (this._holes) {
                        for (i = 0, len = this._holes.length; i < len; i++) {
                            hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
                            hole.push(hole[0]);
                            coords.push(hole);
                        }
                    }

                    return L.GeoJSON.getFeature(this, {
                        type: 'Polygon',
                        coordinates: coords
                    });
                }
            });

            (function() {
                function multiToGeoJSON(type) {
                    return function() {
                        var coords = [];

                        this.eachLayer(function(layer) {
                            coords.push(layer.toGeoJSON().geometry.coordinates);
                        });

                        return L.GeoJSON.getFeature(this, {
                            type: type,
                            coordinates: coords
                        });
                    };
                }

                L.MultiPolyline.include({
                    toGeoJSON: multiToGeoJSON('MultiLineString')
                });
                L.MultiPolygon.include({
                    toGeoJSON: multiToGeoJSON('MultiPolygon')
                });

                L.LayerGroup.include({
                    toGeoJSON: function() {

                        var geometry = this.feature && this.feature.geometry,
                            jsons = [],
                            json;

                        if (geometry && geometry.type === 'MultiPoint') {
                            return multiToGeoJSON('MultiPoint').call(this);
                        }

                        var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';

                        this.eachLayer(function(layer) {
                            if (layer.toGeoJSON) {
                                json = layer.toGeoJSON();
                                jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
                            }
                        });

                        if (isGeometryCollection) {
                            return L.GeoJSON.getFeature(this, {
                                geometries: jsons,
                                type: 'GeometryCollection'
                            });
                        }

                        return {
                            type: 'FeatureCollection',
                            features: jsons
                        };
                    }
                });
            }());

            L.geoJson = function(geojson, options) {
                return new L.GeoJSON(geojson, options);
            };


            /*
             * L.DomEvent contains functions for working with DOM events.
             */

            L.DomEvent = {
                /* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
                addListener: function(obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

                    var id = L.stamp(fn),
                        key = '_leaflet_' + type + id,
                        handler, originalHandler, newType;

                    if (obj[key]) {
                        return this;
                    }

                    handler = function(e) {
                        return fn.call(context || obj, e || L.DomEvent._getEvent());
                    };

                    if (L.Browser.pointer && type.indexOf('touch') === 0) {
                        return this.addPointerListener(obj, type, handler, id);
                    }
                    if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
                        this.addDoubleTapListener(obj, handler, id);
                    }

                    if ('addEventListener' in obj) {

                        if (type === 'mousewheel') {
                            obj.addEventListener('DOMMouseScroll', handler, false);
                            obj.addEventListener(type, handler, false);

                        } else if ((type === 'mouseenter') || (type === 'mouseleave')) {

                            originalHandler = handler;
                            newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

                            handler = function(e) {
                                if (!L.DomEvent._checkMouse(obj, e)) {
                                    return;
                                }
                                return originalHandler(e);
                            };

                            obj.addEventListener(newType, handler, false);

                        } else if (type === 'click' && L.Browser.android) {
                            originalHandler = handler;
                            handler = function(e) {
                                return L.DomEvent._filterClick(e, originalHandler);
                            };

                            obj.addEventListener(type, handler, false);
                        } else {
                            obj.addEventListener(type, handler, false);
                        }

                    } else if ('attachEvent' in obj) {
                        obj.attachEvent('on' + type, handler);
                    }

                    obj[key] = handler;

                    return this;
                },

                removeListener: function(obj, type, fn) { // (HTMLElement, String, Function)

                    var id = L.stamp(fn),
                        key = '_leaflet_' + type + id,
                        handler = obj[key];

                    if (!handler) {
                        return this;
                    }

                    if (L.Browser.pointer && type.indexOf('touch') === 0) {
                        this.removePointerListener(obj, type, id);
                    } else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
                        this.removeDoubleTapListener(obj, id);

                    } else if ('removeEventListener' in obj) {

                        if (type === 'mousewheel') {
                            obj.removeEventListener('DOMMouseScroll', handler, false);
                            obj.removeEventListener(type, handler, false);

                        } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
                            obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
                        } else {
                            obj.removeEventListener(type, handler, false);
                        }
                    } else if ('detachEvent' in obj) {
                        obj.detachEvent('on' + type, handler);
                    }

                    obj[key] = null;

                    return this;
                },

                stopPropagation: function(e) {

                    if (e.stopPropagation) {
                        e.stopPropagation();
                    } else {
                        e.cancelBubble = true;
                    }
                    L.DomEvent._skipped(e);

                    return this;
                },

                disableScrollPropagation: function(el) {
                    var stop = L.DomEvent.stopPropagation;

                    return L.DomEvent
                        .on(el, 'mousewheel', stop)
                        .on(el, 'MozMousePixelScroll', stop);
                },

                disableClickPropagation: function(el) {
                    var stop = L.DomEvent.stopPropagation;

                    for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                        L.DomEvent.on(el, L.Draggable.START[i], stop);
                    }

                    return L.DomEvent
                        .on(el, 'click', L.DomEvent._fakeStop)
                        .on(el, 'dblclick', stop);
                },

                preventDefault: function(e) {

                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }
                    return this;
                },

                stop: function(e) {
                    return L.DomEvent
                        .preventDefault(e)
                        .stopPropagation(e);
                },

                getMousePosition: function(e, container) {
                    if (!container) {
                        return new L.Point(e.clientX, e.clientY);
                    }

                    var rect = container.getBoundingClientRect();

                    return new L.Point(
                        e.clientX - rect.left - container.clientLeft,
                        e.clientY - rect.top - container.clientTop);
                },

                getWheelDelta: function(e) {

                    var delta = 0;

                    if (e.wheelDelta) {
                        delta = e.wheelDelta / 120;
                    }
                    if (e.detail) {
                        delta = -e.detail / 3;
                    }
                    return delta;
                },

                _skipEvents: {},

                _fakeStop: function(e) {
                    // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
                    L.DomEvent._skipEvents[e.type] = true;
                },

                _skipped: function(e) {
                    var skipped = this._skipEvents[e.type];
                    // reset when checking, as it's only used in map container and propagates outside of the map
                    this._skipEvents[e.type] = false;
                    return skipped;
                },

                // check if element really left/entered the event target (for mouseenter/mouseleave)
                _checkMouse: function(el, e) {

                    var related = e.relatedTarget;

                    if (!related) {
                        return true;
                    }

                    try {
                        while (related && (related !== el)) {
                            related = related.parentNode;
                        }
                    } catch (err) {
                        return false;
                    }
                    return (related !== el);
                },

                _getEvent: function() { // evil magic for IE
                    /*jshint noarg:false */
                    var e = window.event;
                    if (!e) {
                        var caller = arguments.callee.caller;
                        while (caller) {
                            e = caller['arguments'][0];
                            if (e && window.Event === e.constructor) {
                                break;
                            }
                            caller = caller.caller;
                        }
                    }
                    return e;
                },

                // this is a horrible workaround for a bug in Android where a single touch triggers two click events
                _filterClick: function(e, handler) {
                    var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
                        elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

                    // are they closer together than 500ms yet more than 100ms?
                    // Android typically triggers them ~300ms apart while multiple listeners
                    // on the same event should be triggered far faster;
                    // or check if click is simulated on the element, and if it is, reject any non-simulated events

                    if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
                        L.DomEvent.stop(e);
                        return;
                    }
                    L.DomEvent._lastClick = timeStamp;

                    return handler(e);
                }
            };

            L.DomEvent.on = L.DomEvent.addListener;
            L.DomEvent.off = L.DomEvent.removeListener;


            /*
             * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
             */

            L.Draggable = L.Class.extend({
                includes: L.Mixin.Events,

                statics: {
                    START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
                    END: {
                        mousedown: 'mouseup',
                        touchstart: 'touchend',
                        pointerdown: 'touchend',
                        MSPointerDown: 'touchend'
                    },
                    MOVE: {
                        mousedown: 'mousemove',
                        touchstart: 'touchmove',
                        pointerdown: 'touchmove',
                        MSPointerDown: 'touchmove'
                    }
                },

                initialize: function(element, dragStartTarget) {
                    this._element = element;
                    this._dragStartTarget = dragStartTarget || element;
                },

                enable: function() {
                    if (this._enabled) {
                        return;
                    }

                    for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                        L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
                    }

                    this._enabled = true;
                },

                disable: function() {
                    if (!this._enabled) {
                        return;
                    }

                    for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                        L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
                    }

                    this._enabled = false;
                    this._moved = false;
                },

                _onDown: function(e) {
                    this._moved = false;

                    if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) {
                        return;
                    }

                    L.DomEvent.stopPropagation(e);

                    if (L.Draggable._disabled) {
                        return;
                    }

                    L.DomUtil.disableImageDrag();
                    L.DomUtil.disableTextSelection();

                    if (this._moving) {
                        return;
                    }

                    var first = e.touches ? e.touches[0] : e;

                    this._startPoint = new L.Point(first.clientX, first.clientY);
                    this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

                    L.DomEvent
                        .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
                        .on(document, L.Draggable.END[e.type], this._onUp, this);
                },

                _onMove: function(e) {
                    if (e.touches && e.touches.length > 1) {
                        this._moved = true;
                        return;
                    }

                    var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
                        newPoint = new L.Point(first.clientX, first.clientY),
                        offset = newPoint.subtract(this._startPoint);

                    if (!offset.x && !offset.y) {
                        return;
                    }
                    if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) {
                        return;
                    }

                    L.DomEvent.preventDefault(e);

                    if (!this._moved) {
                        this.fire('dragstart');

                        this._moved = true;
                        this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

                        L.DomUtil.addClass(document.body, 'leaflet-dragging');
                        this._lastTarget = e.target || e.srcElement;
                        L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
                    }

                    this._newPos = this._startPos.add(offset);
                    this._moving = true;

                    L.Util.cancelAnimFrame(this._animRequest);
                    this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
                },

                _updatePosition: function() {
                    this.fire('predrag');
                    L.DomUtil.setPosition(this._element, this._newPos);
                    this.fire('drag');
                },

                _onUp: function() {
                    L.DomUtil.removeClass(document.body, 'leaflet-dragging');

                    if (this._lastTarget) {
                        L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
                        this._lastTarget = null;
                    }

                    for (var i in L.Draggable.MOVE) {
                        L.DomEvent
                            .off(document, L.Draggable.MOVE[i], this._onMove)
                            .off(document, L.Draggable.END[i], this._onUp);
                    }

                    L.DomUtil.enableImageDrag();
                    L.DomUtil.enableTextSelection();

                    if (this._moved && this._moving) {
                        // ensure drag is not fired after dragend
                        L.Util.cancelAnimFrame(this._animRequest);

                        this.fire('dragend', {
                            distance: this._newPos.distanceTo(this._startPos)
                        });
                    }

                    this._moving = false;
                }
            });


            /*
                L.Handler is a base class for handler classes that are used internally to inject
                interaction features like dragging to classes like Map and Marker.
            */

            L.Handler = L.Class.extend({
                initialize: function(map) {
                    this._map = map;
                },

                enable: function() {
                    if (this._enabled) {
                        return;
                    }

                    this._enabled = true;
                    this.addHooks();
                },

                disable: function() {
                    if (!this._enabled) {
                        return;
                    }

                    this._enabled = false;
                    this.removeHooks();
                },

                enabled: function() {
                    return !!this._enabled;
                }
            });


            /*
             * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
             */

            L.Map.mergeOptions({
                dragging: true,

                inertia: !L.Browser.android23,
                inertiaDeceleration: 3400, // px/s^2
                inertiaMaxSpeed: Infinity, // px/s
                inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
                easeLinearity: 0.25,

                // TODO refactor, move to CRS
                worldCopyJump: false
            });

            L.Map.Drag = L.Handler.extend({
                addHooks: function() {
                    if (!this._draggable) {
                        var map = this._map;

                        this._draggable = new L.Draggable(map._mapPane, map._container);

                        this._draggable.on({
                            'dragstart': this._onDragStart,
                            'drag': this._onDrag,
                            'dragend': this._onDragEnd
                        }, this);

                        if (map.options.worldCopyJump) {
                            this._draggable.on('predrag', this._onPreDrag, this);
                            map.on('viewreset', this._onViewReset, this);

                            map.whenReady(this._onViewReset, this);
                        }
                    }
                    this._draggable.enable();
                },

                removeHooks: function() {
                    this._draggable.disable();
                },

                moved: function() {
                    return this._draggable && this._draggable._moved;
                },

                _onDragStart: function() {
                    var map = this._map;

                    if (map._panAnim) {
                        map._panAnim.stop();
                    }

                    map
                        .fire('movestart')
                        .fire('dragstart');

                    if (map.options.inertia) {
                        this._positions = [];
                        this._times = [];
                    }
                },

                _onDrag: function() {
                    if (this._map.options.inertia) {
                        var time = this._lastTime = +new Date(),
                            pos = this._lastPos = this._draggable._newPos;

                        this._positions.push(pos);
                        this._times.push(time);

                        if (time - this._times[0] > 200) {
                            this._positions.shift();
                            this._times.shift();
                        }
                    }

                    this._map
                        .fire('move')
                        .fire('drag');
                },

                _onViewReset: function() {
                    // TODO fix hardcoded Earth values
                    var pxCenter = this._map.getSize()._divideBy(2),
                        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

                    this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
                    this._worldWidth = this._map.project([0, 180]).x;
                },

                _onPreDrag: function() {
                    // TODO refactor to be able to adjust map pane position after zoom
                    var worldWidth = this._worldWidth,
                        halfWidth = Math.round(worldWidth / 2),
                        dx = this._initialWorldOffset,
                        x = this._draggable._newPos.x,
                        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
                        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
                        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

                    this._draggable._newPos.x = newX;
                },

                _onDragEnd: function(e) {
                    var map = this._map,
                        options = map.options,
                        delay = +new Date() - this._lastTime,

                        noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

                    map.fire('dragend', e);

                    if (noInertia) {
                        map.fire('moveend');

                    } else {

                        var direction = this._lastPos.subtract(this._positions[0]),
                            duration = (this._lastTime + delay - this._times[0]) / 1000,
                            ease = options.easeLinearity,

                            speedVector = direction.multiplyBy(ease / duration),
                            speed = speedVector.distanceTo([0, 0]),

                            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
                            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

                            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
                            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

                        if (!offset.x || !offset.y) {
                            map.fire('moveend');

                        } else {
                            offset = map._limitOffset(offset, map.options.maxBounds);

                            L.Util.requestAnimFrame(function() {
                                map.panBy(offset, {
                                    duration: decelerationDuration,
                                    easeLinearity: ease,
                                    noMoveStart: true
                                });
                            });
                        }
                    }
                }
            });

            L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


            /*
             * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
             */

            L.Map.mergeOptions({
                doubleClickZoom: true
            });

            L.Map.DoubleClickZoom = L.Handler.extend({
                addHooks: function() {
                    this._map.on('dblclick', this._onDoubleClick, this);
                },

                removeHooks: function() {
                    this._map.off('dblclick', this._onDoubleClick, this);
                },

                _onDoubleClick: function(e) {
                    var map = this._map,
                        zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

                    if (map.options.doubleClickZoom === 'center') {
                        map.setZoom(zoom);
                    } else {
                        map.setZoomAround(e.containerPoint, zoom);
                    }
                }
            });

            L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


            /*
             * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
             */

            L.Map.mergeOptions({
                scrollWheelZoom: true
            });

            L.Map.ScrollWheelZoom = L.Handler.extend({
                addHooks: function() {
                    L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
                    L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
                    this._delta = 0;
                },

                removeHooks: function() {
                    L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
                    L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
                },

                _onWheelScroll: function(e) {
                    var delta = L.DomEvent.getWheelDelta(e);

                    this._delta += delta;
                    this._lastMousePos = this._map.mouseEventToContainerPoint(e);

                    if (!this._startTime) {
                        this._startTime = +new Date();
                    }

                    var left = Math.max(40 - (+new Date() - this._startTime), 0);

                    clearTimeout(this._timer);
                    this._timer = setTimeout(L.bind(this._performZoom, this), left);

                    L.DomEvent.preventDefault(e);
                    L.DomEvent.stopPropagation(e);
                },

                _performZoom: function() {
                    var map = this._map,
                        delta = this._delta,
                        zoom = map.getZoom();

                    delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
                    delta = Math.max(Math.min(delta, 4), -4);
                    delta = map._limitZoom(zoom + delta) - zoom;

                    this._delta = 0;
                    this._startTime = null;

                    if (!delta) {
                        return;
                    }

                    if (map.options.scrollWheelZoom === 'center') {
                        map.setZoom(zoom + delta);
                    } else {
                        map.setZoomAround(this._lastMousePos, zoom + delta);
                    }
                }
            });

            L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


            /*
             * Extends the event handling code with double tap support for mobile browsers.
             */

            L.extend(L.DomEvent, {

                _touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
                _touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

                // inspired by Zepto touch code by Thomas Fuchs
                addDoubleTapListener: function(obj, handler, id) {
                    var last,
                        doubleTap = false,
                        delay = 250,
                        touch,
                        pre = '_leaflet_',
                        touchstart = this._touchstart,
                        touchend = this._touchend,
                        trackedTouches = [];

                    function onTouchStart(e) {
                        var count;

                        if (L.Browser.pointer) {
                            trackedTouches.push(e.pointerId);
                            count = trackedTouches.length;
                        } else {
                            count = e.touches.length;
                        }
                        if (count > 1) {
                            return;
                        }

                        var now = Date.now(),
                            delta = now - (last || now);

                        touch = e.touches ? e.touches[0] : e;
                        doubleTap = (delta > 0 && delta <= delay);
                        last = now;
                    }

                    function onTouchEnd(e) {
                        if (L.Browser.pointer) {
                            var idx = trackedTouches.indexOf(e.pointerId);
                            if (idx === -1) {
                                return;
                            }
                            trackedTouches.splice(idx, 1);
                        }

                        if (doubleTap) {
                            if (L.Browser.pointer) {
                                // work around .type being readonly with MSPointer* events
                                var newTouch = {},
                                    prop;

                                // jshint forin:false
                                for (var i in touch) {
                                    prop = touch[i];
                                    if (typeof prop === 'function') {
                                        newTouch[i] = prop.bind(touch);
                                    } else {
                                        newTouch[i] = prop;
                                    }
                                }
                                touch = newTouch;
                            }
                            touch.type = 'dblclick';
                            handler(touch);
                            last = null;
                        }
                    }
                    obj[pre + touchstart + id] = onTouchStart;
                    obj[pre + touchend + id] = onTouchEnd;

                    // on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
                    // will not come through to us, so we will lose track of how many touches are ongoing
                    var endElement = L.Browser.pointer ? document.documentElement : obj;

                    obj.addEventListener(touchstart, onTouchStart, false);
                    endElement.addEventListener(touchend, onTouchEnd, false);

                    if (L.Browser.pointer) {
                        endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
                    }

                    return this;
                },

                removeDoubleTapListener: function(obj, id) {
                    var pre = '_leaflet_';

                    obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
                    (L.Browser.pointer ? document.documentElement : obj).removeEventListener(
                        this._touchend, obj[pre + this._touchend + id], false);

                    if (L.Browser.pointer) {
                        document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],
                            false);
                    }

                    return this;
                }
            });


            /*
             * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
             */

            L.extend(L.DomEvent, {

                //static
                POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
                POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
                POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
                POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

                _pointers: [],
                _pointerDocumentListener: false,

                // Provides a touch events wrapper for (ms)pointer events.
                // Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
                //ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

                addPointerListener: function(obj, type, handler, id) {

                    switch (type) {
                        case 'touchstart':
                            return this.addPointerListenerStart(obj, type, handler, id);
                        case 'touchend':
                            return this.addPointerListenerEnd(obj, type, handler, id);
                        case 'touchmove':
                            return this.addPointerListenerMove(obj, type, handler, id);
                        default:
                            throw 'Unknown touch event type';
                    }
                },

                addPointerListenerStart: function(obj, type, handler, id) {
                    var pre = '_leaflet_',
                        pointers = this._pointers;

                    var cb = function(e) {
                        if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
                            L.DomEvent.preventDefault(e);
                        }

                        var alreadyInArray = false;
                        for (var i = 0; i < pointers.length; i++) {
                            if (pointers[i].pointerId === e.pointerId) {
                                alreadyInArray = true;
                                break;
                            }
                        }
                        if (!alreadyInArray) {
                            pointers.push(e);
                        }

                        e.touches = pointers.slice();
                        e.changedTouches = [e];

                        handler(e);
                    };

                    obj[pre + 'touchstart' + id] = cb;
                    obj.addEventListener(this.POINTER_DOWN, cb, false);

                    // need to also listen for end events to keep the _pointers list accurate
                    // this needs to be on the body and never go away
                    if (!this._pointerDocumentListener) {
                        var internalCb = function(e) {
                            for (var i = 0; i < pointers.length; i++) {
                                if (pointers[i].pointerId === e.pointerId) {
                                    pointers.splice(i, 1);
                                    break;
                                }
                            }
                        };
                        //We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
                        document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
                        document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);

                        this._pointerDocumentListener = true;
                    }

                    return this;
                },

                addPointerListenerMove: function(obj, type, handler, id) {
                    var pre = '_leaflet_',
                        touches = this._pointers;

                    function cb(e) {

                        // don't fire touch moves when mouse isn't down
                        if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
                            return;
                        }

                        for (var i = 0; i < touches.length; i++) {
                            if (touches[i].pointerId === e.pointerId) {
                                touches[i] = e;
                                break;
                            }
                        }

                        e.touches = touches.slice();
                        e.changedTouches = [e];

                        handler(e);
                    }

                    obj[pre + 'touchmove' + id] = cb;
                    obj.addEventListener(this.POINTER_MOVE, cb, false);

                    return this;
                },

                addPointerListenerEnd: function(obj, type, handler, id) {
                    var pre = '_leaflet_',
                        touches = this._pointers;

                    var cb = function(e) {
                        for (var i = 0; i < touches.length; i++) {
                            if (touches[i].pointerId === e.pointerId) {
                                touches.splice(i, 1);
                                break;
                            }
                        }

                        e.touches = touches.slice();
                        e.changedTouches = [e];

                        handler(e);
                    };

                    obj[pre + 'touchend' + id] = cb;
                    obj.addEventListener(this.POINTER_UP, cb, false);
                    obj.addEventListener(this.POINTER_CANCEL, cb, false);

                    return this;
                },

                removePointerListener: function(obj, type, id) {
                    var pre = '_leaflet_',
                        cb = obj[pre + type + id];

                    switch (type) {
                        case 'touchstart':
                            obj.removeEventListener(this.POINTER_DOWN, cb, false);
                            break;
                        case 'touchmove':
                            obj.removeEventListener(this.POINTER_MOVE, cb, false);
                            break;
                        case 'touchend':
                            obj.removeEventListener(this.POINTER_UP, cb, false);
                            obj.removeEventListener(this.POINTER_CANCEL, cb, false);
                            break;
                    }

                    return this;
                }
            });


            /*
             * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
             */

            L.Map.mergeOptions({
                touchZoom: L.Browser.touch && !L.Browser.android23,
                bounceAtZoomLimits: true
            });

            L.Map.TouchZoom = L.Handler.extend({
                addHooks: function() {
                    L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
                },

                removeHooks: function() {
                    L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
                },

                _onTouchStart: function(e) {
                    var map = this._map;

                    if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
                        return;
                    }

                    var p1 = map.mouseEventToLayerPoint(e.touches[0]),
                        p2 = map.mouseEventToLayerPoint(e.touches[1]),
                        viewCenter = map._getCenterLayerPoint();

                    this._startCenter = p1.add(p2)._divideBy(2);
                    this._startDist = p1.distanceTo(p2);

                    this._moved = false;
                    this._zooming = true;

                    this._centerOffset = viewCenter.subtract(this._startCenter);

                    if (map._panAnim) {
                        map._panAnim.stop();
                    }

                    L.DomEvent
                        .on(document, 'touchmove', this._onTouchMove, this)
                        .on(document, 'touchend', this._onTouchEnd, this);

                    L.DomEvent.preventDefault(e);
                },

                _onTouchMove: function(e) {
                    var map = this._map;

                    if (!e.touches || e.touches.length !== 2 || !this._zooming) {
                        return;
                    }

                    var p1 = map.mouseEventToLayerPoint(e.touches[0]),
                        p2 = map.mouseEventToLayerPoint(e.touches[1]);

                    this._scale = p1.distanceTo(p2) / this._startDist;
                    this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

                    if (this._scale === 1) {
                        return;
                    }

                    if (!map.options.bounceAtZoomLimits) {
                        if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
                            (map.getZoom() === map.getMaxZoom() && this._scale > 1)) {
                            return;
                        }
                    }

                    if (!this._moved) {
                        L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

                        map
                            .fire('movestart')
                            .fire('zoomstart');

                        this._moved = true;
                    }

                    L.Util.cancelAnimFrame(this._animRequest);
                    this._animRequest = L.Util.requestAnimFrame(
                        this._updateOnMove, this, true, this._map._container);

                    L.DomEvent.preventDefault(e);
                },

                _updateOnMove: function() {
                    var map = this._map,
                        origin = this._getScaleOrigin(),
                        center = map.layerPointToLatLng(origin),
                        zoom = map.getScaleZoom(this._scale);

                    map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
                },

                _onTouchEnd: function() {
                    if (!this._moved || !this._zooming) {
                        this._zooming = false;
                        return;
                    }

                    var map = this._map;

                    this._zooming = false;
                    L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
                    L.Util.cancelAnimFrame(this._animRequest);

                    L.DomEvent
                        .off(document, 'touchmove', this._onTouchMove)
                        .off(document, 'touchend', this._onTouchEnd);

                    var origin = this._getScaleOrigin(),
                        center = map.layerPointToLatLng(origin),

                        oldZoom = map.getZoom(),
                        floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
                        roundZoomDelta = (floatZoomDelta > 0 ?
                            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),

                        zoom = map._limitZoom(oldZoom + roundZoomDelta),
                        scale = map.getZoomScale(zoom) / this._scale;

                    map._animateZoom(center, zoom, origin, scale);
                },

                _getScaleOrigin: function() {
                    var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
                    return this._startCenter.add(centerOffset);
                }
            });

            L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


            /*
             * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
             */

            L.Map.mergeOptions({
                tap: true,
                tapTolerance: 15
            });

            L.Map.Tap = L.Handler.extend({
                addHooks: function() {
                    L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
                },

                removeHooks: function() {
                    L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
                },

                _onDown: function(e) {
                    if (!e.touches) {
                        return;
                    }

                    L.DomEvent.preventDefault(e);

                    this._fireClick = true;

                    // don't simulate click or track longpress if more than 1 touch
                    if (e.touches.length > 1) {
                        this._fireClick = false;
                        clearTimeout(this._holdTimeout);
                        return;
                    }

                    var first = e.touches[0],
                        el = first.target;

                    this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

                    // if touching a link, highlight it
                    if (el.tagName && el.tagName.toLowerCase() === 'a') {
                        L.DomUtil.addClass(el, 'leaflet-active');
                    }

                    // simulate long hold but setting a timeout
                    this._holdTimeout = setTimeout(L.bind(function() {
                        if (this._isTapValid()) {
                            this._fireClick = false;
                            this._onUp();
                            this._simulateEvent('contextmenu', first);
                        }
                    }, this), 1000);

                    L.DomEvent
                        .on(document, 'touchmove', this._onMove, this)
                        .on(document, 'touchend', this._onUp, this);
                },

                _onUp: function(e) {
                    clearTimeout(this._holdTimeout);

                    L.DomEvent
                        .off(document, 'touchmove', this._onMove, this)
                        .off(document, 'touchend', this._onUp, this);

                    if (this._fireClick && e && e.changedTouches) {

                        var first = e.changedTouches[0],
                            el = first.target;

                        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
                            L.DomUtil.removeClass(el, 'leaflet-active');
                        }

                        // simulate click if the touch didn't move too much
                        if (this._isTapValid()) {
                            this._simulateEvent('click', first);
                        }
                    }
                },

                _isTapValid: function() {
                    return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
                },

                _onMove: function(e) {
                    var first = e.touches[0];
                    this._newPos = new L.Point(first.clientX, first.clientY);
                },

                _simulateEvent: function(type, e) {
                    var simulatedEvent = document.createEvent('MouseEvents');

                    simulatedEvent._simulated = true;
                    e.target._simulatedClick = true;

                    simulatedEvent.initMouseEvent(
                        type, true, true, window, 1,
                        e.screenX, e.screenY,
                        e.clientX, e.clientY,
                        false, false, false, false, 0, null);

                    e.target.dispatchEvent(simulatedEvent);
                }
            });

            if (L.Browser.touch && !L.Browser.pointer) {
                L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
            }


            /*
             * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
             * (zoom to a selected bounding box), enabled by default.
             */

            L.Map.mergeOptions({
                boxZoom: true
            });

            L.Map.BoxZoom = L.Handler.extend({
                initialize: function(map) {
                    this._map = map;
                    this._container = map._container;
                    this._pane = map._panes.overlayPane;
                    this._moved = false;
                },

                addHooks: function() {
                    L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
                },

                removeHooks: function() {
                    L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
                    this._moved = false;
                },

                moved: function() {
                    return this._moved;
                },

                _onMouseDown: function(e) {
                    this._moved = false;

                    if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) {
                        return false;
                    }

                    L.DomUtil.disableTextSelection();
                    L.DomUtil.disableImageDrag();

                    this._startLayerPoint = this._map.mouseEventToLayerPoint(e);

                    L.DomEvent
                        .on(document, 'mousemove', this._onMouseMove, this)
                        .on(document, 'mouseup', this._onMouseUp, this)
                        .on(document, 'keydown', this._onKeyDown, this);
                },

                _onMouseMove: function(e) {
                    if (!this._moved) {
                        this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
                        L.DomUtil.setPosition(this._box, this._startLayerPoint);

                        //TODO refactor: move cursor to styles
                        this._container.style.cursor = 'crosshair';
                        this._map.fire('boxzoomstart');
                    }

                    var startPoint = this._startLayerPoint,
                        box = this._box,

                        layerPoint = this._map.mouseEventToLayerPoint(e),
                        offset = layerPoint.subtract(startPoint),

                        newPos = new L.Point(
                            Math.min(layerPoint.x, startPoint.x),
                            Math.min(layerPoint.y, startPoint.y));

                    L.DomUtil.setPosition(box, newPos);

                    this._moved = true;

                    // TODO refactor: remove hardcoded 4 pixels
                    box.style.width = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
                    box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
                },

                _finish: function() {
                    if (this._moved) {
                        this._pane.removeChild(this._box);
                        this._container.style.cursor = '';
                    }

                    L.DomUtil.enableTextSelection();
                    L.DomUtil.enableImageDrag();

                    L.DomEvent
                        .off(document, 'mousemove', this._onMouseMove)
                        .off(document, 'mouseup', this._onMouseUp)
                        .off(document, 'keydown', this._onKeyDown);
                },

                _onMouseUp: function(e) {

                    this._finish();

                    var map = this._map,
                        layerPoint = map.mouseEventToLayerPoint(e);

                    if (this._startLayerPoint.equals(layerPoint)) {
                        return;
                    }

                    var bounds = new L.LatLngBounds(
                        map.layerPointToLatLng(this._startLayerPoint),
                        map.layerPointToLatLng(layerPoint));

                    map.fitBounds(bounds);

                    map.fire('boxzoomend', {
                        boxZoomBounds: bounds
                    });
                },

                _onKeyDown: function(e) {
                    if (e.keyCode === 27) {
                        this._finish();
                    }
                }
            });

            L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


            /*
             * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
             */

            L.Map.mergeOptions({
                keyboard: true,
                keyboardPanOffset: 80,
                keyboardZoomOffset: 1
            });

            L.Map.Keyboard = L.Handler.extend({

                keyCodes: {
                    left: [37],
                    right: [39],
                    down: [40],
                    up: [38],
                    zoomIn: [187, 107, 61, 171],
                    zoomOut: [189, 109, 173]
                },

                initialize: function(map) {
                    this._map = map;

                    this._setPanOffset(map.options.keyboardPanOffset);
                    this._setZoomOffset(map.options.keyboardZoomOffset);
                },

                addHooks: function() {
                    var container = this._map._container;

                    // make the container focusable by tabbing
                    if (container.tabIndex === -1) {
                        container.tabIndex = '0';
                    }

                    L.DomEvent
                        .on(container, 'focus', this._onFocus, this)
                        .on(container, 'blur', this._onBlur, this)
                        .on(container, 'mousedown', this._onMouseDown, this);

                    this._map
                        .on('focus', this._addHooks, this)
                        .on('blur', this._removeHooks, this);
                },

                removeHooks: function() {
                    this._removeHooks();

                    var container = this._map._container;

                    L.DomEvent
                        .off(container, 'focus', this._onFocus, this)
                        .off(container, 'blur', this._onBlur, this)
                        .off(container, 'mousedown', this._onMouseDown, this);

                    this._map
                        .off('focus', this._addHooks, this)
                        .off('blur', this._removeHooks, this);
                },

                _onMouseDown: function() {
                    if (this._focused) {
                        return;
                    }

                    var body = document.body,
                        docEl = document.documentElement,
                        top = body.scrollTop || docEl.scrollTop,
                        left = body.scrollLeft || docEl.scrollLeft;

                    this._map._container.focus();

                    window.scrollTo(left, top);
                },

                _onFocus: function() {
                    this._focused = true;
                    this._map.fire('focus');
                },

                _onBlur: function() {
                    this._focused = false;
                    this._map.fire('blur');
                },

                _setPanOffset: function(pan) {
                    var keys = this._panKeys = {},
                        codes = this.keyCodes,
                        i, len;

                    for (i = 0, len = codes.left.length; i < len; i++) {
                        keys[codes.left[i]] = [-1 * pan, 0];
                    }
                    for (i = 0, len = codes.right.length; i < len; i++) {
                        keys[codes.right[i]] = [pan, 0];
                    }
                    for (i = 0, len = codes.down.length; i < len; i++) {
                        keys[codes.down[i]] = [0, pan];
                    }
                    for (i = 0, len = codes.up.length; i < len; i++) {
                        keys[codes.up[i]] = [0, -1 * pan];
                    }
                },

                _setZoomOffset: function(zoom) {
                    var keys = this._zoomKeys = {},
                        codes = this.keyCodes,
                        i, len;

                    for (i = 0, len = codes.zoomIn.length; i < len; i++) {
                        keys[codes.zoomIn[i]] = zoom;
                    }
                    for (i = 0, len = codes.zoomOut.length; i < len; i++) {
                        keys[codes.zoomOut[i]] = -zoom;
                    }
                },

                _addHooks: function() {
                    L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
                },

                _removeHooks: function() {
                    L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
                },

                _onKeyDown: function(e) {
                    var key = e.keyCode,
                        map = this._map;

                    if (key in this._panKeys) {

                        if (map._panAnim && map._panAnim._inProgress) {
                            return;
                        }

                        map.panBy(this._panKeys[key]);

                        if (map.options.maxBounds) {
                            map.panInsideBounds(map.options.maxBounds);
                        }

                    } else if (key in this._zoomKeys) {
                        map.setZoom(map.getZoom() + this._zoomKeys[key]);

                    } else {
                        return;
                    }

                    L.DomEvent.stop(e);
                }
            });

            L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


            /*
             * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
             */

            L.Handler.MarkerDrag = L.Handler.extend({
                initialize: function(marker) {
                    this._marker = marker;
                },

                addHooks: function() {
                    var icon = this._marker._icon;
                    if (!this._draggable) {
                        this._draggable = new L.Draggable(icon, icon);
                    }

                    this._draggable
                        .on('dragstart', this._onDragStart, this)
                        .on('drag', this._onDrag, this)
                        .on('dragend', this._onDragEnd, this);
                    this._draggable.enable();
                    L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
                },

                removeHooks: function() {
                    this._draggable
                        .off('dragstart', this._onDragStart, this)
                        .off('drag', this._onDrag, this)
                        .off('dragend', this._onDragEnd, this);

                    this._draggable.disable();
                    L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
                },

                moved: function() {
                    return this._draggable && this._draggable._moved;
                },

                _onDragStart: function() {
                    this._marker
                        .closePopup()
                        .fire('movestart')
                        .fire('dragstart');
                },

                _onDrag: function() {
                    var marker = this._marker,
                        shadow = marker._shadow,
                        iconPos = L.DomUtil.getPosition(marker._icon),
                        latlng = marker._map.layerPointToLatLng(iconPos);

                    // update shadow position
                    if (shadow) {
                        L.DomUtil.setPosition(shadow, iconPos);
                    }

                    marker._latlng = latlng;

                    marker
                        .fire('move', {
                            latlng: latlng
                        })
                        .fire('drag');
                },

                _onDragEnd: function(e) {
                    this._marker
                        .fire('moveend')
                        .fire('dragend', e);
                }
            });


            /*
             * L.Control is a base class for implementing map controls. Handles positioning.
             * All other controls extend from this class.
             */

            L.Control = L.Class.extend({
                options: {
                    position: 'topright'
                },

                initialize: function(options) {
                    L.setOptions(this, options);
                },

                getPosition: function() {
                    return this.options.position;
                },

                setPosition: function(position) {
                    var map = this._map;

                    if (map) {
                        map.removeControl(this);
                    }

                    this.options.position = position;

                    if (map) {
                        map.addControl(this);
                    }

                    return this;
                },

                getContainer: function() {
                    return this._container;
                },

                addTo: function(map) {
                    this._map = map;

                    var container = this._container = this.onAdd(map),
                        pos = this.getPosition(),
                        corner = map._controlCorners[pos];

                    L.DomUtil.addClass(container, 'leaflet-control');

                    if (pos.indexOf('bottom') !== -1) {
                        corner.insertBefore(container, corner.firstChild);
                    } else {
                        corner.appendChild(container);
                    }

                    return this;
                },

                removeFrom: function(map) {
                    var pos = this.getPosition(),
                        corner = map._controlCorners[pos];

                    corner.removeChild(this._container);
                    this._map = null;

                    if (this.onRemove) {
                        this.onRemove(map);
                    }

                    return this;
                },

                _refocusOnMap: function() {
                    if (this._map) {
                        this._map.getContainer().focus();
                    }
                }
            });

            L.control = function(options) {
                return new L.Control(options);
            };


            // adds control-related methods to L.Map

            L.Map.include({
                addControl: function(control) {
                    control.addTo(this);
                    return this;
                },

                removeControl: function(control) {
                    control.removeFrom(this);
                    return this;
                },

                _initControlPos: function() {
                    var corners = this._controlCorners = {},
                        l = 'leaflet-',
                        container = this._controlContainer =
                        L.DomUtil.create('div', l + 'control-container', this._container);

                    function createCorner(vSide, hSide) {
                        var className = l + vSide + ' ' + l + hSide;

                        corners[vSide + hSide] = L.DomUtil.create('div', className, container);
                    }

                    createCorner('top', 'left');
                    createCorner('top', 'right');
                    createCorner('bottom', 'left');
                    createCorner('bottom', 'right');
                },

                _clearControlPos: function() {
                    this._container.removeChild(this._controlContainer);
                }
            });


            /*
             * L.Control.Zoom is used for the default zoom buttons on the map.
             */

            L.Control.Zoom = L.Control.extend({
                options: {
                    position: 'topleft',
                    zoomInText: '+',
                    zoomInTitle: 'Zoom in',
                    zoomOutText: '-',
                    zoomOutTitle: 'Zoom out'
                },

                onAdd: function(map) {
                    var zoomName = 'leaflet-control-zoom',
                        container = L.DomUtil.create('div', zoomName + ' leaflet-bar');

                    this._map = map;

                    this._zoomInButton = this._createButton(
                        this.options.zoomInText, this.options.zoomInTitle,
                        zoomName + '-in', container, this._zoomIn, this);
                    this._zoomOutButton = this._createButton(
                        this.options.zoomOutText, this.options.zoomOutTitle,
                        zoomName + '-out', container, this._zoomOut, this);

                    this._updateDisabled();
                    map.on('zoomend zoomlevelschange', this._updateDisabled, this);

                    return container;
                },

                onRemove: function(map) {
                    map.off('zoomend zoomlevelschange', this._updateDisabled, this);
                },

                _zoomIn: function(e) {
                    this._map.zoomIn(e.shiftKey ? 3 : 1);
                },

                _zoomOut: function(e) {
                    this._map.zoomOut(e.shiftKey ? 3 : 1);
                },

                _createButton: function(html, title, className, container, fn, context) {
                    var link = L.DomUtil.create('a', className, container);
                    link.innerHTML = html;
                    link.href = '#';
                    link.title = title;

                    var stop = L.DomEvent.stopPropagation;

                    L.DomEvent
                        .on(link, 'click', stop)
                        .on(link, 'mousedown', stop)
                        .on(link, 'dblclick', stop)
                        .on(link, 'click', L.DomEvent.preventDefault)
                        .on(link, 'click', fn, context)
                        .on(link, 'click', this._refocusOnMap, context);

                    return link;
                },

                _updateDisabled: function() {
                    var map = this._map,
                        className = 'leaflet-disabled';

                    L.DomUtil.removeClass(this._zoomInButton, className);
                    L.DomUtil.removeClass(this._zoomOutButton, className);

                    if (map._zoom === map.getMinZoom()) {
                        L.DomUtil.addClass(this._zoomOutButton, className);
                    }
                    if (map._zoom === map.getMaxZoom()) {
                        L.DomUtil.addClass(this._zoomInButton, className);
                    }
                }
            });

            L.Map.mergeOptions({
                zoomControl: true
            });

            L.Map.addInitHook(function() {
                if (this.options.zoomControl) {
                    this.zoomControl = new L.Control.Zoom();
                    this.addControl(this.zoomControl);
                }
            });

            L.control.zoom = function(options) {
                return new L.Control.Zoom(options);
            };



            /*
             * L.Control.Attribution is used for displaying attribution on the map (added by default).
             */

            L.Control.Attribution = L.Control.extend({
                options: {
                    position: 'bottomright',
                    prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
                },

                initialize: function(options) {
                    L.setOptions(this, options);

                    this._attributions = {};
                },

                onAdd: function(map) {
                    this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
                    L.DomEvent.disableClickPropagation(this._container);

                    for (var i in map._layers) {
                        if (map._layers[i].getAttribution) {
                            this.addAttribution(map._layers[i].getAttribution());
                        }
                    }

                    map
                        .on('layeradd', this._onLayerAdd, this)
                        .on('layerremove', this._onLayerRemove, this);

                    this._update();

                    return this._container;
                },

                onRemove: function(map) {
                    map
                        .off('layeradd', this._onLayerAdd)
                        .off('layerremove', this._onLayerRemove);

                },

                setPrefix: function(prefix) {
                    this.options.prefix = prefix;
                    this._update();
                    return this;
                },

                addAttribution: function(text) {
                    if (!text) {
                        return;
                    }

                    if (!this._attributions[text]) {
                        this._attributions[text] = 0;
                    }
                    this._attributions[text]++;

                    this._update();

                    return this;
                },

                removeAttribution: function(text) {
                    if (!text) {
                        return;
                    }

                    if (this._attributions[text]) {
                        this._attributions[text]--;
                        this._update();
                    }

                    return this;
                },

                _update: function() {
                    if (!this._map) {
                        return;
                    }

                    var attribs = [];

                    for (var i in this._attributions) {
                        if (this._attributions[i]) {
                            attribs.push(i);
                        }
                    }

                    var prefixAndAttribs = [];

                    if (this.options.prefix) {
                        prefixAndAttribs.push(this.options.prefix);
                    }
                    if (attribs.length) {
                        prefixAndAttribs.push(attribs.join(', '));
                    }

                    this._container.innerHTML = prefixAndAttribs.join(' | ');
                },

                _onLayerAdd: function(e) {
                    if (e.layer.getAttribution) {
                        this.addAttribution(e.layer.getAttribution());
                    }
                },

                _onLayerRemove: function(e) {
                    if (e.layer.getAttribution) {
                        this.removeAttribution(e.layer.getAttribution());
                    }
                }
            });

            L.Map.mergeOptions({
                attributionControl: true
            });

            L.Map.addInitHook(function() {
                if (this.options.attributionControl) {
                    this.attributionControl = (new L.Control.Attribution()).addTo(this);
                }
            });

            L.control.attribution = function(options) {
                return new L.Control.Attribution(options);
            };


            /*
             * L.Control.Scale is used for displaying metric/imperial scale on the map.
             */

            L.Control.Scale = L.Control.extend({
                options: {
                    position: 'bottomleft',
                    maxWidth: 100,
                    metric: true,
                    imperial: true,
                    updateWhenIdle: false
                },

                onAdd: function(map) {
                    this._map = map;

                    var className = 'leaflet-control-scale',
                        container = L.DomUtil.create('div', className),
                        options = this.options;

                    this._addScales(options, className, container);

                    map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
                    map.whenReady(this._update, this);

                    return container;
                },

                onRemove: function(map) {
                    map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
                },

                _addScales: function(options, className, container) {
                    if (options.metric) {
                        this._mScale = L.DomUtil.create('div', className + '-line', container);
                    }
                    if (options.imperial) {
                        this._iScale = L.DomUtil.create('div', className + '-line', container);
                    }
                },

                _update: function() {
                    var bounds = this._map.getBounds(),
                        centerLat = bounds.getCenter().lat,
                        halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
                        dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,

                        size = this._map.getSize(),
                        options = this.options,
                        maxMeters = 0;

                    if (size.x > 0) {
                        maxMeters = dist * (options.maxWidth / size.x);
                    }

                    this._updateScales(options, maxMeters);
                },

                _updateScales: function(options, maxMeters) {
                    if (options.metric && maxMeters) {
                        this._updateMetric(maxMeters);
                    }

                    if (options.imperial && maxMeters) {
                        this._updateImperial(maxMeters);
                    }
                },

                _updateMetric: function(maxMeters) {
                    var meters = this._getRoundNum(maxMeters);

                    this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
                    this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
                },

                _updateImperial: function(maxMeters) {
                    var maxFeet = maxMeters * 3.2808399,
                        scale = this._iScale,
                        maxMiles, miles, feet;

                    if (maxFeet > 5280) {
                        maxMiles = maxFeet / 5280;
                        miles = this._getRoundNum(maxMiles);

                        scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
                        scale.innerHTML = miles + ' mi';

                    } else {
                        feet = this._getRoundNum(maxFeet);

                        scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
                        scale.innerHTML = feet + ' ft';
                    }
                },

                _getScaleWidth: function(ratio) {
                    return Math.round(this.options.maxWidth * ratio) - 10;
                },

                _getRoundNum: function(num) {
                    var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
                        d = num / pow10;

                    d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

                    return pow10 * d;
                }
            });

            L.control.scale = function(options) {
                return new L.Control.Scale(options);
            };


            /*
             * L.Control.Layers is a control to allow users to switch between different layers on the map.
             */

            L.Control.Layers = L.Control.extend({
                options: {
                    collapsed: true,
                    position: 'topright',
                    autoZIndex: true
                },

                initialize: function(baseLayers, overlays, options) {
                    L.setOptions(this, options);

                    this._layers = {};
                    this._lastZIndex = 0;
                    this._handlingClick = false;

                    for (var i in baseLayers) {
                        this._addLayer(baseLayers[i], i);
                    }

                    for (i in overlays) {
                        this._addLayer(overlays[i], i, true);
                    }
                },

                onAdd: function(map) {
                    this._initLayout();
                    this._update();

                    map
                        .on('layeradd', this._onLayerChange, this)
                        .on('layerremove', this._onLayerChange, this);

                    return this._container;
                },

                onRemove: function(map) {
                    map
                        .off('layeradd', this._onLayerChange, this)
                        .off('layerremove', this._onLayerChange, this);
                },

                addBaseLayer: function(layer, name) {
                    this._addLayer(layer, name);
                    this._update();
                    return this;
                },

                addOverlay: function(layer, name) {
                    this._addLayer(layer, name, true);
                    this._update();
                    return this;
                },

                removeLayer: function(layer) {
                    var id = L.stamp(layer);
                    delete this._layers[id];
                    this._update();
                    return this;
                },

                _initLayout: function() {
                    var className = 'leaflet-control-layers',
                        container = this._container = L.DomUtil.create('div', className);

                    //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
                    container.setAttribute('aria-haspopup', true);

                    if (!L.Browser.touch) {
                        L.DomEvent
                            .disableClickPropagation(container)
                            .disableScrollPropagation(container);
                    } else {
                        L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
                    }

                    var form = this._form = L.DomUtil.create('form', className + '-list');

                    if (this.options.collapsed) {
                        if (!L.Browser.android) {
                            L.DomEvent
                                .on(container, 'mouseover', this._expand, this)
                                .on(container, 'mouseout', this._collapse, this);
                        }
                        var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
                        link.href = '#';
                        link.title = 'Layers';

                        if (L.Browser.touch) {
                            L.DomEvent
                                .on(link, 'click', L.DomEvent.stop)
                                .on(link, 'click', this._expand, this);
                        } else {
                            L.DomEvent.on(link, 'focus', this._expand, this);
                        }
                        //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
                        L.DomEvent.on(form, 'click', function() {
                            setTimeout(L.bind(this._onInputClick, this), 0);
                        }, this);

                        this._map.on('click', this._collapse, this);
                        // TODO keyboard accessibility
                    } else {
                        this._expand();
                    }

                    this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
                    this._separator = L.DomUtil.create('div', className + '-separator', form);
                    this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

                    container.appendChild(form);
                },

                _addLayer: function(layer, name, overlay) {
                    var id = L.stamp(layer);

                    this._layers[id] = {
                        layer: layer,
                        name: name,
                        overlay: overlay
                    };

                    if (this.options.autoZIndex && layer.setZIndex) {
                        this._lastZIndex++;
                        layer.setZIndex(this._lastZIndex);
                    }
                },

                _update: function() {
                    if (!this._container) {
                        return;
                    }

                    this._baseLayersList.innerHTML = '';
                    this._overlaysList.innerHTML = '';

                    var baseLayersPresent = false,
                        overlaysPresent = false,
                        i, obj;

                    for (i in this._layers) {
                        obj = this._layers[i];
                        this._addItem(obj);
                        overlaysPresent = overlaysPresent || obj.overlay;
                        baseLayersPresent = baseLayersPresent || !obj.overlay;
                    }

                    this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
                },

                _onLayerChange: function(e) {
                    var obj = this._layers[L.stamp(e.layer)];

                    if (!obj) {
                        return;
                    }

                    if (!this._handlingClick) {
                        this._update();
                    }

                    var type = obj.overlay ?
                        (e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
                        (e.type === 'layeradd' ? 'baselayerchange' : null);

                    if (type) {
                        this._map.fire(type, obj);
                    }
                },

                // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
                _createRadioElement: function(name, checked) {

                    var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
                    if (checked) {
                        radioHtml += ' checked="checked"';
                    }
                    radioHtml += '/>';

                    var radioFragment = document.createElement('div');
                    radioFragment.innerHTML = radioHtml;

                    return radioFragment.firstChild;
                },

                _addItem: function(obj) {
                    var label = document.createElement('label'),
                        input,
                        checked = this._map.hasLayer(obj.layer);

                    if (obj.overlay) {
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.className = 'leaflet-control-layers-selector';
                        input.defaultChecked = checked;
                    } else {
                        input = this._createRadioElement('leaflet-base-layers', checked);
                    }

                    input.layerId = L.stamp(obj.layer);

                    L.DomEvent.on(input, 'click', this._onInputClick, this);

                    var name = document.createElement('span');
                    name.innerHTML = ' ' + obj.name;

                    label.appendChild(input);
                    label.appendChild(name);

                    var container = obj.overlay ? this._overlaysList : this._baseLayersList;
                    container.appendChild(label);

                    return label;
                },

                _onInputClick: function() {
                    var i, input, obj,
                        inputs = this._form.getElementsByTagName('input'),
                        inputsLen = inputs.length;

                    this._handlingClick = true;

                    for (i = 0; i < inputsLen; i++) {
                        input = inputs[i];
                        obj = this._layers[input.layerId];

                        if (input.checked && !this._map.hasLayer(obj.layer)) {
                            this._map.addLayer(obj.layer);

                        } else if (!input.checked && this._map.hasLayer(obj.layer)) {
                            this._map.removeLayer(obj.layer);
                        }
                    }

                    this._handlingClick = false;

                    this._refocusOnMap();
                },

                _expand: function() {
                    L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
                },

                _collapse: function() {
                    this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
                }
            });

            L.control.layers = function(baseLayers, overlays, options) {
                return new L.Control.Layers(baseLayers, overlays, options);
            };


            /*
             * L.PosAnimation is used by Leaflet internally for pan animations.
             */

            L.PosAnimation = L.Class.extend({
                includes: L.Mixin.Events,

                run: function(el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
                    this.stop();

                    this._el = el;
                    this._inProgress = true;
                    this._newPos = newPos;

                    this.fire('start');

                    el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
                        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

                    L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
                    L.DomUtil.setPosition(el, newPos);

                    // toggle reflow, Chrome flickers for some reason if you don't do this
                    L.Util.falseFn(el.offsetWidth);

                    // there's no native way to track value updates of transitioned properties, so we imitate this
                    this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
                },

                stop: function() {
                    if (!this._inProgress) {
                        return;
                    }

                    // if we just removed the transition property, the element would jump to its final position,
                    // so we need to make it stay at the current position

                    L.DomUtil.setPosition(this._el, this._getPos());
                    this._onTransitionEnd();
                    L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
                },

                _onStep: function() {
                    var stepPos = this._getPos();
                    if (!stepPos) {
                        this._onTransitionEnd();
                        return;
                    }
                    // jshint camelcase: false
                    // make L.DomUtil.getPosition return intermediate position value during animation
                    this._el._leaflet_pos = stepPos;

                    this.fire('step');
                },

                // you can't easily get intermediate values of properties animated with CSS3 Transitions,
                // we need to parse computed style (in case of transform it returns matrix string)

                _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,

                _getPos: function() {
                    var left, top, matches,
                        el = this._el,
                        style = window.getComputedStyle(el);

                    if (L.Browser.any3d) {
                        matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
                        if (!matches) {
                            return;
                        }
                        left = parseFloat(matches[1]);
                        top = parseFloat(matches[2]);
                    } else {
                        left = parseFloat(style.left);
                        top = parseFloat(style.top);
                    }

                    return new L.Point(left, top, true);
                },

                _onTransitionEnd: function() {
                    L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

                    if (!this._inProgress) {
                        return;
                    }
                    this._inProgress = false;

                    this._el.style[L.DomUtil.TRANSITION] = '';

                    // jshint camelcase: false
                    // make sure L.DomUtil.getPosition returns the final position value after animation
                    this._el._leaflet_pos = this._newPos;

                    clearInterval(this._stepTimer);

                    this.fire('step').fire('end');
                }

            });


            /*
             * Extends L.Map to handle panning animations.
             */

            L.Map.include({

                setView: function(center, zoom, options) {

                    zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
                    center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
                    options = options || {};

                    if (this._panAnim) {
                        this._panAnim.stop();
                    }

                    if (this._loaded && !options.reset && options !== true) {

                        if (options.animate !== undefined) {
                            options.zoom = L.extend({
                                animate: options.animate
                            }, options.zoom);
                            options.pan = L.extend({
                                animate: options.animate
                            }, options.pan);
                        }

                        // try animating pan or zoom
                        var animated = (this._zoom !== zoom) ?
                            this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
                            this._tryAnimatedPan(center, options.pan);

                        if (animated) {
                            // prevent resize handler call, the view will refresh after animation anyway
                            clearTimeout(this._sizeTimer);
                            return this;
                        }
                    }

                    // animation didn't start, just reset the map view
                    this._resetView(center, zoom);

                    return this;
                },

                panBy: function(offset, options) {
                    offset = L.point(offset).round();
                    options = options || {};

                    if (!offset.x && !offset.y) {
                        return this;
                    }

                    if (!this._panAnim) {
                        this._panAnim = new L.PosAnimation();

                        this._panAnim.on({
                            'step': this._onPanTransitionStep,
                            'end': this._onPanTransitionEnd
                        }, this);
                    }

                    // don't fire movestart if animating inertia
                    if (!options.noMoveStart) {
                        this.fire('movestart');
                    }

                    // animate pan unless animate: false specified
                    if (options.animate !== false) {
                        L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

                        var newPos = this._getMapPanePos().subtract(offset);
                        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
                    } else {
                        this._rawPanBy(offset);
                        this.fire('move').fire('moveend');
                    }

                    return this;
                },

                _onPanTransitionStep: function() {
                    this.fire('move');
                },

                _onPanTransitionEnd: function() {
                    L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
                    this.fire('moveend');
                },

                _tryAnimatedPan: function(center, options) {
                    // difference between the new and current centers in pixels
                    var offset = this._getCenterOffset(center)._floor();

                    // don't animate too far unless animate: true specified in options
                    if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
                        return false;
                    }

                    this.panBy(offset, options);

                    return true;
                }
            });


            /*
             * L.PosAnimation fallback implementation that powers Leaflet pan animations
             * in browsers that don't support CSS3 Transitions.
             */

            L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({

                run: function(el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
                    this.stop();

                    this._el = el;
                    this._inProgress = true;
                    this._duration = duration || 0.25;
                    this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

                    this._startPos = L.DomUtil.getPosition(el);
                    this._offset = newPos.subtract(this._startPos);
                    this._startTime = +new Date();

                    this.fire('start');

                    this._animate();
                },

                stop: function() {
                    if (!this._inProgress) {
                        return;
                    }

                    this._step();
                    this._complete();
                },

                _animate: function() {
                    // animation loop
                    this._animId = L.Util.requestAnimFrame(this._animate, this);
                    this._step();
                },

                _step: function() {
                    var elapsed = (+new Date()) - this._startTime,
                        duration = this._duration * 1000;

                    if (elapsed < duration) {
                        this._runFrame(this._easeOut(elapsed / duration));
                    } else {
                        this._runFrame(1);
                        this._complete();
                    }
                },

                _runFrame: function(progress) {
                    var pos = this._startPos.add(this._offset.multiplyBy(progress));
                    L.DomUtil.setPosition(this._el, pos);

                    this.fire('step');
                },

                _complete: function() {
                    L.Util.cancelAnimFrame(this._animId);

                    this._inProgress = false;
                    this.fire('end');
                },

                _easeOut: function(t) {
                    return 1 - Math.pow(1 - t, this._easeOutPower);
                }
            });


            /*
             * Extends L.Map to handle zoom animations.
             */

            L.Map.mergeOptions({
                zoomAnimation: true,
                zoomAnimationThreshold: 4
            });

            if (L.DomUtil.TRANSITION) {

                L.Map.addInitHook(function() {
                    // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
                    this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&
                        L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;

                    // zoom transitions run with the same duration for all layers, so if one of transitionend events
                    // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
                    if (this._zoomAnimated) {
                        L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
                    }
                });
            }

            L.Map.include(!L.DomUtil.TRANSITION ? {} : {

                _catchTransitionEnd: function(e) {
                    if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
                        this._onZoomTransitionEnd();
                    }
                },

                _nothingToAnimate: function() {
                    return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
                },

                _tryAnimatedZoom: function(center, zoom, options) {

                    if (this._animatingZoom) {
                        return true;
                    }

                    options = options || {};

                    // don't animate if disabled, not supported or zoom difference is too large
                    if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
                        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
                        return false;
                    }

                    // offset is the pixel coords of the zoom origin relative to the current center
                    var scale = this.getZoomScale(zoom),
                        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
                        origin = this._getCenterLayerPoint()._add(offset);

                    // don't animate if the zoom origin isn't within one screen from the current center, unless forced
                    if (options.animate !== true && !this.getSize().contains(offset)) {
                        return false;
                    }

                    this
                        .fire('movestart')
                        .fire('zoomstart');

                    this._animateZoom(center, zoom, origin, scale, null, true);

                    return true;
                },

                _animateZoom: function(center, zoom, origin, scale, delta, backwards, forTouchZoom) {

                    if (!forTouchZoom) {
                        this._animatingZoom = true;
                    }

                    // put transform transition on all layers with leaflet-zoom-animated class
                    L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');

                    // remember what center/zoom to set after animation
                    this._animateToCenter = center;
                    this._animateToZoom = zoom;

                    // disable any dragging during animation
                    if (L.Draggable) {
                        L.Draggable._disabled = true;
                    }

                    L.Util.requestAnimFrame(function() {
                        this.fire('zoomanim', {
                            center: center,
                            zoom: zoom,
                            origin: origin,
                            scale: scale,
                            delta: delta,
                            backwards: backwards
                        });
                        // horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689
                        setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
                    }, this);
                },

                _onZoomTransitionEnd: function() {
                    if (!this._animatingZoom) {
                        return;
                    }

                    this._animatingZoom = false;

                    L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

                    L.Util.requestAnimFrame(function() {
                        this._resetView(this._animateToCenter, this._animateToZoom, true, true);

                        if (L.Draggable) {
                            L.Draggable._disabled = false;
                        }
                    }, this);
                }
            });


            /*
                Zoom animation logic for L.TileLayer.
            */

            L.TileLayer.include({
                _animateZoom: function(e) {
                    if (!this._animating) {
                        this._animating = true;
                        this._prepareBgBuffer();
                    }

                    var bg = this._bgBuffer,
                        transform = L.DomUtil.TRANSFORM,
                        initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
                        scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);

                    bg.style[transform] = e.backwards ?
                        scaleStr + ' ' + initialTransform :
                        initialTransform + ' ' + scaleStr;
                },

                _endZoomAnim: function() {
                    var front = this._tileContainer,
                        bg = this._bgBuffer;

                    front.style.visibility = '';
                    front.parentNode.appendChild(front); // Bring to fore

                    // force reflow
                    L.Util.falseFn(bg.offsetWidth);

                    var zoom = this._map.getZoom();
                    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                        this._clearBgBuffer();
                    }

                    this._animating = false;
                },

                _clearBgBuffer: function() {
                    var map = this._map;

                    if (map && !map._animatingZoom && !map.touchZoom._zooming) {
                        this._bgBuffer.innerHTML = '';
                        this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
                    }
                },

                _prepareBgBuffer: function() {

                    var front = this._tileContainer,
                        bg = this._bgBuffer;

                    // if foreground layer doesn't have many tiles but bg layer does,
                    // keep the existing bg layer and just zoom it some more

                    var bgLoaded = this._getLoadedTilesPercentage(bg),
                        frontLoaded = this._getLoadedTilesPercentage(front);

                    if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

                        front.style.visibility = 'hidden';
                        this._stopLoadingImages(front);
                        return;
                    }

                    // prepare the buffer to become the front tile pane
                    bg.style.visibility = 'hidden';
                    bg.style[L.DomUtil.TRANSFORM] = '';

                    // switch out the current layer to be the new bg layer (and vice-versa)
                    this._tileContainer = bg;
                    bg = this._bgBuffer = front;

                    this._stopLoadingImages(bg);

                    //prevent bg buffer from clearing right after zoom
                    clearTimeout(this._clearBgBufferTimer);
                },

                _getLoadedTilesPercentage: function(container) {
                    var tiles = container.getElementsByTagName('img'),
                        i, len, count = 0;

                    for (i = 0, len = tiles.length; i < len; i++) {
                        if (tiles[i].complete) {
                            count++;
                        }
                    }
                    return count / len;
                },

                // stops loading all tiles in the background layer
                _stopLoadingImages: function(container) {
                    var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
                        i, len, tile;

                    for (i = 0, len = tiles.length; i < len; i++) {
                        tile = tiles[i];

                        if (!tile.complete) {
                            tile.onload = L.Util.falseFn;
                            tile.onerror = L.Util.falseFn;
                            tile.src = L.Util.emptyImageUrl;

                            tile.parentNode.removeChild(tile);
                        }
                    }
                }
            });


            /*
             * Provides L.Map with convenient shortcuts for using browser geolocation features.
             */

            L.Map.include({
                _defaultLocateOptions: {
                    watch: false,
                    setView: false,
                    maxZoom: Infinity,
                    timeout: 10000,
                    maximumAge: 0,
                    enableHighAccuracy: false
                },

                locate: function( /*Object*/ options) {

                    options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

                    if (!navigator.geolocation) {
                        this._handleGeolocationError({
                            code: 0,
                            message: 'Geolocation not supported.'
                        });
                        return this;
                    }

                    var onResponse = L.bind(this._handleGeolocationResponse, this),
                        onError = L.bind(this._handleGeolocationError, this);

                    if (options.watch) {
                        this._locationWatchId =
                            navigator.geolocation.watchPosition(onResponse, onError, options);
                    } else {
                        navigator.geolocation.getCurrentPosition(onResponse, onError, options);
                    }
                    return this;
                },

                stopLocate: function() {
                    if (navigator.geolocation) {
                        navigator.geolocation.clearWatch(this._locationWatchId);
                    }
                    if (this._locateOptions) {
                        this._locateOptions.setView = false;
                    }
                    return this;
                },

                _handleGeolocationError: function(error) {
                    var c = error.code,
                        message = error.message ||
                        (c === 1 ? 'permission denied' :
                            (c === 2 ? 'position unavailable' : 'timeout'));

                    if (this._locateOptions.setView && !this._loaded) {
                        this.fitWorld();
                    }

                    this.fire('locationerror', {
                        code: c,
                        message: 'Geolocation error: ' + message + '.'
                    });
                },

                _handleGeolocationResponse: function(pos) {
                    var lat = pos.coords.latitude,
                        lng = pos.coords.longitude,
                        latlng = new L.LatLng(lat, lng),

                        latAccuracy = 180 * pos.coords.accuracy / 40075017,
                        lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),

                        bounds = L.latLngBounds(
                            [lat - latAccuracy, lng - lngAccuracy], [lat + latAccuracy, lng + lngAccuracy]),

                        options = this._locateOptions;

                    if (options.setView) {
                        var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
                        this.setView(latlng, zoom);
                    }

                    var data = {
                        latlng: latlng,
                        bounds: bounds,
                        timestamp: pos.timestamp
                    };

                    for (var i in pos.coords) {
                        if (typeof pos.coords[i] === 'number') {
                            data[i] = pos.coords[i];
                        }
                    }

                    this.fire('locationfound', data);
                }
            });


        }(window, document));

        /***/
    }),
    /* 4 */
    /***/
    (function(module, exports) {

        var g;

        // This works in non-strict mode
        g = (function() {
            return this;
        })();

        try {
            // This works if eval is allowed (see CSP)
            g = g || Function("return this")() || (1, eval)("this");
        } catch (e) {
            // This works if the window reference is available
            if (typeof window === "object")
                g = window;
        }

        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}

        module.exports = g;


        /***/
    }),
    /* 5 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony default export */
        __webpack_exports__["a"] = ({
            appname: "overpass-turbo",
            defaultServer: "//overpass-api.de/api/",
            suggestedServers: [
                "//overpass-api.de/api/",
                "http://overpass.osm.rambler.ru/cgi/",
                "//overpass.openstreetmap.fr/api/"
            ],
            defaultTiles: "//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
            tileServerAttribution: "&copy; OpenStreetMap.org contributors&ensp;<small>Data:ODbL, Map:cc-by-sa</small>",
            suggestedTiles: [
                "//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                //"http://{s}.tile.opencyclemap.org/cycle/{z}/{x}/{y}.png",
                //"http://{s}.tile2.opencyclemap.org/transport/{z}/{x}/{y}.png",
                //"http://{s}.tile3.opencyclemap.org/landscape/{z}/{x}/{y}.png",
                //"http://otile1.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.jpg",
            ],
            defaultMapView: {
                lat: 41.89,
                lon: 12.492,
                zoom: 16
            },
            maxMapZoom: 20,
            short_url_service: "",
            html2canvas_use_proxy: false,
            // api key for osmnames geocoder, go to http://osmnames.org/api/ to get one if you run your own overpass instance
            osmnamesApiKey: "gtXyh2mBSaN5zWqqqQRh",
            // osmAuth configuration object (used for syncing saved queries). expects an osm-auth config object (min. the oauth_consumer_key and oauth_secret must be given), see https://github.com/osmlab/osm-auth#getting-keys
            osmAuth: null
        });


        /***/
    }),
    /* 6 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(module, global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            /**
             * @license
             * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
             * Build: `lodash modern -o ./dist/lodash.js`
             * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
             * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
             * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             * Available under MIT license <http://lodash.com/license>
             */
            ;
            (function() {

                /** Used as a safe reference for `undefined` in pre ES5 environments */
                var undefined;

                /** Used to pool arrays and objects used internally */
                var arrayPool = [],
                    objectPool = [];

                /** Used to generate unique IDs */
                var idCounter = 0;

                /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
                var keyPrefix = +new Date + '';

                /** Used as the size when optimizations are enabled for large arrays */
                var largeArraySize = 75;

                /** Used as the max size of the `arrayPool` and `objectPool` */
                var maxPoolSize = 40;

                /** Used to detect and test whitespace */
                var whitespace = (
                    // whitespace
                    ' \t\x0B\f\xA0\ufeff' +

                    // line terminators
                    '\n\r\u2028\u2029' +

                    // unicode category "Zs" space separators
                    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
                );

                /** Used to match empty string literals in compiled template source */
                var reEmptyStringLeading = /\b__p \+= '';/g,
                    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

                /**
                 * Used to match ES6 template delimiters
                 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
                 */
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

                /** Used to match regexp flags from their coerced string values */
                var reFlags = /\w*$/;

                /** Used to detected named functions */
                var reFuncName = /^\s*function[ \n\r\t]+\w/;

                /** Used to match "interpolate" template delimiters */
                var reInterpolate = /<%=([\s\S]+?)%>/g;

                /** Used to match leading whitespace and zeros to be removed */
                var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

                /** Used to ensure capturing order of template delimiters */
                var reNoMatch = /($^)/;

                /** Used to detect functions containing a `this` reference */
                var reThis = /\bthis\b/;

                /** Used to match unescaped characters in compiled string literals */
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

                /** Used to assign default `context` object properties */
                var contextProps = [
                    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
                    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
                    'parseInt', 'setTimeout'
                ];

                /** Used to make template sourceURLs easier to identify */
                var templateCounter = 0;

                /** `Object#toString` result shortcuts */
                var argsClass = '[object Arguments]',
                    arrayClass = '[object Array]',
                    boolClass = '[object Boolean]',
                    dateClass = '[object Date]',
                    funcClass = '[object Function]',
                    numberClass = '[object Number]',
                    objectClass = '[object Object]',
                    regexpClass = '[object RegExp]',
                    stringClass = '[object String]';

                /** Used to identify object classifications that `_.clone` supports */
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
                    cloneableClasses[boolClass] = cloneableClasses[dateClass] =
                    cloneableClasses[numberClass] = cloneableClasses[objectClass] =
                    cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

                /** Used as an internal `_.debounce` options object */
                var debounceOptions = {
                    'leading': false,
                    'maxWait': 0,
                    'trailing': false
                };

                /** Used as the property descriptor for `__bindData__` */
                var descriptor = {
                    'configurable': false,
                    'enumerable': false,
                    'value': null,
                    'writable': false
                };

                /** Used to determine if values are of the language type Object */
                var objectTypes = {
                    'boolean': false,
                    'function': true,
                    'object': true,
                    'number': false,
                    'string': false,
                    'undefined': false
                };

                /** Used to escape characters for inclusion in compiled string literals */
                var stringEscapes = {
                    '\\': '\\',
                    "'": "'",
                    '\n': 'n',
                    '\r': 'r',
                    '\t': 't',
                    '\u2028': 'u2028',
                    '\u2029': 'u2029'
                };

                /** Used as a reference to the global object */
                var root = (objectTypes[typeof window] && window) || this;

                /** Detect free variable `exports` */
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

                /** Detect free variable `module` */
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

                /** Detect the popular CommonJS extension `module.exports` */
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

                /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * The base implementation of `_.indexOf` without support for binary searches
                 * or `fromIndex` constraints.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @returns {number} Returns the index of the matched value or `-1`.
                 */
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1,
                        length = array ? array.length : 0;

                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * An implementation of `_.contains` for cache objects that mimics the return
                 * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
                 *
                 * @private
                 * @param {Object} cache The cache object to inspect.
                 * @param {*} value The value to search for.
                 * @returns {number} Returns `0` if `value` is found, else `-1`.
                 */
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;

                    if (type == 'boolean' || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != 'number' && type != 'string') {
                        type = 'object';
                    }
                    var key = type == 'number' ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];

                    return type == 'object' ?
                        (cache && baseIndexOf(cache, value) > -1 ? 0 : -1) :
                        (cache ? 0 : -1);
                }

                /**
                 * Adds a given value to the corresponding cache object.
                 *
                 * @private
                 * @param {*} value The value to add to the cache.
                 */
                function cachePush(value) {
                    var cache = this.cache,
                        type = typeof value;

                    if (type == 'boolean' || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != 'number' && type != 'string') {
                            type = 'object';
                        }
                        var key = type == 'number' ? value : keyPrefix + value,
                            typeCache = cache[type] || (cache[type] = {});

                        if (type == 'object') {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }

                /**
                 * Used by `_.max` and `_.min` as the default callback when a given
                 * collection is a string value.
                 *
                 * @private
                 * @param {string} value The character to inspect.
                 * @returns {number} Returns the code unit of given character.
                 */
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }

                /**
                 * Used by `sortBy` to compare transformed `collection` elements, stable sorting
                 * them in ascending order.
                 *
                 * @private
                 * @param {Object} a The object to compare to `b`.
                 * @param {Object} b The object to compare to `a`.
                 * @returns {number} Returns the sort order indicator of `1` or `-1`.
                 */
                function compareAscending(a, b) {
                    var ac = a.criteria,
                        bc = b.criteria,
                        index = -1,
                        length = ac.length;

                    while (++index < length) {
                        var value = ac[index],
                            other = bc[index];

                        if (value !== other) {
                            if (value > other || typeof value == 'undefined') {
                                return 1;
                            }
                            if (value < other || typeof other == 'undefined') {
                                return -1;
                            }
                        }
                    }
                    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                    // that causes it, under certain circumstances, to return the same value for
                    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
                    //
                    // This also ensures a stable sort in V8 and other engines.
                    // See http://code.google.com/p/v8/issues/detail?id=90
                    return a.index - b.index;
                }

                /**
                 * Creates a cache object to optimize linear searches of large arrays.
                 *
                 * @private
                 * @param {Array} [array=[]] The array to search.
                 * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
                 */
                function createCache(array) {
                    var index = -1,
                        length = array.length,
                        first = array[0],
                        mid = array[(length / 2) | 0],
                        last = array[length - 1];

                    if (first && typeof first == 'object' &&
                        mid && typeof mid == 'object' && last && typeof last == 'object') {
                        return false;
                    }
                    var cache = getObject();
                    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;

                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }

                /**
                 * Used by `template` to escape characters for inclusion in compiled
                 * string literals.
                 *
                 * @private
                 * @param {string} match The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeStringChar(match) {
                    return '\\' + stringEscapes[match];
                }

                /**
                 * Gets an array from the array pool or creates a new one if the pool is empty.
                 *
                 * @private
                 * @returns {Array} The array from the pool.
                 */
                function getArray() {
                    return arrayPool.pop() || [];
                }

                /**
                 * Gets an object from the object pool or creates a new one if the pool is empty.
                 *
                 * @private
                 * @returns {Object} The object from the pool.
                 */
                function getObject() {
                    return objectPool.pop() || {
                        'array': null,
                        'cache': null,
                        'criteria': null,
                        'false': false,
                        'index': 0,
                        'null': false,
                        'number': null,
                        'object': null,
                        'push': null,
                        'string': null,
                        'true': false,
                        'undefined': false,
                        'value': null
                    };
                }

                /**
                 * Releases the given array back to the array pool.
                 *
                 * @private
                 * @param {Array} [array] The array to release.
                 */
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }

                /**
                 * Releases the given object back to the object pool.
                 *
                 * @private
                 * @param {Object} [object] The object to release.
                 */
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }

                /**
                 * Slices the `collection` from the `start` index up to, but not including,
                 * the `end` index.
                 *
                 * Note: This function is used instead of `Array#slice` to support node lists
                 * in IE < 9 and to ensure dense arrays are returned.
                 *
                 * @private
                 * @param {Array|Object|string} collection The collection to slice.
                 * @param {number} start The start index.
                 * @param {number} end The end index.
                 * @returns {Array} Returns the new array.
                 */
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == 'undefined') {
                        end = array ? array.length : 0;
                    }
                    var index = -1,
                        length = end - start || 0,
                        result = Array(length < 0 ? 0 : length);

                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * Create a new `lodash` function using the given context object.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {Object} [context=root] The context object.
                 * @returns {Function} Returns the `lodash` function.
                 */
                function runInContext(context) {
                    // Avoid issues with some ES3 environments that attempt to use values, named
                    // after built-in constructors like `Object`, for the creation of literals.
                    // ES5 clears this up by stating that literals must use built-in constructors.
                    // See http://es5.github.io/#x11.1.5.
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

                    /** Native constructor references */
                    var Array = context.Array,
                        Boolean = context.Boolean,
                        Date = context.Date,
                        Function = context.Function,
                        Math = context.Math,
                        Number = context.Number,
                        Object = context.Object,
                        RegExp = context.RegExp,
                        String = context.String,
                        TypeError = context.TypeError;

                    /**
                     * Used for `Array` method references.
                     *
                     * Normally `Array.prototype` would suffice, however, using an array literal
                     * avoids issues in Narwhal.
                     */
                    var arrayRef = [];

                    /** Used for native method references */
                    var objectProto = Object.prototype;

                    /** Used to restore the original `_` reference in `noConflict` */
                    var oldDash = context._;

                    /** Used to resolve the internal [[Class]] of values */
                    var toString = objectProto.toString;

                    /** Used to detect if a method is native */
                    var reNative = RegExp('^' +
                        String(toString)
                        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                        .replace(/toString| for [^\]]+/g, '.*?') + '$'
                    );

                    /** Native method shortcuts */
                    var ceil = Math.ceil,
                        clearTimeout = context.clearTimeout,
                        floor = Math.floor,
                        fnToString = Function.prototype.toString,
                        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
                        hasOwnProperty = objectProto.hasOwnProperty,
                        push = arrayRef.push,
                        setTimeout = context.setTimeout,
                        splice = arrayRef.splice,
                        unshift = arrayRef.unshift;

                    /** Used to set meta data on functions */
                    var defineProperty = (function() {
                        // IE 8 only accepts DOM elements
                        try {
                            var o = {},
                                func = isNative(func = Object.defineProperty) && func,
                                result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }());

                    /* Native method shortcuts for methods with the same name as other `lodash` methods */
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
                        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
                        nativeIsFinite = context.isFinite,
                        nativeIsNaN = context.isNaN,
                        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
                        nativeMax = Math.max,
                        nativeMin = Math.min,
                        nativeParseInt = context.parseInt,
                        nativeRandom = Math.random;

                    /** Used to lookup a built-in constructor by [[Class]] */
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object which wraps the given value to enable intuitive
                     * method chaining.
                     *
                     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
                     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
                     * and `unshift`
                     *
                     * Chaining is supported in custom builds as long as the `value` method is
                     * implicitly or explicitly included in the build.
                     *
                     * The chainable wrapper functions are:
                     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
                     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
                     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
                     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
                     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
                     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
                     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
                     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
                     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
                     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
                     * and `zip`
                     *
                     * The non-chainable wrapper functions are:
                     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
                     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
                     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
                     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
                     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
                     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
                     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
                     * `template`, `unescape`, `uniqueId`, and `value`
                     *
                     * The wrapper functions `first` and `last` return wrapped values when `n` is
                     * provided, otherwise they return unwrapped values.
                     *
                     * Explicit chaining can be enabled by using the `_.chain` method.
                     *
                     * @name _
                     * @constructor
                     * @category Chaining
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @returns {Object} Returns a `lodash` instance.
                     * @example
                     *
                     * var wrapped = _([1, 2, 3]);
                     *
                     * // returns an unwrapped value
                     * wrapped.reduce(function(sum, num) {
                     *   return sum + num;
                     * });
                     * // => 6
                     *
                     * // returns a wrapped value
                     * var squares = wrapped.map(function(num) {
                     *   return num * num;
                     * });
                     *
                     * _.isArray(squares);
                     * // => false
                     *
                     * _.isArray(squares.value());
                     * // => true
                     */
                    function lodash(value) {
                        // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
                        return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__')) ?
                            value :
                            new lodashWrapper(value);
                    }

                    /**
                     * A fast path for creating `lodash` wrapper objects.
                     *
                     * @private
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @param {boolean} chainAll A flag to enable chaining for all methods
                     * @returns {Object} Returns a `lodash` instance.
                     */
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    // ensure `new lodashWrapper` is an instance of `lodash`
                    lodashWrapper.prototype = lodash.prototype;

                    /**
                     * An object used to flag environments features.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    var support = lodash.support = {};

                    /**
                     * Detect if functions can be decompiled by `Function#toString`
                     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

                    /**
                     * Detect if `Function#name` is supported (all but IE).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.funcNames = typeof Function.name == 'string';

                    /**
                     * By default, the template delimiters used by Lo-Dash are similar to those in
                     * embedded Ruby (ERB). Change the following template settings to use alternative
                     * delimiters.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    lodash.templateSettings = {

                        /**
                         * Used to detect `data` property values to be HTML-escaped.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'escape': /<%-([\s\S]+?)%>/g,

                        /**
                         * Used to detect code to be evaluated.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'evaluate': /<%([\s\S]+?)%>/g,

                        /**
                         * Used to detect `data` property values to inject.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'interpolate': reInterpolate,

                        /**
                         * Used to reference the data object in the template text.
                         *
                         * @memberOf _.templateSettings
                         * @type string
                         */
                        'variable': '',

                        /**
                         * Used to import variables into the compiled template.
                         *
                         * @memberOf _.templateSettings
                         * @type Object
                         */
                        'imports': {

                            /**
                             * A reference to the `lodash` function.
                             *
                             * @memberOf _.templateSettings.imports
                             * @type Function
                             */
                            '_': lodash
                        }
                    };

                    /*--------------------------------------------------------------------------*/

                    /**
                     * The base implementation of `_.bind` that creates the bound function and
                     * sets its meta data.
                     *
                     * @private
                     * @param {Array} bindData The bind data array.
                     * @returns {Function} Returns the new bound function.
                     */
                    function baseBind(bindData) {
                        var func = bindData[0],
                            partialArgs = bindData[2],
                            thisArg = bindData[4];

                        function bound() {
                            // `Function#bind` spec
                            // http://es5.github.io/#x15.3.4.5
                            if (partialArgs) {
                                // avoid `arguments` object deoptimizations by using `slice` instead
                                // of `Array.prototype.slice.call` and not assigning `arguments` to a
                                // variable as a ternary expression
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            // mimic the constructor's `return` behavior
                            // http://es5.github.io/#x13.2.2
                            if (this instanceof bound) {
                                // ensure `new bound` is an instance of `func`
                                var thisBinding = baseCreate(func.prototype),
                                    result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }

                    /**
                     * The base implementation of `_.clone` without argument juggling or support
                     * for `thisArg` binding.
                     *
                     * @private
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep=false] Specify a deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates clones with source counterparts.
                     * @returns {*} Returns the cloned value.
                     */
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != 'undefined') {
                                return result;
                            }
                        }
                        // inspect [[Class]]
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                                case boolClass:
                                case dateClass:
                                    return new ctor(+value);

                                case numberClass:
                                case stringClass:
                                    return new ctor(value);

                                case regexpClass:
                                    result = ctor(value.source, reFlags.exec(value));
                                    result.lastIndex = value.lastIndex;
                                    return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            // check for circular references and return corresponding clone
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());

                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        // add array properties assigned by `RegExp#exec`
                        if (isArr) {
                            if (hasOwnProperty.call(value, 'index')) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, 'input')) {
                                result.input = value.input;
                            }
                        }
                        // exit for shallow clone
                        if (!isDeep) {
                            return result;
                        }
                        // add the source value to the stack of traversed objects
                        // and associate it with its clone
                        stackA.push(value);
                        stackB.push(result);

                        // recursively populate clone (susceptible to call stack limits)
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });

                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.create` without support for assigning
                     * properties to the created object.
                     *
                     * @private
                     * @param {Object} prototype The object to inherit from.
                     * @returns {Object} Returns the new object.
                     */
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    // fallback for browsers without `Object.create`
                    if (!nativeCreate) {
                        baseCreate = (function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object;
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }());
                    }

                    /**
                     * The base implementation of `_.createCallback` without support for creating
                     * "_.pluck" or "_.where" style callbacks.
                     *
                     * @private
                     * @param {*} [func=identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of the created callback.
                     * @param {number} [argCount] The number of arguments the callback accepts.
                     * @returns {Function} Returns a callback function.
                     */
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != 'function') {
                            return identity;
                        }
                        // exit early for no `thisArg` or already bound by `Function#bind`
                        if (typeof thisArg == 'undefined' || !('prototype' in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == 'undefined') {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    // checks if `func` references the `this` keyword and stores the result
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        // exit early if there are no `this` references or `func` is bound
                        if (bindData === false || (bindData !== true && bindData[1] & 1)) {
                            return func;
                        }
                        switch (argCount) {
                            case 1:
                                return function(value) {
                                    return func.call(thisArg, value);
                                };
                            case 2:
                                return function(a, b) {
                                    return func.call(thisArg, a, b);
                                };
                            case 3:
                                return function(value, index, collection) {
                                    return func.call(thisArg, value, index, collection);
                                };
                            case 4:
                                return function(accumulator, value, index, collection) {
                                    return func.call(thisArg, accumulator, value, index, collection);
                                };
                        }
                        return bind(func, thisArg);
                    }

                    /**
                     * The base implementation of `createWrapper` that creates the wrapper and
                     * sets its meta data.
                     *
                     * @private
                     * @param {Array} bindData The bind data array.
                     * @returns {Function} Returns the new function.
                     */
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0],
                            bitmask = bindData[1],
                            partialArgs = bindData[2],
                            partialRightArgs = bindData[3],
                            thisArg = bindData[4],
                            arity = bindData[5];

                        var isBind = bitmask & 1,
                            isBindKey = bitmask & 2,
                            isCurry = bitmask & 4,
                            isCurryBound = bitmask & 8,
                            key = func;

                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }

                    /**
                     * The base implementation of `_.difference` that accepts a single array
                     * of values to exclude.
                     *
                     * @private
                     * @param {Array} array The array to process.
                     * @param {Array} [values] The array of values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     */
                    function baseDifference(array, values) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = array ? array.length : 0,
                            isLarge = length >= largeArraySize && indexOf === baseIndexOf,
                            result = [];

                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.flatten` without support for callback
                     * shorthands or `thisArg` binding.
                     *
                     * @private
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
                     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
                     * @param {number} [fromIndex=0] The index to start from.
                     * @returns {Array} Returns a new flattened array.
                     */
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1,
                            length = array ? array.length : 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];

                            if (value && typeof value == 'object' && typeof value.length == 'number' &&
                                (isArray(value) || isArguments(value))) {
                                // recursively flatten arrays (susceptible to call stack limits)
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1,
                                    valLength = value.length,
                                    resIndex = result.length;

                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
                     * that allows partial "_.where" style comparisons.
                     *
                     * @private
                     * @param {*} a The value to compare.
                     * @param {*} b The other value to compare.
                     * @param {Function} [callback] The function to customize comparing values.
                     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
                     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
                     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     */
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        // used to indicate that when comparing objects, `a` has at least the properties of `b`
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != 'undefined') {
                                return !!result;
                            }
                        }
                        // exit early for identical values
                        if (a === b) {
                            // treat `+0` vs. `-0` as not equal
                            return a !== 0 || (1 / a == 1 / b);
                        }
                        var type = typeof a,
                            otherType = typeof b;

                        // exit early for unlike primitive values
                        if (a === a &&
                            !(a && objectTypes[type]) &&
                            !(b && objectTypes[otherType])) {
                            return false;
                        }
                        // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
                        // http://es5.github.io/#x15.3.4.4
                        if (a == null || b == null) {
                            return a === b;
                        }
                        // compare [[Class]] names
                        var className = toString.call(a),
                            otherClass = toString.call(b);

                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                            case boolClass:
                            case dateClass:
                                // coerce dates and booleans to numbers, dates to milliseconds and booleans
                                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
                                return +a == +b;

                            case numberClass:
                                // treat `NaN` vs. `NaN` as equal
                                return (a != +a) ?
                                    b != +b
                                    // but treat `+0` vs. `-0` as not equal
                                    :
                                    (a == 0 ? (1 / a == 1 / b) : a == +b);

                            case regexpClass:
                            case stringClass:
                                // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
                                // treat string primitives and their corresponding object instances as equal
                                return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            // unwrap any `lodash` wrapped values
                            var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
                                bWrapped = hasOwnProperty.call(b, '__wrapped__');

                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            // exit for functions and DOM nodes
                            if (className != objectClass) {
                                return false;
                            }
                            // in older versions of Opera, `arguments` objects have `Array` constructors
                            var ctorA = a.constructor,
                                ctorB = b.constructor;

                            // non `Object` object instances with different constructors are not equal
                            if (ctorA != ctorB &&
                                !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
                                ('constructor' in a && 'constructor' in b)
                            ) {
                                return false;
                            }
                        }
                        // assume cyclic structures are equal
                        // the algorithm for detecting cyclic structures is adapted from ES 5.1
                        // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;

                        // add `a` and `b` to the stack of traversed objects
                        stackA.push(a);
                        stackB.push(b);

                        // recursively compare objects and arrays (susceptible to call stack limits)
                        if (isArr) {
                            // compare lengths to determine if a deep comparison is necessary
                            length = a.length;
                            size = b.length;
                            result = size == length;

                            if (result || isWhere) {
                                // deep compare the contents, ignoring non-numeric properties
                                while (size--) {
                                    var index = length,
                                        value = b[size];

                                    if (isWhere) {
                                        while (index--) {
                                            if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
                            // which, in this case, is more costly
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    // count the number of properties.
                                    size++;
                                    // deep compare each property value.
                                    return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
                                }
                            });

                            if (result && !isWhere) {
                                // ensure both objects have the same number of properties
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        // `size` will be `-1` if `a` has more properties than `b`
                                        return (result = --size > -1);
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();

                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.merge` without argument juggling or support
                     * for `thisArg` binding.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} [callback] The function to customize merging properties.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     */
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found,
                                isArr,
                                result = source,
                                value = object[key];

                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                // avoid merging previously merged cyclic sources
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if ((found = stackA[stackLength] == source)) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if ((isShallow = typeof result != 'undefined')) {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ?
                                            (isArray(value) ? value : []) :
                                            (isPlainObject(value) ? value : {});
                                    }
                                    // add `source` and associated `value` to the stack of traversed objects
                                    stackA.push(source);
                                    stackB.push(value);

                                    // recursively merge objects and arrays (susceptible to call stack limits)
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == 'undefined') {
                                        result = source;
                                    }
                                }
                                if (typeof result != 'undefined') {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }

                    /**
                     * The base implementation of `_.random` without argument juggling or support
                     * for returning floating-point numbers.
                     *
                     * @private
                     * @param {number} min The minimum possible value.
                     * @param {number} max The maximum possible value.
                     * @returns {number} Returns a random number.
                     */
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }

                    /**
                     * The base implementation of `_.uniq` without support for callback shorthands
                     * or `thisArg` binding.
                     *
                     * @private
                     * @param {Array} array The array to process.
                     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
                     * @param {Function} [callback] The function called per iteration.
                     * @returns {Array} Returns a duplicate-value-free array.
                     */
                    function baseUniq(array, isSorted, callback) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = array ? array.length : 0,
                            result = [];

                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
                            seen = (callback || isLarge) ? getArray() : result;

                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index],
                                computed = callback ? callback(value, index, array) : value;

                            if (isSorted ?
                                !index || seen[seen.length - 1] !== computed :
                                indexOf(seen, computed) < 0
                            ) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }

                    /**
                     * Creates a function that aggregates a collection, creating an object composed
                     * of keys generated from the results of running each element of the collection
                     * through a callback. The given `setter` function sets the keys and values
                     * of the composed object.
                     *
                     * @private
                     * @param {Function} setter The setter function.
                     * @returns {Function} Returns the new aggregator function.
                     */
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);

                            var index = -1,
                                length = collection ? collection.length : 0;

                            if (typeof length == 'number') {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a function that, when called, either curries or invokes `func`
                     * with an optional `this` binding and partially applied arguments.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of method flags to compose.
                     *  The bitmask may be composed of the following flags:
                     *  1 - `_.bind`
                     *  2 - `_.bindKey`
                     *  4 - `_.curry`
                     *  8 - `_.curry` (bound)
                     *  16 - `_.partial`
                     *  32 - `_.partialRight`
                     * @param {Array} [partialArgs] An array of arguments to prepend to those
                     *  provided to the new function.
                     * @param {Array} [partialRightArgs] An array of arguments to append to those
                     *  provided to the new function.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new function.
                     */
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1,
                            isBindKey = bitmask & 2,
                            isCurry = bitmask & 4,
                            isCurryBound = bitmask & 8,
                            isPartial = bitmask & 16,
                            isPartialRight = bitmask & 32;

                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError;
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            // clone `bindData`
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            // set `thisBinding` is not previously bound
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            // set if previously bound but not currently (subsequent curried functions)
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            // set curried arity if not yet set
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            // append partial left arguments
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            // append partial right arguments
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            // merge flags
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        // fast path for `_.bind`
                        var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
                        return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
                    }

                    /**
                     * Used by `escape` to convert characters to HTML entities.
                     *
                     * @private
                     * @param {string} match The matched character to escape.
                     * @returns {string} Returns the escaped character.
                     */
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }

                    /**
                     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
                     * customized, this method returns the custom method, otherwise it returns
                     * the `baseIndexOf` function.
                     *
                     * @private
                     * @returns {Function} Returns the "indexOf" function.
                     */
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }

                    /**
                     * Checks if `value` is a native function.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
                     */
                    function isNative(value) {
                        return typeof value == 'function' && reNative.test(value);
                    }

                    /**
                     * Sets `this` binding data on a given function.
                     *
                     * @private
                     * @param {Function} func The function to set data on.
                     * @param {Array} value The data array to set.
                     */
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, '__bindData__', descriptor);
                    };

                    /**
                     * A fallback implementation of `isPlainObject` which checks if a given value
                     * is an object created by the `Object` constructor, assuming objects created
                     * by the `Object` constructor have no inherited enumerable properties and that
                     * there are no `Object.prototype` extensions.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     */
                    function shimIsPlainObject(value) {
                        var ctor,
                            result;

                        // avoid non Object objects, `arguments` objects, and DOM elements
                        if (!(value && toString.call(value) == objectClass) ||
                            (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        // In most environments an object's own properties are iterated before
                        // its inherited properties. If the last iterated property is an object's
                        // own property then there are no inherited enumerable properties.
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == 'undefined' || hasOwnProperty.call(value, result);
                    }

                    /**
                     * Used by `unescape` to convert HTML entities to characters.
                     *
                     * @private
                     * @param {string} match The matched character to unescape.
                     * @returns {string} Returns the unescaped character.
                     */
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Checks if `value` is an `arguments` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
                     * @example
                     *
                     * (function() { return _.isArguments(arguments); })(1, 2, 3);
                     * // => true
                     *
                     * _.isArguments([1, 2, 3]);
                     * // => false
                     */
                    function isArguments(value) {
                        return value && typeof value == 'object' && typeof value.length == 'number' &&
                            toString.call(value) == argsClass || false;
                    }

                    /**
                     * Checks if `value` is an array.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
                     * @example
                     *
                     * (function() { return _.isArray(arguments); })();
                     * // => false
                     *
                     * _.isArray([1, 2, 3]);
                     * // => true
                     */
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == 'object' && typeof value.length == 'number' &&
                            toString.call(value) == arrayClass || false;
                    };

                    /**
                     * A fallback implementation of `Object.keys` which produces an array of the
                     * given object's own enumerable property names.
                     *
                     * @private
                     * @type Function
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names.
                     */
                    var shimKeys = function(object) {
                        var index, iterable = object,
                            result = [];
                        if (!iterable) return result;
                        if (!(objectTypes[typeof object])) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result
                    };

                    /**
                     * Creates an array composed of the own enumerable property names of an object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names.
                     * @example
                     *
                     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
                     */
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };

                    /**
                     * Used to convert characters to HTML entities:
                     *
                     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
                     * don't require escaping in HTML and have no special meaning unless they're part
                     * of a tag or an unquoted attribute value.
                     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
                     */
                    var htmlEscapes = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    };

                    /** Used to convert HTML entities to characters */
                    var htmlUnescapes = invert(htmlEscapes);

                    /** Used to match HTML entities and HTML characters */
                    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
                        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object. Subsequent sources will overwrite property assignments of previous
                     * sources. If a callback is provided it will be executed to produce the
                     * assigned values. The callback is bound to `thisArg` and invoked with two
                     * arguments; (objectValue, sourceValue).
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @alias extend
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param {Function} [callback] The function to customize assigning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
                     * // => { 'name': 'fred', 'employer': 'slate' }
                     *
                     * var defaults = _.partialRight(_.assign, function(a, b) {
                     *   return typeof a == 'undefined' ? b : a;
                     * });
                     *
                     * var object = { 'name': 'barney' };
                     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
                     * // => { 'name': 'barney', 'employer': 'slate' }
                     */
                    var assign = function(object, source, guard) {
                        var index, iterable = object,
                            result = iterable;
                        if (!iterable) return result;
                        var args = arguments,
                            argsIndex = 0,
                            argsLength = typeof guard == 'number' ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1,
                                    ownProps = objectTypes[typeof iterable] && keys(iterable),
                                    length = ownProps ? ownProps.length : 0;

                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result
                    };

                    /**
                     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
                     * be cloned, otherwise they will be assigned by reference. If a callback
                     * is provided it will be executed to produce the cloned values. If the
                     * callback returns `undefined` cloning will be handled by the method instead.
                     * The callback is bound to `thisArg` and invoked with one argument; (value).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep=false] Specify a deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the cloned value.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * var shallow = _.clone(characters);
                     * shallow[0] === characters[0];
                     * // => true
                     *
                     * var deep = _.clone(characters, true);
                     * deep[0] === characters[0];
                     * // => false
                     *
                     * _.mixin({
                     *   'clone': _.partialRight(_.clone, function(value) {
                     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
                     *   })
                     * });
                     *
                     * var clone = _.clone(document.body);
                     * clone.childNodes.length;
                     * // => 0
                     */
                    function clone(value, isDeep, callback, thisArg) {
                        // allows working with "Collections" methods without using their `index`
                        // and `collection` arguments for `isDeep` and `callback`
                        if (typeof isDeep != 'boolean' && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
                    }

                    /**
                     * Creates a deep clone of `value`. If a callback is provided it will be
                     * executed to produce the cloned values. If the callback returns `undefined`
                     * cloning will be handled by the method instead. The callback is bound to
                     * `thisArg` and invoked with one argument; (value).
                     *
                     * Note: This method is loosely based on the structured clone algorithm. Functions
                     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
                     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
                     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the deep cloned value.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * var deep = _.cloneDeep(characters);
                     * deep[0] === characters[0];
                     * // => false
                     *
                     * var view = {
                     *   'label': 'docs',
                     *   'node': element
                     * };
                     *
                     * var clone = _.cloneDeep(view, function(value) {
                     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
                     * });
                     *
                     * clone.node == view.node;
                     * // => false
                     */
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
                    }

                    /**
                     * Creates an object that inherits from the given `prototype` object. If a
                     * `properties` object is provided its own enumerable properties are assigned
                     * to the created object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} prototype The object to inherit from.
                     * @param {Object} [properties] The properties to assign to the object.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * function Circle() {
                     *   Shape.call(this);
                     * }
                     *
                     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
                     *
                     * var circle = new Circle;
                     * circle instanceof Circle;
                     * // => true
                     *
                     * circle instanceof Shape;
                     * // => true
                     */
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object for all destination properties that resolve to `undefined`. Once a
                     * property is set, additional defaults of the same property will be ignored.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param- {Object} [guard] Allows working with `_.reduce` without using its
                     *  `key` and `object` arguments as sources.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * var object = { 'name': 'barney' };
                     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
                     * // => { 'name': 'barney', 'employer': 'slate' }
                     */
                    var defaults = function(object, source, guard) {
                        var index, iterable = object,
                            result = iterable;
                        if (!iterable) return result;
                        var args = arguments,
                            argsIndex = 0,
                            argsLength = typeof guard == 'number' ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1,
                                    ownProps = objectTypes[typeof iterable] && keys(iterable),
                                    length = ownProps ? ownProps.length : 0;

                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == 'undefined') result[index] = iterable[index];
                                }
                            }
                        }
                        return result
                    };

                    /**
                     * This method is like `_.findIndex` except that it returns the key of the
                     * first element that passes the callback check, instead of the element itself.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [callback=identity] The function called per
                     *  iteration. If a property name or object is provided it will be used to
                     *  create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
                     * @example
                     *
                     * var characters = {
                     *   'barney': {  'age': 36, 'blocked': false },
                     *   'fred': {    'age': 40, 'blocked': true },
                     *   'pebbles': { 'age': 1,  'blocked': false }
                     * };
                     *
                     * _.findKey(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => 'barney' (property order is not guaranteed across environments)
                     *
                     * // using "_.where" callback shorthand
                     * _.findKey(characters, { 'age': 1 });
                     * // => 'pebbles'
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findKey(characters, 'blocked');
                     * // => 'fred'
                     */
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * This method is like `_.findKey` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [callback=identity] The function called per
                     *  iteration. If a property name or object is provided it will be used to
                     *  create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
                     * @example
                     *
                     * var characters = {
                     *   'barney': {  'age': 36, 'blocked': true },
                     *   'fred': {    'age': 40, 'blocked': false },
                     *   'pebbles': { 'age': 1,  'blocked': true }
                     * };
                     *
                     * _.findLastKey(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
                     *
                     * // using "_.where" callback shorthand
                     * _.findLastKey(characters, { 'age': 40 });
                     * // => 'fred'
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findLastKey(characters, 'blocked');
                     * // => 'pebbles'
                     */
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * Iterates over own and inherited enumerable properties of an object,
                     * executing the callback for each property. The callback is bound to `thisArg`
                     * and invoked with three arguments; (value, key, object). Callbacks may exit
                     * iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * Shape.prototype.move = function(x, y) {
                     *   this.x += x;
                     *   this.y += y;
                     * };
                     *
                     * _.forIn(new Shape, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
                     */
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection,
                            result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result
                    };

                    /**
                     * This method is like `_.forIn` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * Shape.prototype.move = function(x, y) {
                     *   this.x += x;
                     *   this.y += y;
                     * };
                     *
                     * _.forInRight(new Shape, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
                     */
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];

                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });

                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }

                    /**
                     * Iterates over own enumerable properties of an object, executing the callback
                     * for each property. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, key, object). Callbacks may exit iteration early by
                     * explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
                     *   console.log(key);
                     * });
                     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
                     */
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection,
                            result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1,
                            ownProps = objectTypes[typeof iterable] && keys(iterable),
                            length = ownProps ? ownProps.length : 0;

                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result
                    };

                    /**
                     * This method is like `_.forOwn` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
                     */
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object),
                            length = props.length;

                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }

                    /**
                     * Creates a sorted array of property names of all enumerable properties,
                     * own and inherited, of `object` that have function values.
                     *
                     * @static
                     * @memberOf _
                     * @alias methods
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names that have function values.
                     * @example
                     *
                     * _.functions(_);
                     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
                     */
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }

                    /**
                     * Checks if the specified property name exists as a direct property of `object`,
                     * instead of an inherited property.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @param {string} key The name of the property to check.
                     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
                     * @example
                     *
                     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
                     * // => true
                     */
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }

                    /**
                     * Creates an object composed of the inverted keys and values of the given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to invert.
                     * @returns {Object} Returns the created inverted object.
                     * @example
                     *
                     * _.invert({ 'first': 'fred', 'second': 'barney' });
                     * // => { 'fred': 'first', 'barney': 'second' }
                     */
                    function invert(object) {
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = {};

                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }

                    /**
                     * Checks if `value` is a boolean value.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
                     * @example
                     *
                     * _.isBoolean(null);
                     * // => false
                     */
                    function isBoolean(value) {
                        return value === true || value === false ||
                            value && typeof value == 'object' && toString.call(value) == boolClass || false;
                    }

                    /**
                     * Checks if `value` is a date.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
                     * @example
                     *
                     * _.isDate(new Date);
                     * // => true
                     */
                    function isDate(value) {
                        return value && typeof value == 'object' && toString.call(value) == dateClass || false;
                    }

                    /**
                     * Checks if `value` is a DOM element.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
                     * @example
                     *
                     * _.isElement(document.body);
                     * // => true
                     */
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }

                    /**
                     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
                     * length of `0` and objects with no own enumerable properties are considered
                     * "empty".
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Array|Object|string} value The value to inspect.
                     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
                     * @example
                     *
                     * _.isEmpty([1, 2, 3]);
                     * // => false
                     *
                     * _.isEmpty({});
                     * // => true
                     *
                     * _.isEmpty('');
                     * // => true
                     */
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value),
                            length = value.length;

                        if ((className == arrayClass || className == stringClass || className == argsClass) ||
                            (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return (result = false);
                        });
                        return result;
                    }

                    /**
                     * Performs a deep comparison between two values to determine if they are
                     * equivalent to each other. If a callback is provided it will be executed
                     * to compare values. If the callback returns `undefined` comparisons will
                     * be handled by the method instead. The callback is bound to `thisArg` and
                     * invoked with two arguments; (a, b).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} a The value to compare.
                     * @param {*} b The other value to compare.
                     * @param {Function} [callback] The function to customize comparing values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * var copy = { 'name': 'fred' };
                     *
                     * object == copy;
                     * // => false
                     *
                     * _.isEqual(object, copy);
                     * // => true
                     *
                     * var words = ['hello', 'goodbye'];
                     * var otherWords = ['hi', 'goodbye'];
                     *
                     * _.isEqual(words, otherWords, function(a, b) {
                     *   var reGreet = /^(?:hello|hi)$/i,
                     *       aGreet = _.isString(a) && reGreet.test(a),
                     *       bGreet = _.isString(b) && reGreet.test(b);
                     *
                     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
                     * });
                     * // => true
                     */
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
                    }

                    /**
                     * Checks if `value` is, or can be coerced to, a finite number.
                     *
                     * Note: This is not the same as native `isFinite` which will return true for
                     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
                     * @example
                     *
                     * _.isFinite(-101);
                     * // => true
                     *
                     * _.isFinite('10');
                     * // => true
                     *
                     * _.isFinite(true);
                     * // => false
                     *
                     * _.isFinite('');
                     * // => false
                     *
                     * _.isFinite(Infinity);
                     * // => false
                     */
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }

                    /**
                     * Checks if `value` is a function.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
                     * @example
                     *
                     * _.isFunction(_);
                     * // => true
                     */
                    function isFunction(value) {
                        return typeof value == 'function';
                    }

                    /**
                     * Checks if `value` is the language type of Object.
                     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
                     * @example
                     *
                     * _.isObject({});
                     * // => true
                     *
                     * _.isObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isObject(1);
                     * // => false
                     */
                    function isObject(value) {
                        // check if the value is the ECMAScript language type of Object
                        // http://es5.github.io/#x8
                        // and avoid a V8 bug
                        // http://code.google.com/p/v8/issues/detail?id=2291
                        return !!(value && objectTypes[typeof value]);
                    }

                    /**
                     * Checks if `value` is `NaN`.
                     *
                     * Note: This is not the same as native `isNaN` which will return `true` for
                     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
                     * @example
                     *
                     * _.isNaN(NaN);
                     * // => true
                     *
                     * _.isNaN(new Number(NaN));
                     * // => true
                     *
                     * isNaN(undefined);
                     * // => true
                     *
                     * _.isNaN(undefined);
                     * // => false
                     */
                    function isNaN(value) {
                        // `NaN` as a primitive is the only value that is not equal to itself
                        // (perform the [[Class]] check first to avoid errors with some host objects in IE)
                        return isNumber(value) && value != +value;
                    }

                    /**
                     * Checks if `value` is `null`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
                     * @example
                     *
                     * _.isNull(null);
                     * // => true
                     *
                     * _.isNull(undefined);
                     * // => false
                     */
                    function isNull(value) {
                        return value === null;
                    }

                    /**
                     * Checks if `value` is a number.
                     *
                     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
                     * @example
                     *
                     * _.isNumber(8.4 * 5);
                     * // => true
                     */
                    function isNumber(value) {
                        return typeof value == 'number' ||
                            value && typeof value == 'object' && toString.call(value) == numberClass || false;
                    }

                    /**
                     * Checks if `value` is an object created by the `Object` constructor.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * _.isPlainObject(new Shape);
                     * // => false
                     *
                     * _.isPlainObject([1, 2, 3]);
                     * // => false
                     *
                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                     * // => true
                     */
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf,
                            objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

                        return objProto ?
                            (value == objProto || getPrototypeOf(value) == objProto) :
                            shimIsPlainObject(value);
                    };

                    /**
                     * Checks if `value` is a regular expression.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
                     * @example
                     *
                     * _.isRegExp(/fred/);
                     * // => true
                     */
                    function isRegExp(value) {
                        return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
                    }

                    /**
                     * Checks if `value` is a string.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
                     * @example
                     *
                     * _.isString('fred');
                     * // => true
                     */
                    function isString(value) {
                        return typeof value == 'string' ||
                            value && typeof value == 'object' && toString.call(value) == stringClass || false;
                    }

                    /**
                     * Checks if `value` is `undefined`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
                     * @example
                     *
                     * _.isUndefined(void 0);
                     * // => true
                     */
                    function isUndefined(value) {
                        return typeof value == 'undefined';
                    }

                    /**
                     * Creates an object with the same keys as `object` and values generated by
                     * running each own enumerable property of `object` through the callback.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
                     * @example
                     *
                     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     *
                     * var characters = {
                     *   'fred': { 'name': 'fred', 'age': 40 },
                     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
                     * };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.mapValues(characters, 'age');
                     * // => { 'fred': 40, 'pebbles': 1 }
                     */
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);

                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }

                    /**
                     * Recursively merges own enumerable properties of the source object(s), that
                     * don't resolve to `undefined` into the destination object. Subsequent sources
                     * will overwrite property assignments of previous sources. If a callback is
                     * provided it will be executed to produce the merged values of the destination
                     * and source properties. If the callback returns `undefined` merging will
                     * be handled by the method instead. The callback is bound to `thisArg` and
                     * invoked with two arguments; (objectValue, sourceValue).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param {Function} [callback] The function to customize merging properties.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * var names = {
                     *   'characters': [
                     *     { 'name': 'barney' },
                     *     { 'name': 'fred' }
                     *   ]
                     * };
                     *
                     * var ages = {
                     *   'characters': [
                     *     { 'age': 36 },
                     *     { 'age': 40 }
                     *   ]
                     * };
                     *
                     * _.merge(names, ages);
                     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
                     *
                     * var food = {
                     *   'fruits': ['apple'],
                     *   'vegetables': ['beet']
                     * };
                     *
                     * var otherFood = {
                     *   'fruits': ['banana'],
                     *   'vegetables': ['carrot']
                     * };
                     *
                     * _.merge(food, otherFood, function(a, b) {
                     *   return _.isArray(a) ? a.concat(b) : undefined;
                     * });
                     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
                     */
                    function merge(object) {
                        var args = arguments,
                            length = 2;

                        if (!isObject(object)) {
                            return object;
                        }
                        // allows working with `_.reduce` and `_.reduceRight` without using
                        // their `index` and `collection` arguments
                        if (typeof args[2] != 'number') {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == 'function') {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == 'function') {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length),
                            index = -1,
                            stackA = getArray(),
                            stackB = getArray();

                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }

                    /**
                     * Creates a shallow clone of `object` excluding the specified properties.
                     * Property names may be specified as individual arguments or as arrays of
                     * property names. If a callback is provided it will be executed for each
                     * property of `object` omitting the properties the callback returns truey
                     * for. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The source object.
                     * @param {Function|...string|string[]} [callback] The properties to omit or the
                     *  function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns an object without the omitted properties.
                     * @example
                     *
                     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
                     * // => { 'name': 'fred' }
                     *
                     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
                     *   return typeof value == 'number';
                     * });
                     * // => { 'name': 'fred' }
                     */
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != 'function') {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));

                            var index = -1,
                                length = props.length;

                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Creates a two dimensional array of an object's key-value pairs,
                     * i.e. `[[key1, value1], [key2, value2]]`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns new array of key-value pairs.
                     * @example
                     *
                     * _.pairs({ 'barney': 36, 'fred': 40 });
                     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
                     */
                    function pairs(object) {
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            var key = props[index];
                            result[index] = [key, object[key]];
                        }
                        return result;
                    }

                    /**
                     * Creates a shallow clone of `object` composed of the specified properties.
                     * Property names may be specified as individual arguments or as arrays of
                     * property names. If a callback is provided it will be executed for each
                     * property of `object` picking the properties the callback returns truey
                     * for. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The source object.
                     * @param {Function|...string|string[]} [callback] The function called per
                     *  iteration or property names to pick, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns an object composed of the picked properties.
                     * @example
                     *
                     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
                     * // => { 'name': 'fred' }
                     *
                     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
                     *   return key.charAt(0) != '_';
                     * });
                     * // => { 'name': 'fred' }
                     */
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != 'function') {
                            var index = -1,
                                props = baseFlatten(arguments, true, false, 1),
                                length = isObject(object) ? props.length : 0;

                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * An alternative to `_.reduce` this method transforms `object` to a new
                     * `accumulator` object which is the result of running each of its own
                     * enumerable properties through a callback, with each callback execution
                     * potentially mutating the `accumulator` object. The callback is bound to
                     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
                     * Callbacks may exit iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Array|Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] The custom accumulator value.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
                     *   num *= num;
                     *   if (num % 2) {
                     *     return result.push(num) < 3;
                     *   }
                     * });
                     * // => [1, 9, 25]
                     *
                     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
                     *   result[key] = num * 3;
                     * });
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     */
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor,
                                    proto = ctor && ctor.prototype;

                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }

                    /**
                     * Creates an array composed of the own enumerable property values of `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property values.
                     * @example
                     *
                     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => [1, 2, 3] (property order is not guaranteed across environments)
                     */
                    function values(object) {
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates an array of elements from the specified indexes, or keys, of the
                     * `collection`. Indexes may be specified as individual arguments or as arrays
                     * of indexes.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
                     *   to retrieve, specified as individual indexes or arrays of indexes.
                     * @returns {Array} Returns a new array of elements corresponding to the
                     *  provided indexes.
                     * @example
                     *
                     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
                     * // => ['a', 'c', 'e']
                     *
                     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
                     * // => ['fred', 'pebbles']
                     */
                    function at(collection) {
                        var args = arguments,
                            index = -1,
                            props = baseFlatten(args, true, false, 1),
                            length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }

                    /**
                     * Checks if a given value is present in a collection using strict equality
                     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
                     * offset from the end of the collection.
                     *
                     * @static
                     * @memberOf _
                     * @alias include
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {*} target The value to check for.
                     * @param {number} [fromIndex=0] The index to search from.
                     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
                     * @example
                     *
                     * _.contains([1, 2, 3], 1);
                     * // => true
                     *
                     * _.contains([1, 2, 3], 1, 2);
                     * // => false
                     *
                     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
                     * // => true
                     *
                     * _.contains('pebbles', 'eb');
                     * // => true
                     */
                    function contains(collection, target, fromIndex) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = collection ? collection.length : 0,
                            result = false;

                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == 'number') {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through the callback. The corresponding value
                     * of each key is the number of times the key was returned by the callback.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy(['one', 'two', 'three'], 'length');
                     * // => { '3': 2, '5': 1 }
                     */
                    var countBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
                    });

                    /**
                     * Checks if the given callback returns truey value for **all** elements of
                     * a collection. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias all
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if all elements passed the callback check,
                     *  else `false`.
                     * @example
                     *
                     * _.every([true, 1, null, 'yes']);
                     * // => false
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.every(characters, 'age');
                     * // => true
                     *
                     * // using "_.where" callback shorthand
                     * _.every(characters, { 'age': 36 });
                     * // => false
                     */
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = -1,
                            length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return (result = !!callback(value, index, collection));
                            });
                        }
                        return result;
                    }

                    /**
                     * Iterates over elements of a collection, returning an array of all elements
                     * the callback returns truey for. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias select
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of elements that passed the callback check.
                     * @example
                     *
                     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
                     * // => [2, 4, 6]
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.filter(characters, 'blocked');
                     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
                     *
                     * // using "_.where" callback shorthand
                     * _.filter(characters, { 'age': 36 });
                     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
                     */
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = -1,
                            length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Iterates over elements of a collection, returning the first element that
                     * the callback returns truey for. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias detect, findWhere
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the found element, else `undefined`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': false },
                     *   { 'name': 'fred',    'age': 40, 'blocked': true },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
                     * ];
                     *
                     * _.find(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
                     *
                     * // using "_.where" callback shorthand
                     * _.find(characters, { 'age': 1 });
                     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
                     *
                     * // using "_.pluck" callback shorthand
                     * _.find(characters, 'blocked');
                     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
                     */
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = -1,
                            length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }

                    /**
                     * This method is like `_.find` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the found element, else `undefined`.
                     * @example
                     *
                     * _.findLast([1, 2, 3, 4], function(num) {
                     *   return num % 2 == 1;
                     * });
                     * // => 3
                     */
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * Iterates over elements of a collection, executing the callback for each
                     * element. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection). Callbacks may exit iteration early by
                     * explicitly returning `false`.
                     *
                     * Note: As with other "Collections" methods, objects with a `length` property
                     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                     * may be used for object iteration.
                     *
                     * @static
                     * @memberOf _
                     * @alias each
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
                     * // => logs each number and returns '1,2,3'
                     *
                     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
                     * // => logs each number and returns the object (property order is not guaranteed across environments)
                     */
                    function forEach(collection, callback, thisArg) {
                        var index = -1,
                            length = collection ? collection.length : 0;

                        callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == 'number') {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }

                    /**
                     * This method is like `_.forEach` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias eachRight
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
                     * // => logs each number from right to left and returns '3,2,1'
                     */
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == 'number') {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of a collection through the callback. The corresponding value
                     * of each key is an array of the elements responsible for generating the key.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * // using "_.pluck" callback shorthand
                     * _.groupBy(['one', 'two', 'three'], 'length');
                     * // => { '3': ['one', 'two'], '5': ['three'] }
                     */
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of the collection through the given callback. The corresponding
                     * value of each key is the last element responsible for generating the key.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * var keys = [
                     *   { 'dir': 'left', 'code': 97 },
                     *   { 'dir': 'right', 'code': 100 }
                     * ];
                     *
                     * _.indexBy(keys, 'dir');
                     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     */
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });

                    /**
                     * Invokes the method named by `methodName` on each element in the `collection`
                     * returning an array of the results of each invoked method. Additional arguments
                     * will be provided to each invoked method. If `methodName` is a function it
                     * will be invoked for, and `this` bound to, each element in the `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|string} methodName The name of the method to invoke or
                     *  the function invoked per iteration.
                     * @param {...*} [arg] Arguments to invoke the method with.
                     * @returns {Array} Returns a new array of the results of each invoked method.
                     * @example
                     *
                     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
                     * // => [[1, 5, 7], [1, 2, 3]]
                     *
                     * _.invoke([123, 456], String.prototype.split, '');
                     * // => [['1', '2', '3'], ['4', '5', '6']]
                     */
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2),
                            index = -1,
                            isFunc = typeof methodName == 'function',
                            length = collection ? collection.length : 0,
                            result = Array(typeof length == 'number' ? length : 0);

                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }

                    /**
                     * Creates an array of values by running each element in the collection
                     * through the callback. The callback is bound to `thisArg` and invoked with
                     * three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias collect
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of the results of each `callback` execution.
                     * @example
                     *
                     * _.map([1, 2, 3], function(num) { return num * 3; });
                     * // => [3, 6, 9]
                     *
                     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
                     * // => [3, 6, 9] (property order is not guaranteed across environments)
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.map(characters, 'name');
                     * // => ['barney', 'fred']
                     */
                    function map(collection, callback, thisArg) {
                        var index = -1,
                            length = collection ? collection.length : 0;

                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == 'number') {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }

                    /**
                     * Retrieves the maximum value of a collection. If the collection is empty or
                     * falsey `-Infinity` is returned. If a callback is provided it will be executed
                     * for each value in the collection to generate the criterion by which the value
                     * is ranked. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the maximum value.
                     * @example
                     *
                     * _.max([4, 2, 8, 6]);
                     * // => 8
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.max(characters, function(chr) { return chr.age; });
                     * // => { 'name': 'fred', 'age': 40 };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.max(characters, 'age');
                     * // => { 'name': 'fred', 'age': 40 };
                     */
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity,
                            result = computed;

                        // allows working with functions like `_.map` without using
                        // their `index` argument as a callback
                        if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1,
                                length = collection.length;

                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = (callback == null && isString(collection)) ?
                                charAtCallback :
                                lodash.createCallback(callback, thisArg, 3);

                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Retrieves the minimum value of a collection. If the collection is empty or
                     * falsey `Infinity` is returned. If a callback is provided it will be executed
                     * for each value in the collection to generate the criterion by which the value
                     * is ranked. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the minimum value.
                     * @example
                     *
                     * _.min([4, 2, 8, 6]);
                     * // => 2
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.min(characters, function(chr) { return chr.age; });
                     * // => { 'name': 'barney', 'age': 36 };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.min(characters, 'age');
                     * // => { 'name': 'barney', 'age': 36 };
                     */
                    function min(collection, callback, thisArg) {
                        var computed = Infinity,
                            result = computed;

                        // allows working with functions like `_.map` without using
                        // their `index` argument as a callback
                        if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1,
                                length = collection.length;

                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = (callback == null && isString(collection)) ?
                                charAtCallback :
                                lodash.createCallback(callback, thisArg, 3);

                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Retrieves the value of a specified property from all elements in the collection.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {string} property The name of the property to pluck.
                     * @returns {Array} Returns a new array of property values.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.pluck(characters, 'name');
                     * // => ['barney', 'fred']
                     */
                    var pluck = map;

                    /**
                     * Reduces a collection to a value which is the accumulated result of running
                     * each element in the collection through the callback, where each successive
                     * callback execution consumes the return value of the previous execution. If
                     * `accumulator` is not provided the first element of the collection will be
                     * used as the initial `accumulator` value. The callback is bound to `thisArg`
                     * and invoked with four arguments; (accumulator, value, index|key, collection).
                     *
                     * @static
                     * @memberOf _
                     * @alias foldl, inject
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] Initial value of the accumulator.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var sum = _.reduce([1, 2, 3], function(sum, num) {
                     *   return sum + num;
                     * });
                     * // => 6
                     *
                     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
                     *   result[key] = num * 3;
                     *   return result;
                     * }, {});
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     */
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);

                        var index = -1,
                            length = collection.length;

                        if (typeof length == 'number') {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ?
                                    (noaccum = false, value) :
                                    callback(accumulator, value, index, collection)
                            });
                        }
                        return accumulator;
                    }

                    /**
                     * This method is like `_.reduce` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias foldr
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] Initial value of the accumulator.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var list = [[0, 1], [2, 3], [4, 5]];
                     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
                     * // => [4, 5, 2, 3, 0, 1]
                     */
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ?
                                (noaccum = false, value) :
                                callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }

                    /**
                     * The opposite of `_.filter` this method returns the elements of a
                     * collection that the callback does **not** return truey for.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of elements that failed the callback check.
                     * @example
                     *
                     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
                     * // => [1, 3, 5]
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.reject(characters, 'blocked');
                     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
                     *
                     * // using "_.where" callback shorthand
                     * _.reject(characters, { 'age': 36 });
                     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
                     */
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }

                    /**
                     * Retrieves a random element or `n` random elements from a collection.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to sample.
                     * @param {number} [n] The number of elements to sample.
                     * @param- {Object} [guard] Allows working with functions like `_.map`
                     *  without using their `index` arguments as `n`.
                     * @returns {Array} Returns the random sample(s) of `collection`.
                     * @example
                     *
                     * _.sample([1, 2, 3, 4]);
                     * // => 2
                     *
                     * _.sample([1, 2, 3, 4], 2);
                     * // => [3, 1]
                     */
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != 'number') {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }

                    /**
                     * Creates an array of shuffled values, using a version of the Fisher-Yates
                     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to shuffle.
                     * @returns {Array} Returns a new shuffled collection.
                     * @example
                     *
                     * _.shuffle([1, 2, 3, 4, 5, 6]);
                     * // => [4, 1, 6, 3, 5, 2]
                     */
                    function shuffle(collection) {
                        var index = -1,
                            length = collection ? collection.length : 0,
                            result = Array(typeof length == 'number' ? length : 0);

                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }

                    /**
                     * Gets the size of the `collection` by returning `collection.length` for arrays
                     * and array-like objects or the number of own enumerable properties for objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to inspect.
                     * @returns {number} Returns `collection.length` or number of own enumerable properties.
                     * @example
                     *
                     * _.size([1, 2]);
                     * // => 2
                     *
                     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => 3
                     *
                     * _.size('pebbles');
                     * // => 7
                     */
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == 'number' ? length : keys(collection).length;
                    }

                    /**
                     * Checks if the callback returns a truey value for **any** element of a
                     * collection. The function returns as soon as it finds a passing value and
                     * does not iterate over the entire collection. The callback is bound to
                     * `thisArg` and invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias any
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if any element passed the callback check,
                     *  else `false`.
                     * @example
                     *
                     * _.some([null, 0, 'yes', false], Boolean);
                     * // => true
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.some(characters, 'blocked');
                     * // => true
                     *
                     * // using "_.where" callback shorthand
                     * _.some(characters, { 'age': 1 });
                     * // => false
                     */
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = -1,
                            length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                if ((result = callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }

                    /**
                     * Creates an array of elements, sorted in ascending order by the results of
                     * running each element in a collection through the callback. This method
                     * performs a stable sort, that is, it will preserve the original sort order
                     * of equal elements. The callback is bound to `thisArg` and invoked with
                     * three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an array of property names is provided for `callback` the collection
                     * will be sorted by each property value.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of sorted elements.
                     * @example
                     *
                     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
                     * // => [3, 1, 2]
                     *
                     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
                     * // => [3, 1, 2]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36 },
                     *   { 'name': 'fred',    'age': 40 },
                     *   { 'name': 'barney',  'age': 26 },
                     *   { 'name': 'fred',    'age': 30 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.map(_.sortBy(characters, 'age'), _.values);
                     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
                     *
                     * // sorting by multiple properties
                     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
                     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
                     */
                    function sortBy(collection, callback, thisArg) {
                        var index = -1,
                            isArr = isArray(callback),
                            length = collection ? collection.length : 0,
                            result = Array(typeof length == 'number' ? length : 0);

                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });

                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }

                    /**
                     * Converts the `collection` to an array.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to convert.
                     * @returns {Array} Returns the new converted array.
                     * @example
                     *
                     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
                     * // => [2, 3, 4]
                     */
                    function toArray(collection) {
                        if (collection && typeof collection.length == 'number') {
                            return slice(collection);
                        }
                        return values(collection);
                    }

                    /**
                     * Performs a deep comparison of each element in a `collection` to the given
                     * `properties` object, returning an array of all elements that have equivalent
                     * property values.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Object} props The object of property values to filter by.
                     * @returns {Array} Returns a new array of elements that have the given properties.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
                     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * _.where(characters, { 'age': 36 });
                     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
                     *
                     * _.where(characters, { 'pets': ['dino'] });
                     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
                     */
                    var where = filter;

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates an array with all falsey values removed. The values `false`, `null`,
                     * `0`, `""`, `undefined`, and `NaN` are all falsey.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to compact.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.compact([0, 1, false, 2, '', 3]);
                     * // => [1, 2, 3]
                     */
                    function compact(array) {
                        var index = -1,
                            length = array ? array.length : 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }

                    /**
                     * Creates an array excluding all values of the provided arrays using strict
                     * equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to process.
                     * @param {...Array} [values] The arrays of values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
                     * // => [1, 3, 4]
                     */
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }

                    /**
                     * This method is like `_.find` except that it returns the index of the first
                     * element that passes the callback check, instead of the element itself.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': false },
                     *   { 'name': 'fred',    'age': 40, 'blocked': true },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
                     * ];
                     *
                     * _.findIndex(characters, function(chr) {
                     *   return chr.age < 20;
                     * });
                     * // => 2
                     *
                     * // using "_.where" callback shorthand
                     * _.findIndex(characters, { 'age': 36 });
                     * // => 0
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findIndex(characters, 'blocked');
                     * // => 1
                     */
                    function findIndex(array, callback, thisArg) {
                        var index = -1,
                            length = array ? array.length : 0;

                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * This method is like `_.findIndex` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': true },
                     *   { 'name': 'fred',    'age': 40, 'blocked': false },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
                     * ];
                     *
                     * _.findLastIndex(characters, function(chr) {
                     *   return chr.age > 30;
                     * });
                     * // => 1
                     *
                     * // using "_.where" callback shorthand
                     * _.findLastIndex(characters, { 'age': 36 });
                     * // => 0
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findLastIndex(characters, 'blocked');
                     * // => 2
                     */
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }

                    /**
                     * Gets the first element or first `n` elements of an array. If a callback
                     * is provided elements at the beginning of the array are returned as long
                     * as the callback returns truey. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias head, take
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback] The function called
                     *  per element or the number of elements to return. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the first element(s) of `array`.
                     * @example
                     *
                     * _.first([1, 2, 3]);
                     * // => 1
                     *
                     * _.first([1, 2, 3], 2);
                     * // => [1, 2]
                     *
                     * _.first([1, 2, 3], function(num) {
                     *   return num < 3;
                     * });
                     * // => [1, 2]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.first(characters, 'blocked');
                     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
                     *
                     * // using "_.where" callback shorthand
                     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
                     * // => ['barney', 'fred']
                     */
                    function first(array, callback, thisArg) {
                        var n = 0,
                            length = array ? array.length : 0;

                        if (typeof callback != 'number' && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }

                    /**
                     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
                     * is truey, the array will only be flattened a single level. If a callback
                     * is provided each element of the array is passed through the callback before
                     * flattening. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new flattened array.
                     * @example
                     *
                     * _.flatten([1, [2], [3, [[4]]]]);
                     * // => [1, 2, 3, 4];
                     *
                     * _.flatten([1, [2], [3, [[4]]]], true);
                     * // => [1, 2, 3, [[4]]];
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
                     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.flatten(characters, 'pets');
                     * // => ['hoppy', 'baby puss', 'dino']
                     */
                    function flatten(array, isShallow, callback, thisArg) {
                        // juggle arguments
                        if (typeof isShallow != 'boolean' && isShallow != null) {
                            thisArg = callback;
                            callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }

                    /**
                     * Gets the index at which the first occurrence of `value` is found using
                     * strict equality for comparisons, i.e. `===`. If the array is already sorted
                     * providing `true` for `fromIndex` will run a faster binary search.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                     *  to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value or `-1`.
                     * @example
                     *
                     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
                     * // => 1
                     *
                     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
                     * // => 4
                     *
                     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
                     * // => 2
                     */
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == 'number') {
                            var length = array ? array.length : 0;
                            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }

                    /**
                     * Gets all but the last element or last `n` elements of an array. If a
                     * callback is provided elements at the end of the array are excluded from
                     * the result as long as the callback returns truey. The callback is bound
                     * to `thisArg` and invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback=1] The function called
                     *  per element or the number of elements to exclude. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a slice of `array`.
                     * @example
                     *
                     * _.initial([1, 2, 3]);
                     * // => [1, 2]
                     *
                     * _.initial([1, 2, 3], 2);
                     * // => [1]
                     *
                     * _.initial([1, 2, 3], function(num) {
                     *   return num > 1;
                     * });
                     * // => [1]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.initial(characters, 'blocked');
                     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
                     *
                     * // using "_.where" callback shorthand
                     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
                     * // => ['barney', 'fred']
                     */
                    function initial(array, callback, thisArg) {
                        var n = 0,
                            length = array ? array.length : 0;

                        if (typeof callback != 'number' && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = (callback == null || thisArg) ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }

                    /**
                     * Creates an array of unique values present in all provided arrays using
                     * strict equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of shared values.
                     * @example
                     *
                     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
                     * // => [1, 2]
                     */
                    function intersection() {
                        var args = [],
                            argsIndex = -1,
                            argsLength = arguments.length,
                            caches = getArray(),
                            indexOf = getIndexOf(),
                            trustIndexOf = indexOf === baseIndexOf,
                            seen = getArray();

                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize &&
                                    createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0],
                            index = -1,
                            length = array ? array.length : 0,
                            result = [];

                        outer:
                            while (++index < length) {
                                var cache = caches[0];
                                value = array[index];

                                if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                    argsIndex = argsLength;
                                    (cache || seen).push(value);
                                    while (--argsIndex) {
                                        cache = caches[argsIndex];
                                        if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                            continue outer;
                                        }
                                    }
                                    result.push(value);
                                }
                            }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }

                    /**
                     * Gets the last element or last `n` elements of an array. If a callback is
                     * provided elements at the end of the array are returned as long as the
                     * callback returns truey. The callback is bound to `thisArg` and invoked
                     * with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback] The function called
                     *  per element or the number of elements to return. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the last element(s) of `array`.
                     * @example
                     *
                     * _.last([1, 2, 3]);
                     * // => 3
                     *
                     * _.last([1, 2, 3], 2);
                     * // => [2, 3]
                     *
                     * _.last([1, 2, 3], function(num) {
                     *   return num > 1;
                     * });
                     * // => [2, 3]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.pluck(_.last(characters, 'blocked'), 'name');
                     * // => ['fred', 'pebbles']
                     *
                     * // using "_.where" callback shorthand
                     * _.last(characters, { 'employer': 'na' });
                     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
                     */
                    function last(array, callback, thisArg) {
                        var n = 0,
                            length = array ? array.length : 0;

                        if (typeof callback != 'number' && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }

                    /**
                     * Gets the index at which the last occurrence of `value` is found using strict
                     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
                     * as the offset from the end of the collection.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {number} [fromIndex=array.length-1] The index to search from.
                     * @returns {number} Returns the index of the matched value or `-1`.
                     * @example
                     *
                     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
                     * // => 4
                     *
                     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
                     * // => 1
                     */
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == 'number') {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * Removes all provided values from the given array using strict equality for
                     * comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to modify.
                     * @param {...*} [value] The values to remove.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3, 1, 2, 3];
                     * _.pull(array, 2, 3);
                     * console.log(array);
                     * // => [1, 1]
                     */
                    function pull(array) {
                        var args = arguments,
                            argsIndex = 0,
                            argsLength = args.length,
                            length = array ? array.length : 0;

                        while (++argsIndex < argsLength) {
                            var index = -1,
                                value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }

                    /**
                     * Creates an array of numbers (positive and/or negative) progressing from
                     * `start` up to but not including `end`. If `start` is less than `stop` a
                     * zero-length range is created unless a negative `step` is specified.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @param {number} [step=1] The value to increment or decrement by.
                     * @returns {Array} Returns a new range array.
                     * @example
                     *
                     * _.range(4);
                     * // => [0, 1, 2, 3]
                     *
                     * _.range(1, 5);
                     * // => [1, 2, 3, 4]
                     *
                     * _.range(0, 20, 5);
                     * // => [0, 5, 10, 15]
                     *
                     * _.range(0, -4, -1);
                     * // => [0, -1, -2, -3]
                     *
                     * _.range(1, 4, 0);
                     * // => [1, 1, 1]
                     *
                     * _.range(0);
                     * // => []
                     */
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == 'number' ? step : (+step || 1);

                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        // use `Array(length)` so engines like Chakra and V8 avoid slower modes
                        // http://youtu.be/XAqIpGU8ZZk#t=17m25s
                        var index = -1,
                            length = nativeMax(0, ceil((end - start) / (step || 1))),
                            result = Array(length);

                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }

                    /**
                     * Removes all elements from an array that the callback returns truey for
                     * and returns an array of removed elements. The callback is bound to `thisArg`
                     * and invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to modify.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of removed elements.
                     * @example
                     *
                     * var array = [1, 2, 3, 4, 5, 6];
                     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
                     *
                     * console.log(array);
                     * // => [1, 3, 5]
                     *
                     * console.log(evens);
                     * // => [2, 4, 6]
                     */
                    function remove(array, callback, thisArg) {
                        var index = -1,
                            length = array ? array.length : 0,
                            result = [];

                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }

                    /**
                     * The opposite of `_.initial` this method gets all but the first element or
                     * first `n` elements of an array. If a callback function is provided elements
                     * at the beginning of the array are excluded from the result as long as the
                     * callback returns truey. The callback is bound to `thisArg` and invoked
                     * with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias drop, tail
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback=1] The function called
                     *  per element or the number of elements to exclude. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a slice of `array`.
                     * @example
                     *
                     * _.rest([1, 2, 3]);
                     * // => [2, 3]
                     *
                     * _.rest([1, 2, 3], 2);
                     * // => [3]
                     *
                     * _.rest([1, 2, 3], function(num) {
                     *   return num < 3;
                     * });
                     * // => [3]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.pluck(_.rest(characters, 'blocked'), 'name');
                     * // => ['fred', 'pebbles']
                     *
                     * // using "_.where" callback shorthand
                     * _.rest(characters, { 'employer': 'slate' });
                     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
                     */
                    function rest(array, callback, thisArg) {
                        if (typeof callback != 'number' && callback != null) {
                            var n = 0,
                                index = -1,
                                length = array ? array.length : 0;

                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }

                    /**
                     * Uses a binary search to determine the smallest index at which a value
                     * should be inserted into a given sorted array in order to maintain the sort
                     * order of the array. If a callback is provided it will be executed for
                     * `value` and each element of `array` to compute their sort ranking. The
                     * callback is bound to `thisArg` and invoked with one argument; (value).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedIndex([20, 30, 50], 40);
                     * // => 2
                     *
                     * // using "_.pluck" callback shorthand
                     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
                     * // => 2
                     *
                     * var dict = {
                     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
                     * };
                     *
                     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
                     *   return dict.wordToNumber[word];
                     * });
                     * // => 2
                     *
                     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
                     *   return this.wordToNumber[word];
                     * }, dict);
                     * // => 2
                     */
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0,
                            high = array ? array.length : low;

                        // explicitly reference `identity` for better inlining in Firefox
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);

                        while (low < high) {
                            var mid = (low + high) >>> 1;
                            (callback(array[mid]) < value) ?
                            low = mid + 1: high = mid;
                        }
                        return low;
                    }

                    /**
                     * Creates an array of unique values, in order, of the provided arrays using
                     * strict equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of combined values.
                     * @example
                     *
                     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
                     * // => [1, 2, 3, 5, 4]
                     */
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }

                    /**
                     * Creates a duplicate-value-free version of an array using strict equality
                     * for comparisons, i.e. `===`. If the array is sorted, providing
                     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
                     * each element of `array` is passed through the callback before uniqueness
                     * is computed. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias unique
                     * @category Arrays
                     * @param {Array} array The array to process.
                     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a duplicate-value-free array.
                     * @example
                     *
                     * _.uniq([1, 2, 1, 3, 1]);
                     * // => [1, 2, 3]
                     *
                     * _.uniq([1, 1, 2, 2, 3], true);
                     * // => [1, 2, 3]
                     *
                     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
                     * // => ['A', 'b', 'C']
                     *
                     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
                     * // => [1, 2.5, 3]
                     *
                     * // using "_.pluck" callback shorthand
                     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                     * // => [{ 'x': 1 }, { 'x': 2 }]
                     */
                    function uniq(array, isSorted, callback, thisArg) {
                        // juggle arguments
                        if (typeof isSorted != 'boolean' && isSorted != null) {
                            thisArg = callback;
                            callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }

                    /**
                     * Creates an array excluding all provided values using strict equality for
                     * comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to filter.
                     * @param {...*} [value] The values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
                     * // => [2, 3, 4]
                     */
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }

                    /**
                     * Creates an array that is the symmetric difference of the provided arrays.
                     * See http://en.wikipedia.org/wiki/Symmetric_difference.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of values.
                     * @example
                     *
                     * _.xor([1, 2, 3], [5, 2, 1, 4]);
                     * // => [3, 5, 4]
                     *
                     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
                     * // => [1, 4, 5]
                     */
                    function xor() {
                        var index = -1,
                            length = arguments.length;

                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ?
                                    baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) :
                                    array;
                            }
                        }
                        return result || [];
                    }

                    /**
                     * Creates an array of grouped elements, the first of which contains the first
                     * elements of the given arrays, the second of which contains the second
                     * elements of the given arrays, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @alias unzip
                     * @category Arrays
                     * @param {...Array} [array] Arrays to process.
                     * @returns {Array} Returns a new array of grouped elements.
                     * @example
                     *
                     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     */
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0],
                            index = -1,
                            length = array ? max(pluck(array, 'length')) : 0,
                            result = Array(length < 0 ? 0 : length);

                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }

                    /**
                     * Creates an object composed from arrays of `keys` and `values`. Provide
                     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
                     * or two arrays, one of `keys` and one of corresponding `values`.
                     *
                     * @static
                     * @memberOf _
                     * @alias object
                     * @category Arrays
                     * @param {Array} keys The array of keys.
                     * @param {Array} [values=[]] The array of values.
                     * @returns {Object} Returns an object composed of the given keys and
                     *  corresponding values.
                     * @example
                     *
                     * _.zipObject(['fred', 'barney'], [30, 40]);
                     * // => { 'fred': 30, 'barney': 40 }
                     */
                    function zipObject(keys, values) {
                        var index = -1,
                            length = keys ? keys.length : 0,
                            result = {};

                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates a function that executes `func`, with  the `this` binding and
                     * arguments of the created function, only after being called `n` times.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {number} n The number of times the function must be called before
                     *  `func` is executed.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var saves = ['profile', 'settings'];
                     *
                     * var done = _.after(saves.length, function() {
                     *   console.log('Done saving!');
                     * });
                     *
                     * _.forEach(saves, function(type) {
                     *   asyncSave({ 'type': type, 'complete': done });
                     * });
                     * // => logs 'Done saving!', after all saves have completed
                     */
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }

                    /**
                     * Creates a function that, when called, invokes `func` with the `this`
                     * binding of `thisArg` and prepends any additional `bind` arguments to those
                     * provided to the bound function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to bind.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var func = function(greeting) {
                     *   return greeting + ' ' + this.name;
                     * };
                     *
                     * func = _.bind(func, { 'name': 'fred' }, 'hi');
                     * func();
                     * // => 'hi fred'
                     */
                    function bind(func, thisArg) {
                        return arguments.length > 2 ?
                            createWrapper(func, 17, slice(arguments, 2), null, thisArg) :
                            createWrapper(func, 1, null, null, thisArg);
                    }

                    /**
                     * Binds methods of an object to the object itself, overwriting the existing
                     * method. Method names may be specified as individual arguments or as arrays
                     * of method names. If no method names are provided all the function properties
                     * of `object` will be bound.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Object} object The object to bind and assign the bound methods to.
                     * @param {...string} [methodName] The object method names to
                     *  bind, specified as individual method names or arrays of method names.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var view = {
                     *   'label': 'docs',
                     *   'onClick': function() { console.log('clicked ' + this.label); }
                     * };
                     *
                     * _.bindAll(view);
                     * jQuery('#docs').on('click', view.onClick);
                     * // => logs 'clicked docs', when the button is clicked
                     */
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
                            index = -1,
                            length = funcs.length;

                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }

                    /**
                     * Creates a function that, when called, invokes the method at `object[key]`
                     * and prepends any additional `bindKey` arguments to those provided to the bound
                     * function. This method differs from `_.bind` by allowing bound functions to
                     * reference methods that will be redefined or don't yet exist.
                     * See http://michaux.ca/articles/lazy-function-definition-pattern.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Object} object The object the method belongs to.
                     * @param {string} key The key of the method.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var object = {
                     *   'name': 'fred',
                     *   'greet': function(greeting) {
                     *     return greeting + ' ' + this.name;
                     *   }
                     * };
                     *
                     * var func = _.bindKey(object, 'greet', 'hi');
                     * func();
                     * // => 'hi fred'
                     *
                     * object.greet = function(greeting) {
                     *   return greeting + 'ya ' + this.name + '!';
                     * };
                     *
                     * func();
                     * // => 'hiya fred!'
                     */
                    function bindKey(object, key) {
                        return arguments.length > 2 ?
                            createWrapper(key, 19, slice(arguments, 2), null, object) :
                            createWrapper(key, 3, null, null, object);
                    }

                    /**
                     * Creates a function that is the composition of the provided functions,
                     * where each function consumes the return value of the function that follows.
                     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
                     * Each function is executed with the `this` binding of the composed function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {...Function} [func] Functions to compose.
                     * @returns {Function} Returns the new composed function.
                     * @example
                     *
                     * var realNameMap = {
                     *   'pebbles': 'penelope'
                     * };
                     *
                     * var format = function(name) {
                     *   name = realNameMap[name.toLowerCase()] || name;
                     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                     * };
                     *
                     * var greet = function(formatted) {
                     *   return 'Hiya ' + formatted + '!';
                     * };
                     *
                     * var welcome = _.compose(greet, format);
                     * welcome('pebbles');
                     * // => 'Hiya Penelope!'
                     */
                    function compose() {
                        var funcs = arguments,
                            length = funcs.length;

                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError;
                            }
                        }
                        return function() {
                            var args = arguments,
                                length = funcs.length;

                            while (length--) {
                                args = [funcs[length].apply(this, args)];
                            }
                            return args[0];
                        };
                    }

                    /**
                     * Creates a function which accepts one or more arguments of `func` that when
                     * invoked either executes `func` returning its result, if all `func` arguments
                     * have been provided, or returns a function that accepts one or more of the
                     * remaining `func` arguments, and so on. The arity of `func` can be specified
                     * if `func.length` is not sufficient.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var curried = _.curry(function(a, b, c) {
                     *   console.log(a + b + c);
                     * });
                     *
                     * curried(1)(2)(3);
                     * // => 6
                     *
                     * curried(1, 2)(3);
                     * // => 6
                     *
                     * curried(1, 2, 3);
                     * // => 6
                     */
                    function curry(func, arity) {
                        arity = typeof arity == 'number' ? arity : (+arity || func.length);
                        return createWrapper(func, 4, null, null, null, arity);
                    }

                    /**
                     * Creates a function that will delay the execution of `func` until after
                     * `wait` milliseconds have elapsed since the last time it was invoked.
                     * Provide an options object to indicate that `func` should be invoked on
                     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
                     * to the debounced function will return the result of the last `func` call.
                     *
                     * Note: If `leading` and `trailing` options are `true` `func` will be called
                     * on the trailing edge of the timeout only if the the debounced function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to debounce.
                     * @param {number} wait The number of milliseconds to delay.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
                     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
                     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
                     * @returns {Function} Returns the new debounced function.
                     * @example
                     *
                     * // avoid costly calculations while the window size is in flux
                     * var lazyLayout = _.debounce(calculateLayout, 150);
                     * jQuery(window).on('resize', lazyLayout);
                     *
                     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
                     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
                     *   'leading': true,
                     *   'trailing': false
                     * });
                     *
                     * // ensure `batchLog` is executed once after 1 second of debounced calls
                     * var source = new EventSource('/stream');
                     * source.addEventListener('message', _.debounce(batchLog, 250, {
                     *   'maxWait': 1000
                     * }, false);
                     */
                    function debounce(func, wait, options) {
                        var args,
                            maxTimeoutId,
                            result,
                            stamp,
                            thisArg,
                            timeoutId,
                            trailingCall,
                            lastCalled = 0,
                            maxWait = false,
                            trailing = true;

                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = 'trailing' in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };

                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || (maxWait !== wait)) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };

                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);

                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled),
                                    isCalled = remaining <= 0;

                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }

                    /**
                     * Defers executing the `func` function until the current call stack has cleared.
                     * Additional arguments will be provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to defer.
                     * @param {...*} [arg] Arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.defer(function(text) { console.log(text); }, 'deferred');
                     * // logs 'deferred' after one or more milliseconds
                     */
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }

                    /**
                     * Executes the `func` function after `wait` milliseconds. Additional arguments
                     * will be provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay execution.
                     * @param {...*} [arg] Arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.delay(function(text) { console.log(text); }, 1000, 'later');
                     * // => logs 'later' after one second
                     */
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }

                    /**
                     * Creates a function that memoizes the result of `func`. If `resolver` is
                     * provided it will be used to determine the cache key for storing the result
                     * based on the arguments provided to the memoized function. By default, the
                     * first argument provided to the memoized function is used as the cache key.
                     * The `func` is executed with the `this` binding of the memoized function.
                     * The result cache is exposed as the `cache` property on the memoized function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to have its output memoized.
                     * @param {Function} [resolver] A function used to resolve the cache key.
                     * @returns {Function} Returns the new memoizing function.
                     * @example
                     *
                     * var fibonacci = _.memoize(function(n) {
                     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
                     * });
                     *
                     * fibonacci(9)
                     * // => 34
                     *
                     * var data = {
                     *   'fred': { 'name': 'fred', 'age': 40 },
                     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
                     * };
                     *
                     * // modifying the result cache
                     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
                     * get('pebbles');
                     * // => { 'name': 'pebbles', 'age': 1 }
                     *
                     * get.cache.pebbles.name = 'penelope';
                     * get('pebbles');
                     * // => { 'name': 'penelope', 'age': 1 }
                     */
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        var memoized = function() {
                            var cache = memoized.cache,
                                key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

                            return hasOwnProperty.call(cache, key) ?
                                cache[key] :
                                (cache[key] = func.apply(this, arguments));
                        }
                        memoized.cache = {};
                        return memoized;
                    }

                    /**
                     * Creates a function that is restricted to execute `func` once. Repeat calls to
                     * the function will return the value of the first call. The `func` is executed
                     * with the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var initialize = _.once(createApplication);
                     * initialize();
                     * initialize();
                     * // `initialize` executes `createApplication` once
                     */
                    function once(func) {
                        var ran,
                            result;

                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);

                            // clear the `func` variable so the function may be garbage collected
                            func = null;
                            return result;
                        };
                    }

                    /**
                     * Creates a function that, when called, invokes `func` with any additional
                     * `partial` arguments prepended to those provided to the new function. This
                     * method is similar to `_.bind` except it does **not** alter the `this` binding.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) { return greeting + ' ' + name; };
                     * var hi = _.partial(greet, 'hi');
                     * hi('fred');
                     * // => 'hi fred'
                     */
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }

                    /**
                     * This method is like `_.partial` except that `partial` arguments are
                     * appended to those provided to the new function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
                     *
                     * var options = {
                     *   'variable': 'data',
                     *   'imports': { 'jq': $ }
                     * };
                     *
                     * defaultsDeep(options, _.templateSettings);
                     *
                     * options.variable
                     * // => 'data'
                     *
                     * options.imports
                     * // => { '_': _, 'jq': $ }
                     */
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }

                    /**
                     * Creates a function that, when executed, will only call the `func` function
                     * at most once per every `wait` milliseconds. Provide an options object to
                     * indicate that `func` should be invoked on the leading and/or trailing edge
                     * of the `wait` timeout. Subsequent calls to the throttled function will
                     * return the result of the last `func` call.
                     *
                     * Note: If `leading` and `trailing` options are `true` `func` will be called
                     * on the trailing edge of the timeout only if the the throttled function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to throttle.
                     * @param {number} wait The number of milliseconds to throttle executions to.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
                     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
                     * @returns {Function} Returns the new throttled function.
                     * @example
                     *
                     * // avoid excessively updating the position while scrolling
                     * var throttled = _.throttle(updatePosition, 100);
                     * jQuery(window).on('scroll', throttled);
                     *
                     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
                     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
                     *   'trailing': false
                     * }));
                     */
                    function throttle(func, wait, options) {
                        var leading = true,
                            trailing = true;

                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = 'leading' in options ? options.leading : leading;
                            trailing = 'trailing' in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;

                        return debounce(func, wait, debounceOptions);
                    }

                    /**
                     * Creates a function that provides `value` to the wrapper function as its
                     * first argument. Additional arguments provided to the function are appended
                     * to those provided to the wrapper function. The wrapper is executed with
                     * the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {*} value The value to wrap.
                     * @param {Function} wrapper The wrapper function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var p = _.wrap(_.escape, function(func, text) {
                     *   return '<p>' + func(text) + '</p>';
                     * });
                     *
                     * p('Fred, Wilma, & Pebbles');
                     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
                     */
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [value]);
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates a function that returns `value`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} value The value to return from the new function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * var getter = _.constant(object);
                     * getter() === object;
                     * // => true
                     */
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }

                    /**
                     * Produces a callback bound to an optional `thisArg`. If `func` is a property
                     * name the created callback will return the property value for a given element.
                     * If `func` is an object the created callback will return `true` for elements
                     * that contain the equivalent object properties, otherwise it will return `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} [func=identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of the created callback.
                     * @param {number} [argCount] The number of arguments the callback accepts.
                     * @returns {Function} Returns a callback function.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // wrap to create custom callback shorthands
                     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
                     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
                     *   return !match ? func(callback, thisArg) : function(object) {
                     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
                     *   };
                     * });
                     *
                     * _.filter(characters, 'age__gt38');
                     * // => [{ 'name': 'fred', 'age': 40 }]
                     */
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == 'function') {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        // handle "_.pluck" style callback shorthands
                        if (type != 'object') {
                            return property(func);
                        }
                        var props = keys(func),
                            key = props[0],
                            a = func[key];

                        // handle "_.where" style callback shorthands
                        if (props.length == 1 && a === a && !isObject(a)) {
                            // fast path the common case of providing an object with a single
                            // property containing a primitive value
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || (1 / a == 1 / b));
                            };
                        }
                        return function(object) {
                            var length = props.length,
                                result = false;

                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }

                    /**
                     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
                     * corresponding HTML entities.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} string The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escape('Fred, Wilma, & Pebbles');
                     * // => 'Fred, Wilma, &amp; Pebbles'
                     */
                    function escape(string) {
                        return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }

                    /**
                     * This method returns the first argument provided to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} value Any value.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * _.identity(object) === object;
                     * // => true
                     */
                    function identity(value) {
                        return value;
                    }

                    /**
                     * Adds function properties of a source object to the destination object.
                     * If `object` is a function methods will be added to its prototype as well.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {Function|Object} [object=lodash] object The destination object.
                     * @param {Object} source The object of functions to add.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
                     * @example
                     *
                     * function capitalize(string) {
                     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
                     * }
                     *
                     * _.mixin({ 'capitalize': capitalize });
                     * _.capitalize('fred');
                     * // => 'Fred'
                     *
                     * _('fred').capitalize().value();
                     * // => 'Fred'
                     *
                     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
                     * _('fred').capitalize();
                     * // => 'Fred'
                     */
                    function mixin(object, source, options) {
                        var chain = true,
                            methodNames = source && functions(source);

                        if (!source || (!options && !methodNames.length)) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && 'chain' in options) {
                            chain = options.chain;
                        }
                        var ctor = object,
                            isFunc = isFunction(ctor);

                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__,
                                        value = this.__wrapped__,
                                        args = [value];

                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }

                    /**
                     * Reverts the '_' variable to its previous value and returns a reference to
                     * the `lodash` function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @returns {Function} Returns the `lodash` function.
                     * @example
                     *
                     * var lodash = _.noConflict();
                     */
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }

                    /**
                     * A no-operation function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * _.noop(object) === undefined;
                     * // => true
                     */
                    function noop() {
                        // no operation performed
                    }

                    /**
                     * Gets the number of milliseconds that have elapsed since the Unix epoch
                     * (1 January 1970 00:00:00 UTC).
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @example
                     *
                     * var stamp = _.now();
                     * _.defer(function() { console.log(_.now() - stamp); });
                     * // => logs the number of milliseconds it took for the deferred function to be called
                     */
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };

                    /**
                     * Converts the given value into an integer of the specified radix.
                     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
                     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
                     *
                     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
                     * implementations. See http://es5.github.io/#E.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} value The value to parse.
                     * @param {number} [radix] The radix used to interpret the value to parse.
                     * @returns {number} Returns the new integer value.
                     * @example
                     *
                     * _.parseInt('08');
                     * // => 8
                     */
                    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
                        // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
                    };

                    /**
                     * Creates a "_.pluck" style function, which returns the `key` value of a
                     * given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} key The name of the property to retrieve.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'fred',   'age': 40 },
                     *   { 'name': 'barney', 'age': 36 }
                     * ];
                     *
                     * var getName = _.property('name');
                     *
                     * _.map(characters, getName);
                     * // => ['barney', 'fred']
                     *
                     * _.sortBy(characters, getName);
                     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
                     */
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }

                    /**
                     * Produces a random number between `min` and `max` (inclusive). If only one
                     * argument is provided a number between `0` and the given number will be
                     * returned. If `floating` is truey or either `min` or `max` are floats a
                     * floating-point number will be returned instead of an integer.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {number} [min=0] The minimum possible value.
                     * @param {number} [max=1] The maximum possible value.
                     * @param {boolean} [floating=false] Specify returning a floating-point number.
                     * @returns {number} Returns a random number.
                     * @example
                     *
                     * _.random(0, 5);
                     * // => an integer between 0 and 5
                     *
                     * _.random(5);
                     * // => also an integer between 0 and 5
                     *
                     * _.random(5, true);
                     * // => a floating-point number between 0 and 5
                     *
                     * _.random(1.2, 5.2);
                     * // => a floating-point number between 1.2 and 5.2
                     */
                    function random(min, max, floating) {
                        var noMin = min == null,
                            noMax = max == null;

                        if (floating == null) {
                            if (typeof min == 'boolean' && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == 'boolean') {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
                        }
                        return baseRandom(min, max);
                    }

                    /**
                     * Resolves the value of property `key` on `object`. If `key` is a function
                     * it will be invoked with the `this` binding of `object` and its result returned,
                     * else the property value is returned. If `object` is falsey then `undefined`
                     * is returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {Object} object The object to inspect.
                     * @param {string} key The name of the property to resolve.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = {
                     *   'cheese': 'crumpets',
                     *   'stuff': function() {
                     *     return 'nonsense';
                     *   }
                     * };
                     *
                     * _.result(object, 'cheese');
                     * // => 'crumpets'
                     *
                     * _.result(object, 'stuff');
                     * // => 'nonsense'
                     */
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }

                    /**
                     * A micro-templating method that handles arbitrary delimiters, preserves
                     * whitespace, and correctly escapes quotes within interpolated code.
                     *
                     * Note: In the development build, `_.template` utilizes sourceURLs for easier
                     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                     *
                     * For more information on precompiling templates see:
                     * http://lodash.com/custom-builds
                     *
                     * For more information on Chrome extension sandboxes see:
                     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} text The template text.
                     * @param {Object} data The data object used to populate the text.
                     * @param {Object} [options] The options object.
                     * @param {RegExp} [options.escape] The "escape" delimiter.
                     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
                     * @param {Object} [options.imports] An object to import into the template as local variables.
                     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
                     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
                     * @param {string} [variable] The data object variable name.
                     * @returns {Function|string} Returns a compiled function when no `data` object
                     *  is given, else it returns the interpolated text.
                     * @example
                     *
                     * // using the "interpolate" delimiter to create a compiled template
                     * var compiled = _.template('hello <%= name %>');
                     * compiled({ 'name': 'fred' });
                     * // => 'hello fred'
                     *
                     * // using the "escape" delimiter to escape HTML in data property values
                     * _.template('<b><%- value %></b>', { 'value': '<script>' });
                     * // => '<b>&lt;script&gt;</b>'
                     *
                     * // using the "evaluate" delimiter to generate HTML
                     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
                     * _.template(list, { 'people': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
                     * _.template('hello ${ name }', { 'name': 'pebbles' });
                     * // => 'hello pebbles'
                     *
                     * // using the internal `print` function in "evaluate" delimiters
                     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
                     * // => 'hello barney!'
                     *
                     * // using a custom template delimiters
                     * _.templateSettings = {
                     *   'interpolate': /{{([\s\S]+?)}}/g
                     * };
                     *
                     * _.template('hello {{ name }}!', { 'name': 'mustache' });
                     * // => 'hello mustache!'
                     *
                     * // using the `imports` option to import jQuery
                     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
                     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the `sourceURL` option to specify a custom sourceURL for the template
                     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
                     * compiled(data);
                     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
                     *
                     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
                     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
                     * compiled.source;
                     * // => function(data) {
                     *   var __t, __p = '', __e = _.escape;
                     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
                     *   return __p;
                     * }
                     *
                     * // using the `source` property to inline compiled templates for meaningful
                     * // line numbers in error messages and a stack trace
                     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                     *   var JST = {\
                     *     "main": ' + _.template(mainText).source + '\
                     *   };\
                     * ');
                     */
                    function template(text, data, options) {
                        // based on John Resig's `tmpl` implementation
                        // http://ejohn.org/blog/javascript-micro-templating/
                        // and Laura Doktorova's doT.js
                        // https://github.com/olado/doT
                        var settings = lodash.templateSettings;
                        text = String(text || '');

                        // avoid missing dependencies when `iteratorTemplate` is not defined
                        options = defaults({}, options, settings);

                        var imports = defaults({}, options.imports, settings.imports),
                            importsKeys = keys(imports),
                            importsValues = values(imports);

                        var isEvaluating,
                            index = 0,
                            interpolate = options.interpolate || reNoMatch,
                            source = "__p += '";

                        // compile the regexp to match each delimiter
                        var reDelimiters = RegExp(
                            (options.escape || reNoMatch).source + '|' +
                            interpolate.source + '|' +
                            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                            (options.evaluate || reNoMatch).source + '|$', 'g');

                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);

                            // escape characters that cannot be included in string literals
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                            // replace delimiters with snippets
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;

                            // the JS engine embedded in Adobe products requires returning the `match`
                            // string in order to produce the correct `offset` value
                            return match;
                        });

                        source += "';\n";

                        // if `variable` is not specified, wrap a with-statement around the generated
                        // code to add the data object to the top of the scope chain
                        var variable = options.variable,
                            hasVariable = variable;

                        if (!hasVariable) {
                            variable = 'obj';
                            source = 'with (' + variable + ') {\n' + source + '\n}\n';
                        }
                        // cleanup code by stripping empty strings
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                            .replace(reEmptyStringMiddle, '$1')
                            .replace(reEmptyStringTrailing, '$1;');

                        // frame code as the function body
                        source = 'function(' + variable + ') {\n' +
                            (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
                            "var __t, __p = '', __e = _.escape" +
                            (isEvaluating ?
                                ', __j = Array.prototype.join;\n' +
                                "function print() { __p += __j.call(arguments, '') }\n" :
                                ';\n'
                            ) +
                            source +
                            'return __p\n}';

                        // Use a sourceURL for easier debugging.
                        // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                        var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

                        try {
                            var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        // provide the compiled function's source by its `toString` method, in
                        // supported environments, or the `source` property as a convenience for
                        // inlining compiled templates during the build process
                        result.source = source;
                        return result;
                    }

                    /**
                     * Executes the callback `n` times, returning an array of the results
                     * of each callback execution. The callback is bound to `thisArg` and invoked
                     * with one argument; (index).
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {number} n The number of times to execute the callback.
                     * @param {Function} callback The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns an array of the results of each `callback` execution.
                     * @example
                     *
                     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
                     * // => [3, 6, 4]
                     *
                     * _.times(3, function(n) { mage.castSpell(n); });
                     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
                     *
                     * _.times(3, function(n) { this.cast(n); }, mage);
                     * // => also calls `mage.castSpell(n)` three times
                     */
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1,
                            result = Array(n);

                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }

                    /**
                     * The inverse of `_.escape` this method converts the HTML entities
                     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
                     * corresponding characters.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} string The string to unescape.
                     * @returns {string} Returns the unescaped string.
                     * @example
                     *
                     * _.unescape('Fred, Barney &amp; Pebbles');
                     * // => 'Fred, Barney & Pebbles'
                     */
                    function unescape(string) {
                        return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }

                    /**
                     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} [prefix] The value to prefix the ID with.
                     * @returns {string} Returns the unique ID.
                     * @example
                     *
                     * _.uniqueId('contact_');
                     * // => 'contact_104'
                     *
                     * _.uniqueId();
                     * // => '105'
                     */
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? '' : prefix) + id;
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object that wraps the given value with explicit
                     * method chaining enabled.
                     *
                     * @static
                     * @memberOf _
                     * @category Chaining
                     * @param {*} value The value to wrap.
                     * @returns {Object} Returns the wrapper object.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36 },
                     *   { 'name': 'fred',    'age': 40 },
                     *   { 'name': 'pebbles', 'age': 1 }
                     * ];
                     *
                     * var youngest = _.chain(characters)
                     *     .sortBy('age')
                     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
                     *     .first()
                     *     .value();
                     * // => 'pebbles is 1'
                     */
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }

                    /**
                     * Invokes `interceptor` with the `value` as the first argument and then
                     * returns `value`. The purpose of this method is to "tap into" a method
                     * chain in order to perform operations on intermediate results within
                     * the chain.
                     *
                     * @static
                     * @memberOf _
                     * @category Chaining
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * _([1, 2, 3, 4])
                     *  .tap(function(array) { array.pop(); })
                     *  .reverse()
                     *  .value();
                     * // => [3, 2, 1]
                     */
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }

                    /**
                     * Enables explicit method chaining on the wrapper object.
                     *
                     * @name chain
                     * @memberOf _
                     * @category Chaining
                     * @returns {*} Returns the wrapper object.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // without explicit chaining
                     * _(characters).first();
                     * // => { 'name': 'barney', 'age': 36 }
                     *
                     * // with explicit chaining
                     * _(characters).chain()
                     *   .first()
                     *   .pick('age')
                     *   .value();
                     * // => { 'age': 36 }
                     */
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }

                    /**
                     * Produces the `toString` result of the wrapped value.
                     *
                     * @name toString
                     * @memberOf _
                     * @category Chaining
                     * @returns {string} Returns the string result.
                     * @example
                     *
                     * _([1, 2, 3]).toString();
                     * // => '1,2,3'
                     */
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }

                    /**
                     * Extracts the wrapped value.
                     *
                     * @name valueOf
                     * @memberOf _
                     * @alias value
                     * @category Chaining
                     * @returns {*} Returns the wrapped value.
                     * @example
                     *
                     * _([1, 2, 3]).valueOf();
                     * // => [1, 2, 3]
                     */
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }

                    /*--------------------------------------------------------------------------*/

                    // add functions that return wrapped values when chaining
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;

                    // add aliases
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;

                    // add functions to `lodash.prototype`
                    mixin(lodash);

                    /*--------------------------------------------------------------------------*/

                    // add functions that return unwrapped values when chaining
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;

                    // add aliases
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;

                    mixin(function() {
                        var source = {}
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);

                    /*--------------------------------------------------------------------------*/

                    // add functions capable of returning wrapped and unwrapped values when chaining
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;

                    // add aliases
                    lodash.take = first;
                    lodash.head = first;

                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== 'sample';
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__,
                                    result = func(this.__wrapped__, n, guard);

                                return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function'))) ?
                                    result :
                                    new lodashWrapper(result, chainAll);
                            };
                        }
                    });

                    /*--------------------------------------------------------------------------*/

                    /**
                     * The semantic version number.
                     *
                     * @static
                     * @memberOf _
                     * @type string
                     */
                    lodash.VERSION = '2.4.1';

                    // add "Chaining" functions to the wrapper
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;

                    // add `Array` functions that return unwrapped values
                    forEach(['join', 'pop', 'shift'], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__,
                                result = func.apply(this.__wrapped__, arguments);

                            return chainAll ?
                                new lodashWrapper(result, chainAll) :
                                result;
                        };
                    });

                    // add `Array` functions that return the existing wrapped value
                    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });

                    // add `Array` functions that return new wrapped values
                    forEach(['concat', 'slice', 'splice'], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });

                    return lodash;
                }

                /*--------------------------------------------------------------------------*/

                // expose Lo-Dash
                var _ = runInContext();

                // some AMD build optimizers like r.js check for condition patterns like the following:
                if (true) {
                    // Expose Lo-Dash to the global object even when an AMD loader is present in
                    // case Lo-Dash is loaded with a RequireJS shim config.
                    // See http://requirejs.org/docs/api.html#config-shim
                    root._ = _;

                    // define as an anonymous module so, through path mapping, it can be
                    // referenced as the "underscore" module
                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                            return _;
                        }.call(exports, __webpack_require__, exports, module),
                        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                }
                // check for `exports` after `define` in case a build optimizer adds an `exports` object
                else if (freeExports && freeModule) {
                    // in Node.js or RingoJS
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    }
                    // in Narwhal or Rhino -require
                    else {
                        freeExports._ = _;
                    }
                } else {
                    // in a browser or Rhino
                    root._ = _;
                }
            }.call(this));

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(10)(module), __webpack_require__(4)))

        /***/
    }),
    /* 7 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "c", function() {
            return Base64;
        });
        /* harmony export (immutable) */
        __webpack_exports__["d"] = lzw_encode;
        /* harmony export (immutable) */
        __webpack_exports__["b"] = lzw_decode;
        /* harmony export (immutable) */
        __webpack_exports__["a"] = htmlentities;
        /* harmony export (immutable) */
        __webpack_exports__["e"] = levenshteinDistance;
        /* ---
         * Base64 encode / decode
         * initial version fom http://www.webtoolkit.info/
         * modified to support more url friendly variant "base64url".
         * modified to include Base64 for decimal numbers.
         * modified to support native (= much faster) base64 encoders
         * ---
         * lzw_* taken from jsolait library (http://jsolait.net/), LGPL
         * slightly modified to support utf8 strings.
         * ---
         * Levenshtein Distance from iD editor project, WTFPL
         */
        var Base64 = {
            // private property
            _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

            // public method for encoding
            encode: function(input, not_base64url) {
                var output = "";
                //input = Base64._utf8_encode(input);
                input = unescape(encodeURIComponent(input));

                if (typeof window.btoa == "function") {
                    output = window.btoa(input);
                } else {
                    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                    var i = 0;

                    while (i < input.length) {
                        chr1 = input.charCodeAt(i++);
                        chr2 = input.charCodeAt(i++);
                        chr3 = input.charCodeAt(i++);

                        enc1 = chr1 >> 2;
                        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                        enc4 = chr3 & 63;

                        if (isNaN(chr2)) {
                            enc3 = enc4 = 64;
                        } else if (isNaN(chr3)) {
                            enc4 = 64;
                        }

                        output =
                            output +
                            this._keyStr.charAt(enc1) +
                            this._keyStr.charAt(enc2) +
                            this._keyStr.charAt(enc3) +
                            this._keyStr.charAt(enc4);
                    }
                }

                if (!not_base64url) return this._convert_to_base64url(output);
                else return output;
            },

            // public method for decoding
            // this decodes base64url as well as standard base64 with or without padding)
            decode: function(input, binary) {
                var output = "";
                input = this._convert_to_base64nopad(input);
                input = input.replace(/[^A-Za-z0-9\+\/]/g, "");
                //reappend the padding
                input = input + "==".substring(0, (4 - input.length % 4) % 4);

                if (typeof window.btoa == "function") {
                    output = window.atob(input);
                } else {
                    var chr1, chr2, chr3;
                    var enc1, enc2, enc3, enc4;
                    var i = 0;

                    while (i < input.length) {
                        enc1 = this._keyStr.indexOf(input.charAt(i++));
                        enc2 = this._keyStr.indexOf(input.charAt(i++));
                        enc3 = this._keyStr.indexOf(input.charAt(i++));
                        enc4 = this._keyStr.indexOf(input.charAt(i++));

                        chr1 = (enc1 << 2) | (enc2 >> 4);
                        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                        chr3 = ((enc3 & 3) << 6) | enc4;

                        output = output + String.fromCharCode(chr1);

                        if (enc3 != 64) {
                            output = output + String.fromCharCode(chr2);
                        }
                        if (enc4 != 64) {
                            output = output + String.fromCharCode(chr3);
                        }
                    }
                }

                function str2ab(str) {
                    var buf = new ArrayBuffer(str.length); // 1 byte for each char
                    var bufView = new Uint8Array(buf);
                    for (var i = 0, strLen = str.length; i < strLen; i++) {
                        bufView[i] = str.charCodeAt(i);
                    }
                    return buf;
                }

                if (!binary) {
                    // try to decode utf8 characters
                    try {
                        output = decodeURIComponent(escape(output));
                    } catch (e) {}
                } else {
                    // convert binary string to typed (Uint8) array
                    output = str2ab(output);
                }
                return output;
            },

            encodeNum: function(num, not_base64url) {
                var output = "";
                if (num == 0) return this._keyStr.charAt(0);
                var neg = false;
                if (num < 0) {
                    neg = true;
                    num = Math.abs(num);
                }
                while (num > 0) {
                    output = this._keyStr.charAt(num % 64) + output;
                    num -= num % 64;
                    num /= 64;
                }
                if (neg) output = "~" + output;
                if (!not_base64url) return this._convert_to_base64url(output);
                else return output;
            },

            decodeNum: function(input) {
                input = this._convert_to_base64nopad(input);
                input = input.replace(/[^A-Za-z0-9\+\/.]/g, "");
                var num = 0;
                var neg = false;
                if (input.charAt(0) == ".") {
                    neg = true;
                    input = input.substr(1);
                }
                for (var i = 0; i < input.length; i++) {
                    num +=
                        this._keyStr.indexOf(input.charAt(input.length - 1 - i)) *
                        Math.pow(64, i);
                }
                return (neg ? -1 : 1) * num;
            },

            _convert_to_base64url: function(input) {
                return input.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
            },
            _convert_to_base64nopad: function(input) {
                return input.replace(/\-/g, "+").replace(/_/g, "/");
            },

            // private method for UTF-8 encoding
            _utf8_encode: function(string) {
                string = string.replace(/\r\n/g, "\n");
                var utftext = "";

                for (var n = 0; n < string.length; n++) {
                    var c = string.charCodeAt(n);

                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    } else if (c > 127 && c < 2048) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    } else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }
                }

                return utftext;
            },

            // private method for UTF-8 decoding
            _utf8_decode: function(utftext) {
                var string = "";
                var i = 0;
                var c = (c1 = c2 = 0);

                while (i < utftext.length) {
                    c = utftext.charCodeAt(i);

                    if (c < 128) {
                        string += String.fromCharCode(c);
                        i++;
                    } else if (c > 191 && c < 224) {
                        c2 = utftext.charCodeAt(i + 1);
                        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                        i += 2;
                    } else {
                        c2 = utftext.charCodeAt(i + 1);
                        c3 = utftext.charCodeAt(i + 2);
                        string += String.fromCharCode(
                            ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)
                        );
                        i += 3;
                    }
                }

                return string;
            }
        };

        // LZW-compress a string
        function lzw_encode(s) {
            //s = Base64._utf8_encode(s);
            s = unescape(encodeURIComponent(s));
            var dict = {};
            var data = (s + "").split("");
            var out = [];
            var currChar;
            var phrase = data[0];
            var code = 256;
            for (var i = 1; i < data.length; i++) {
                currChar = data[i];
                if (dict[phrase + currChar] != null) {
                    phrase += currChar;
                } else {
                    out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));
                    dict[phrase + currChar] = code;
                    code++;
                    phrase = currChar;
                }
            }
            out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));
            for (var i = 0; i < out.length; i++) {
                out[i] = String.fromCharCode(out[i]);
            }
            return out.join("");
        }

        // Decompress an LZW-encoded string
        function lzw_decode(s) {
            var dict = {};
            var data = (s + "").split("");
            var currChar = data[0];
            var oldPhrase = currChar;
            var out = [currChar];
            var code = 256;
            var phrase;
            for (var i = 1; i < data.length; i++) {
                var currCode = data[i].charCodeAt(0);
                if (currCode < 256) {
                    phrase = data[i];
                } else {
                    phrase = dict[currCode] ? dict[currCode] : oldPhrase + currChar;
                }
                out.push(phrase);
                currChar = phrase.charAt(0);
                dict[code] = oldPhrase + currChar;
                code++;
                oldPhrase = phrase;
            }
            //return Base64._utf8_decode(out.join(""));
            return decodeURIComponent(escape(out.join("")));
        }

        // escape strings to show them directly in the html.
        function htmlentities(str) {
            return String(str)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;");
        }

        // Levenshtein Distance
        // from https://github.com/systemed/iD/blob/1e78ee5c87669aac407c69493f3f532c823346ef/js/id/util.js#L97-L115
        function levenshteinDistance(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;
            var matrix = [];
            for (var i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            for (var j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            for (i = 1; i <= b.length; i++) {
                for (j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // substitution
                            Math.min(
                                matrix[i][j - 1] + 1, // insertion
                                matrix[i - 1][j] + 1
                            )
                        ); // deletion
                    }
                }
            }
            return matrix[b.length][a.length];
        }


        /***/
    }),
    /* 8 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(6);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__configs__ = __webpack_require__(5);
        // Settings class




        function Settings(namespace, version) {
            // == private members ==
            var prefix = namespace + "_";
            var ls = {
                setItem: function(n, v) {
                    this[n] = v;
                },
                getItem: function(n) {
                    return this[n] !== undefined ? this[n] : null;
                }
            };
            try {
                localStorage.setItem(prefix + "test", 123);
                localStorage.removeItem(prefix + "test");
                ls = localStorage;
            } catch (e) {}
            var settings_version = version;
            var version = +ls.getItem(prefix + "version");
            var settings = {};
            var upgrade_callbacks = [];

            // == public methods ==
            this.define_setting = function(name, type, preset, version) {
                settings[name] = {
                    type: type,
                    preset: preset,
                    version: version
                };
            };
            this.define_upgrade_callback = function(version, fun) {
                upgrade_callbacks[version] = fun;
            };

            this.set = function(name, value) {
                if (
                    value === undefined // use preset if no value is given
                )
                    value = settings[name].preset;
                if (
                    settings[name].type != "String" // stringify all non-string values.
                )
                    value = JSON.stringify(value);
                ls.setItem(prefix + name, value);
            };
            this.get = function(name) {
                // initialize new settings
                if (settings[name].version > version) this.set(name, undefined);
                // load the setting
                var value = ls.getItem(prefix + name);
                if (
                    settings[name].type != "String" // parse all non-string values.
                )
                    value = JSON.parse(value);
                return value;
            };

            this.load = function() {
                // load all settings into the objects namespace
                for (var name in settings) {
                    this[name] = this.get(name);
                }
                // version upgrade
                if (version == 0) this.first_time_visit = true;
                if (version < settings_version) {
                    for (var v = version + 1; v <= settings_version; v++) {
                        if (typeof upgrade_callbacks[v] == "function")
                            upgrade_callbacks[v](this);
                    }
                    version = settings_version;
                    ls.setItem(prefix + "version", version);
                }
            };
            this.save = function() {
                // save all settings from the objects namespace
                for (var name in settings) {
                    this.set(name, this[name]);
                }
            };
        }
        // examples
        var examples = {
            "Drinking Water": {
                overpass: "/*\nThis is an example Overpass query.\nTry it out by pressing the Run button above!\nYou can find more examples with the Load tool.\n*/\nnode\n  [amenity=drinking_water]\n  ({{bbox}});\nout;"
            },
            "Cycle Network": {
                overpass: "/*\nThis shows the cycleway and cycleroute network.\n*/\n\n[out:json];\n\n(\n  // get cycle route relatoins\n  relation[route=bicycle]({{bbox}})->.cr;\n  // get cycleways\n  way[highway=cycleway]({{bbox}});\n  way[highway=path][bicycle=designated]({{bbox}});\n);\n\nout body;\n>;\nout skel qt;"
            },
            "Where am I?": {
                overpass: "/*\nThis lists all areas which include the map center point.\n*/\n[out:json];\nis_in({{center}});\nout;"
            },
            "Mountains in Area": {
                overpass: '/*\nThis shows all mountains (peaks) in the Dolomites.\nYou may want to use the "zoom onto data" button. =>\n*/\n\n[out:json];\n\n// search the area of the Dolmites\narea\n  [place=region]\n  ["region:type"="mountain_area"]\n  ["name:en"="Dolomites"];\nout body;\n\n// get all peaks in the area\nnode\n  [natural=peak]\n  (area);\nout body qt;\n\n// additionally, show the outline of the area\nrelation\n  [place=region]\n  ["region:type"="mountain_area"]\n  ["name:en"="Dolomites"];\nout body;\n>;\nout skel qt;'
            },
            "Map Call": {
                overpass: "/*\nThis is a simple map call.\nIt returns all data in the bounding box.\n*/\n[out:xml];\n(\n  node({{bbox}});\n  <;\n);\nout meta;"
            },
            "MapCSS styling": {
                overpass: "/*\nThis example shows how the data can be styled.\nHere, some common amenities are displayed in \ndifferent colors.\n\nRead more: http://wiki.openstreetmap.org/wiki/Overpass_turbo/MapCSS\n*/\n[out:json];\n\n(\n  node[amenity]({{bbox}});\n  way[amenity]({{bbox}});\n  relation[amenity]({{bbox}});\n);\nout body;\n>;\nout skel qt;\n\n{{style: /* this is the MapCSS stylesheet */\nnode, area\n{ color:gray; fill-color:gray; }\n\nnode[amenity=drinking_water],\nnode[amenity=fountain]\n{ color:blue; fill-color:blue; }\n\nnode[amenity=place_of_worship],\narea[amenity=place_of_worship]\n{ color:grey; fill-color:grey; }\n\nnode[amenity=~/(restaurant|hotel|cafe)/],\narea[amenity=~/(restaurant|hotel|cafe)/]\n{ color:red; fill-color:red; }\n\nnode[amenity=parking],\narea[amenity=parking]\n{ color:yellow; fill-color:yellow; }\n\nnode[amenity=bench]\n{ color:brown; fill-color:brown; }\n\nnode[amenity=~/(kindergarten|school|university)/],\narea[amenity=~/(kindergarten|school|university)/]\n{ color:green; fill-color:green; }\n}}"
            }
        };
        var examples_initial_example = "Drinking Water";

        // global settings object
        var settings = new Settings(
            __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname !== "overpass-turbo" ? __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname : "overpass-ide", // todo: use appname consistently
            34 // settings version number
        );

        /* harmony default export */
        __webpack_exports__["a"] = (settings);

        // map coordinates
        settings.define_setting("coords_lat", "Float", __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].defaultMapView.lat, 1);
        settings.define_setting("coords_lon", "Float", __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].defaultMapView.lon, 1);
        settings.define_setting(
            "coords_zoom",
            "Integer",
            __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].defaultMapView.zoom,
            1
        );
        // saves
        settings.define_setting(
            "code",
            "Object",
            examples[examples_initial_example],
            1
        );
        settings.define_setting("saves", "Object", examples, 1);
        // api server
        settings.define_setting("server", "String", __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].defaultServer, 1);
        // sharing options
        settings.define_setting("share_compression", "String", "auto", 1);
        settings.define_setting("share_include_pos", "Boolean", false, 1);
        // code editor & map view
        settings.define_setting("use_rich_editor", "Boolean", true, 1);
        settings.define_setting("tile_server", "String", __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].defaultTiles, 1);
        settings.define_setting("enable_crosshairs", "Boolean", false, 1);
        // export settings
        settings.define_setting("export_image_scale", "Boolean", true, 1);
        settings.define_setting("export_image_attribution", "Boolean", true, 1);
        // CORS/ajax/etc. settings
        settings.define_setting("force_simple_cors_request", "Boolean", false, 11);
        // background opacity
        settings.define_setting("background_opacity", "Float", 1.0, 13);
        // autorepair message on "no visible data"
        settings.define_setting("no_autorepair", "Boolean", false, 16);
        // resizable panels
        settings.define_setting("editor_width", "String", "", 17);
        // UI language
        settings.define_setting("ui_language", "String", "auto", 19);
        // disable poi-o-matic
        settings.define_setting("disable_poiomatic", "boolean", false, 21);
        // show data stats
        settings.define_setting("show_data_stats", "boolean", true, 21);

        //settings.define_setting(,,,);

        // upgrade callbacks
        settings.define_upgrade_callback(12, function(s) {
            // migrate code and saved examples to new mustache style syntax
            var migrate = function(code) {
                code.overpass = code.overpass.replace(/\(bbox\)/g, "({{bbox}})");
                code.overpass = code.overpass.replace(
                    /<bbox-query\/>/g,
                    "<bbox-query {{bbox}}/>"
                );
                code.overpass = code.overpass.replace(
                    /<coord-query\/>/g,
                    "<coord-query {{center}}/>"
                );
                return code;
            };
            s.code = migrate(s.code);
            for (var ex in s.saves) {
                s.saves[ex] = migrate(s.saves[ex]);
            }
            s.save();
        });
        settings.define_upgrade_callback(18, function(s) {
            // enable "Include current map state in shared links" by default
            s.share_include_pos = true;
            s.save();
        });
        settings.define_upgrade_callback(20, function(s) {
            // update "Mountains in Area" example
            s.saves["Mountains in Area"] = examples["Mountains in Area"];
            s.save();
        });
        settings.define_upgrade_callback(22, function(s) {
            // categorize saved queries
            for (var q in s.saves) {
                if (examples[q]) s.saves[q].type = "example";
                else s.saves[q].type = "saved_query";
            }
            // define some templates
            s.saves["key"] = {
                type: "template",
                parameters: ["key"],
                overpass: '<!--\nthis query looks for nodes, ways and relations \nwith the given key.\n-->\n{{key=???}}\n<osm-script output="json">\n  <union>\n    <query type="node">\n      <has-kv k="{{key}}"/>\n      <bbox-query {{bbox}}/>\n    </query>\n    <query type="way">\n      <has-kv k="{{key}}"/>\n      <bbox-query {{bbox}}/>\n    </query>\n    <query type="relation">\n      <has-kv k="{{key}}"/>\n      <bbox-query {{bbox}}/>\n    </query>\n  </union>\n  <print mode="body"/>\n  <recurse type="down"/>\n  <print mode="skeleton"/>\n</osm-script>'
            };
            s.saves["key-type"] = {
                type: "template",
                parameters: ["key", "type"],
                overpass: '<!--\nthis query looks for nodes, ways or relations \nwith the given key.\n-->\n{{key=???}}\n{{type=???}}\n<osm-script output="json">\n  <query type="{{type}}">\n    <has-kv k="{{key}}"/>\n    <bbox-query {{bbox}}/>\n  </query>\n  <print mode="body"/>\n  <recurse type="down"/>\n  <print mode="skeleton"/>\n</osm-script>'
            };
            s.saves["key-value"] = {
                type: "template",
                parameters: ["key", "value"],
                overpass: '<!--\nthis query looks for nodes, ways and relations \nwith the given key/value combination.\n-->\n{{key=???}}\n{{value=???}}\n<osm-script output="json">\n  <union>\n    <query type="node">\n      <has-kv k="{{key}}" v="{{value}}"/>\n      <bbox-query {{bbox}}/>\n    </query>\n    <query type="way">\n      <has-kv k="{{key}}" v="{{value}}"/>\n      <bbox-query {{bbox}}/>\n    </query>\n    <query type="relation">\n      <has-kv k="{{key}}" v="{{value}}"/>\n      <bbox-query {{bbox}}/>\n    </query>\n  </union>\n  <print mode="body"/>\n  <recurse type="down"/>\n  <print mode="skeleton"/>\n</osm-script>'
            };
            s.saves["key-value-type"] = {
                type: "template",
                parameters: ["key", "value", "type"],
                overpass: '<!--\nthis query looks for nodes, ways or relations \nwith the given key/value combination.\n-->\n{{key=???}}\n{{value=???}}\n{{type=???}}\n<osm-script output="json">\n  <query type="{{type}}">\n    <has-kv k="{{key}}" v="{{value}}"/>\n    <bbox-query {{bbox}}/>\n  </query>\n  <print mode="body"/>\n  <recurse type="down"/>\n  <print mode="skeleton"/>\n</osm-script>'
            };
            s.save();
        });
        settings.define_upgrade_callback(23, function(s) {
            s.saves["type-id"] = {
                type: "template",
                parameters: ["type", "id"],
                overpass: '<!--\nthis query looks for a node, way or relation \nwith the given id.\n-->\n{{type=???}}\n{{id=???}}\n<osm-script output="json">\n  <id-query type="{{type}}" ref="{{id}}"/>\n  <print mode="body"/>\n  <recurse type="down"/>\n  <print mode="skeleton"/>\n</osm-script>'
            };
            s.save();
        });
        settings.define_upgrade_callback(24, function(s) {
            // categorize saved queries
            for (var q in s.saves) {
                if (!s.saves[q].type) s.saves[q].type = "saved_query";
            }
            s.save();
        });
        settings.define_upgrade_callback(25, function(s) {
            // upgrade template description text
            for (var q in s.saves) {
                if (s.saves[q].type == "template") {
                    s.saves[q].overpass = s.saves[q].overpass.replace("<!--\nt", "<!--\nT");
                    s.saves[q].overpass = s.saves[q].overpass.replace(
                        "\n-->",
                        "\nChoose your region and hit the Run button above!\n-->"
                    );
                }
            }
            s.save();
        });
        settings.define_upgrade_callback(27, function(s) {
            // rename "List Areas" to "Where am I?"
            if (!s.saves["Where am I?"]) {
                s.saves["Where am I?"] = s.saves["List Areas"];
                delete s.saves["List Areas"];
            }
            // add mapcss example
            s.saves["MapCSS styling"] = {
                type: "example",
                overpass: examples["MapCSS styling"]
            };
            s.save();
        });
        settings.define_upgrade_callback(28, function(s) {
            // generalize URLs to not explicitly use http protocol
            s.server = s.server.replace(/^http:\/\//, "//");
            s.tile_server = s.tile_server.replace(/^http:\/\//, "//");
            s.save();
        });
        settings.define_upgrade_callback(29, function(s) {
            // convert templates to wizard-syntax
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(s.saves, function(save, name) {
                if (save.type !== "template") return;
                switch (name) {
                    case "key":
                        save.wizard = "{{key}}=*";
                        break;
                    case "key-type":
                        save.wizard = "{{key}}=* and type:{{type}}";
                        break;
                    case "key-value":
                        save.wizard = "{{key}}={{value}}";
                        break;
                    case "key-value-type":
                        save.wizard = "{{key}}={{value}} and type:{{type}}";
                        break;
                    case "type-id":
                        save.wizard = "type:{{type}} and id:{{id}} global";
                        break;
                    default:
                        return;
                }
                delete save.overpass;
            });
            s.save();
        });

        settings.define_upgrade_callback(30, function(s) {
            // add comments for templates
            var chooseAndRun = "\nChoose your region and hit the Run button above!";
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(s.saves, function(save, name) {
                if (save.type !== "template") return;
                switch (name) {
                    case "key":
                        save.comment =
                            "This query looks for nodes, ways and relations \nwith the given key.";
                        save.comment += chooseAndRun;
                        break;
                    case "key-type":
                        save.comment =
                            "This query looks for nodes, ways or relations \nwith the given key.";
                        save.comment += chooseAndRun;
                        break;
                    case "key-value":
                        save.comment =
                            "This query looks for nodes, ways and relations \nwith the given key/value combination.";
                        save.comment += chooseAndRun;
                        break;
                    case "key-value-type":
                        save.comment =
                            "This query looks for nodes, ways or relations \nwith the given key/value combination.";
                        save.comment += chooseAndRun;
                        break;
                    case "type-id":
                        save.comment =
                            "This query looks for a node, way or relation \nwith the given id.";
                        save.comment += "\nTo execute, hit the Run button above!";
                        break;
                    default:
                        return;
                }
                delete save.overpass;
            });
            s.save();
        });

        settings.define_upgrade_callback(31, function(s) {
            // rewrite examples in OverpassQL
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(s.saves, function(save, name) {
                if (save.type !== "example") return;
                switch (name) {
                    case "Drinking Water":
                    case "Cycle Network":
                    case "Mountains in Area":
                    case "Map Call":
                    case "Where am I?":
                    case "MapCSS styling":
                        save.overpass = examples[name].overpass;
                        break;
                    default:
                        return;
                }
            });
            delete s.saves["Drinking Water (Overpass QL)"];
            s.save();
        });

        settings.define_upgrade_callback(32, function(s) {
            // fix typo in query definition
            s.saves["MapCSS styling"].overpass = s.saves[
                "MapCSS styling"
            ].overpass.replace("<;", ">;");
            s.save();
        });

        settings.define_upgrade_callback(33, function(s) {
            s.saves["Attic date query"] = {
                type: "example",
                overpass: [
                    "/* This query loads all objects as of 2016-01-01 */",
                    '[date:"2016-01-01T00:00:00Z"]',
                    "(",
                    "  node({{bbox}});",
                    "  way({{bbox}});",
                    "  relation({{bbox}});",
                    ");",
                    "out body;",
                    ">;",
                    "out skel qt;"
                ].join("\n")
            };
            s.save();
        });

        settings.define_upgrade_callback(34, function(s) {
            s.saves["Attic date query"].overpass = s.saves[
                "Attic date query"
            ].overpass.replace('00:00Z"]\n', '00:00Z"];\n');
        });


        /***/
    }),
    /* 9 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global) {
            var assign = make_assign()
            var create = make_create()
            var trim = make_trim()
            var Global = (typeof window !== 'undefined' ? window : global)

            module.exports = {
                assign: assign,
                create: create,
                trim: trim,
                bind: bind,
                slice: slice,
                each: each,
                map: map,
                pluck: pluck,
                isList: isList,
                isFunction: isFunction,
                isObject: isObject,
                Global: Global
            }

            function make_assign() {
                if (Object.assign) {
                    return Object.assign
                } else {
                    return function shimAssign(obj, props1, props2, etc) {
                        for (var i = 1; i < arguments.length; i++) {
                            each(Object(arguments[i]), function(val, key) {
                                obj[key] = val
                            })
                        }
                        return obj
                    }
                }
            }

            function make_create() {
                if (Object.create) {
                    return function create(obj, assignProps1, assignProps2, etc) {
                        var assignArgsList = slice(arguments, 1)
                        return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
                    }
                } else {
                    function F() {} // eslint-disable-line no-inner-declarations
                    return function create(obj, assignProps1, assignProps2, etc) {
                        var assignArgsList = slice(arguments, 1)
                        F.prototype = obj
                        return assign.apply(this, [new F()].concat(assignArgsList))
                    }
                }
            }

            function make_trim() {
                if (String.prototype.trim) {
                    return function trim(str) {
                        return String.prototype.trim.call(str)
                    }
                } else {
                    return function trim(str) {
                        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
                    }
                }
            }

            function bind(obj, fn) {
                return function() {
                    return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
                }
            }

            function slice(arr, index) {
                return Array.prototype.slice.call(arr, index || 0)
            }

            function each(obj, fn) {
                pluck(obj, function(val, key) {
                    fn(val, key)
                    return false
                })
            }

            function map(obj, fn) {
                var res = (isList(obj) ? [] : {})
                pluck(obj, function(v, k) {
                    res[k] = fn(v, k)
                    return false
                })
                return res
            }

            function pluck(obj, fn) {
                if (isList(obj)) {
                    for (var i = 0; i < obj.length; i++) {
                        if (fn(obj[i], i)) {
                            return obj[i]
                        }
                    }
                } else {
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            if (fn(obj[key], key)) {
                                return obj[key]
                            }
                        }
                    }
                }
            }

            function isList(val) {
                return (val != null && typeof val != 'function' && typeof val.length == 'number')
            }

            function isFunction(val) {
                return val && {}.toString.call(val) === '[object Function]'
            }

            function isObject(val) {
                return val && {}.toString.call(val) === '[object Object]'
            }

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(4)))

        /***/
    }),
    /* 10 */
    /***/
    (function(module, exports) {

        module.exports = function(module) {
            if (!module.webpackPolyfill) {
                module.deprecate = function() {};
                module.paths = [];
                // module.parent = undefined by default
                if (!module.children) module.children = [];
                Object.defineProperty(module, "loaded", {
                    enumerable: true,
                    get: function() {
                        return module.l;
                    }
                });
                Object.defineProperty(module, "id", {
                    enumerable: true,
                    get: function() {
                        return module.i;
                    }
                });
                module.webpackPolyfill = 1;
            }
            return module;
        };


        /***/
    }),
    /* 11 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(2);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(6);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2_leaflet__ = __webpack_require__(3);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2_leaflet___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_leaflet__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3_mapbbcode_src_controls_PopupIcon_js__ = __webpack_require__(26);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3_mapbbcode_src_controls_PopupIcon_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_mapbbcode_src_controls_PopupIcon_js__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_4__OSM4Leaflet__ = __webpack_require__(15);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_5__GeoJsonNoVanish__ = __webpack_require__(14);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_6_polylabel__ = __webpack_require__(32);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_6_polylabel___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_polylabel__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_7__configs__ = __webpack_require__(5);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_8__settings__ = __webpack_require__(8);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_9__overpass__ = __webpack_require__(11);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_10__misc__ = __webpack_require__(7);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_11__jsmapcss__ = __webpack_require__(22);
        // global overpass object




        var overpass = new function() {
            // == private members ==
            var originalGeom2Layer;
            // == public members ==
            this.handlers = {};

            // == private methods ==
            var fire = function() {
                var name = arguments[0];
                if (typeof overpass.handlers[name] != "function") return undefined;
                var handler_args = [];
                for (var i = 1; i < arguments.length; i++) handler_args.push(arguments[i]);
                return overpass.handlers[name].apply({}, handler_args);
            };

            // == public methods ==

            this.init = function() {
                // register mapcss extensions
                /* own MapCSS-extension:
                 * added symbol-* properties
                 * TODO: implement symbol-shape = marker|square?|shield?|...
                 */
                __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].PointStyle.prototype.properties.push(
                    "symbol_shape",
                    "symbol_size",
                    "symbol_stroke_width",
                    "symbol_stroke_color",
                    "symbol_stroke_opacity",
                    "symbol_fill_color",
                    "symbol_fill_opacity"
                );
                __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].PointStyle.prototype.symbol_shape = "";
                __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].PointStyle.prototype.symbol_size = NaN;
                __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].PointStyle.prototype.symbol_stroke_width = NaN;
                __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].PointStyle.prototype.symbol_stroke_color = null;
                __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].PointStyle.prototype.symbol_stroke_opacity = NaN;
                __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].PointStyle.prototype.symbol_fill_color = null;
                __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].PointStyle.prototype.symbol_fill_opacity = NaN;

                // prepare some Leaflet hacks
                originalGeom2Layer = __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.GeoJSON.geometryToLayer;
            };

            // updates the map
            this.run_query = function(
                query,
                query_lang,
                cache,
                shouldCacheOnly,
                server,
                user_mapcss
            ) {
                server = server || __WEBPACK_IMPORTED_MODULE_7__configs__["a" /* default */ ].defaultServer;
                // 1. get overpass json data
                if (query_lang == "xml") {
                    // beautify not well formed xml queries (workaround for non matching error lines)
                    if (!query.match(/^<\?xml/)) {
                        if (!query.match(/<osm-script/))
                            query = "<osm-script>" + query + "</osm-script>";
                        query = '<?xml version="1.0" encoding="UTF-8"?>' + query;
                    }
                }
                fire("onProgress", "calling Overpass API interpreter", function(callback) {
                    // kill the query on abort
                    overpass.ajax_request.abort();
                    // try to abort queries via kill_my_queries
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.get(server + "kill_my_queries").success(callback).error(function() {
                        console.log("Warning: failed to kill query.");
                        callback();
                    });
                });
                var request_headers = {};
                var additional_get_data = "";
                if (__WEBPACK_IMPORTED_MODULE_8__settings__["a" /* default */ ].force_simple_cors_request) {
                    additional_get_data = "?X-Requested-With=" + __WEBPACK_IMPORTED_MODULE_7__configs__["a" /* default */ ].appname;
                } else {
                    request_headers["X-Requested-With"] = __WEBPACK_IMPORTED_MODULE_7__configs__["a" /* default */ ].appname;
                }
                var onSuccessCb = function(data, textStatus, jqXHR) {
                    //textStatus is not needed in the successCallback, don't cache it
                    if (cache) cache[query] = [data, undefined, jqXHR];

                    var data_amount = jqXHR.responseText.length;
                    var data_txt;
                    // round amount of data
                    var scale = Math.floor(Math.log(data_amount) / Math.log(10));
                    data_amount =
                        Math.round(data_amount / Math.pow(10, scale)) * Math.pow(10, scale);
                    if (data_amount < 1000) data_txt = data_amount + " bytes";
                    else if (data_amount < 1000000) data_txt = data_amount / 1000 + " kB";
                    else data_txt = data_amount / 1000000 + " MB";
                    fire("onProgress", "received about " + data_txt + " of data");
                    fire(
                        "onDataRecieved",
                        data_amount,
                        data_txt,
                        function() {
                            // abort callback
                            fire("onAbort");
                            return;
                        },
                        function() {
                            // continue callback
                            // different cases of loaded data: json data, xml data or error message?
                            var data_mode = null;
                            var geojson;
                            var stats = {};
                            fire("onProgress", "parsing data");
                            setTimeout(function() {
                                // hacky firefox hack :( (it is not properly detecting json from the content-type header)
                                if (typeof data == "string" && data[0] == "{") {
                                    // if the data is a string, but looks more like a json object
                                    try {
                                        data = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.parseJSON(data);
                                    } catch (e) {}
                                }
                                // hacky firefox hack :( (it is not properly detecting xml from the content-type header)
                                if (
                                    typeof data == "string" &&
                                    data.substr(0, 5) == "<?xml" &&
                                    jqXHR.status === 200 &&
                                    !(jqXHR.getResponseHeader("content-type") || "")
                                    .match(/text\/html/) &&
                                    data.match(/<osm/)
                                ) {
                                    try {
                                        jqXHR.responseXML = data;
                                        data = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.parseXML(data);
                                    } catch (e) {
                                        delete jqXHR.responseXML;
                                    }
                                }
                                if (
                                    typeof data == "string" ||
                                    (typeof data == "object" &&
                                        jqXHR.responseXML &&
                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()("remark", data).length > 0) ||
                                    (typeof data == "object" && data.remark && data.remark.length > 0)
                                ) {
                                    // maybe an error message
                                    data_mode = "unknown";
                                    var is_error = false;
                                    is_error =
                                        is_error ||
                                        (typeof data == "string" && // html coded error messages
                                            data.indexOf("Error") != -1 &&
                                            data.indexOf("<script") == -1 && // detect output="custom" content
                                            data.indexOf("<h2>Public Transport Stops</h2>") == -1); // detect output="popup" content
                                    is_error =
                                        is_error ||
                                        (typeof data == "object" &&
                                            jqXHR.responseXML &&
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("remark", data).length > 0);
                                    is_error =
                                        is_error ||
                                        (typeof data == "object" &&
                                            data.remark &&
                                            data.remark.length > 0);
                                    if (is_error) {
                                        // this really looks like an error message, so lets open an additional modal error message
                                        var errmsg = "?";
                                        if (typeof data == "string") {
                                            errmsg = data
                                                .replace(/([\S\s]*<body>)/, "")
                                                .replace(/(<\/body>[\S\s]*)/, "");
                                            // do some magic cleanup for better legibility of the actual error message
                                            errmsg = errmsg.replace(
                                                /<p>The data included in this document is from .*?<\/p>/,
                                                ""
                                            );
                                            var fullerrmsg = errmsg;
                                            errmsg = errmsg.replace(
                                                /open64: 0 Success \/osm3s_v\d+\.\d+\.\d+_osm_base (\w+::)*\w+\./,
                                                "[]"
                                            );
                                        }
                                        if (typeof data == "object" && jqXHR.responseXML)
                                            errmsg = "<p>" + __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.trim(__WEBPACK_IMPORTED_MODULE_0_jquery___default()("remark", data).text()) + "</p>";
                                        if (typeof data == "object" && data.remark)
                                            errmsg = "<p>" + __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.trim(data.remark) + "</p>";
                                        console.log("Overpass API error", fullerrmsg || errmsg); // write (full) error message to console for easier debugging
                                        fire("onQueryError", errmsg);
                                        data_mode = "error";
                                        // parse errors and highlight error lines
                                        var errlines = errmsg.match(/line \d+:/g) || [];
                                        for (var i = 0; i < errlines.length; i++) {
                                            fire("onQueryErrorLine", 1 * errlines[i].match(/\d+/)[0]);
                                        }
                                    }
                                    // the html error message returned by overpass API looks goods also in xml mode ^^
                                    overpass.resultType = "error";
                                    data = {
                                        elements: []
                                    };
                                    overpass.timestamp = undefined;
                                    overpass.timestampAreas = undefined;
                                    overpass.copyright = undefined;
                                    stats.data = {
                                        nodes: 0,
                                        ways: 0,
                                        relations: 0,
                                        areas: 0
                                    };
                                    //geojson = [{features:[]}, {features:[]}, {features:[]}];
                                } else if (typeof data == "object" && jqXHR.responseXML) {
                                    // xml data
                                    overpass.resultType = "xml";
                                    data_mode = "xml";
                                    overpass.timestamp = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm > meta:first-of-type", data).attr(
                                        "osm_base"
                                    );
                                    overpass.timestampAreas = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                        "osm > meta:first-of-type",
                                        data
                                    ).attr("areas");
                                    overpass.copyright = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm > note:first-of-type", data).text();
                                    stats.data = {
                                        nodes: __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm > node", data).length,
                                        ways: __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm > way", data).length,
                                        relations: __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm > relation", data).length,
                                        areas: __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm > area", data).length
                                    };
                                    //// convert to geoJSON
                                    //geojson = overpass.overpassXML2geoJSON(data);
                                } else {
                                    // maybe json data
                                    overpass.resultType = "javascript";
                                    data_mode = "json";
                                    overpass.timestamp = data.osm3s.timestamp_osm_base;
                                    overpass.timestampAreas = data.osm3s.timestamp_areas_base;
                                    overpass.copyright = data.osm3s.copyright;
                                    stats.data = {
                                        nodes: __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.grep(data.elements, function(d) {
                                            return d.type == "node";
                                        }).length,
                                        ways: __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.grep(data.elements, function(d) {
                                            return d.type == "way";
                                        }).length,
                                        relations: __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.grep(data.elements, function(d) {
                                            return d.type == "relation";
                                        }).length,
                                        areas: __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.grep(data.elements, function(d) {
                                            return d.type == "area";
                                        }).length
                                    };
                                    //// convert to geoJSON
                                    //geojson = overpass.overpassJSON2geoJSON(data);
                                }

                                //fire("onProgress", "applying styles"); // doesn't correspond to what's really going on. (the whole code could in principle be put further up and called "preparing mapcss styles" or something, but it's probably not worth the effort)
                                setTimeout(function() {
                                    // test user supplied mapcss stylesheet
                                    try {
                                        var dummy_mapcss = new __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].RuleSet();
                                        dummy_mapcss.parseCSS(user_mapcss);
                                        try {
                                            dummy_mapcss.getStyles({
                                                    isSubject: function() {
                                                        return true;
                                                    },
                                                    getParentObjects: function() {
                                                        return [];
                                                    }
                                                }, [],
                                                18
                                            );
                                        } catch (e) {
                                            throw new Error("MapCSS runtime error.");
                                        }
                                    } catch (e) {
                                        user_mapcss = "";
                                        fire("onStyleError", "<p>" + e.message + "</p>");
                                    }
                                    var mapcss = new __WEBPACK_IMPORTED_MODULE_11__jsmapcss__["a" /* default */ ].RuleSet();
                                    mapcss.parseCSS(
                                        "" +
                                        "node, way, relation {color:black; fill-color:black; opacity:1; fill-opacity: 1; width:10;} \n" +
                                        // point features
                                        "node {color:#03f; width:2; opacity:0.7; fill-color:#fc0; fill-opacity:0.3;} \n" +
                                        // line features
                                        "line {color:#03f; width:5; opacity:0.6;} \n" +
                                        // polygon features
                                        "area {color:#03f; width:2; opacity:0.7; fill-color:#fc0; fill-opacity:0.3;} \n" +
                                        // style modifications
                                        // objects in relations
                                        "relation node, relation way, relation {color:#d0f;} \n" +
                                        // tainted objects
                                        "way:tainted, relation:tainted {dashes:5,8;} \n" +
                                        // placeholder points
                                        "way:placeholder, relation:placeholder {fill-color:#f22;} \n" +
                                        // highlighted features
                                        "node:active, way:active, relation:active {color:#f50; fill-color:#f50;} \n" +
                                        // user supplied mapcss
                                        user_mapcss
                                    );
                                    var get_feature_style = function(feature, highlight) {
                                        function hasInterestingTags(props) {
                                            // this checks if the node has any tags other than "created_by"
                                            return (
                                                props &&
                                                props.tags &&
                                                (function(o) {
                                                    for (var k in o)
                                                        if (k != "created_by" && k != "source") return true;
                                                    return false;
                                                })(props.tags)
                                            );
                                        }
                                        var s = mapcss.getStyles({
                                                isSubject: function(subject) {
                                                    switch (subject) {
                                                        case "node":
                                                            return (
                                                                feature.properties.type == "node" ||
                                                                feature.geometry.type == "Point"
                                                            );
                                                        case "area":
                                                            return (
                                                                feature.geometry.type == "Polygon" ||
                                                                feature.geometry.type == "MultiPolygon"
                                                            );
                                                        case "line":
                                                            return (
                                                                feature.geometry.type == "LineString" ||
                                                                feature.geometry.type == "MultiLineString"
                                                            );
                                                        case "way":
                                                            return feature.properties.type == "way";
                                                        case "relation":
                                                            return feature.properties.type == "relation";
                                                    }
                                                    return false;
                                                },
                                                getParentObjects: function() {
                                                    if (feature.properties.relations.length == 0) return [];
                                                    else
                                                        return feature.properties.relations.map(function(rel) {
                                                            return {
                                                                tags: rel.reltags,
                                                                isSubject: function(subject) {
                                                                    return (
                                                                        subject == "relation" ||
                                                                        (subject == "area" &&
                                                                            rel.reltags.type == "multipolyon")
                                                                    );
                                                                },
                                                                getParentObjects: function() {
                                                                    return [];
                                                                }
                                                            };
                                                        });
                                                }
                                            },
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(
                                                feature.properties && feature.properties.tainted ?
                                                {
                                                    ":tainted": true
                                                } :
                                                {},
                                                feature.properties && feature.properties.geometry ?
                                                {
                                                    ":placeholder": true
                                                } :
                                                {},
                                                feature.is_placeholder ? {
                                                    ":placeholder": true
                                                } : {},
                                                hasInterestingTags(feature.properties) ?
                                                {
                                                    ":tagged": true
                                                } :
                                                {
                                                    ":untagged": true
                                                },
                                                highlight ? {
                                                    ":active": true
                                                } : {},
                                                feature.properties.tags
                                            ),
                                            18 /*restyle on zoom??*/
                                        );
                                        return s;
                                    };

                                    __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.GeoJSON.geometryToLayer = function(
                                        feature,
                                        pointToLayer /*,*/
                                    ) {
                                        var s = get_feature_style(feature);
                                        var stl = s.textStyles["default"] || {};
                                        var layer = originalGeom2Layer.apply(this, arguments);

                                        function getFeatureLabelPosition(feature) {
                                            var latlng;
                                            switch (feature.geometry.type) {
                                                case "Point":
                                                    latlng = layer.getLatLng();
                                                    break;
                                                case "MultiPolygon":
                                                    var labelPolygon,
                                                        bestVal = -Infinity;
                                                    layer.getLayers().forEach(function(layer) {
                                                        var size = layer
                                                            .getBounds()
                                                            .getNorthEast()
                                                            .distanceTo(layer.getBounds().getSouthWest());
                                                        if (size > bestVal) {
                                                            labelPolygon = layer;
                                                            bestVal = size;
                                                        }
                                                    });
                                                case "Polygon":
                                                    if (!labelPolygon) labelPolygon = layer;
                                                    latlng = __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.CRS.EPSG3857.pointToLatLng(
                                                        __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.point(
                                                            __WEBPACK_IMPORTED_MODULE_6_polylabel___default()(
                                                                [labelPolygon.getLatLngs()]
                                                                .concat(labelPolygon._holes)
                                                                .map(function(ring) {
                                                                    return ring
                                                                        .map(function(latlng) {
                                                                            return __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.CRS.EPSG3857.latLngToPoint(
                                                                                latlng,
                                                                                20
                                                                            );
                                                                        })
                                                                        .map(function(p) {
                                                                            return [p.x, p.y];
                                                                        });
                                                                })
                                                            )
                                                        ),
                                                        20
                                                    );
                                                    break;
                                                case "MultiLineString":
                                                    var labelLayer,
                                                        bestVal = -Infinity;
                                                    layer.getLayers().forEach(function(layer) {
                                                        var size = layer
                                                            .getBounds()
                                                            .getNorthEast()
                                                            .distanceTo(layer.getBounds().getSouthWest());
                                                        if (size > bestVal) {
                                                            labelLayer = layer;
                                                            bestVal = size;
                                                        }
                                                    });
                                                case "LineString":
                                                    if (!labelLayer) labelLayer = layer;
                                                    var latlngs = labelLayer.getLatLngs();
                                                    if (latlngs.length % 2 == 1)
                                                        latlng = latlngs[Math.floor(latlngs.length / 2)];
                                                    else {
                                                        var latlng1 = latlngs[Math.floor(latlngs.length / 2)],
                                                            latlng2 = latlngs[Math.floor(latlngs.length / 2 - 1)];
                                                        latlng = __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.latLng([
                                                            (latlng1.lat + latlng2.lat) / 2,
                                                            (latlng1.lng + latlng2.lng) / 2
                                                        ]);
                                                    }
                                                    break;
                                                default:
                                                    // todo: multipoints
                                                    console.error(
                                                        "unsupported geometry type while constructing text label:",
                                                        feature.geometry.type
                                                    );
                                            }
                                            return latlng;
                                        }
                                        var text;
                                        if (
                                            (stl["text"] && stl.evals["text"] && (text = stl["text"])) ||
                                            (stl["text"] && (text = feature.properties.tags[stl["text"]]))
                                        ) {
                                            var textIcon = new __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.PopupIcon(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(text), {
                                                color: "rgba(255,255,255,0.8)"
                                            });
                                            var textmarker = new __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.Marker(
                                                getFeatureLabelPosition(feature), {
                                                    icon: textIcon
                                                }
                                            );
                                            return new __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.FeatureGroup(__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.compact([layer, textmarker]));
                                        }
                                        return layer;
                                    };
                                    //overpass.geojsonLayer =
                                    //new L.GeoJSON(null, {
                                    //new L.GeoJsonNoVanish(null, {
                                    overpass.osmLayer = new __WEBPACK_IMPORTED_MODULE_4__OSM4Leaflet__["a" /* default */ ](null, {
                                        afterParse: function() {
                                            fire("onProgress", "rendering geoJSON");
                                        },
                                        baseLayerClass: __WEBPACK_IMPORTED_MODULE_8__settings__["a" /* default */ ].disable_poiomatic ?
                                            __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.GeoJSON :
                                            __WEBPACK_IMPORTED_MODULE_5__GeoJsonNoVanish__["a" /* default */ ],
                                        baseLayerOptions: {
                                            threshold: 9 * Math.sqrt(2) * 2,
                                            compress: function(feature) {
                                                return true;
                                            },
                                            style: function(feature, highlight) {
                                                var stl = {};
                                                var s = get_feature_style(feature, highlight);
                                                // apply mapcss styles
                                                function get_property(styles, properties) {
                                                    for (var i = properties.length - 1; i >= 0; i--)
                                                        if (styles[properties[i]] !== undefined)
                                                            return styles[properties[i]];
                                                    return undefined;
                                                }
                                                switch (feature.geometry.type) {
                                                    case "Point":
                                                        var styles = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({},
                                                            s.shapeStyles["default"],
                                                            s.pointStyles["default"]
                                                        );
                                                        var p = get_property(styles, [
                                                            "color",
                                                            "symbol_stroke_color"
                                                        ]);
                                                        if (p !== undefined) stl.color = p;
                                                        var p = get_property(styles, [
                                                            "opacity",
                                                            "symbol_stroke_opacity"
                                                        ]);
                                                        if (p !== undefined) stl.opacity = p;
                                                        var p = get_property(styles, [
                                                            "width",
                                                            "symbol_stroke_width"
                                                        ]);
                                                        if (p !== undefined) stl.weight = p;
                                                        var p = get_property(styles, [
                                                            "fill_color",
                                                            "symbol_fill_color"
                                                        ]);
                                                        if (p !== undefined) stl.fillColor = p;
                                                        var p = get_property(styles, [
                                                            "fill_opacity",
                                                            "symbol_fill_opacity"
                                                        ]);
                                                        if (p !== undefined) stl.fillOpacity = p;
                                                        var p = get_property(styles, ["dashes"]);
                                                        if (p !== undefined) stl.dashArray = p.join(",");
                                                        break;
                                                    case "LineString":
                                                    case "MultiLineString":
                                                        var styles = s.shapeStyles["default"];
                                                        var p = get_property(styles, ["color"]);
                                                        if (p !== undefined) stl.color = p;
                                                        var p = get_property(styles, ["opacity"]);
                                                        if (p !== undefined) stl.opacity = p;
                                                        var p = get_property(styles, ["width"]);
                                                        if (p !== undefined) stl.weight = p;
                                                        var p = get_property(styles, ["offset"]);
                                                        if (p !== undefined) stl.offset = -p; // MapCSS and PolylineOffset definitions use different signs
                                                        var p = get_property(styles, ["dashes"]);
                                                        if (p !== undefined) stl.dashArray = p.join(",");
                                                        break;
                                                    case "Polygon":
                                                    case "MultiPolygon":
                                                        var styles = s.shapeStyles["default"];
                                                        var p = get_property(styles, ["color", "casing_color"]);
                                                        if (p !== undefined) stl.color = p;
                                                        var p = get_property(styles, [
                                                            "opacity",
                                                            "casing_opacity"
                                                        ]);
                                                        if (p !== undefined) stl.opacity = p;
                                                        var p = get_property(styles, ["width", "casing_width"]);
                                                        if (p !== undefined) stl.weight = p;
                                                        var p = get_property(styles, ["fill_color"]);
                                                        if (p !== undefined) stl.fillColor = p;
                                                        var p = get_property(styles, ["fill_opacity"]);
                                                        if (p !== undefined) stl.fillOpacity = p;
                                                        var p = get_property(styles, ["dashes"]);
                                                        if (p !== undefined) stl.dashArray = p.join(",");
                                                        break;
                                                }
                                                // todo: more style properties? linecap, linejoin?
                                                // return style object
                                                return stl;
                                            },
                                            pointToLayer: function(feature, latlng) {
                                                // todo: labels!
                                                var s = get_feature_style(feature);
                                                var stl = s.pointStyles["default"] || {};
                                                var text;
                                                var marker;
                                                if (stl["icon_image"]) {
                                                    // return image marker
                                                    var iconUrl = stl["icon_image"].match(
                                                        /^url\(['"](.*)['"]\)$/
                                                    )[1];
                                                    var iconSize;
                                                    if (stl["icon_width"])
                                                        iconSize = [stl["icon_width"], stl["icon_width"]];
                                                    if (stl["icon_height"] && iconSize)
                                                        iconSize[1] = stl["icon_height"];
                                                    var icon = new __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.Icon({
                                                        iconUrl: iconUrl,
                                                        iconSize: iconSize
                                                        // todo: anchor, shadow?, ...
                                                    });
                                                    marker = new __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.Marker(latlng, {
                                                        icon: icon
                                                    });
                                                } else if (stl["symbol_shape"] == "none") {
                                                    marker = new __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.Marker(latlng, {
                                                        icon: new __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.DivIcon({
                                                            iconSize: [0, 0],
                                                            html: "",
                                                            className: "leaflet-dummy-none-marker"
                                                        })
                                                    });
                                                } else if (
                                                    stl["symbol_shape"] == "circle" ||
                                                    true /*if nothing else is specified*/
                                                ) {
                                                    // return circle marker
                                                    var r = stl["symbol_size"] || 9;
                                                    marker = new __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.CircleMarker(latlng, {
                                                        radius: r
                                                    });
                                                }
                                                return marker;
                                            },
                                            onEachFeature: function(feature, layer) {
                                                layer.on("click", function(e) {
                                                    var popup = "";
                                                    if (feature.properties.type == "node")
                                                        popup +=
                                                        "<h2>Node <a href='//www.openstreetmap.org/node/" +
                                                        feature.properties.id +
                                                        "' target='_blank'>" +
                                                        feature.properties.id +
                                                        "</a></h2>";
                                                    else if (feature.properties.type == "way")
                                                        popup +=
                                                        "<h2>Way <a href='//www.openstreetmap.org/way/" +
                                                        feature.properties.id +
                                                        "' target='_blank'>" +
                                                        feature.properties.id +
                                                        "</a></h2>";
                                                    else if (feature.properties.type == "relation")
                                                        popup +=
                                                        "<h2>Relation <a href='//www.openstreetmap.org/relation/" +
                                                        feature.properties.id +
                                                        "' target='_blank'>" +
                                                        feature.properties.id +
                                                        "</a></h2>";
                                                    else
                                                        popup +=
                                                        "<h2>" +
                                                        feature.properties.type +
                                                        " #" +
                                                        feature.properties.id +
                                                        "</h2>";
                                                    if (
                                                        feature.properties &&
                                                        feature.properties.tags &&
                                                        !__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.isEmptyObject(feature.properties.tags)
                                                    ) {
                                                        popup += '<h3>Tags:</h3><ul class="plain">';
                                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(feature.properties.tags, function(k, v) {
                                                            k = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(k); // escaping strings!
                                                            v = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(v);
                                                            // hyperlinks for http,https and ftp URLs
                                                            var urls;
                                                            if (
                                                                (urls = v.match(
                                                                    /\b((?:(https?|ftp):\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/gi
                                                                ))
                                                            ) {
                                                                urls.forEach(function(url) {
                                                                    var href = url.match(/^(https?|ftp):\/\//) ?
                                                                        url :
                                                                        "http://" + url;
                                                                    v = v.replace(
                                                                        url,
                                                                        '<a href="' +
                                                                        href +
                                                                        '" target="_blank">' +
                                                                        url +
                                                                        "</a>"
                                                                    );
                                                                });
                                                            } else {
                                                                // hyperlinks for email adresses
                                                                v = v.replace(
                                                                    /(([^\s()<>]+)@([^\s()<>]+[^\s`!()\[\]{};:'".,<>?]))/g,
                                                                    '<a href="mailto:$1" target="_blank">$1</a>'
                                                                );
                                                            }
                                                            // hyperlinks for wikipedia entries
                                                            var wiki_lang, wiki_page;
                                                            if (
                                                                ((wiki_lang = k.match(/^wikipedia\:(.*)$/)) &&
                                                                    (wiki_page = v)) ||
                                                                (k == "wikipedia" &&
                                                                    (wiki_lang = v.match(/^([a-zA-Z]+)\:(.*)$/)) &&
                                                                    (wiki_page = wiki_lang[2]))
                                                            )
                                                                v =
                                                                '<a href="//' +
                                                                wiki_lang[1] +
                                                                ".wikipedia.org/wiki/" +
                                                                encodeURIComponent(wiki_page) +
                                                                '" target="_blank">' +
                                                                v +
                                                                "</a>";
                                                            // hyperlinks for wikidata entries
                                                            var wikidata_page;
                                                            if (
                                                                (k == "wikidata" &&
                                                                    (wikidata_page = v.match(/^Q[0-9]+$/))) ||
                                                                (k.match(/:wikidata$/) &&
                                                                    (wikidata_page = v.match(/^Q[0-9]+$/)))
                                                            )
                                                                v =
                                                                '<a href="//www.wikidata.org/wiki/' +
                                                                encodeURIComponent(wikidata_page[0]) +
                                                                '" target="_blank">' +
                                                                v +
                                                                "</a>";
                                                            // hyperlinks for wikimedia-commons entries
                                                            var wikimediacommons_page;
                                                            if (
                                                                k == "wikimedia_commons" &&
                                                                (wikimediacommons_page = v.match(
                                                                    /^(Category|File):(.*)/
                                                                ))
                                                            )
                                                                v =
                                                                '<a href="//commons.wikimedia.org/wiki/' +
                                                                wikimediacommons_page[1] +
                                                                ":" +
                                                                encodeURIComponent(wikimediacommons_page[2]) +
                                                                '" target="_blank">' +
                                                                v +
                                                                "</a>";
                                                            // hyperlinks for mapillary entries
                                                            var mapillary_page;
                                                            if (
                                                                (k == "mapillary" &&
                                                                    (mapillary_page = v.match(/^[-a-zA-Z0-9]+$/))) ||
                                                                (k.match(/^mapillary:/) &&
                                                                    (mapillary_page = v.match(/^[-a-zA-Z0-9]+$/)))
                                                            )
                                                                v =
                                                                '<a href="https://www.mapillary.com/app?focus=photo&pKey=' +
                                                                mapillary_page[0] +
                                                                '" target="_blank">' +
                                                                v +
                                                                "</a>";

                                                            popup += "<li>" + k + "=" + v + "</li>";
                                                        });
                                                        popup += "</ul>";
                                                    }
                                                    if (
                                                        feature.properties &&
                                                        feature.properties.relations &&
                                                        !__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.isEmptyObject(feature.properties.relations)
                                                    ) {
                                                        popup += '<h3>Relations:</h3><ul class="plain">';
                                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(feature.properties.relations, function(k, v) {
                                                            popup +=
                                                                "<li><a href='//www.openstreetmap.org/relation/" +
                                                                v["rel"] +
                                                                "' target='_blank'>" +
                                                                v["rel"] +
                                                                "</a>";
                                                            if (
                                                                v.reltags &&
                                                                (v.reltags.name || v.reltags.ref || v.reltags.type)
                                                            )
                                                                popup +=
                                                                " <i>" +
                                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.trim(
                                                                    (v.reltags.type ?
                                                                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(v.reltags.type) + " " :
                                                                        "") +
                                                                    (v.reltags.ref ?
                                                                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(v.reltags.ref) + " " :
                                                                        "") +
                                                                    (v.reltags.name ?
                                                                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(v.reltags.name) + " " :
                                                                        "")
                                                                ) +
                                                                "</i>";
                                                            if (v["role"])
                                                                popup +=
                                                                " as <i>" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(v["role"]) + "</i>";
                                                            popup += "</li>";
                                                        });
                                                        popup += "</ul>";
                                                    }
                                                    if (
                                                        feature.properties &&
                                                        feature.properties.meta &&
                                                        !__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.isEmptyObject(feature.properties.meta)
                                                    ) {
                                                        popup += '<h3>Meta:</h3><ul class="plain">';
                                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(feature.properties.meta, function(k, v) {
                                                            k = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(k);
                                                            v = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__misc__["a" /* htmlentities */ ])(v);
                                                            if (k == "user")
                                                                v =
                                                                '<a href="//www.openstreetmap.org/user/' +
                                                                encodeURIComponent(v) +
                                                                '" target="_blank">' +
                                                                v +
                                                                "</a>";
                                                            if (k == "changeset")
                                                                v =
                                                                '<a href="//www.openstreetmap.org/changeset/' +
                                                                encodeURIComponent(v) +
                                                                '" target="_blank">' +
                                                                v +
                                                                "</a>";
                                                            popup += "<li>" + k + "=" + v + "</li>";
                                                        });
                                                        popup += "</ul>";
                                                    }
                                                    if (feature.geometry.type == "Point")
                                                        popup +=
                                                        "<h3>Coordinates:</h3><p>" +
                                                        feature.geometry.coordinates[1] +
                                                        " / " +
                                                        feature.geometry.coordinates[0] +
                                                        " <small>(lat/lon)</small></p>";
                                                    if (
                                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.inArray(feature.geometry.type, [
                                                            "LineString",
                                                            "Polygon",
                                                            "MultiPolygon"
                                                        ]) != -1
                                                    ) {
                                                        if (
                                                            feature.properties &&
                                                            feature.properties.tainted == true
                                                        ) {
                                                            popup +=
                                                                "<p><strong>Attention: incomplete geometry (e.g. some nodes missing)</strong></p>";
                                                        }
                                                    }
                                                    var latlng;
                                                    if (typeof e.target.getLatLng == "function")
                                                        latlng = e.target.getLatLng(); // node-ish features (circles, markers, icons, placeholders)
                                                    else latlng = e.latlng; // all other (lines, polygons, multipolygons)
                                                    var p = __WEBPACK_IMPORTED_MODULE_2_leaflet___default.a.popup({
                                                            maxHeight: 600
                                                        }, this)
                                                        .setLatLng(latlng)
                                                        .setContent(popup);
                                                    p.layer = layer;
                                                    fire("onPopupReady", p);
                                                });
                                            }
                                        }
                                    });

                                    setTimeout(function() {
                                        overpass.osmLayer.addData(data, function() {
                                            // save geojson and raw data
                                            geojson = overpass.osmLayer.getGeoJSON();
                                            overpass.geojson = geojson;
                                            overpass.data = data;

                                            // calc stats
                                            stats.geojson = {
                                                polys: 0,
                                                lines: 0,
                                                pois: 0
                                            };
                                            for (var i = 0; i < geojson.features.length; i++)
                                                switch (geojson.features[i].geometry.type) {
                                                    case "Polygon":
                                                    case "MultiPolygon":
                                                        stats.geojson.polys++;
                                                        break;
                                                    case "LineString":
                                                    case "MultiLineString":
                                                        stats.geojson.lines++;
                                                        break;
                                                    case "Point":
                                                    case "MultiPoint":
                                                        stats.geojson.pois++;
                                                        break;
                                                }
                                            overpass.stats = stats;

                                            if (!shouldCacheOnly) fire("onGeoJsonReady");

                                            // print raw data
                                            fire("onProgress", "printing raw data");
                                            setTimeout(function() {
                                                overpass.resultText = jqXHR.responseText;
                                                fire("onRawDataPresent");

                                                // todo: the following would profit from some unit testing
                                                // this is needed for auto-tab-switching: if there is only non map-visible data, show it directly
                                                if (geojson.features.length === 0) {
                                                    // no visible data
                                                    // switch only if there is some unplottable data in the returned json/xml.
                                                    var empty_msg;
                                                    if (
                                                        (data_mode == "json" && data.elements.length > 0) ||
                                                        (data_mode == "xml" &&
                                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm", data).children().not("note,meta,bounds")
                                                            .length > 0)
                                                    ) {
                                                        // check for "only areas returned"
                                                        if (
                                                            (data_mode == "json" &&
                                                                __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.all(data.elements, {
                                                                    type: "area"
                                                                })) ||
                                                            (data_mode == "xml" &&
                                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm", data)
                                                                .children()
                                                                .not("note,meta,bounds,area").length == 0)
                                                        )
                                                            empty_msg = "only areas returned";
                                                        else if (
                                                            (data_mode == "json" &&
                                                                __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.some(data.elements, {
                                                                    type: "node"
                                                                })) ||
                                                            (data_mode == "xml" &&
                                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm", data).children().filter("node").length > 0)
                                                        )
                                                            // check for "ids_only" or "tags" on nodes
                                                            empty_msg = "no coordinates returned";
                                                        else if (
                                                            (data_mode == "json" &&
                                                                __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.some(data.elements, {
                                                                    type: "way"
                                                                }) &&
                                                                !__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.some(
                                                                    __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.filter(data.elements, {
                                                                        type: "way"
                                                                    }),
                                                                    "nodes"
                                                                )) ||
                                                            (data_mode == "xml" &&
                                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm", data).children().filter("way").length >
                                                                0 &&
                                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm", data)
                                                                .children()
                                                                .filter("way")
                                                                .children()
                                                                .filter("nd").length == 0)
                                                        )
                                                            // check for "ids_only" or "tags" on ways
                                                            empty_msg = "no coordinates returned";
                                                        else if (
                                                            (data_mode == "json" &&
                                                                __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.some(data.elements, {
                                                                    type: "relation"
                                                                }) &&
                                                                !__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.some(
                                                                    __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.filter(data.elements, {
                                                                        type: "relation"
                                                                    }),
                                                                    "members"
                                                                )) ||
                                                            (data_mode == "xml" &&
                                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm", data).children().filter("relation")
                                                                .length > 0 &&
                                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm", data)
                                                                .children()
                                                                .filter("relation")
                                                                .children()
                                                                .filter("member").length == 0)
                                                        )
                                                            // check for "ids_only" or "tags" on relations
                                                            empty_msg = "no coordinates returned";
                                                        else empty_msg = "no visible data";
                                                    } else if (data_mode == "error") {
                                                        empty_msg = "an error occured";
                                                    } else if (data_mode == "unknown") {
                                                        empty_msg = "unstructured data returned";
                                                    } else {
                                                        empty_msg = "received empty dataset";
                                                    }
                                                    // show why there is an empty map
                                                    fire("onEmptyMap", empty_msg, data_mode);
                                                }

                                                // closing wait spinner
                                                fire("onDone");
                                            }, 1); // end setTimeout
                                        });
                                    }, 1); // end setTimeout
                                }, 1); // end setTimeout
                            }, 1); // end setTimeout
                        }
                    );
                };
                if (cache && cache.hasOwnProperty(query)) {
                    onSuccessCb.apply(this, cache[query]);
                } else {
                    overpass.ajax_request = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.ajax(
                        server + "interpreter" + additional_get_data, {
                            type: "POST",
                            data: {
                                data: query
                            },
                            headers: request_headers,
                            success: onSuccessCb,
                            error: function(jqXHR, textStatus, errorThrown) {
                                if (textStatus == "abort") return; // ignore aborted queries.
                                fire("onProgress", "error during ajax call");
                                if (
                                    jqXHR.status == 400 ||
                                    jqXHR.status == 504 ||
                                    jqXHR.status == 429
                                ) {
                                    // todo: handle those in a separate routine
                                    // pass 400 Bad Request errors to the standard result parser, as this is most likely going to be a syntax error in the query.
                                    this.success(jqXHR.responseText, textStatus, jqXHR);
                                    return;
                                }
                                overpass.resultText = jqXHR.resultText;
                                var errmsg = "";
                                if (jqXHR.state() == "rejected")
                                    errmsg +=
                                    "<p>Request rejected. (e.g. server not found, request blocked by browser addon, request redirected, internal server errors, etc.)</p>";
                                if (textStatus == "parsererror")
                                    errmsg += "<p>Error while parsing the data (parsererror).</p>";
                                else if (textStatus != "error" && textStatus != jqXHR.statusText)
                                    errmsg += "<p>Error-Code: " + textStatus + "</p>";
                                if (
                                    (jqXHR.status != 0 && jqXHR.status != 200) ||
                                    jqXHR.statusText != "OK" // note to me: jqXHR.status "should" give http status codes
                                )
                                    errmsg +=
                                    "<p>Error-Code: " +
                                    jqXHR.statusText +
                                    " (" +
                                    jqXHR.status +
                                    ")</p>";
                                fire("onAjaxError", errmsg);
                                // closing wait spinner
                                fire("onDone");
                            }
                        }
                    ); // getJSON
                }
            };

            // == initializations ==
        }(); // end create overpass object

        /* harmony default export */
        __webpack_exports__["a"] = (overpass);


        /***/
    }),
    /* 12 */
    /***/
    (function(module, exports) {

        // removed by extract-text-webpack-plugin

        /***/
    }),
    /* 13 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = query;
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(6);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
        // query parser module


        function query() {
            var statements = {};

            var parser = {};

            parser.parse = function(query, shortcuts, callback, _found_statements) {
                // 1. get list of overpass turbo statements
                statements = {};
                if (_found_statements) statements = _found_statements;
                var statement = /{{([A-Za-z0-9_]+):([\s\S]*?)}}/;
                var s;
                while ((s = query.match(statement))) {
                    var s_name = s[1];
                    var s_instr = s[2];
                    var s_replace = "";
                    // save instructions for later
                    if (statements[s_name] === undefined) statements[s_name] = "";
                    statements[s_name] += s_instr;
                    // if the statement is a shortcut, replace its content
                    if (shortcuts[s_name] !== undefined) {
                        // these shortcuts can also be callback functions, like {{date:-1day}}
                        if (typeof shortcuts[s_name] === "function") {
                            shortcuts[s_name](s_instr, function(res) {
                                var seed = Math.round(Math.random() * Math.pow(2, 22)); // todo: use some kind of checksum of s_instr if possible
                                shortcuts["__statement__" + s_name + "__" + seed] = res;
                                query = query.replace(
                                    "{{" + s_name + ":" + s_instr + "}}",
                                    "{{__statement__" + s_name + "__" + seed + ":" + s_instr + "}}"
                                );
                                // recursively call the parser with updated shortcuts
                                parser.parse(query, shortcuts, callback, statements);
                            });
                            return;
                        } else s_replace = shortcuts[s_name];
                    }
                    // remove statement, but preserve number of newlines
                    var lc = s_instr.split(/\r?\n|\r/).length;
                    query = query.replace(
                        "{{" + s_name + ":" + s_instr + "}}",
                        s_replace + Array(lc).join("\n")
                    );
                }
                // 2. get user defined constants
                var constants = {};
                var constant = /{{([A-Za-z0-9_]+)=(.+?)}}/;
                var c;
                while ((c = query.match(constant))) {
                    var c_name = c[1];
                    var c_val = c[2];
                    constants[c_name] = c_val;
                    // remove constant definitions
                    query = query.replace(constant, "");
                }
                // 3. expand shortcuts (global and user defined)
                __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend(constants, shortcuts, function(a, b) {
                    return typeof a == "undefined" ? b : a;
                });
                for (var c_name in constants) {
                    var c_val = constants[c_name];
                    query = query.replace(new RegExp("{{" + c_name + "}}", "g"), c_val);
                }
                // 4. remove remaining (e.g. unknown) mustache templates:
                var m;
                while ((m = query.match(/{{[\S\s]*?}}/gm))) {
                    // count lines in template and replace mustache with same number of newlines
                    var lc = m[0].split(/\r?\n|\r/).length;
                    query = query.replace(m[0], Array(lc).join("\n"));
                }
                // return the query
                callback(query);
            };

            parser.hasStatement = function(statement) {
                return statements.hasOwnProperty(statement);
            };

            parser.getStatement = function(statement) {
                return statements[statement];
            };

            return parser;
        }


        /***/
    }),
    /* 14 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_leaflet__ = __webpack_require__(3);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_leaflet___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_leaflet__);


        __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.GeoJsonNoVanish = __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.GeoJSON.extend({
            initialize: function(geojson, options) {
                this.options = {
                    threshold: 10
                };
                __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.GeoJSON.prototype.initialize.call(this, geojson, options);
            },
            onAdd: function(map) {
                this._map = map;
                this.eachLayer(map.addLayer, map);

                this._map.addEventListener("zoomend", this._onZoomEnd, this);
                this._onZoomEnd();
            },
            onRemove: function(map) {
                this._map.removeEventListener("zoomend", this._onZoomEnd, this);

                this.eachLayer(map.removeLayer, map);
                this._map = null;
            },
            _onZoomEnd: function() {
                // todo: name
                // todo: possible optimizations: zoomOut = skip already compressed objects (and vice versa)
                var is_max_zoom = this._map.getZoom() == this._map.getMaxZoom();
                this.eachLayer(function(o) {
                    if (!o.feature || !o.feature.geometry) return; // skip invalid layers
                    if (o.feature.geometry.type == "Point" && !o.obj) return; // skip node features
                    var crs = this._map.options.crs;
                    if (o.obj) {
                        // already compressed feature
                        var bounds = o.obj.getBounds();
                        var p1 = crs.latLngToPoint(bounds.getSouthWest(), o._map.getZoom());
                        var p2 = crs.latLngToPoint(bounds.getNorthEast(), o._map.getZoom());
                        var d = Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
                        if (d > Math.pow(this.options.threshold, 2) || is_max_zoom) {
                            delete o.obj.placeholder;
                            this.addLayer(o.obj);
                            this.removeLayer(o);
                        }
                        return;
                    }
                    if (is_max_zoom) return; // do not compress objects at max zoom
                    if (this.options.compress && !this.options.compress(o.feature)) return;
                    var bounds = o.getBounds();
                    var p1 = crs.latLngToPoint(bounds.getSouthWest(), o._map.getZoom());
                    var p2 = crs.latLngToPoint(bounds.getNorthEast(), o._map.getZoom());
                    var d = Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
                    if (d > Math.pow(this.options.threshold, 2)) return;
                    /*var c = this.options.pointToLayer ? 
                              this.options.pointToLayer(o.feature, bounds.getCenter()) : 
                              new L.Marker(bounds.getCenter());*/
                    var center = bounds.getCenter();
                    var f = __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.extend({}, o.feature);
                    f.is_placeholder = true;
                    f.geometry = {
                        type: "Point",
                        coordinates: [center.lng, center.lat]
                    };
                    var c = __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.GeoJSON.geometryToLayer(f, this.options.pointToLayer);
                    o.placeholder = c;
                    c.feature = f;
                    this.resetStyle(c);
                    c.obj = o;
                    //c.addEventListener("click dblclick mousedown mouseover mouseout contextmenu", function(e) {
                    c.on("click", function(e) {
                        this.obj.fireEvent(e.type, e);
                    });
                    this.addLayer(c);
                    this.removeLayer(o);
                }, this);
            }
        });
        __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.geoJsonNoVanish = function(geojson, options) {
            return new __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.GeoJsonNoVanish(geojson, options);
        };

        /* harmony default export */
        __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.GeoJsonNoVanish);


        /***/
    }),
    /* 15 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_leaflet__ = __webpack_require__(3);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_leaflet___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_leaflet__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_osmtogeojson__ = __webpack_require__(29);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_osmtogeojson___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_osmtogeojson__);



        __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.OSM4Leaflet = __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.Class.extend({
            initialize: function(data, options) {
                this.options = {
                    data_mode: "xml",
                    baseLayerClass: __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.GeoJSON,
                    baseLayerOptions: {}
                };
                __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.Util.setOptions(this, options);

                this._baseLayer = new this.options.baseLayerClass(
                    null,
                    this.options.baseLayerOptions
                );
                this._resultData = null;
                // if data
                if (data) this.addData(data);
            },
            addData: function(data, onDone) {
                var obj = this;
                setTimeout(function() {
                    // 1. convert to GeoJSON
                    var geojson = __WEBPACK_IMPORTED_MODULE_1_osmtogeojson___default()(data, {
                        flatProperties: false
                    });
                    obj._resultData = geojson;
                    if (obj.options.afterParse) obj.options.afterParse();
                    setTimeout(function() {
                        // 2. add to baseLayer
                        obj._baseLayer.addData(geojson);
                        if (onDone) onDone();
                    }, 1); //end setTimeout
                }, 1); //end setTimeout
            },
            getGeoJSON: function() {
                return this._resultData;
            },
            getBaseLayer: function() {
                return this._baseLayer;
            },
            onAdd: function(map) {
                this._baseLayer.addTo(map);
            },
            onRemove: function(map) {
                map.removeLayer(this._baseLayer);
            }
        });

        __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.osm4Leaflet = function(data, options) {
            return new __WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.OSM4Leaflet(data, options);
        };

        /* harmony default export */
        __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_leaflet___default.a.OSM4Leaflet);


        /***/
    }),
    /* 16 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__Style_js__ = __webpack_require__(1);
        // ----------------------------------------------------------------------
        // Condition base class



        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition = function() {};
        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition.prototype = {
            type: "", // eq/ne/regex etc.
            params: [], // what to test against

            init: function(_type) {
                // summary:     A condition to evaluate.
                this.type = _type;
                this.params = Array.prototype.slice.call(arguments, 1);
                return this;
            },

            test: function(tags) {
                // summary:     Run the condition against the supplied tags.
                var p = this.params;
                switch (this.type) {
                    case "eq":
                        return tags[p[0]] == p[1];
                    case "ne":
                        return tags[p[0]] != p[1];
                    case "regex":
                        var r = new RegExp(p[1], "i");
                        return r.test(tags[p[0]]);
                    case "true":
                        return tags[p[0]] == "true" || tags[p[0]] == "yes" || tags[p[0]] == "1";
                    case "false":
                        return tags[p[0]] == "false" || tags[p[0]] == "no" || tags[p[0]] == "0";
                    case "set":
                        return tags[p[0]] !== undefined && tags[p[0]] !== "";
                    case "unset":
                        return tags[p[0]] === undefined || tags[p[0]] === "";
                    case "<":
                        return Number(tags[p[0]]) < Number(p[1]);
                    case "<=":
                        return Number(tags[p[0]]) <= Number(p[1]);
                    case ">":
                        return Number(tags[p[0]]) > Number(p[1]);
                    case ">=":
                        return Number(tags[p[0]]) >= Number(p[1]);
                }
                return false;
            },

            toString: function() {
                return "[" + this.type + ": " + this.params + "]";
            }
        };


        /***/
    }),
    /* 17 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__Style_js__ = __webpack_require__(1);
        // ----------------------------------------------------------------------
        // Rule class



        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Rule = function() {};
        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Rule.prototype = {
            conditions: [], // the Conditions to be evaluated for the Rule to be fulfilled
            isAnd: true, // do all Conditions need to be true for the Rule to be fulfilled? (Always =true for MapCSS)
            minZoom: 0, // minimum zoom level at which the Rule is fulfilled
            maxZoom: 255, // maximum zoom level at which the Rule is fulfilled
            subject: "", // entity type to which the Rule applies: 'way', 'node', 'relation', 'area' (closed way) or 'line' (unclosed way)

            addSubject: function(_subject) {
                // summary:     A MapCSS selector. Contains a list of Conditions; the entity type to which the selector applies;
                //              and the zoom levels at which it is true. way[waterway=river][boat=yes] would be parsed into one Rule.
                //              The selectors and declaration together form a StyleChooser.
                this.subject = _subject;
                this.conditions = [];
            },

            addCondition: function(_condition) {
                // summary:     Add a condition to this rule.
                this.conditions.push(_condition);
            },

            test: function(entity, tags, zoom) {
                // summary: Evaluate the Rule on the given entity, tags and zoom level.
                // returns: true if the Rule passes, false if the conditions aren't fulfilled.
                if (this.subject !== "" && !entity.isSubject(this.subject)) {
                    return false;
                }
                if (zoom < this.minZoom || zoom > this.maxZoom) {
                    return false;
                }

                var v = true;
                var i = 0;
                var isAnd = this.isAnd;
                this.conditions.forEach(function(condition) {
                    var r = condition.test(tags);
                    if (i === 0) {
                        v = r;
                    } else if (isAnd) {
                        v = v && r;
                    } else {
                        v = v || r;
                    }
                    i++;
                });
                return v;
            },

            toString: function() {
                return (
                    this.subject +
                    " z" +
                    this.minZoom +
                    "-" +
                    this.maxZoom +
                    ": " +
                    this.conditions
                );
            }
        };


        /***/
    }),
    /* 18 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__Style_js__ = __webpack_require__(1);
        // ----------------------------------------------------------------------
        // RuleChain base class
        // In contrast to Halcyon, note that length() is a function, not a getter property

        /** A descendant list of MapCSS selectors (Rules).

          For example,
          relation[type=route] way[highway=primary]
          ^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^
          first Rule           second Rule
          |------------|---------|
          |
          one RuleChain

        */



        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].RuleChain = function() {
            this.rules = []; // list of Rules
            this.subpart = "default"; // subpart name, as in way[highway=primary]::centreline
        };
        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].RuleChain.prototype = {
            // Functions to define the RuleChain
            addRule: function(_subject) {
                this.rules.push(new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Rule());
                this.rules[this.rules.length - 1].addSubject(_subject);
            },

            addConditionToLast: function(_condition) {
                this.rules[this.rules.length - 1].addCondition(_condition);
            },

            addZoomToLast: function(z1, z2) {
                this.rules[this.rules.length - 1].minZoom = z1;
                this.rules[this.rules.length - 1].maxZoom = z2;
            },

            length: function() {
                return this.rules.length;
            },

            setSubpart: function(subpart) {
                this.subpart = subpart || "default";
            },

            // Test a ruleChain
            // - run a set of tests in the chain
            //      works backwards from at position "pos" in array, or -1  for the last
            //      separate tags object is required in case they've been dynamically retagged
            // - if they fail, return false
            // - if they succeed, and it's the last in the chain, return happily
            // - if they succeed, and there's more in the chain, rerun this for each parent until success

            test: function(pos, entity, tags, zoom) {
                // summary:     Test a rule chain by running all the tests in reverse order.
                if (this.rules.length === 0) {
                    return true;
                } // orig: { return false; } // todo: wildcard selector "*" semms broken...
                if (pos == -1) {
                    pos = this.rules.length - 1;
                }

                var r = this.rules[pos];
                if (!r.test(entity, tags, zoom)) {
                    return false;
                }
                if (pos === 0) {
                    return true;
                }

                var o = entity.getParentObjects(); //TODO//entity.entity.parentObjects();
                for (var i = 0; i < o.length; i++) {
                    var p = o[i];
                    if (this.test(pos - 1, p, p.tags, zoom)) {
                        return true;
                    }
                }
                return false;
            }
        };


        /***/
    }),
    /* 19 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__Style_js__ = __webpack_require__(1);
        // RuleSet base class
        // needs to cope with nested CSS files
        // doesn't do untagged nodes optimisation



        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].RuleSet = function() {};

        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].RuleSet.prototype = {
            choosers: [], // list of StyleChoosers

            getStyles: function(entity, tags, zoom) {
                // summary:     Find the styles for a given entity.
                var sl = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleList();
                for (var i in this.choosers) {
                    this.choosers[i].updateStyles(entity, tags, sl, zoom);
                }
                return sl; // styleparser.StyleList
            },

            /*loadFromCSS: function(url, callback) {
                  // summary:       Load a MapCSS file from a URL, then throw it at the parser when it's loaded.
                  this.callback = callback;
                  $.ajax({
                      url: url,
                      success: _.bind(this.parseCSS, this)
                  });
              },*/

            parseCSS: function(css) {
                // summary:     Parse a CSS document into a set of StyleChoosers.
                var previous = 0; // what was the previous CSS word?
                var sc = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser(); // currently being assembled
                this.choosers = [];
                css = css.replace(/[\r\n]/g, ""); // strip linebreaks because JavaScript doesn't have the /s modifier

                var o = {};
                while (css.length > 0) {
                    // CSS comment
                    if ((o = this.COMMENT.exec(css))) {
                        css = css.replace(this.COMMENT, "");

                        // Whitespace (probably only at beginning of file)
                    } else if ((o = this.WHITESPACE.exec(css))) {
                        css = css.replace(this.WHITESPACE, "");

                        // Class - .motorway, .builtup, :hover
                    } else if ((o = this.CLASS.exec(css))) {
                        if (previous == this.oDECLARATION) {
                            this.saveChooser(sc);
                            sc = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser();
                        }

                        css = css.replace(this.CLASS, "");
                        sc
                            .currentChain()
                            .addConditionToLast(new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("set", o[1]));
                        previous = this.oCONDITION;

                        // Not class - !.motorway, !.builtup, !:hover
                    } else if ((o = this.NOT_CLASS.exec(css))) {
                        if (previous == this.oDECLARATION) {
                            this.saveChooser(sc);
                            sc = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser();
                        }

                        css = css.replace(this.NOT_CLASS, "");
                        sc
                            .currentChain()
                            .addConditionToLast(new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("unset", o[1]));
                        previous = this.oCONDITION;

                        // Zoom
                    } else if ((o = this.ZOOM.exec(css))) {
                        if (previous != this.oOBJECT && previous != this.oCONDITION) {
                            sc.currentChain().addRule();
                        }

                        css = css.replace(this.ZOOM, "");
                        var z = this.parseZoom(o[1]);
                        sc.currentChain().addZoomToLast(z[0], z[1]);
                        sc.zoomSpecific = true;
                        previous = this.oZOOM;

                        // Grouping - just a comma
                    } else if ((o = this.GROUP.exec(css))) {
                        css = css.replace(this.GROUP, "");
                        sc.newRuleChain();
                        previous = this.oGROUP;

                        // Condition - [highway=primary]
                    } else if ((o = this.CONDITION.exec(css))) {
                        if (previous == this.oDECLARATION) {
                            this.saveChooser(sc);
                            sc = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser();
                        }
                        if (
                            previous != this.oOBJECT &&
                            previous != this.oZOOM &&
                            previous != this.oCONDITION
                        ) {
                            sc.currentChain().addRule();
                        }
                        css = css.replace(this.CONDITION, "");
                        sc.currentChain().addConditionToLast(this.parseCondition(o[1]));
                        previous = this.oCONDITION;

                        // Object - way, node, relation
                    } else if ((o = this.OBJECT.exec(css))) {
                        // TODO: raise error if object is none of node|way|relation|line|area|canvas|* ?
                        if (previous == this.oDECLARATION) {
                            this.saveChooser(sc);
                            sc = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser();
                        }

                        css = css.replace(this.OBJECT, "");
                        sc.currentChain().addRule(o[1]);
                        previous = this.oOBJECT;

                        // Subpart - ::centreline
                    } else if ((o = this.SUBPART.exec(css))) {
                        if (previous == this.oDECLARATION) {
                            this.saveChooser(sc);
                            sc = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser();
                        }
                        css = css.replace(this.SUBPART, "");
                        sc.currentChain().setSubpart(o[1]);
                        previous = this.oSUBPART;

                        // Declaration - {...}
                    } else if ((o = this.DECLARATION.exec(css))) {
                        css = css.replace(this.DECLARATION, "");
                        sc.addStyles(this.parseDeclaration(o[1]));
                        previous = this.oDECLARATION;

                        // Unknown pattern
                    } else if ((o = this.UNKNOWN.exec(css))) {
                        css = css.replace(this.UNKNOWN, "");
                        // TODO: own error class
                        throw new Error(
                            'Error while parsing MapCSS at "' +
                            o[1] +
                            (css.length > 38 ? css.substr(0, 36) + "..." : css) +
                            '"'
                        );
                        // console.log("unknown: "+o[1]);
                    } else {
                        // console.log("choked on "+css);
                        throw new Error("MapCSS parsing choked on " + css);
                        return;
                    }
                }
                if (previous == this.oDECLARATION) {
                    this.saveChooser(sc);
                    sc = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser();
                }
                if (this.callback) {
                    this.callback();
                }
            },

            saveChooser: function(sc) {
                this.choosers.push(sc);
            },

            parseDeclaration: function(s) {
                var styles = [];
                var t = {};
                var o = {};
                var k, v;

                // Create styles
                var ss = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].ShapeStyle();
                var ps = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].PointStyle();
                var ts = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].TextStyle();
                var hs = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].ShieldStyle();
                var xs = new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].InstructionStyle();

                var r = s.split(";");
                var isEval = {};
                for (var i in r) {
                    var a = r[i];
                    if ((o = this.ASSIGNMENT_EVAL.exec(a))) {
                        k = o[1].replace(this.DASH, "_");
                        t[k] = o[2];
                        isEval[k] = true;
                    } else if ((o = this.ASSIGNMENT.exec(a))) {
                        k = o[1].replace(this.DASH, "_");
                        t[k] = o[2];
                    } else if ((o = this.SET_TAG_EVAL.exec(a))) {} else if ((o = this.SET_TAG.exec(a))) {
                        // xs.addSetTag(o[1],this.saveEval(o[2]));
                        xs.addSetTag(o[1], o[2]);
                    } else if ((o = this.SET_TAG_TRUE.exec(a))) {
                        xs.addSetTag(o[1], true);
                    } else if ((o = this.EXIT.exec(a))) {
                        xs.setPropertyFromString("breaker", true);
                    }
                }

                /*// Find sublayer
                    // TODO: Why the renaming z_index -> sublayer?
                    //       This hardcoded variable isn't used anywhere.
                    //       Looks like this was replaced by the "subparts"...
                    var sub=5;
                    if (t['z_index']) { sub=Number(t['z_index']); delete t['z_index']; }
                    ss.sublayer=ps.sublayer=ts.sublayer=hs.sublayer=sub;
                    xs.sublayer=10;*/

                /*// Find "interactive" property - it's true unless explicitly set false
                    var inter=true;
                    if (t['interactive']) { inter=t['interactive'].match(this.FALSE) ? false : true; delete t['interactive']; }
                    ss.interactive=ps.interactive=ts.interactive=hs.interactive=xs.interactive=inter;*/

                // Munge special values
                // (we should stop doing this and do it in the style instead)
                // TODO: font_bold??? wtf? -> support propper MapCSS properites!
                if (t["font_weight"]) {
                    t["font_bold"] = t["font_weight"].match(this.BOLD) ? true : false;
                    delete t["font_weight"];
                }
                if (t["font_style"]) {
                    t["font_italic"] = t["font_style"].match(this.ITALIC) ? true : false;
                    delete t["font_style"];
                }
                if (t["text_decoration"]) {
                    t["font_underline"] = t["text_decoration"].match(this.UNDERLINE) ?
                        true :
                        false;
                    delete t["text_decoration"];
                }
                if (t["text_position"]) {
                    t["text_center"] = t["text_position"].match(this.CENTER) ? true : false;
                    delete t["text_position"];
                }
                if (t["text_transform"]) {
                    if (t["text_transform"].match(this.CAPS)) {
                        t["font_caps"] = true;
                    } else {
                        t["font_caps"] = false;
                    }
                    delete t["text_transform"];
                }

                // Assign each property to the appropriate style
                for (a in t) {
                    // Parse properties
                    v = t[a];

                    // Set in styles
                    if (ss.has(a)) {
                        ss.setPropertyFromString(a, v, isEval[a]);
                    } else if (ps.has(a)) {
                        ps.setPropertyFromString(a, v, isEval[a]);
                    } else if (ts.has(a)) {
                        ts.setPropertyFromString(a, v, isEval[a]);
                    } else if (hs.has(a)) {
                        hs.setPropertyFromString(a, v, isEval[a]);
                    } else {
                        // console.log(a+" not found");
                    }
                }

                // Add each style to list
                if (ss.edited) {
                    styles.push(ss);
                }
                if (ps.edited) {
                    styles.push(ps);
                }
                if (ts.edited) {
                    styles.push(ts);
                }
                if (hs.edited) {
                    styles.push(hs);
                }
                if (xs.edited) {
                    styles.push(xs);
                }
                return styles;
            },

            parseZoom: function(s) {
                var o = {};
                var maxscale = 999; // TODO: hardcoded
                var minscale = -999; // TODO: hardcoded
                if ((o = this.ZOOM_MINMAX.exec(s))) {
                    return [o[1], o[2]];
                } else if ((o = this.ZOOM_MIN.exec(s))) {
                    return [o[1], maxscale];
                } else if ((o = this.ZOOM_MAX.exec(s))) {
                    return [minscale, o[1]];
                } else if ((o = this.ZOOM_SINGLE.exec(s))) {
                    return [o[1], o[1]];
                }
                return null;
            },

            parseCondition: function(s) {
                var o = {};
                if ((o = this.CONDITION_TRUE.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("true", o[1]);
                } else if ((o = this.CONDITION_FALSE.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("false", o[1]);
                } else if ((o = this.CONDITION_SET.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("set", o[1]);
                } else if ((o = this.CONDITION_UNSET.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("unset", o[1]);
                } else if ((o = this.CONDITION_NE.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("ne", o[1], o[2]);
                } else if ((o = this.CONDITION_GT.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init(">", o[1], o[2]);
                } else if ((o = this.CONDITION_GE.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init(">=", o[1], o[2]);
                } else if ((o = this.CONDITION_LT.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("<", o[1], o[2]);
                } else if ((o = this.CONDITION_LE.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("<=", o[1], o[2]);
                } else if ((o = this.CONDITION_REGEX.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("regex", o[1], o[2]);
                } else if ((o = this.CONDITION_EQ.exec(s))) {
                    return new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].Condition().init("eq", o[1], o[2]);
                }
                return null;
            },

            parseCSSColor: function(colorStr) {
                // todo: this should be done at user (=style consumer) side (if necessary).
                // -> move to a more appropriate location
                colorStr = colorStr.toLowerCase();
                if (this.CSSCOLORS[colorStr]) {
                    return this.CSSCOLORS[colorStr];
                } else {
                    var match = this.HEX.exec(colorStr);
                    if (match) {
                        if (match[1].length == 3) {
                            // repeat digits. #abc => 0xaabbcc
                            return Number(
                                "0x" +
                                match[1].charAt(0) +
                                match[1].charAt(0) +
                                match[1].charAt(1) +
                                match[1].charAt(1) +
                                match[1].charAt(2) +
                                match[1].charAt(2)
                            );
                        } else if (match[1].length == 6) {
                            return Number("0x" + match[1]);
                        } else {
                            return Number("0x000000"); //as good as any
                        }
                    }
                }
                return 0;
            },

            // Regular expression tests and other constants

            WHITESPACE: /^\s+/,
            COMMENT: /\/\*.+?\*\/\s*/,
            CLASS: /^([\.:]\w+)\s*/,
            NOT_CLASS: /^!([\.:]\w+)\s*/,
            ZOOM: /^\|\s*z([\d\-]+)\s*/i,
            GROUP: /^,\s*/i,
            CONDITION: /^\[(.+?)\]\s*/,
            OBJECT: /^(\w+)\s*/, // TODO: match also "*" (and handle the wildcard appropriately)
            DECLARATION: /^\{(.+?)\}\s*/,
            SUBPART: /^::(\w+)\s*/,
            UNKNOWN: /^(\S+)\s*/,

            ZOOM_MINMAX: /^(\d+)\-(\d+)$/,
            ZOOM_MIN: /^(\d+)\-$/,
            ZOOM_MAX: /^\-(\d+)$/,
            ZOOM_SINGLE: /^(\d+)$/,

            CONDITION_TRUE: /^\s*([:\w]+)\s*=\s*yes\s*$/i,
            CONDITION_FALSE: /^\s*([:\w]+)\s*=\s*no\s*$/i,
            CONDITION_SET: /^\s*([:\w]+)\s*$/,
            CONDITION_UNSET: /^\s*!([:\w]+)\s*$/,
            CONDITION_EQ: /^\s*([:\w]+)\s*=\s*(.+)\s*$/,
            CONDITION_NE: /^\s*([:\w]+)\s*!=\s*(.+)\s*$/,
            CONDITION_GT: /^\s*([:\w]+)\s*>\s*(.+)\s*$/,
            CONDITION_GE: /^\s*([:\w]+)\s*>=\s*(.+)\s*$/,
            CONDITION_LT: /^\s*([:\w]+)\s*<\s*(.+)\s*$/,
            CONDITION_LE: /^\s*([:\w]+)\s*<=\s*(.+)\s*$/,
            CONDITION_REGEX: /^\s*([:\w]+)\s*=~\/\s*(.+)\/\s*$/,

            ASSIGNMENT_EVAL: /^\s*(\S+)\s*\:\s*eval\s*\(\s*['"](.+?)['"]\s*\)\s*$/i, // TODO: match only two matching quotes
            ASSIGNMENT: /^\s*(\S+)\s*\:\s*(.+?)\s*$/,
            SET_TAG_EVAL: /^\s*set\s+(\S+)\s*=\s*eval\s*\(\s*'(.+?)'\s*\)\s*$/i,
            SET_TAG: /^\s*set\s+(\S+)\s*=\s*(.+?)\s*$/i,
            SET_TAG_TRUE: /^\s*set\s+(\S+)\s*$/i,
            EXIT: /^\s*exit\s*$/i,

            oZOOM: 2,
            oGROUP: 3,
            oCONDITION: 4,
            oOBJECT: 5,
            oDECLARATION: 6,
            oSUBPART: 7,

            DASH: /\-/g,
            COLOR: /color$/,
            BOLD: /^bold$/i,
            ITALIC: /^italic|oblique$/i,
            UNDERLINE: /^underline$/i,
            CAPS: /^uppercase$/i,
            CENTER: /^center$/i,
            FALSE: /^(no|false|0)$/i,

            HEX: /^#([0-9a-f]+)$/i,

            CSSCOLORS: {
                aliceblue: 0xf0f8ff,
                antiquewhite: 0xfaebd7,
                aqua: 0x00ffff,
                aquamarine: 0x7fffd4,
                azure: 0xf0ffff,
                beige: 0xf5f5dc,
                bisque: 0xffe4c4,
                black: 0x000000,
                blanchedalmond: 0xffebcd,
                blue: 0x0000ff,
                blueviolet: 0x8a2be2,
                brown: 0xa52a2a,
                burlywood: 0xdeb887,
                cadetblue: 0x5f9ea0,
                chartreuse: 0x7fff00,
                chocolate: 0xd2691e,
                coral: 0xff7f50,
                cornflowerblue: 0x6495ed,
                cornsilk: 0xfff8dc,
                crimson: 0xdc143c,
                cyan: 0x00ffff,
                darkblue: 0x00008b,
                darkcyan: 0x008b8b,
                darkgoldenrod: 0xb8860b,
                darkgray: 0xa9a9a9,
                darkgreen: 0x006400,
                darkkhaki: 0xbdb76b,
                darkmagenta: 0x8b008b,
                darkolivegreen: 0x556b2f,
                darkorange: 0xff8c00,
                darkorchid: 0x9932cc,
                darkred: 0x8b0000,
                darksalmon: 0xe9967a,
                darkseagreen: 0x8fbc8f,
                darkslateblue: 0x483d8b,
                darkslategray: 0x2f4f4f,
                darkturquoise: 0x00ced1,
                darkviolet: 0x9400d3,
                deeppink: 0xff1493,
                deepskyblue: 0x00bfff,
                dimgray: 0x696969,
                dodgerblue: 0x1e90ff,
                firebrick: 0xb22222,
                floralwhite: 0xfffaf0,
                forestgreen: 0x228b22,
                fuchsia: 0xff00ff,
                gainsboro: 0xdcdcdc,
                ghostwhite: 0xf8f8ff,
                gold: 0xffd700,
                goldenrod: 0xdaa520,
                gray: 0x808080,
                green: 0x008000,
                greenyellow: 0xadff2f,
                honeydew: 0xf0fff0,
                hotpink: 0xff69b4,
                indianred: 0xcd5c5c,
                indigo: 0x4b0082,
                ivory: 0xfffff0,
                khaki: 0xf0e68c,
                lavender: 0xe6e6fa,
                lavenderblush: 0xfff0f5,
                lawngreen: 0x7cfc00,
                lemonchiffon: 0xfffacd,
                lightblue: 0xadd8e6,
                lightcoral: 0xf08080,
                lightcyan: 0xe0ffff,
                lightgoldenrodyellow: 0xfafad2,
                lightgrey: 0xd3d3d3,
                lightgreen: 0x90ee90,
                lightpink: 0xffb6c1,
                lightsalmon: 0xffa07a,
                lightseagreen: 0x20b2aa,
                lightskyblue: 0x87cefa,
                lightslategray: 0x778899,
                lightsteelblue: 0xb0c4de,
                lightyellow: 0xffffe0,
                lime: 0x00ff00,
                limegreen: 0x32cd32,
                linen: 0xfaf0e6,
                magenta: 0xff00ff,
                maroon: 0x800000,
                mediumaquamarine: 0x66cdaa,
                mediumblue: 0x0000cd,
                mediumorchid: 0xba55d3,
                mediumpurple: 0x9370d8,
                mediumseagreen: 0x3cb371,
                mediumslateblue: 0x7b68ee,
                mediumspringgreen: 0x00fa9a,
                mediumturquoise: 0x48d1cc,
                mediumvioletred: 0xc71585,
                midnightblue: 0x191970,
                mintcream: 0xf5fffa,
                mistyrose: 0xffe4e1,
                moccasin: 0xffe4b5,
                navajowhite: 0xffdead,
                navy: 0x000080,
                oldlace: 0xfdf5e6,
                olive: 0x808000,
                olivedrab: 0x6b8e23,
                orange: 0xffa500,
                orangered: 0xff4500,
                orchid: 0xda70d6,
                palegoldenrod: 0xeee8aa,
                palegreen: 0x98fb98,
                paleturquoise: 0xafeeee,
                palevioletred: 0xd87093,
                papayawhip: 0xffefd5,
                peachpuff: 0xffdab9,
                peru: 0xcd853f,
                pink: 0xffc0cb,
                plum: 0xdda0dd,
                powderblue: 0xb0e0e6,
                purple: 0x800080,
                red: 0xff0000,
                rosybrown: 0xbc8f8f,
                royalblue: 0x4169e1,
                saddlebrown: 0x8b4513,
                salmon: 0xfa8072,
                sandybrown: 0xf4a460,
                seagreen: 0x2e8b57,
                seashell: 0xfff5ee,
                sienna: 0xa0522d,
                silver: 0xc0c0c0,
                skyblue: 0x87ceeb,
                slateblue: 0x6a5acd,
                slategray: 0x708090,
                snow: 0xfffafa,
                springgreen: 0x00ff7f,
                steelblue: 0x4682b4,
                tan: 0xd2b48c,
                teal: 0x008080,
                thistle: 0xd8bfd8,
                tomato: 0xff6347,
                turquoise: 0x40e0d0,
                violet: 0xee82ee,
                wheat: 0xf5deb3,
                white: 0xffffff,
                whitesmoke: 0xf5f5f5,
                yellow: 0xffff00,
                yellowgreen: 0x9acd32
            }
        };


        /***/
    }),
    /* 20 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__Style_js__ = __webpack_require__(1);
        // styleparser/StyleChooser.js



        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser = function() {
            this.ruleChains = [new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].RuleChain()];
            this.styles = [];
        };

        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleChooser.prototype = {
            // UpdateStyles doesn't support image-widths yet
            // or setting maxwidth/_width
            ruleChains: [], // array of RuleChains (each one an array of Rules)
            styles: [], // array of ShapeStyle/ShieldStyle/TextStyle/PointStyle
            zoomSpecific: false, // are any of the rules zoom-specific?

            rcpos: 0,
            stylepos: 0,

            constructor: function() {
                // summary:     A combination of the selectors (ruleChains) and declaration (styles).
                //              For example, way[highway=footway] node[barrier=gate] { icon: gate.png; } is one StyleChooser.
            },

            currentChain: function() {
                return this.ruleChains[this.ruleChains.length - 1];
            },

            newRuleChain: function() {
                // summary:     Starts a new ruleChain in this.ruleChains.
                if (this.ruleChains[this.ruleChains.length - 1].length() > 0) {
                    this.ruleChains.push(new __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].RuleChain());
                }
            },

            addStyles: function(a) {
                this.styles = this.styles.concat(a);
            },

            updateStyles: function(entity, tags, sl, zoom) {
                if (this.zoomSpecific) {
                    sl.validAt = zoom;
                }

                // Are any of the ruleChains fulfilled?
                var w;
                for (var i in this.ruleChains) {
                    var c = this.ruleChains[i];
                    if (c.test(-1, entity, tags, zoom)) {
                        sl.addSubpart(c.subpart);

                        // Update StyleList
                        for (var j in this.styles) {
                            var r = this.styles[j];
                            var a;
                            switch (r.styleType) {
                                case "ShapeStyle":
                                    sl.maxwidth = Math.max(sl.maxwidth, r.maxwidth());
                                    a = sl.shapeStyles;
                                    break;
                                case "ShieldStyle":
                                    a = sl.shieldStyles;
                                    break;
                                case "TextStyle":
                                    a = sl.textStyles;
                                    break;
                                case "PointStyle":
                                    sl.maxwidth = Math.max(sl.maxwidth, r.maxwidth());
                                    a = sl.pointStyles;
                                    break;
                                case "InstructionStyle":
                                    if (r.breaker) {
                                        return;
                                    }
                                    for (var k in r.set_tags) {
                                        tags[k] = r.set_tags[k];
                                    }
                                    a = {}; // "dev/null" stylechooser reciever
                                    break;
                            }
                            if (r.drawn()) {
                                tags[":drawn"] = "yes";
                            }
                            tags._width = sl.maxwidth;

                            r.runEvals(tags);
                            // helper function
                            if (a[c.subpart]) {
                                // // If there's already a style on this sublayer, then merge them
                                // // (making a deep copy if necessary to avoid altering the root style)
                                // if (!a[c.subpart].merged) { a[c.subpart]=extend({},a[c.subpart]); }
                                extend(a[c.subpart], r);
                            } else {
                                // // Otherwise, just assign it
                                a[c.subpart] = extend({}, r);
                            }
                        }
                    }
                }
            }
        };

        function extend(destination, source) {
            for (var property in source) {
                if (source.hasOwnProperty(property)) {
                    destination[property] = source[property];
                }
            }
            return destination;
        }


        /***/
    }),
    /* 21 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__Style_js__ = __webpack_require__(1);
        // ----------------------------------------------------------------------
        // StyleList class



        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleList = function() {
            this.shapeStyles = {};
            this.textStyles = {};
            this.pointStyles = {};
            this.shieldStyles = {};
        };
        __WEBPACK_IMPORTED_MODULE_0__Style_js__["a" /* default */ ].StyleList.prototype = {
            maxwidth: 0,
            subparts: [], // List of subparts used in this StyleList
            validAt: -1, // Zoom level this is valid at (or -1 at all levels - saves recomputing)

            hasStyles: function() {
                // summary:     Does this StyleList contain any styles?
                return (
                    this.hasShapeStyles() ||
                    this.hasTextStyles() ||
                    this.hasPointStyles() ||
                    this.hasShieldStyles()
                );
            },

            hasFills: function() {
                // summary:     Does this StyleList contain any styles with a fill?
                for (var s in this.shapeStyles) {
                    if (!isNaN(this.shapeStyles(s).fill_color) ||
                        this.shapeStyles(s).fill_image
                    )
                        return true;
                }
                return false;
            },

            layerOverride: function() {
                // summary:     If this StyleList manually forces an OSM layer, return it, otherwise null.
                for (var s in this.shapeStyles) {
                    if (!isNaN(this.shapeStyles[s].layer)) return this.shapeStyles[s].layer;
                }
                return NaN;
            },

            addSubpart: function(s) {
                // summary:     Record that a subpart is used in this StyleList.
                if (this.subparts.indexOf(s) == -1) {
                    this.subparts.push(s);
                }
            },

            isValidAt: function(zoom) {
                // summary:     Is this StyleList valid at a given zoom?
                return this.validAt == -1 || this.validAt == zoom;
            },

            toString: function() {
                // summary:     Summarise StyleList as String - for debugging
                var str = "";
                var k;
                for (k in this.shapeStyles) {
                    str += "- SS " + k + "=" + this.shapeStyles[k] + "\n";
                }
                for (k in this.textStyles) {
                    str += "- TS " + k + "=" + this.textStyles[k] + "\n";
                }
                for (k in this.pointStyles) {
                    str += "- PS " + k + "=" + this.pointStyles[k] + "\n";
                }
                for (k in this.shieldStyles) {
                    str += "- sS " + k + "=" + this.shieldStyles[k] + "\n";
                }
                return str;
            },

            hasShapeStyles: function() {
                for (var a in this.shapeStyles) {
                    return true;
                }
                return false;
            },
            hasTextStyles: function() {
                for (var a in this.textStyles) {
                    return true;
                }
                return false;
            },
            hasPointStyles: function() {
                for (var a in this.pointStyles) {
                    return true;
                }
                return false;
            },
            hasShieldStyles: function() {
                for (var a in this.shieldStyles) {
                    return true;
                }
                return false;
            }
        };


        /***/
    }),
    /* 22 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__Style_js__ = __webpack_require__(1);
        /* harmony reexport (binding) */
        __webpack_require__.d(__webpack_exports__, "a", function() {
            return __WEBPACK_IMPORTED_MODULE_0__Style_js__["a"];
        });
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__Condition__ = __webpack_require__(16);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2__Rule__ = __webpack_require__(17);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3__RuleChain__ = __webpack_require__(18);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_4__RuleSet__ = __webpack_require__(19);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_5__Style__ = __webpack_require__(1);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_6__StyleChooser__ = __webpack_require__(20);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_7__StyleList__ = __webpack_require__(21);
        /*! this is mostly based on work by Richard Fairhurst, initially developed for iD editor, but abbandoned. See: http://lists.openstreetmap.org/pipermail/mapcss/2013-February/000341.html . This is under WTFPL. */
        //export {default} from './eval.pegjs';




        /***/
    }),
    /* 23 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_promise_polyfill__ = __webpack_require__(153);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_promise_polyfill___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_promise_polyfill__);


        // To add to window
        if (!window.Promise) {
            window.Promise = __WEBPACK_IMPORTED_MODULE_0_promise_polyfill___default.a;
        }


        /***/
    }),
    /* 24 */
    /***/
    (function(module, exports, __webpack_require__) {

        var wgs84 = __webpack_require__(34);

        module.exports.geometry = geometry;
        module.exports.ring = ringArea;

        function geometry(_) {
            if (_.type === 'Polygon') return polygonArea(_.coordinates);
            else if (_.type === 'MultiPolygon') {
                var area = 0;
                for (var i = 0; i < _.coordinates.length; i++) {
                    area += polygonArea(_.coordinates[i]);
                }
                return area;
            } else {
                return null;
            }
        }

        function polygonArea(coords) {
            var area = 0;
            if (coords && coords.length > 0) {
                area += Math.abs(ringArea(coords[0]));
                for (var i = 1; i < coords.length; i++) {
                    area -= Math.abs(ringArea(coords[i]));
                }
            }
            return area;
        }

        /**
         * Calculate the approximate area of the polygon were it projected onto
         *     the earth.  Note that this area will be positive if ring is oriented
         *     clockwise, otherwise it will be negative.
         *
         * Reference:
         * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
         *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
         *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
         *
         * Returns:
         * {float} The approximate signed geodesic area of the polygon in square
         *     meters.
         */

        function ringArea(coords) {
            var area = 0;

            if (coords.length > 2) {
                var p1, p2;
                for (var i = 0; i < coords.length - 1; i++) {
                    p1 = coords[i];
                    p2 = coords[i + 1];
                    area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
                }

                area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
            }

            return area;
        }

        function rad(_) {
            return _ * Math.PI / 180;
        }


        /***/
    }),
    /* 25 */
    /***/
    (function(module, exports, __webpack_require__) {

        var geojsonArea = __webpack_require__(24);

        module.exports = rewind;

        function rewind(gj, outer) {
            switch ((gj && gj.type) || null) {
                case 'FeatureCollection':
                    gj.features = gj.features.map(curryOuter(rewind, outer));
                    return gj;
                case 'Feature':
                    gj.geometry = rewind(gj.geometry, outer);
                    return gj;
                case 'Polygon':
                case 'MultiPolygon':
                    return correct(gj, outer);
                default:
                    return gj;
            }
        }

        function curryOuter(a, b) {
            return function(_) {
                return a(_, b);
            };
        }

        function correct(_, outer) {
            if (_.type === 'Polygon') {
                _.coordinates = correctRings(_.coordinates, outer);
            } else if (_.type === 'MultiPolygon') {
                _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
            }
            return _;
        }

        function correctRings(_, outer) {
            outer = !!outer;
            _[0] = wind(_[0], outer);
            for (var i = 1; i < _.length; i++) {
                _[i] = wind(_[i], !outer);
            }
            return _;
        }

        function wind(_, dir) {
            return cw(_) === dir ? _ : _.reverse();
        }

        function cw(_) {
            return geojsonArea.ring(_) >= 0;
        }


        /***/
    }),
    /* 26 */
    /***/
    (function(module, exports) {

        /*
         * Small popup-like icon to replace big L.Popup
         */

        L.PopupIcon = L.Icon.extend({
            options: {
                selectable: false,
                color: 'white',
                width: 150
            },

            initialize: function(text, options) {
                L.Icon.prototype.initialize.call(this, options);
                this._text = text;
            },

            bindTo: function(marker) {
                this._marker = marker;
                marker.setIcon(this);
                return marker;
            },

            createIcon: function() {
                var pdiv = document.createElement('div'),
                    div = document.createElement('div'),
                    width = this.options.width;

                pdiv.style.position = 'absolute';
                div.style.position = 'absolute';
                div.style.width = width + 'px';
                div.style.bottom = '-3px';
                div.style.pointerEvents = 'none';
                div.style.left = (-width / 2) + 'px';
                div.style.margin = div.style.padding = '0';
                pdiv.style.margin = pdiv.style.padding = '0';

                var contentDiv = document.createElement('div');
                contentDiv.innerHTML = this._text;
                contentDiv.style.textAlign = 'center';
                contentDiv.style.lineHeight = '1.2';
                contentDiv.style.backgroundColor = this.options.color;
                contentDiv.style.boxShadow = '0px 1px 10px rgba(0, 0, 0, 0.655)';
                contentDiv.style.padding = '4px 7px';
                contentDiv.style.borderRadius = '5px';
                contentDiv.style.margin = '0 auto';
                contentDiv.style.display = 'table';
                contentDiv.style.pointerEvents = 'auto';

                if (this.options.selectable && (!this._marker || (!this._marker.options.clickable && !this._marker.options.draggable))) {
                    var stop = L.DomEvent.stopPropagation;
                    L.DomEvent
                        .on(contentDiv, 'click', stop)
                        .on(contentDiv, 'mousedown', stop)
                        .on(contentDiv, 'dblclick', stop);
                }

                var tipcDiv = document.createElement('div');
                tipcDiv.className = 'leaflet-popup-tip-container';
                tipcDiv.style.width = '20px';
                tipcDiv.style.height = '11px';
                tipcDiv.style.padding = '0';
                tipcDiv.style.margin = '0 auto';
                var tipDiv = document.createElement('div');
                tipDiv.className = 'leaflet-popup-tip';
                tipDiv.style.width = tipDiv.style.height = '8px';
                tipDiv.style.marginTop = '-5px';
                tipDiv.style.boxShadow = 'none';
                tipcDiv.appendChild(tipDiv);

                div.appendChild(contentDiv);
                div.appendChild(tipcDiv);
                pdiv.appendChild(div);
                return pdiv;
            },

            createShadow: function() {
                return null;
            }
        });

        L.popupIcon = function(text, options) {
            return new L.PopupIcon(text, options);
        };


        /***/
    }),
    /* 27 */
    /***/
    (function(module, exports, __webpack_require__) {

        module.exports = __webpack_require__(28)


        /***/
    }),
    /* 28 */
    /***/
    (function(module, exports) {

        module.exports = [{
            "key": "building",
            "polygon": "all"
        }, {
            "key": "highway",
            "polygon": "whitelist",
            "values": ["services", "rest_area", "escape", "elevator"]
        }, {
            "key": "natural",
            "polygon": "blacklist",
            "values": ["coastline", "cliff", "ridge", "arete", "tree_row"]
        }, {
            "key": "landuse",
            "polygon": "all"
        }, {
            "key": "waterway",
            "polygon": "whitelist",
            "values": ["riverbank", "dock", "boatyard", "dam"]
        }, {
            "key": "amenity",
            "polygon": "all"
        }, {
            "key": "leisure",
            "polygon": "all"
        }, {
            "key": "barrier",
            "polygon": "whitelist",
            "values": ["city_wall", "ditch", "hedge", "retaining_wall", "wall", "spikes"]
        }, {
            "key": "railway",
            "polygon": "whitelist",
            "values": ["station", "turntable", "roundhouse", "platform"]
        }, {
            "key": "area",
            "polygon": "all"
        }, {
            "key": "boundary",
            "polygon": "all"
        }, {
            "key": "man_made",
            "polygon": "blacklist",
            "values": ["cutline", "embankment", "pipeline"]
        }, {
            "key": "power",
            "polygon": "whitelist",
            "values": ["plant", "substation", "generator", "transformer"]
        }, {
            "key": "place",
            "polygon": "all"
        }, {
            "key": "shop",
            "polygon": "all"
        }, {
            "key": "aeroway",
            "polygon": "blacklist",
            "values": ["taxiway"]
        }, {
            "key": "tourism",
            "polygon": "all"
        }, {
            "key": "historic",
            "polygon": "all"
        }, {
            "key": "public_transport",
            "polygon": "all"
        }, {
            "key": "office",
            "polygon": "all"
        }, {
            "key": "building:part",
            "polygon": "all"
        }, {
            "key": "military",
            "polygon": "all"
        }, {
            "key": "ruins",
            "polygon": "all"
        }, {
            "key": "area:highway",
            "polygon": "all"
        }, {
            "key": "craft",
            "polygon": "all"
        }, {
            "key": "golf",
            "polygon": "all"
        }, {
            "key": "indoor",
            "polygon": "all"
        }]

        /***/
    }),
    /* 29 */
    /***/
    (function(module, exports, __webpack_require__) {

        var _ = __webpack_require__(30);
        var rewind = __webpack_require__(25);

        // see https://wiki.openstreetmap.org/wiki/Overpass_turbo/Polygon_Features
        var polygonFeatures = {};
        __webpack_require__(27).forEach(function(tags) {
            if (tags.polygon === "all")
                polygonFeatures[tags.key] = true;
            else {
                var list = (tags.polygon === "whitelist") ? "included_values" : "excluded_values",
                    tagValuesObj = {};
                tags.values.forEach(function(value) {
                    tagValuesObj[value] = true;
                });
                polygonFeatures[tags.key] = {};
                polygonFeatures[tags.key][list] = tagValuesObj;
            }
        });

        // default deduplication helper function
        function default_deduplicator(objectA, objectB) {
            // default deduplication handler:
            // if object versions differ, use highest available version
            if ((objectA.version || objectB.version) &&
                (objectA.version !== objectB.version)) {
                return (+objectA.version || 0) > (+objectB.version || 0) ?
                    objectA :
                    objectB;
            }
            // otherwise: return merged obj properties
            return _.merge(objectA, objectB);
        }

        var osmtogeojson = {};

        osmtogeojson = function(data, options, featureCallback) {

            options = _.merge({
                    verbose: false,
                    flatProperties: true,
                    uninterestingTags: {
                        "source": true,
                        "source_ref": true,
                        "source:ref": true,
                        "history": true,
                        "attribution": true,
                        "created_by": true,
                        "tiger:county": true,
                        "tiger:tlid": true,
                        "tiger:upload_uuid": true
                    },
                    polygonFeatures: polygonFeatures,
                    deduplicator: default_deduplicator
                },
                options
            );

            var result;
            if (((typeof XMLDocument !== "undefined") && data instanceof XMLDocument ||
                    (typeof XMLDocument === "undefined") && data.childNodes))
                result = _osmXML2geoJSON(data);
            else
                result = _overpassJSON2geoJSON(data);
            return result;

            function _overpassJSON2geoJSON(json) {
                // sort elements
                var nodes = new Array();
                var ways = new Array();
                var rels = new Array();
                // helper functions
                function centerGeometry(object) {
                    var pseudoNode = _.clone(object);
                    pseudoNode.lat = object.center.lat;
                    pseudoNode.lon = object.center.lon;
                    pseudoNode.__is_center_placeholder = true;
                    nodes.push(pseudoNode);
                }

                function boundsGeometry(object) {
                    var pseudoWay = _.clone(object);
                    pseudoWay.nodes = [];

                    function addPseudoNode(lat, lon, i) {
                        var pseudoNode = {
                            type: "node",
                            id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i,
                            lat: lat,
                            lon: lon
                        }
                        pseudoWay.nodes.push(pseudoNode.id);
                        nodes.push(pseudoNode);
                    }
                    addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.minlon, 1);
                    addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.minlon, 2);
                    addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.maxlon, 3);
                    addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.maxlon, 4);
                    pseudoWay.nodes.push(pseudoWay.nodes[0]);
                    pseudoWay.__is_bounds_placeholder = true;
                    ways.push(pseudoWay);
                }

                function fullGeometryWay(way) {
                    function addFullGeometryNode(lat, lon, id) {
                        var geometryNode = {
                            type: "node",
                            id: id,
                            lat: lat,
                            lon: lon
                        }
                        nodes.push(geometryNode);
                    }
                    if (!_.isArray(way.nodes)) {
                        way.nodes = way.geometry.map(function(nd) {
                            if (nd !== null) // have to skip ref-less nodes
                                return "_anonymous@" + nd.lat + "/" + nd.lon;
                            else
                                return "_anonymous@unknown_location";
                        });
                    }
                    way.geometry.forEach(function(nd, i) {
                        if (nd) {
                            addFullGeometryNode(
                                nd.lat,
                                nd.lon,
                                way.nodes[i]
                            );
                        }
                    });
                }

                function fullGeometryRelation(rel) {
                    function addFullGeometryNode(lat, lon, id) {
                        var geometryNode = {
                            type: "node",
                            id: id,
                            lat: lat,
                            lon: lon
                        }
                        nodes.push(geometryNode);
                    }

                    function addFullGeometryWay(geometry, id) {
                        // shared multipolygon ways cannot be defined multiple times with the same id.
                        if (ways.some(function(way) { // todo: this is slow :(
                                return way.type == "way" && way.id == id;
                            })) return;
                        var geometryWay = {
                            type: "way",
                            id: id,
                            nodes: []
                        }

                        function addFullGeometryWayPseudoNode(lat, lon) {
                            // todo? do not save the same pseudo node multiple times
                            var geometryPseudoNode = {
                                type: "node",
                                id: "_anonymous@" + lat + "/" + lon,
                                lat: lat,
                                lon: lon
                            }
                            geometryWay.nodes.push(geometryPseudoNode.id);
                            nodes.push(geometryPseudoNode);
                        }
                        geometry.forEach(function(nd) {
                            if (nd) {
                                addFullGeometryWayPseudoNode(
                                    nd.lat,
                                    nd.lon
                                );
                            } else {
                                geometryWay.nodes.push(undefined);
                            }
                        });
                        ways.push(geometryWay);
                    }
                    rel.members.forEach(function(member, i) {
                        if (member.type == "node") {
                            if (member.lat) {
                                addFullGeometryNode(
                                    member.lat,
                                    member.lon,
                                    member.ref
                                );
                            }
                        } else if (member.type == "way") {
                            if (member.geometry) {
                                member.ref = "_fullGeom" + member.ref;
                                addFullGeometryWay(
                                    member.geometry,
                                    member.ref
                                );
                            }
                        }
                    });
                }
                // create copies of individual json objects to make sure the original data doesn't get altered
                // todo: cloning is slow: see if this can be done differently!
                for (var i = 0; i < json.elements.length; i++) {
                    switch (json.elements[i].type) {
                        case "node":
                            var node = json.elements[i];
                            nodes.push(node);
                            break;
                        case "way":
                            var way = _.clone(json.elements[i]);
                            way.nodes = _.clone(way.nodes);
                            ways.push(way);
                            if (way.center)
                                centerGeometry(way);
                            if (way.geometry)
                                fullGeometryWay(way);
                            else if (way.bounds)
                                boundsGeometry(way);
                            break;
                        case "relation":
                            var rel = _.clone(json.elements[i]);
                            rel.members = _.clone(rel.members);
                            rels.push(rel);
                            var has_full_geometry = rel.members && rel.members.some(function(member) {
                                return member.type == "node" && member.lat ||
                                    member.type == "way" && member.geometry && member.geometry.length > 0
                            });
                            if (rel.center)
                                centerGeometry(rel);
                            if (has_full_geometry)
                                fullGeometryRelation(rel);
                            else if (rel.bounds)
                                boundsGeometry(rel);
                            break;
                        default:
                            // type=area (from coord-query) is an example for this case.
                    }
                }
                return _convert2geoJSON(nodes, ways, rels);
            }

            function _osmXML2geoJSON(xml) {
                // sort elements
                var nodes = new Array();
                var ways = new Array();
                var rels = new Array();
                // helper function
                function copy_attribute(x, o, attr) {
                    if (x.hasAttribute(attr))
                        o[attr] = x.getAttribute(attr);
                }

                function centerGeometry(object, centroid) {
                    var pseudoNode = _.clone(object);
                    copy_attribute(centroid, pseudoNode, 'lat');
                    copy_attribute(centroid, pseudoNode, 'lon');
                    pseudoNode.__is_center_placeholder = true;
                    nodes.push(pseudoNode);
                }

                function boundsGeometry(object, bounds) {
                    var pseudoWay = _.clone(object);
                    pseudoWay.nodes = [];

                    function addPseudoNode(lat, lon, i) {
                        var pseudoNode = {
                            type: "node",
                            id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i,
                            lat: lat,
                            lon: lon
                        }
                        pseudoWay.nodes.push(pseudoNode.id);
                        nodes.push(pseudoNode);
                    }
                    addPseudoNode(bounds.getAttribute('minlat'), bounds.getAttribute('minlon'), 1);
                    addPseudoNode(bounds.getAttribute('maxlat'), bounds.getAttribute('minlon'), 2);
                    addPseudoNode(bounds.getAttribute('maxlat'), bounds.getAttribute('maxlon'), 3);
                    addPseudoNode(bounds.getAttribute('minlat'), bounds.getAttribute('maxlon'), 4);
                    pseudoWay.nodes.push(pseudoWay.nodes[0]);
                    pseudoWay.__is_bounds_placeholder = true;
                    ways.push(pseudoWay);
                }

                function fullGeometryWay(way, nds) {
                    function addFullGeometryNode(lat, lon, id) {
                        var geometryNode = {
                            type: "node",
                            id: id,
                            lat: lat,
                            lon: lon
                        }
                        nodes.push(geometryNode);
                        return geometryNode.id;
                    }
                    if (!_.isArray(way.nodes)) {
                        way.nodes = [];
                        _.each(nds, function(nd, i) {
                            way.nodes.push("_anonymous@" + nd.getAttribute('lat') + "/" + nd.getAttribute('lon'));
                        });
                    }
                    _.each(nds, function(nd, i) {
                        if (nd.getAttribute('lat')) {
                            addFullGeometryNode(
                                nd.getAttribute('lat'),
                                nd.getAttribute('lon'),
                                way.nodes[i]
                            );
                        }
                    });
                }

                function fullGeometryRelation(rel, members) {
                    function addFullGeometryNode(lat, lon, id) {
                        var geometryNode = {
                            type: "node",
                            id: id,
                            lat: lat,
                            lon: lon
                        }
                        nodes.push(geometryNode);
                    }

                    function addFullGeometryWay(nds, id) {
                        // shared multipolygon ways cannot be defined multiple times with the same id.
                        if (ways.some(function(way) { // todo: this is slow :(
                                return way.type == "way" && way.id == id;
                            })) return;
                        var geometryWay = {
                            type: "way",
                            id: id,
                            nodes: []
                        }

                        function addFullGeometryWayPseudoNode(lat, lon) {
                            // todo? do not save the same pseudo node multiple times
                            var geometryPseudoNode = {
                                type: "node",
                                id: "_anonymous@" + lat + "/" + lon,
                                lat: lat,
                                lon: lon
                            }
                            geometryWay.nodes.push(geometryPseudoNode.id);
                            nodes.push(geometryPseudoNode);
                        }
                        _.each(nds, function(nd) {
                            if (nd.getAttribute('lat')) {
                                addFullGeometryWayPseudoNode(
                                    nd.getAttribute('lat'),
                                    nd.getAttribute('lon')
                                );
                            } else {
                                geometryWay.nodes.push(undefined);
                            }
                        });
                        ways.push(geometryWay);
                    }
                    _.each(members, function(member, i) {
                        if (rel.members[i].type == "node") {
                            if (member.getAttribute('lat')) {
                                addFullGeometryNode(
                                    member.getAttribute('lat'),
                                    member.getAttribute('lon'),
                                    rel.members[i].ref
                                );
                            }
                        } else if (rel.members[i].type == "way") {
                            if (member.getElementsByTagName('nd').length > 0) {
                                rel.members[i].ref = "_fullGeom" + rel.members[i].ref;
                                addFullGeometryWay(
                                    member.getElementsByTagName('nd'),
                                    rel.members[i].ref
                                );
                            }
                        }
                    });
                }
                // nodes
                _.each(xml.getElementsByTagName('node'), function(node, i) {
                    var tags = {};
                    _.each(node.getElementsByTagName('tag'), function(tag) {
                        tags[tag.getAttribute('k')] = tag.getAttribute('v');
                    });
                    var nodeObject = {
                        'type': 'node'
                    };
                    copy_attribute(node, nodeObject, 'id');
                    copy_attribute(node, nodeObject, 'lat');
                    copy_attribute(node, nodeObject, 'lon');
                    copy_attribute(node, nodeObject, 'version');
                    copy_attribute(node, nodeObject, 'timestamp');
                    copy_attribute(node, nodeObject, 'changeset');
                    copy_attribute(node, nodeObject, 'uid');
                    copy_attribute(node, nodeObject, 'user');
                    if (!_.isEmpty(tags))
                        nodeObject.tags = tags;
                    nodes.push(nodeObject);
                });
                // ways
                var centroid, bounds;
                _.each(xml.getElementsByTagName('way'), function(way, i) {
                    var tags = {};
                    var wnodes = [];
                    _.each(way.getElementsByTagName('tag'), function(tag) {
                        tags[tag.getAttribute('k')] = tag.getAttribute('v');
                    });
                    var has_full_geometry = false;
                    _.each(way.getElementsByTagName('nd'), function(nd, i) {
                        var id;
                        if (id = nd.getAttribute('ref'))
                            wnodes[i] = id;
                        if (!has_full_geometry && nd.getAttribute('lat'))
                            has_full_geometry = true;
                    });
                    var wayObject = {
                        "type": "way"
                    };
                    copy_attribute(way, wayObject, 'id');
                    copy_attribute(way, wayObject, 'version');
                    copy_attribute(way, wayObject, 'timestamp');
                    copy_attribute(way, wayObject, 'changeset');
                    copy_attribute(way, wayObject, 'uid');
                    copy_attribute(way, wayObject, 'user');
                    if (wnodes.length > 0)
                        wayObject.nodes = wnodes;
                    if (!_.isEmpty(tags))
                        wayObject.tags = tags;
                    if (centroid = way.getElementsByTagName('center')[0])
                        centerGeometry(wayObject, centroid);
                    if (has_full_geometry)
                        fullGeometryWay(wayObject, way.getElementsByTagName('nd'));
                    else if (bounds = way.getElementsByTagName('bounds')[0])
                        boundsGeometry(wayObject, bounds);
                    ways.push(wayObject);
                });
                // relations
                _.each(xml.getElementsByTagName('relation'), function(relation, i) {
                    var tags = {};
                    var members = [];
                    _.each(relation.getElementsByTagName('tag'), function(tag) {
                        tags[tag.getAttribute('k')] = tag.getAttribute('v');
                    });
                    var has_full_geometry = false;
                    _.each(relation.getElementsByTagName('member'), function(member, i) {
                        members[i] = {};
                        copy_attribute(member, members[i], 'ref');
                        copy_attribute(member, members[i], 'role');
                        copy_attribute(member, members[i], 'type');
                        if (!has_full_geometry &&
                            (members[i].type == 'node' && member.getAttribute('lat')) ||
                            (members[i].type == 'way' && member.getElementsByTagName('nd').length > 0))
                            has_full_geometry = true;
                    });
                    var relObject = {
                        "type": "relation"
                    }
                    copy_attribute(relation, relObject, 'id');
                    copy_attribute(relation, relObject, 'version');
                    copy_attribute(relation, relObject, 'timestamp');
                    copy_attribute(relation, relObject, 'changeset');
                    copy_attribute(relation, relObject, 'uid');
                    copy_attribute(relation, relObject, 'user');
                    if (members.length > 0)
                        relObject.members = members;
                    if (!_.isEmpty(tags))
                        relObject.tags = tags;
                    if (centroid = relation.getElementsByTagName('center')[0])
                        centerGeometry(relObject, centroid);
                    if (has_full_geometry)
                        fullGeometryRelation(relObject, relation.getElementsByTagName('member'));
                    else if (bounds = relation.getElementsByTagName('bounds')[0])
                        boundsGeometry(relObject, bounds);
                    rels.push(relObject);
                });
                return _convert2geoJSON(nodes, ways, rels);
            }

            function _convert2geoJSON(nodes, ways, rels) {

                // helper function that checks if there are any tags other than "created_by", "source", etc. or any tag provided in ignore_tags
                function has_interesting_tags(t, ignore_tags) {
                    if (typeof ignore_tags !== "object")
                        ignore_tags = {};
                    if (typeof options.uninterestingTags === "function")
                        return !options.uninterestingTags(t, ignore_tags);
                    for (var k in t)
                        if (!(options.uninterestingTags[k] === true) &&
                            !(ignore_tags[k] === true || ignore_tags[k] === t[k]))
                            return true;
                    return false;
                };
                // helper function to extract meta information
                function build_meta_information(object) {
                    var res = {
                        "timestamp": object.timestamp,
                        "version": object.version,
                        "changeset": object.changeset,
                        "user": object.user,
                        "uid": object.uid
                    };
                    for (var k in res)
                        if (res[k] === undefined)
                            delete res[k];
                    return res;
                }

                // some data processing (e.g. filter nodes only used for ways)
                var nodeids = new Object();
                var poinids = new Object();
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (nodeids[node.id] !== undefined) {
                        // handle input data duplication
                        node = options.deduplicator(node, nodeids[node.id]);
                    }
                    nodeids[node.id] = node;
                    if (typeof node.tags != 'undefined' &&
                        has_interesting_tags(node.tags)) // this checks if the node has any tags other than "created_by"
                        poinids[node.id] = true;
                }
                // todo -> after deduplication of relations??
                for (var i = 0; i < rels.length; i++) {
                    if (_.isArray(rels[i].members)) {
                        for (var j = 0; j < rels[i].members.length; j++) {
                            if (rels[i].members[j].type == "node")
                                poinids[rels[i].members[j].ref] = true;
                        }
                    }
                }
                var wayids = new Object();
                var waynids = new Object();
                for (var i = 0; i < ways.length; i++) {
                    var way = ways[i];
                    if (wayids[way.id]) {
                        // handle input data duplication
                        way = options.deduplicator(way, wayids[way.id]);
                    }
                    wayids[way.id] = way;
                    if (_.isArray(way.nodes)) {
                        for (var j = 0; j < way.nodes.length; j++) {
                            if (typeof way.nodes[j] === "object") continue; // ignore already replaced way node objects
                            waynids[way.nodes[j]] = true;
                            way.nodes[j] = nodeids[way.nodes[j]];
                        }
                    }
                }
                var pois = new Array();
                for (var id in nodeids) {
                    var node = nodeids[id];
                    if (!waynids[id] || poinids[id])
                        pois.push(node);
                }
                var relids = new Array();
                for (var i = 0; i < rels.length; i++) {
                    var rel = rels[i];
                    if (relids[rel.id]) {
                        // handle input data duplication
                        rel = options.deduplicator(rel, relids[rel.id]);
                    }
                    relids[rel.id] = rel;
                }
                var relsmap = {
                    node: {},
                    way: {},
                    relation: {}
                };
                for (var id in relids) {
                    var rel = relids[id];
                    if (!_.isArray(rel.members)) {
                        if (options.verbose) console.warn('Relation', rel.type + '/' + rel.id, 'ignored because it has no members');
                        continue; // ignore relations without members (e.g. returned by an ids_only query)
                    }
                    for (var j = 0; j < rel.members.length; j++) {
                        var m_type = rel.members[j].type;
                        var m_ref = rel.members[j].ref;
                        if (typeof m_ref !== "number") {
                            // de-namespace full geometry content
                            m_ref = m_ref.replace("_fullGeom", "");
                        }
                        if (!relsmap[m_type]) {
                            if (options.verbose) console.warn('Relation', rel.type + '/' + rel.id, 'member', m_type + '/' + m_ref, 'ignored because it has an invalid type');
                            continue;
                        }
                        if (typeof relsmap[m_type][m_ref] === "undefined")
                            relsmap[m_type][m_ref] = [];
                        relsmap[m_type][m_ref].push({
                            "role": rel.members[j].role,
                            "rel": rel.id,
                            "reltags": rel.tags,
                        });
                    }
                }
                // construct geojson
                var geojson;
                var geojsonnodes = [];
                for (i = 0; i < pois.length; i++) {
                    if (typeof pois[i].lon == "undefined" || typeof pois[i].lat == "undefined") {
                        if (options.verbose) console.warn('POI', pois[i].type + '/' + pois[i].id, 'ignored because it lacks coordinates');
                        continue; // lon and lat are required for showing a point
                    }
                    var feature = {
                        "type": "Feature",
                        "id": pois[i].type + "/" + pois[i].id,
                        "properties": {
                            "type": pois[i].type,
                            "id": pois[i].id,
                            "tags": pois[i].tags || {},
                            "relations": relsmap["node"][pois[i].id] || [],
                            "meta": build_meta_information(pois[i])
                        },
                        "geometry": {
                            "type": "Point",
                            "coordinates": [+pois[i].lon, +pois[i].lat],
                        }
                    };
                    if (pois[i].__is_center_placeholder)
                        feature.properties["geometry"] = "center";
                    if (!featureCallback)
                        geojsonnodes.push(feature);
                    else
                        featureCallback(feature);
                }
                var geojsonlines = [];
                var geojsonpolygons = [];
                // process multipolygons
                for (var i = 0; i < rels.length; i++) {
                    // todo: refactor such that this loops over relids instead of rels?
                    if (relids[rels[i].id] !== rels[i]) {
                        // skip relation because it's a deduplication artifact
                        continue;
                    }
                    if ((typeof rels[i].tags != "undefined") &&
                        (rels[i].tags["type"] == "route" || rels[i].tags["type"] == "waterway")) {
                        if (!_.isArray(rels[i].members)) {
                            if (options.verbose) console.warn('Route', rels[i].type + '/' + rels[i].id, 'ignored because it has no members');
                            continue; // ignore relations without members (e.g. returned by an ids_only query)
                        }
                        rels[i].members.forEach(function(m) {
                            if (wayids[m.ref] && !has_interesting_tags(wayids[m.ref].tags))
                                wayids[m.ref].is_skippablerelationmember = true;
                        });
                        feature = construct_multilinestring(rels[i]);
                        if (feature === false) {
                            if (options.verbose) console.warn('Route relation', rels[i].type + '/' + rels[i].id, 'ignored because it has invalid geometry');
                            continue; // abort if feature could not be constructed
                        }
                        if (!featureCallback)
                            geojsonpolygons.push(feature);
                        else
                            featureCallback(rewind(feature));

                        function construct_multilinestring(rel) {
                            var is_tainted = false;
                            // prepare route members
                            var members;
                            members = rel.members.filter(function(m) {
                                return m.type === "way";
                            });
                            members = members.map(function(m) {
                                var way = wayids[m.ref];
                                if (way === undefined || way.nodes === undefined) { // check for missing ways
                                    if (options.verbose) console.warn('Route ' + rel.type + '/' + rel.id, 'tainted by a missing or incomplete  way', m.type + '/' + m.ref);
                                    is_tainted = true;
                                    return;
                                }
                                return { // TODO: this is slow! :(
                                    id: m.ref,
                                    role: m.role,
                                    way: way,
                                    nodes: way.nodes.filter(function(n) {
                                        if (n !== undefined)
                                            return true;
                                        is_tainted = true;
                                        if (options.verbose) console.warn('Route', rel.type + '/' + rel.id, 'tainted by a way', m.type + '/' + m.ref, 'with a missing node');
                                        return false;
                                    })
                                };
                            });
                            members = _.compact(members);
                            // construct connected linestrings
                            var linestrings;
                            linestrings = join(members);

                            // sanitize mp-coordinates (remove empty clusters or rings, {lat,lon,...} to [lon,lat]
                            var coords = [];
                            coords = _.compact(linestrings.map(function(linestring) {
                                return _.compact(linestring.map(function(node) {
                                    return [+node.lon, +node.lat];
                                }));
                            }));

                            if (coords.length == 0) {
                                if (options.verbose) console.warn('Route', rel.type + '/' + rel.id, 'contains no coordinates');
                                return false; // ignore routes without coordinates
                            }

                            // mp parsed, now construct the geoJSON
                            var feature = {
                                "type": "Feature",
                                "id": rel.type + "/" + rel.id,
                                "properties": {
                                    "type": rel.type,
                                    "id": rel.id,
                                    "tags": rel.tags || {},
                                    "relations": relsmap[rel.type][rel.id] || [],
                                    "meta": build_meta_information(rel)
                                },
                                "geometry": {
                                    "type": coords.length === 1 ? "LineString" : "MultiLineString",
                                    "coordinates": coords.length === 1 ? coords[0] : coords,
                                }
                            }
                            if (is_tainted) {
                                if (options.verbose) console.warn('Route', rel.type + '/' + rel.id, 'is tainted');
                                feature.properties["tainted"] = true;
                            }
                            return feature;
                        }
                    } // end construct multilinestring for route relations
                    if ((typeof rels[i].tags != "undefined") &&
                        (rels[i].tags["type"] == "multipolygon" || rels[i].tags["type"] == "boundary")) {
                        if (!_.isArray(rels[i].members)) {
                            if (options.verbose) console.warn('Multipolygon', rels[i].type + '/' + rels[i].id, 'ignored because it has no members');
                            continue; // ignore relations without members (e.g. returned by an ids_only query)
                        }
                        var outer_count = 0;
                        for (var j = 0; j < rels[i].members.length; j++)
                            if (rels[i].members[j].role == "outer")
                                outer_count++;
                            else if (options.verbose && rels[i].members[j].role != "inner")
                            console.warn('Multipolygon', rels[i].type + '/' + rels[i].id, 'member', rels[i].members[j].type + '/' + rels[i].members[j].ref, 'ignored because it has an invalid role: "' + rels[i].members[j].role + '"');
                        rels[i].members.forEach(function(m) {
                            if (wayids[m.ref]) {
                                // this even works in the following corner case:
                                // a multipolygon amenity=xxx with outer line tagged amenity=yyy
                                // see https://github.com/tyrasd/osmtogeojson/issues/7
                                if (m.role === "outer" && !has_interesting_tags(wayids[m.ref].tags, rels[i].tags))
                                    wayids[m.ref].is_skippablerelationmember = true;
                                if (m.role === "inner" && !has_interesting_tags(wayids[m.ref].tags))
                                    wayids[m.ref].is_skippablerelationmember = true;
                            }
                        });
                        if (outer_count == 0) {
                            if (options.verbose) console.warn('Multipolygon relation', rels[i].type + '/' + rels[i].id, 'ignored because it has no outer ways');
                            continue; // ignore multipolygons without outer ways
                        }
                        var simple_mp = false;
                        if (outer_count == 1 && !has_interesting_tags(rels[i].tags, {
                                "type": true
                            }))
                            simple_mp = true;
                        var feature = null;
                        if (!simple_mp) {
                            feature = construct_multipolygon(rels[i], rels[i]);
                        } else {
                            // simple multipolygon
                            var outer_way = rels[i].members.filter(function(m) {
                                return m.role === "outer";
                            })[0];
                            outer_way = wayids[outer_way.ref];
                            if (outer_way === undefined) {
                                if (options.verbose) console.warn('Multipolygon relation', rels[i].type + '/' + rels[i].id, 'ignored because outer way', outer_way.type + '/' + outer_way.ref, 'is missing');
                                continue; // abort if outer way object is not present
                            }
                            outer_way.is_skippablerelationmember = true;
                            feature = construct_multipolygon(outer_way, rels[i]);
                        }
                        if (feature === false) {
                            if (options.verbose) console.warn('Multipolygon relation', rels[i].type + '/' + rels[i].id, 'ignored because it has invalid geometry');
                            continue; // abort if feature could not be constructed
                        }
                        if (!featureCallback)
                            geojsonpolygons.push(feature);
                        else
                            featureCallback(rewind(feature));

                        function construct_multipolygon(tag_object, rel) {
                            var is_tainted = false;
                            var mp_geometry = simple_mp ? 'way' : 'relation',
                                mp_id = typeof tag_object.id === "number" ? tag_object.id : +(tag_object.id.replace("_fullGeom", ""));
                            // prepare mp members
                            var members;
                            members = rel.members.filter(function(m) {
                                return m.type === "way";
                            });
                            members = members.map(function(m) {
                                var way = wayids[m.ref];
                                if (way === undefined || way.nodes === undefined) { // check for missing ways
                                    if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'tainted by a missing or incomplete way', m.type + '/' + m.ref);
                                    is_tainted = true;
                                    return;
                                }
                                return { // TODO: this is slow! :(
                                    id: m.ref,
                                    role: m.role || "outer",
                                    way: way,
                                    nodes: way.nodes.filter(function(n) {
                                        if (n !== undefined)
                                            return true;
                                        is_tainted = true;
                                        if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'tainted by a way', m.type + '/' + m.ref, 'with a missing node');
                                        return false;
                                    })
                                };
                            });
                            members = _.compact(members);
                            // construct outer and inner rings
                            var outers, inners;
                            outers = join(members.filter(function(m) {
                                return m.role === "outer";
                            }));
                            inners = join(members.filter(function(m) {
                                return m.role === "inner";
                            }));
                            // sort rings
                            var mp;

                            function findOuter(inner) {
                                var polygonIntersectsPolygon = function(outer, inner) {
                                    for (var i = 0; i < inner.length; i++)
                                        if (pointInPolygon(inner[i], outer))
                                            return true;
                                    return false;
                                }
                                var mapCoordinates = function(from) {
                                    return from.map(function(n) {
                                        return [+n.lat, +n.lon];
                                    });
                                }
                                // stolen from iD/geo.js,
                                // based on https://github.com/substack/point-in-polygon,
                                // ray-casting algorithm based on http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                                var pointInPolygon = function(point, polygon) {
                                    var x = point[0],
                                        y = point[1],
                                        inside = false;
                                    for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                                        var xi = polygon[i][0],
                                            yi = polygon[i][1];
                                        var xj = polygon[j][0],
                                            yj = polygon[j][1];
                                        var intersect = ((yi > y) != (yj > y)) &&
                                            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                                        if (intersect) inside = !inside;
                                    }
                                    return inside;
                                };
                                // stolen from iD/relation.js
                                var o, outer;
                                // todo: all this coordinate mapping makes this unneccesarily slow.
                                // see the "todo: this is slow! :(" above.
                                inner = mapCoordinates(inner);
                                /*for (o = 0; o < outers.length; o++) {
                                  outer = mapCoordinates(outers[o]);
                                  if (polygonContainsPolygon(outer, inner))
                                    return o;
                                }*/
                                for (o = 0; o < outers.length; o++) {
                                    outer = mapCoordinates(outers[o]);
                                    if (polygonIntersectsPolygon(outer, inner))
                                        return o;
                                }
                            }
                            mp = outers.map(function(o) {
                                return [o];
                            });
                            for (var j = 0; j < inners.length; j++) {
                                var o = findOuter(inners[j]);
                                if (o !== undefined)
                                    mp[o].push(inners[j]);
                                else
                                if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains an inner ring with no containing outer');
                                // so, no outer ring for this inner ring is found.
                                // We're going to ignore holes in empty space.
                                ;
                            }
                            // sanitize mp-coordinates (remove empty clusters or rings, {lat,lon,...} to [lon,lat]
                            var mp_coords = [];
                            mp_coords = _.compact(mp.map(function(cluster) {
                                var cl = _.compact(cluster.map(function(ring) {
                                    if (ring.length < 4) { // todo: is this correct: ring.length < 4 ?
                                        if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains a ring with less than four nodes');
                                        return;
                                    }
                                    return _.compact(ring.map(function(node) {
                                        return [+node.lon, +node.lat];
                                    }));
                                }));
                                if (cl.length == 0) {
                                    if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains an empty ring cluster');
                                    return;
                                }
                                return cl;
                            }));

                            if (mp_coords.length == 0) {
                                if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains no coordinates');
                                return false; // ignore multipolygons without coordinates
                            }
                            var mp_type = "MultiPolygon";
                            if (mp_coords.length === 1) {
                                mp_type = "Polygon";
                                mp_coords = mp_coords[0];
                            }
                            // mp parsed, now construct the geoJSON
                            var feature = {
                                "type": "Feature",
                                "id": tag_object.type + "/" + mp_id,
                                "properties": {
                                    "type": tag_object.type,
                                    "id": mp_id,
                                    "tags": tag_object.tags || {},
                                    "relations": relsmap[tag_object.type][tag_object.id] || [],
                                    "meta": build_meta_information(tag_object)
                                },
                                "geometry": {
                                    "type": mp_type,
                                    "coordinates": mp_coords,
                                }
                            }
                            if (is_tainted) {
                                if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'is tainted');
                                feature.properties["tainted"] = true;
                            }
                            return feature;
                        }
                    }
                }
                // process lines and polygons
                for (var i = 0; i < ways.length; i++) {
                    // todo: refactor such that this loops over wayids instead of ways?
                    if (wayids[ways[i].id] !== ways[i]) {
                        // skip way because it's a deduplication artifact
                        continue;
                    }
                    if (!_.isArray(ways[i].nodes)) {
                        if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'ignored because it has no nodes');
                        continue; // ignore ways without nodes (e.g. returned by an ids_only query)
                    }
                    if (ways[i].is_skippablerelationmember)
                        continue; // ignore ways which are already rendered as (part of) a multipolygon
                    if (typeof ways[i].id !== "number") {
                        // remove full geometry namespace for output
                        ways[i].id = +ways[i].id.replace("_fullGeom", "");
                    }
                    ways[i].tainted = false;
                    ways[i].hidden = false;
                    var coords = new Array();
                    for (j = 0; j < ways[i].nodes.length; j++) {
                        if (typeof ways[i].nodes[j] == "object")
                            coords.push([+ways[i].nodes[j].lon, +ways[i].nodes[j].lat]);
                        else {
                            if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'is tainted by an invalid node');
                            ways[i].tainted = true;
                        }
                    }
                    if (coords.length <= 1) { // invalid way geometry
                        if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'ignored because it contains too few nodes');
                        continue;
                    }
                    var way_type = "LineString"; // default
                    if (typeof ways[i].nodes[0] != "undefined" && typeof ways[i].nodes[ways[i].nodes.length - 1] != "undefined" && // way has its start/end nodes loaded
                        ways[i].nodes[0].id === ways[i].nodes[ways[i].nodes.length - 1].id && // ... and forms a closed ring
                        (
                            typeof ways[i].tags != "undefined" && // ... and has tags
                            _isPolygonFeature(ways[i].tags) // ... and tags say it is a polygon
                            || // or is a placeholder for a bounds geometry
                            ways[i].__is_bounds_placeholder
                        )
                    ) {
                        way_type = "Polygon";
                        coords = [coords];
                    }
                    var feature = {
                        "type": "Feature",
                        "id": ways[i].type + "/" + ways[i].id,
                        "properties": {
                            "type": ways[i].type,
                            "id": ways[i].id,
                            "tags": ways[i].tags || {},
                            "relations": relsmap["way"][ways[i].id] || [],
                            "meta": build_meta_information(ways[i])
                        },
                        "geometry": {
                            "type": way_type,
                            "coordinates": coords,
                        }
                    }
                    if (ways[i].tainted) {
                        if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'is tainted');
                        feature.properties["tainted"] = true;
                    }
                    if (ways[i].__is_bounds_placeholder)
                        feature.properties["geometry"] = "bounds";
                    if (!featureCallback) {
                        if (way_type == "LineString")
                            geojsonlines.push(feature);
                        else
                            geojsonpolygons.push(feature);
                    } else {
                        featureCallback(rewind(feature));
                    }
                }

                if (featureCallback)
                    return true;

                geojson = {
                    "type": "FeatureCollection",
                    "features": []
                };
                geojson.features = geojson.features.concat(geojsonpolygons);
                geojson.features = geojson.features.concat(geojsonlines);
                geojson.features = geojson.features.concat(geojsonnodes);
                // optionally, flatten properties
                if (options.flatProperties) {
                    geojson.features.forEach(function(f) {
                        f.properties = _.merge(
                            f.properties.meta,
                            f.properties.tags, {
                                id: f.properties.type + "/" + f.properties.id
                            }
                        );
                    });
                }
                // fix polygon winding
                geojson = rewind(geojson);
                return geojson;
            }

            function _isPolygonFeature(tags) {
                var polygonFeatures = options.polygonFeatures;
                if (typeof polygonFeatures === "function")
                    return polygonFeatures(tags);
                // explicitely tagged non-areas
                if (tags['area'] === 'no')
                    return false;
                // assuming that a typical OSM way has in average less tags than
                // the polygonFeatures list, this way around should be faster
                for (var key in tags) {
                    var val = tags[key];
                    var pfk = polygonFeatures[key];
                    // continue with next if tag is unknown or not "categorizing"
                    if (typeof pfk === 'undefined')
                        continue;
                    // continue with next if tag is explicitely un-set ("building=no")
                    if (val === 'no')
                        continue;
                    // check polygon features for: general acceptance, included or excluded values
                    if (pfk === true)
                        return true;
                    if (pfk.included_values && pfk.included_values[val] === true)
                        return true;
                    if (pfk.excluded_values && pfk.excluded_values[val] !== true)
                        return true;
                }
                // if no tags matched, this ain't no area.
                return false;
            }
        };

        // helper that joins adjacent osm ways into linestrings or linear rings
        function join(ways) {
            var _first = function(arr) {
                return arr[0]
            };
            var _last = function(arr) {
                return arr[arr.length - 1]
            };
            // stolen from iD/relation.js
            var joined = [],
                current, first, last, i, how, what;
            while (ways.length) {
                current = ways.pop().nodes.slice();
                joined.push(current);
                while (ways.length && _first(current) !== _last(current)) {
                    first = _first(current);
                    last = _last(current);
                    for (i = 0; i < ways.length; i++) {
                        what = ways[i].nodes;
                        if (last === _first(what)) {
                            how = current.push;
                            what = what.slice(1);
                            break;
                        } else if (last === _last(what)) {
                            how = current.push;
                            what = what.slice(0, -1).reverse();
                            break;
                        } else if (first == _last(what)) {
                            how = current.unshift;
                            what = what.slice(0, -1);
                            break;
                        } else if (first == _first(what)) {
                            how = current.unshift;
                            what = what.slice(1).reverse();
                            break;
                        } else {
                            what = how = null;
                        }
                    }
                    if (!what)
                        break; // Invalid geometry (dangling way, unclosed ring)
                    ways.splice(i, 1);
                    how.apply(current, what);
                }
            }
            return joined;
        }

        // for backwards compatibility
        osmtogeojson.toGeojson = osmtogeojson;

        module.exports = osmtogeojson;


        /***/
    }),
    /* 30 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global, module) {
            /**
             * @license
             * lodash (Custom Build) <https://lodash.com/>
             * Build: `lodash exports="node" include="clone,merge,isEmpty,isArray,compact,each" -d`
             * Copyright jQuery Foundation and other contributors <https://jquery.org/>
             * Released under MIT license <https://lodash.com/license>
             * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
             * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             */
            ;
            (function() {

                /** Used as a safe reference for `undefined` in pre-ES5 environments. */
                var undefined;

                /** Used as the semantic version number. */
                var VERSION = '4.15.0';

                /** Used as the size to enable large array optimizations. */
                var LARGE_ARRAY_SIZE = 200;

                /** Used as the `TypeError` message for "Functions" methods. */
                var FUNC_ERROR_TEXT = 'Expected a function';

                /** Used to stand-in for `undefined` hash values. */
                var HASH_UNDEFINED = '__lodash_hash_undefined__';

                /** Used to compose bitmasks for comparison styles. */
                var UNORDERED_COMPARE_FLAG = 1,
                    PARTIAL_COMPARE_FLAG = 2;

                /** Used as references for various `Number` constants. */
                var INFINITY = 1 / 0,
                    MAX_SAFE_INTEGER = 9007199254740991;

                /** `Object#toString` result references. */
                var argsTag = '[object Arguments]',
                    arrayTag = '[object Array]',
                    boolTag = '[object Boolean]',
                    dateTag = '[object Date]',
                    errorTag = '[object Error]',
                    funcTag = '[object Function]',
                    genTag = '[object GeneratorFunction]',
                    mapTag = '[object Map]',
                    numberTag = '[object Number]',
                    objectTag = '[object Object]',
                    promiseTag = '[object Promise]',
                    regexpTag = '[object RegExp]',
                    setTag = '[object Set]',
                    stringTag = '[object String]',
                    symbolTag = '[object Symbol]',
                    weakMapTag = '[object WeakMap]';

                var arrayBufferTag = '[object ArrayBuffer]',
                    dataViewTag = '[object DataView]',
                    float32Tag = '[object Float32Array]',
                    float64Tag = '[object Float64Array]',
                    int8Tag = '[object Int8Array]',
                    int16Tag = '[object Int16Array]',
                    int32Tag = '[object Int32Array]',
                    uint8Tag = '[object Uint8Array]',
                    uint8ClampedTag = '[object Uint8ClampedArray]',
                    uint16Tag = '[object Uint16Array]',
                    uint32Tag = '[object Uint32Array]';

                /** Used to match property names within property paths. */
                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                    reIsPlainProp = /^\w*$/,
                    reLeadingDot = /^\./,
                    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

                /**
                 * Used to match `RegExp`
                 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                 */
                var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

                /** Used to match backslashes in property paths. */
                var reEscapeChar = /\\(\\)?/g;

                /** Used to match `RegExp` flags from their coerced string values. */
                var reFlags = /\w*$/;

                /** Used to detect host constructors (Safari). */
                var reIsHostCtor = /^\[object .+?Constructor\]$/;

                /** Used to detect unsigned integer values. */
                var reIsUint = /^(?:0|[1-9]\d*)$/;

                /** Used to identify `toStringTag` values of typed arrays. */
                var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                    typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
                    typedArrayTags[errorTag] = typedArrayTags[funcTag] =
                    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
                    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
                    typedArrayTags[setTag] = typedArrayTags[stringTag] =
                    typedArrayTags[weakMapTag] = false;

                /** Used to identify `toStringTag` values supported by `_.clone`. */
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] =
                    cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
                    cloneableTags[boolTag] = cloneableTags[dateTag] =
                    cloneableTags[float32Tag] = cloneableTags[float64Tag] =
                    cloneableTags[int8Tag] = cloneableTags[int16Tag] =
                    cloneableTags[int32Tag] = cloneableTags[mapTag] =
                    cloneableTags[numberTag] = cloneableTags[objectTag] =
                    cloneableTags[regexpTag] = cloneableTags[setTag] =
                    cloneableTags[stringTag] = cloneableTags[symbolTag] =
                    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] =
                    cloneableTags[weakMapTag] = false;

                /** Detect free variable `global` from Node.js. */
                var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

                /** Detect free variable `self`. */
                var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

                /** Used as a reference to the global object. */
                var root = freeGlobal || freeSelf || Function('return this')();

                /** Detect free variable `exports`. */
                var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

                /** Detect free variable `module`. */
                var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports = freeModule && freeModule.exports === freeExports;

                /** Detect free variable `process` from Node.js. */
                var freeProcess = moduleExports && freeGlobal.process;

                /** Used to access faster Node.js helpers. */
                var nodeUtil = (function() {
                    try {
                        return freeProcess && freeProcess.binding('util');
                    } catch (e) {}
                }());

                /* Node.js helper references. */
                var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

                /*--------------------------------------------------------------------------*/

                /**
                 * Adds the key-value `pair` to `map`.
                 *
                 * @private
                 * @param {Object} map The map to modify.
                 * @param {Array} pair The key-value pair to add.
                 * @returns {Object} Returns `map`.
                 */
                function addMapEntry(map, pair) {
                    // Don't return `map.set` because it's not chainable in IE 11.
                    map.set(pair[0], pair[1]);
                    return map;
                }

                /**
                 * Adds `value` to `set`.
                 *
                 * @private
                 * @param {Object} set The set to modify.
                 * @param {*} value The value to add.
                 * @returns {Object} Returns `set`.
                 */
                function addSetEntry(set, value) {
                    // Don't return `set.add` because it's not chainable in IE 11.
                    set.add(value);
                    return set;
                }

                /**
                 * A faster alternative to `Function#apply`, this function invokes `func`
                 * with the `this` binding of `thisArg` and the arguments of `args`.
                 *
                 * @private
                 * @param {Function} func The function to invoke.
                 * @param {*} thisArg The `this` binding of `func`.
                 * @param {Array} args The arguments to invoke `func` with.
                 * @returns {*} Returns the result of `func`.
                 */
                function apply(func, thisArg, args) {
                    switch (args.length) {
                        case 0:
                            return func.call(thisArg);
                        case 1:
                            return func.call(thisArg, args[0]);
                        case 2:
                            return func.call(thisArg, args[0], args[1]);
                        case 3:
                            return func.call(thisArg, args[0], args[1], args[2]);
                    }
                    return func.apply(thisArg, args);
                }

                /**
                 * A specialized version of `_.forEach` for arrays without support for
                 * iteratee shorthands.
                 *
                 * @private
                 * @param {Array} [array] The array to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array} Returns `array`.
                 */
                function arrayEach(array, iteratee) {
                    var index = -1,
                        length = array ? array.length : 0;

                    while (++index < length) {
                        if (iteratee(array[index], index, array) === false) {
                            break;
                        }
                    }
                    return array;
                }

                /**
                 * Appends the elements of `values` to `array`.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to append.
                 * @returns {Array} Returns `array`.
                 */
                function arrayPush(array, values) {
                    var index = -1,
                        length = values.length,
                        offset = array.length;

                    while (++index < length) {
                        array[offset + index] = values[index];
                    }
                    return array;
                }

                /**
                 * A specialized version of `_.reduce` for arrays without support for
                 * iteratee shorthands.
                 *
                 * @private
                 * @param {Array} [array] The array to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @param {*} [accumulator] The initial value.
                 * @param {boolean} [initAccum] Specify using the first element of `array` as
                 *  the initial value.
                 * @returns {*} Returns the accumulated value.
                 */
                function arrayReduce(array, iteratee, accumulator, initAccum) {
                    var index = -1,
                        length = array ? array.length : 0;

                    if (initAccum && length) {
                        accumulator = array[++index];
                    }
                    while (++index < length) {
                        accumulator = iteratee(accumulator, array[index], index, array);
                    }
                    return accumulator;
                }

                /**
                 * A specialized version of `_.some` for arrays without support for iteratee
                 * shorthands.
                 *
                 * @private
                 * @param {Array} [array] The array to iterate over.
                 * @param {Function} predicate The function invoked per iteration.
                 * @returns {boolean} Returns `true` if any element passes the predicate check,
                 *  else `false`.
                 */
                function arraySome(array, predicate) {
                    var index = -1,
                        length = array ? array.length : 0;

                    while (++index < length) {
                        if (predicate(array[index], index, array)) {
                            return true;
                        }
                    }
                    return false;
                }

                /**
                 * The base implementation of `_.property` without support for deep paths.
                 *
                 * @private
                 * @param {string} key The key of the property to get.
                 * @returns {Function} Returns the new accessor function.
                 */
                function baseProperty(key) {
                    return function(object) {
                        return object == null ? undefined : object[key];
                    };
                }

                /**
                 * The base implementation of `_.times` without support for iteratee shorthands
                 * or max array length checks.
                 *
                 * @private
                 * @param {number} n The number of times to invoke `iteratee`.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array} Returns the array of results.
                 */
                function baseTimes(n, iteratee) {
                    var index = -1,
                        result = Array(n);

                    while (++index < n) {
                        result[index] = iteratee(index);
                    }
                    return result;
                }

                /**
                 * The base implementation of `_.unary` without support for storing metadata.
                 *
                 * @private
                 * @param {Function} func The function to cap arguments for.
                 * @returns {Function} Returns the new capped function.
                 */
                function baseUnary(func) {
                    return function(value) {
                        return func(value);
                    };
                }

                /**
                 * Gets the value at `key` of `object`.
                 *
                 * @private
                 * @param {Object} [object] The object to query.
                 * @param {string} key The key of the property to get.
                 * @returns {*} Returns the property value.
                 */
                function getValue(object, key) {
                    return object == null ? undefined : object[key];
                }

                /**
                 * Checks if `value` is a host object in IE < 9.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
                 */
                function isHostObject(value) {
                    // Many host objects are `Object` objects that can coerce to strings
                    // despite having improperly defined `toString` methods.
                    var result = false;
                    if (value != null && typeof value.toString != 'function') {
                        try {
                            result = !!(value + '');
                        } catch (e) {}
                    }
                    return result;
                }

                /**
                 * Converts `map` to its key-value pairs.
                 *
                 * @private
                 * @param {Object} map The map to convert.
                 * @returns {Array} Returns the key-value pairs.
                 */
                function mapToArray(map) {
                    var index = -1,
                        result = Array(map.size);

                    map.forEach(function(value, key) {
                        result[++index] = [key, value];
                    });
                    return result;
                }

                /**
                 * Creates a unary function that invokes `func` with its argument transformed.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {Function} transform The argument transform.
                 * @returns {Function} Returns the new function.
                 */
                function overArg(func, transform) {
                    return function(arg) {
                        return func(transform(arg));
                    };
                }

                /**
                 * Converts `set` to an array of its values.
                 *
                 * @private
                 * @param {Object} set The set to convert.
                 * @returns {Array} Returns the values.
                 */
                function setToArray(set) {
                    var index = -1,
                        result = Array(set.size);

                    set.forEach(function(value) {
                        result[++index] = value;
                    });
                    return result;
                }

                /*--------------------------------------------------------------------------*/

                /** Used for built-in method references. */
                var arrayProto = Array.prototype,
                    funcProto = Function.prototype,
                    objectProto = Object.prototype;

                /** Used to detect overreaching core-js shims. */
                var coreJsData = root['__core-js_shared__'];

                /** Used to detect methods masquerading as native. */
                var maskSrcKey = (function() {
                    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                    return uid ? ('Symbol(src)_1.' + uid) : '';
                }());

                /** Used to resolve the decompiled source of functions. */
                var funcToString = funcProto.toString;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /** Used to infer the `Object` constructor. */
                var objectCtorString = funcToString.call(Object);

                /**
                 * Used to resolve the
                 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objectToString = objectProto.toString;

                /** Used to detect if a method is native. */
                var reIsNative = RegExp('^' +
                    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
                    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                );

                /** Built-in value references. */
                var Buffer = moduleExports ? root.Buffer : undefined,
                    Symbol = root.Symbol,
                    Uint8Array = root.Uint8Array,
                    getPrototype = overArg(Object.getPrototypeOf, Object),
                    objectCreate = Object.create,
                    propertyIsEnumerable = objectProto.propertyIsEnumerable,
                    splice = arrayProto.splice;

                /* Built-in method references for those with the same name as other `lodash` methods. */
                var nativeGetSymbols = Object.getOwnPropertySymbols,
                    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
                    nativeKeys = overArg(Object.keys, Object),
                    nativeMax = Math.max;

                /* Built-in method references that are verified to be native. */
                var DataView = getNative(root, 'DataView'),
                    Map = getNative(root, 'Map'),
                    Promise = getNative(root, 'Promise'),
                    Set = getNative(root, 'Set'),
                    WeakMap = getNative(root, 'WeakMap'),
                    nativeCreate = getNative(Object, 'create');

                /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
                var nonEnumShadows = !propertyIsEnumerable.call({
                    'valueOf': 1
                }, 'valueOf');

                /** Used to lookup unminified function names. */
                var realNames = {};

                /** Used to detect maps, sets, and weakmaps. */
                var dataViewCtorString = toSource(DataView),
                    mapCtorString = toSource(Map),
                    promiseCtorString = toSource(Promise),
                    setCtorString = toSource(Set),
                    weakMapCtorString = toSource(WeakMap);

                /** Used to convert symbols to primitives and strings. */
                var symbolProto = Symbol ? Symbol.prototype : undefined,
                    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
                    symbolToString = symbolProto ? symbolProto.toString : undefined;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a `lodash` object which wraps `value` to enable implicit method
                 * chain sequences. Methods that operate on and return arrays, collections,
                 * and functions can be chained together. Methods that retrieve a single value
                 * or may return a primitive value will automatically end the chain sequence
                 * and return the unwrapped value. Otherwise, the value must be unwrapped
                 * with `_#value`.
                 *
                 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
                 * enabled using `_.chain`.
                 *
                 * The execution of chained methods is lazy, that is, it's deferred until
                 * `_#value` is implicitly or explicitly called.
                 *
                 * Lazy evaluation allows several methods to support shortcut fusion.
                 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
                 * the creation of intermediate arrays and can greatly reduce the number of
                 * iteratee executions. Sections of a chain sequence qualify for shortcut
                 * fusion if the section is applied to an array of at least `200` elements
                 * and any iteratees accept only one argument. The heuristic for whether a
                 * section qualifies for shortcut fusion is subject to change.
                 *
                 * Chaining is supported in custom builds as long as the `_#value` method is
                 * directly or indirectly included in the build.
                 *
                 * In addition to lodash methods, wrappers have `Array` and `String` methods.
                 *
                 * The wrapper `Array` methods are:
                 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
                 *
                 * The wrapper `String` methods are:
                 * `replace` and `split`
                 *
                 * The wrapper methods that support shortcut fusion are:
                 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
                 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
                 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
                 *
                 * The chainable wrapper methods are:
                 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
                 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
                 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
                 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
                 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
                 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
                 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
                 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
                 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
                 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
                 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
                 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
                 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
                 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
                 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
                 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
                 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
                 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
                 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
                 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
                 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
                 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
                 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
                 * `zipObject`, `zipObjectDeep`, and `zipWith`
                 *
                 * The wrapper methods that are **not** chainable by default are:
                 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
                 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
                 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
                 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
                 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
                 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
                 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
                 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
                 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
                 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
                 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
                 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
                 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
                 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
                 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
                 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
                 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
                 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
                 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
                 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
                 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
                 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
                 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
                 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
                 * `upperFirst`, `value`, and `words`
                 *
                 * @name _
                 * @constructor
                 * @category Seq
                 * @param {*} value The value to wrap in a `lodash` instance.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * function square(n) {
                 *   return n * n;
                 * }
                 *
                 * var wrapped = _([1, 2, 3]);
                 *
                 * // Returns an unwrapped value.
                 * wrapped.reduce(_.add);
                 * // => 6
                 *
                 * // Returns a wrapped value.
                 * var squares = wrapped.map(square);
                 *
                 * _.isArray(squares);
                 * // => false
                 *
                 * _.isArray(squares.value());
                 * // => true
                 */
                function lodash() {
                    // No operation performed.
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a hash object.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [entries] The key-value pairs to cache.
                 */
                function Hash(entries) {
                    var index = -1,
                        length = entries ? entries.length : 0;

                    this.clear();
                    while (++index < length) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }

                /**
                 * Removes all key-value entries from the hash.
                 *
                 * @private
                 * @name clear
                 * @memberOf Hash
                 */
                function hashClear() {
                    this.__data__ = nativeCreate ? nativeCreate(null) : {};
                }

                /**
                 * Removes `key` and its value from the hash.
                 *
                 * @private
                 * @name delete
                 * @memberOf Hash
                 * @param {Object} hash The hash to modify.
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function hashDelete(key) {
                    return this.has(key) && delete this.__data__[key];
                }

                /**
                 * Gets the hash value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf Hash
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function hashGet(key) {
                    var data = this.__data__;
                    if (nativeCreate) {
                        var result = data[key];
                        return result === HASH_UNDEFINED ? undefined : result;
                    }
                    return hasOwnProperty.call(data, key) ? data[key] : undefined;
                }

                /**
                 * Checks if a hash value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf Hash
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function hashHas(key) {
                    var data = this.__data__;
                    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
                }

                /**
                 * Sets the hash `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf Hash
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the hash instance.
                 */
                function hashSet(key, value) {
                    var data = this.__data__;
                    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
                    return this;
                }

                // Add methods to `Hash`.
                Hash.prototype.clear = hashClear;
                Hash.prototype['delete'] = hashDelete;
                Hash.prototype.get = hashGet;
                Hash.prototype.has = hashHas;
                Hash.prototype.set = hashSet;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an list cache object.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [entries] The key-value pairs to cache.
                 */
                function ListCache(entries) {
                    var index = -1,
                        length = entries ? entries.length : 0;

                    this.clear();
                    while (++index < length) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }

                /**
                 * Removes all key-value entries from the list cache.
                 *
                 * @private
                 * @name clear
                 * @memberOf ListCache
                 */
                function listCacheClear() {
                    this.__data__ = [];
                }

                /**
                 * Removes `key` and its value from the list cache.
                 *
                 * @private
                 * @name delete
                 * @memberOf ListCache
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function listCacheDelete(key) {
                    var data = this.__data__,
                        index = assocIndexOf(data, key);

                    if (index < 0) {
                        return false;
                    }
                    var lastIndex = data.length - 1;
                    if (index == lastIndex) {
                        data.pop();
                    } else {
                        splice.call(data, index, 1);
                    }
                    return true;
                }

                /**
                 * Gets the list cache value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf ListCache
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function listCacheGet(key) {
                    var data = this.__data__,
                        index = assocIndexOf(data, key);

                    return index < 0 ? undefined : data[index][1];
                }

                /**
                 * Checks if a list cache value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf ListCache
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function listCacheHas(key) {
                    return assocIndexOf(this.__data__, key) > -1;
                }

                /**
                 * Sets the list cache `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf ListCache
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the list cache instance.
                 */
                function listCacheSet(key, value) {
                    var data = this.__data__,
                        index = assocIndexOf(data, key);

                    if (index < 0) {
                        data.push([key, value]);
                    } else {
                        data[index][1] = value;
                    }
                    return this;
                }

                // Add methods to `ListCache`.
                ListCache.prototype.clear = listCacheClear;
                ListCache.prototype['delete'] = listCacheDelete;
                ListCache.prototype.get = listCacheGet;
                ListCache.prototype.has = listCacheHas;
                ListCache.prototype.set = listCacheSet;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a map cache object to store key-value pairs.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [entries] The key-value pairs to cache.
                 */
                function MapCache(entries) {
                    var index = -1,
                        length = entries ? entries.length : 0;

                    this.clear();
                    while (++index < length) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }

                /**
                 * Removes all key-value entries from the map.
                 *
                 * @private
                 * @name clear
                 * @memberOf MapCache
                 */
                function mapCacheClear() {
                    this.__data__ = {
                        'hash': new Hash,
                        'map': new(Map || ListCache),
                        'string': new Hash
                    };
                }

                /**
                 * Removes `key` and its value from the map.
                 *
                 * @private
                 * @name delete
                 * @memberOf MapCache
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function mapCacheDelete(key) {
                    return getMapData(this, key)['delete'](key);
                }

                /**
                 * Gets the map value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf MapCache
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function mapCacheGet(key) {
                    return getMapData(this, key).get(key);
                }

                /**
                 * Checks if a map value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf MapCache
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function mapCacheHas(key) {
                    return getMapData(this, key).has(key);
                }

                /**
                 * Sets the map `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf MapCache
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the map cache instance.
                 */
                function mapCacheSet(key, value) {
                    getMapData(this, key).set(key, value);
                    return this;
                }

                // Add methods to `MapCache`.
                MapCache.prototype.clear = mapCacheClear;
                MapCache.prototype['delete'] = mapCacheDelete;
                MapCache.prototype.get = mapCacheGet;
                MapCache.prototype.has = mapCacheHas;
                MapCache.prototype.set = mapCacheSet;

                /*------------------------------------------------------------------------*/

                /**
                 *
                 * Creates an array cache object to store unique values.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [values] The values to cache.
                 */
                function SetCache(values) {
                    var index = -1,
                        length = values ? values.length : 0;

                    this.__data__ = new MapCache;
                    while (++index < length) {
                        this.add(values[index]);
                    }
                }

                /**
                 * Adds `value` to the array cache.
                 *
                 * @private
                 * @name add
                 * @memberOf SetCache
                 * @alias push
                 * @param {*} value The value to cache.
                 * @returns {Object} Returns the cache instance.
                 */
                function setCacheAdd(value) {
                    this.__data__.set(value, HASH_UNDEFINED);
                    return this;
                }

                /**
                 * Checks if `value` is in the array cache.
                 *
                 * @private
                 * @name has
                 * @memberOf SetCache
                 * @param {*} value The value to search for.
                 * @returns {number} Returns `true` if `value` is found, else `false`.
                 */
                function setCacheHas(value) {
                    return this.__data__.has(value);
                }

                // Add methods to `SetCache`.
                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                SetCache.prototype.has = setCacheHas;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a stack cache object to store key-value pairs.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [entries] The key-value pairs to cache.
                 */
                function Stack(entries) {
                    this.__data__ = new ListCache(entries);
                }

                /**
                 * Removes all key-value entries from the stack.
                 *
                 * @private
                 * @name clear
                 * @memberOf Stack
                 */
                function stackClear() {
                    this.__data__ = new ListCache;
                }

                /**
                 * Removes `key` and its value from the stack.
                 *
                 * @private
                 * @name delete
                 * @memberOf Stack
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function stackDelete(key) {
                    return this.__data__['delete'](key);
                }

                /**
                 * Gets the stack value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf Stack
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function stackGet(key) {
                    return this.__data__.get(key);
                }

                /**
                 * Checks if a stack value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf Stack
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function stackHas(key) {
                    return this.__data__.has(key);
                }

                /**
                 * Sets the stack `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf Stack
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the stack cache instance.
                 */
                function stackSet(key, value) {
                    var cache = this.__data__;
                    if (cache instanceof ListCache) {
                        var pairs = cache.__data__;
                        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                            pairs.push([key, value]);
                            return this;
                        }
                        cache = this.__data__ = new MapCache(pairs);
                    }
                    cache.set(key, value);
                    return this;
                }

                // Add methods to `Stack`.
                Stack.prototype.clear = stackClear;
                Stack.prototype['delete'] = stackDelete;
                Stack.prototype.get = stackGet;
                Stack.prototype.has = stackHas;
                Stack.prototype.set = stackSet;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an array of the enumerable property names of the array-like `value`.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @param {boolean} inherited Specify returning inherited property names.
                 * @returns {Array} Returns the array of property names.
                 */
                function arrayLikeKeys(value, inherited) {
                    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                    // Safari 9 makes `arguments.length` enumerable in strict mode.
                    var result = (isArray(value) || isArguments(value)) ?
                        baseTimes(value.length, String) :
                        [];

                    var length = result.length,
                        skipIndexes = !!length;

                    for (var key in value) {
                        if ((inherited || hasOwnProperty.call(value, key)) &&
                            !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
                            result.push(key);
                        }
                    }
                    return result;
                }

                /**
                 * This function is like `assignValue` except that it doesn't assign
                 * `undefined` values.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {string} key The key of the property to assign.
                 * @param {*} value The value to assign.
                 */
                function assignMergeValue(object, key, value) {
                    if ((value !== undefined && !eq(object[key], value)) ||
                        (typeof key == 'number' && value === undefined && !(key in object))) {
                        object[key] = value;
                    }
                }

                /**
                 * Assigns `value` to `key` of `object` if the existing value is not equivalent
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {string} key The key of the property to assign.
                 * @param {*} value The value to assign.
                 */
                function assignValue(object, key, value) {
                    var objValue = object[key];
                    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                        (value === undefined && !(key in object))) {
                        object[key] = value;
                    }
                }

                /**
                 * Gets the index at which the `key` is found in `array` of key-value pairs.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {*} key The key to search for.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function assocIndexOf(array, key) {
                    var length = array.length;
                    while (length--) {
                        if (eq(array[length][0], key)) {
                            return length;
                        }
                    }
                    return -1;
                }

                /**
                 * The base implementation of `_.assign` without support for multiple sources
                 * or `customizer` functions.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @returns {Object} Returns `object`.
                 */
                function baseAssign(object, source) {
                    return object && copyObject(source, keys(source), object);
                }

                /**
                 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                 * traversed objects.
                 *
                 * @private
                 * @param {*} value The value to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @param {boolean} [isFull] Specify a clone including symbols.
                 * @param {Function} [customizer] The function to customize cloning.
                 * @param {string} [key] The key of `value`.
                 * @param {Object} [object] The parent object of `value`.
                 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                 * @returns {*} Returns the cloned value.
                 */
                function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
                    var result;
                    if (customizer) {
                        result = object ? customizer(value, key, object, stack) : customizer(value);
                    }
                    if (result !== undefined) {
                        return result;
                    }
                    if (!isObject(value)) {
                        return value;
                    }
                    var isArr = isArray(value);
                    if (isArr) {
                        result = initCloneArray(value);
                        if (!isDeep) {
                            return copyArray(value, result);
                        }
                    } else {
                        var tag = getTag(value),
                            isFunc = tag == funcTag || tag == genTag;

                        if (isBuffer(value)) {
                            return cloneBuffer(value, isDeep);
                        }
                        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                            if (isHostObject(value)) {
                                return object ? value : {};
                            }
                            result = initCloneObject(isFunc ? {} : value);
                            if (!isDeep) {
                                return copySymbols(value, baseAssign(result, value));
                            }
                        } else {
                            if (!cloneableTags[tag]) {
                                return object ? value : {};
                            }
                            result = initCloneByTag(value, tag, baseClone, isDeep);
                        }
                    }
                    // Check for circular references and return its corresponding clone.
                    stack || (stack = new Stack);
                    var stacked = stack.get(value);
                    if (stacked) {
                        return stacked;
                    }
                    stack.set(value, result);

                    if (!isArr) {
                        var props = isFull ? getAllKeys(value) : keys(value);
                    }
                    arrayEach(props || value, function(subValue, key) {
                        if (props) {
                            key = subValue;
                            subValue = value[key];
                        }
                        // Recursively populate clone (susceptible to call stack limits).
                        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
                    });
                    return result;
                }

                /**
                 * The base implementation of `_.create` without support for assigning
                 * properties to the created object.
                 *
                 * @private
                 * @param {Object} prototype The object to inherit from.
                 * @returns {Object} Returns the new object.
                 */
                function baseCreate(proto) {
                    return isObject(proto) ? objectCreate(proto) : {};
                }

                /**
                 * The base implementation of `_.forEach` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 */
                var baseEach = createBaseEach(baseForOwn);

                /**
                 * The base implementation of `baseForOwn` which iterates over `object`
                 * properties returned by `keysFunc` and invokes `iteratee` for each property.
                 * Iteratee functions may exit iteration early by explicitly returning `false`.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @returns {Object} Returns `object`.
                 */
                var baseFor = createBaseFor();

                /**
                 * The base implementation of `_.forOwn` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 */
                function baseForOwn(object, iteratee) {
                    return object && baseFor(object, iteratee, keys);
                }

                /**
                 * The base implementation of `_.get` without support for default values.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to get.
                 * @returns {*} Returns the resolved value.
                 */
                function baseGet(object, path) {
                    path = isKey(path, object) ? [path] : castPath(path);

                    var index = 0,
                        length = path.length;

                    while (object != null && index < length) {
                        object = object[toKey(path[index++])];
                    }
                    return (index && index == length) ? object : undefined;
                }

                /**
                 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                 * symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @param {Function} symbolsFunc The function to get the symbols of `object`.
                 * @returns {Array} Returns the array of property names and symbols.
                 */
                function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                    var result = keysFunc(object);
                    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
                }

                /**
                 * The base implementation of `getTag`.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @returns {string} Returns the `toStringTag`.
                 */
                function baseGetTag(value) {
                    return objectToString.call(value);
                }

                /**
                 * The base implementation of `_.hasIn` without support for deep paths.
                 *
                 * @private
                 * @param {Object} [object] The object to query.
                 * @param {Array|string} key The key to check.
                 * @returns {boolean} Returns `true` if `key` exists, else `false`.
                 */
                function baseHasIn(object, key) {
                    return object != null && key in Object(object);
                }

                /**
                 * The base implementation of `_.isEqual` which supports partial comparisons
                 * and tracks traversed objects.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @param {boolean} [bitmask] The bitmask of comparison flags.
                 *  The bitmask may be composed of the following flags:
                 *     1 - Unordered comparison
                 *     2 - Partial comparison
                 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 */
                function baseIsEqual(value, other, customizer, bitmask, stack) {
                    if (value === other) {
                        return true;
                    }
                    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                        return value !== value && other !== other;
                    }
                    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
                }

                /**
                 * A specialized version of `baseIsEqual` for arrays and objects which performs
                 * deep comparisons and tracks traversed objects enabling objects with circular
                 * references to be compared.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
                 *  for more details.
                 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
                    var objIsArr = isArray(object),
                        othIsArr = isArray(other),
                        objTag = arrayTag,
                        othTag = arrayTag;

                    if (!objIsArr) {
                        objTag = getTag(object);
                        objTag = objTag == argsTag ? objectTag : objTag;
                    }
                    if (!othIsArr) {
                        othTag = getTag(other);
                        othTag = othTag == argsTag ? objectTag : othTag;
                    }
                    var objIsObj = objTag == objectTag && !isHostObject(object),
                        othIsObj = othTag == objectTag && !isHostObject(other),
                        isSameTag = objTag == othTag;

                    if (isSameTag && !objIsObj) {
                        stack || (stack = new Stack);
                        return (objIsArr || isTypedArray(object)) ?
                            equalArrays(object, other, equalFunc, customizer, bitmask, stack) :
                            equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
                    }
                    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                        if (objIsWrapped || othIsWrapped) {
                            var objUnwrapped = objIsWrapped ? object.value() : object,
                                othUnwrapped = othIsWrapped ? other.value() : other;

                            stack || (stack = new Stack);
                            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
                        }
                    }
                    if (!isSameTag) {
                        return false;
                    }
                    stack || (stack = new Stack);
                    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
                }

                /**
                 * The base implementation of `_.isMatch` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property values to match.
                 * @param {Array} matchData The property names, values, and compare flags to match.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                 */
                function baseIsMatch(object, source, matchData, customizer) {
                    var index = matchData.length,
                        length = index,
                        noCustomizer = !customizer;

                    if (object == null) {
                        return !length;
                    }
                    object = Object(object);
                    while (index--) {
                        var data = matchData[index];
                        if ((noCustomizer && data[2]) ?
                            data[1] !== object[data[0]] :
                            !(data[0] in object)
                        ) {
                            return false;
                        }
                    }
                    while (++index < length) {
                        data = matchData[index];
                        var key = data[0],
                            objValue = object[key],
                            srcValue = data[1];

                        if (noCustomizer && data[2]) {
                            if (objValue === undefined && !(key in object)) {
                                return false;
                            }
                        } else {
                            var stack = new Stack;
                            if (customizer) {
                                var result = customizer(objValue, srcValue, key, object, source, stack);
                            }
                            if (!(result === undefined ?
                                    baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) :
                                    result
                                )) {
                                return false;
                            }
                        }
                    }
                    return true;
                }

                /**
                 * The base implementation of `_.isNative` without bad shim checks.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a native function,
                 *  else `false`.
                 */
                function baseIsNative(value) {
                    if (!isObject(value) || isMasked(value)) {
                        return false;
                    }
                    var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
                    return pattern.test(toSource(value));
                }

                /**
                 * The base implementation of `_.isTypedArray` without Node.js optimizations.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                 */
                function baseIsTypedArray(value) {
                    return isObjectLike(value) &&
                        isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
                }

                /**
                 * The base implementation of `_.iteratee`.
                 *
                 * @private
                 * @param {*} [value=_.identity] The value to convert to an iteratee.
                 * @returns {Function} Returns the iteratee.
                 */
                function baseIteratee(value) {
                    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                    if (typeof value == 'function') {
                        return value;
                    }
                    if (value == null) {
                        return identity;
                    }
                    if (typeof value == 'object') {
                        return isArray(value) ?
                            baseMatchesProperty(value[0], value[1]) :
                            baseMatches(value);
                    }
                    return property(value);
                }

                /**
                 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function baseKeys(object) {
                    if (!isPrototype(object)) {
                        return nativeKeys(object);
                    }
                    var result = [];
                    for (var key in Object(object)) {
                        if (hasOwnProperty.call(object, key) && key != 'constructor') {
                            result.push(key);
                        }
                    }
                    return result;
                }

                /**
                 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function baseKeysIn(object) {
                    if (!isObject(object)) {
                        return nativeKeysIn(object);
                    }
                    var isProto = isPrototype(object),
                        result = [];

                    for (var key in object) {
                        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                            result.push(key);
                        }
                    }
                    return result;
                }

                /**
                 * The base implementation of `_.matches` which doesn't clone `source`.
                 *
                 * @private
                 * @param {Object} source The object of property values to match.
                 * @returns {Function} Returns the new spec function.
                 */
                function baseMatches(source) {
                    var matchData = getMatchData(source);
                    if (matchData.length == 1 && matchData[0][2]) {
                        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                    }
                    return function(object) {
                        return object === source || baseIsMatch(object, source, matchData);
                    };
                }

                /**
                 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
                 *
                 * @private
                 * @param {string} path The path of the property to get.
                 * @param {*} srcValue The value to match.
                 * @returns {Function} Returns the new spec function.
                 */
                function baseMatchesProperty(path, srcValue) {
                    if (isKey(path) && isStrictComparable(srcValue)) {
                        return matchesStrictComparable(toKey(path), srcValue);
                    }
                    return function(object) {
                        var objValue = get(object, path);
                        return (objValue === undefined && objValue === srcValue) ?
                            hasIn(object, path) :
                            baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
                    };
                }

                /**
                 * The base implementation of `_.merge` without support for multiple sources.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @param {number} srcIndex The index of `source`.
                 * @param {Function} [customizer] The function to customize merged values.
                 * @param {Object} [stack] Tracks traversed source values and their merged
                 *  counterparts.
                 */
                function baseMerge(object, source, srcIndex, customizer, stack) {
                    if (object === source) {
                        return;
                    }
                    if (!(isArray(source) || isTypedArray(source))) {
                        var props = baseKeysIn(source);
                    }
                    arrayEach(props || source, function(srcValue, key) {
                        if (props) {
                            key = srcValue;
                            srcValue = source[key];
                        }
                        if (isObject(srcValue)) {
                            stack || (stack = new Stack);
                            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                        } else {
                            var newValue = customizer ?
                                customizer(object[key], srcValue, (key + ''), object, source, stack) :
                                undefined;

                            if (newValue === undefined) {
                                newValue = srcValue;
                            }
                            assignMergeValue(object, key, newValue);
                        }
                    });
                }

                /**
                 * A specialized version of `baseMerge` for arrays and objects which performs
                 * deep merges and tracks traversed objects enabling objects with circular
                 * references to be merged.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @param {string} key The key of the value to merge.
                 * @param {number} srcIndex The index of `source`.
                 * @param {Function} mergeFunc The function to merge values.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @param {Object} [stack] Tracks traversed source values and their merged
                 *  counterparts.
                 */
                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                    var objValue = object[key],
                        srcValue = source[key],
                        stacked = stack.get(srcValue);

                    if (stacked) {
                        assignMergeValue(object, key, stacked);
                        return;
                    }
                    var newValue = customizer ?
                        customizer(objValue, srcValue, (key + ''), object, source, stack) :
                        undefined;

                    var isCommon = newValue === undefined;

                    if (isCommon) {
                        newValue = srcValue;
                        if (isArray(srcValue) || isTypedArray(srcValue)) {
                            if (isArray(objValue)) {
                                newValue = objValue;
                            } else if (isArrayLikeObject(objValue)) {
                                newValue = copyArray(objValue);
                            } else {
                                isCommon = false;
                                newValue = baseClone(srcValue, true);
                            }
                        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                            if (isArguments(objValue)) {
                                newValue = toPlainObject(objValue);
                            } else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
                                isCommon = false;
                                newValue = baseClone(srcValue, true);
                            } else {
                                newValue = objValue;
                            }
                        } else {
                            isCommon = false;
                        }
                    }
                    if (isCommon) {
                        // Recursively merge objects and arrays (susceptible to call stack limits).
                        stack.set(srcValue, newValue);
                        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                        stack['delete'](srcValue);
                    }
                    assignMergeValue(object, key, newValue);
                }

                /**
                 * A specialized version of `baseProperty` which supports deep paths.
                 *
                 * @private
                 * @param {Array|string} path The path of the property to get.
                 * @returns {Function} Returns the new accessor function.
                 */
                function basePropertyDeep(path) {
                    return function(object) {
                        return baseGet(object, path);
                    };
                }

                /**
                 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
                 *
                 * @private
                 * @param {Function} func The function to apply a rest parameter to.
                 * @param {number} [start=func.length-1] The start position of the rest parameter.
                 * @returns {Function} Returns the new function.
                 */
                function baseRest(func, start) {
                    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
                    return function() {
                        var args = arguments,
                            index = -1,
                            length = nativeMax(args.length - start, 0),
                            array = Array(length);

                        while (++index < length) {
                            array[index] = args[start + index];
                        }
                        index = -1;
                        var otherArgs = Array(start + 1);
                        while (++index < start) {
                            otherArgs[index] = args[index];
                        }
                        otherArgs[start] = array;
                        return apply(func, this, otherArgs);
                    };
                }

                /**
                 * The base implementation of `_.toString` which doesn't convert nullish
                 * values to empty strings.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {string} Returns the string.
                 */
                function baseToString(value) {
                    // Exit early for strings to avoid a performance hit in some environments.
                    if (typeof value == 'string') {
                        return value;
                    }
                    if (isSymbol(value)) {
                        return symbolToString ? symbolToString.call(value) : '';
                    }
                    var result = (value + '');
                    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                }

                /**
                 * Casts `value` to a path array if it's not one.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {Array} Returns the cast property path array.
                 */
                function castPath(value) {
                    return isArray(value) ? value : stringToPath(value);
                }

                /**
                 * Creates a clone of  `buffer`.
                 *
                 * @private
                 * @param {Buffer} buffer The buffer to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Buffer} Returns the cloned buffer.
                 */
                function cloneBuffer(buffer, isDeep) {
                    if (isDeep) {
                        return buffer.slice();
                    }
                    var result = new buffer.constructor(buffer.length);
                    buffer.copy(result);
                    return result;
                }

                /**
                 * Creates a clone of `arrayBuffer`.
                 *
                 * @private
                 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                 * @returns {ArrayBuffer} Returns the cloned array buffer.
                 */
                function cloneArrayBuffer(arrayBuffer) {
                    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                    return result;
                }

                /**
                 * Creates a clone of `dataView`.
                 *
                 * @private
                 * @param {Object} dataView The data view to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned data view.
                 */
                function cloneDataView(dataView, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                }

                /**
                 * Creates a clone of `map`.
                 *
                 * @private
                 * @param {Object} map The map to clone.
                 * @param {Function} cloneFunc The function to clone values.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned map.
                 */
                function cloneMap(map, isDeep, cloneFunc) {
                    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
                    return arrayReduce(array, addMapEntry, new map.constructor);
                }

                /**
                 * Creates a clone of `regexp`.
                 *
                 * @private
                 * @param {Object} regexp The regexp to clone.
                 * @returns {Object} Returns the cloned regexp.
                 */
                function cloneRegExp(regexp) {
                    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                    result.lastIndex = regexp.lastIndex;
                    return result;
                }

                /**
                 * Creates a clone of `set`.
                 *
                 * @private
                 * @param {Object} set The set to clone.
                 * @param {Function} cloneFunc The function to clone values.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned set.
                 */
                function cloneSet(set, isDeep, cloneFunc) {
                    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
                    return arrayReduce(array, addSetEntry, new set.constructor);
                }

                /**
                 * Creates a clone of the `symbol` object.
                 *
                 * @private
                 * @param {Object} symbol The symbol object to clone.
                 * @returns {Object} Returns the cloned symbol object.
                 */
                function cloneSymbol(symbol) {
                    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                }

                /**
                 * Creates a clone of `typedArray`.
                 *
                 * @private
                 * @param {Object} typedArray The typed array to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned typed array.
                 */
                function cloneTypedArray(typedArray, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                }

                /**
                 * Copies the values of `source` to `array`.
                 *
                 * @private
                 * @param {Array} source The array to copy values from.
                 * @param {Array} [array=[]] The array to copy values to.
                 * @returns {Array} Returns `array`.
                 */
                function copyArray(source, array) {
                    var index = -1,
                        length = source.length;

                    array || (array = Array(length));
                    while (++index < length) {
                        array[index] = source[index];
                    }
                    return array;
                }

                /**
                 * Copies properties of `source` to `object`.
                 *
                 * @private
                 * @param {Object} source The object to copy properties from.
                 * @param {Array} props The property identifiers to copy.
                 * @param {Object} [object={}] The object to copy properties to.
                 * @param {Function} [customizer] The function to customize copied values.
                 * @returns {Object} Returns `object`.
                 */
                function copyObject(source, props, object, customizer) {
                    object || (object = {});

                    var index = -1,
                        length = props.length;

                    while (++index < length) {
                        var key = props[index];

                        var newValue = customizer ?
                            customizer(object[key], source[key], key, object, source) :
                            undefined;

                        assignValue(object, key, newValue === undefined ? source[key] : newValue);
                    }
                    return object;
                }

                /**
                 * Copies own symbol properties of `source` to `object`.
                 *
                 * @private
                 * @param {Object} source The object to copy symbols from.
                 * @param {Object} [object={}] The object to copy symbols to.
                 * @returns {Object} Returns `object`.
                 */
                function copySymbols(source, object) {
                    return copyObject(source, getSymbols(source), object);
                }

                /**
                 * Creates a function like `_.assign`.
                 *
                 * @private
                 * @param {Function} assigner The function to assign values.
                 * @returns {Function} Returns the new assigner function.
                 */
                function createAssigner(assigner) {
                    return baseRest(function(object, sources) {
                        var index = -1,
                            length = sources.length,
                            customizer = length > 1 ? sources[length - 1] : undefined,
                            guard = length > 2 ? sources[2] : undefined;

                        customizer = (assigner.length > 3 && typeof customizer == 'function') ?
                            (length--, customizer) :
                            undefined;

                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                            customizer = length < 3 ? undefined : customizer;
                            length = 1;
                        }
                        object = Object(object);
                        while (++index < length) {
                            var source = sources[index];
                            if (source) {
                                assigner(object, source, index, customizer);
                            }
                        }
                        return object;
                    });
                }

                /**
                 * Creates a `baseEach` or `baseEachRight` function.
                 *
                 * @private
                 * @param {Function} eachFunc The function to iterate over a collection.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new base function.
                 */
                function createBaseEach(eachFunc, fromRight) {
                    return function(collection, iteratee) {
                        if (collection == null) {
                            return collection;
                        }
                        if (!isArrayLike(collection)) {
                            return eachFunc(collection, iteratee);
                        }
                        var length = collection.length,
                            index = fromRight ? length : -1,
                            iterable = Object(collection);

                        while ((fromRight ? index-- : ++index < length)) {
                            if (iteratee(iterable[index], index, iterable) === false) {
                                break;
                            }
                        }
                        return collection;
                    };
                }

                /**
                 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
                 *
                 * @private
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new base function.
                 */
                function createBaseFor(fromRight) {
                    return function(object, iteratee, keysFunc) {
                        var index = -1,
                            iterable = Object(object),
                            props = keysFunc(object),
                            length = props.length;

                        while (length--) {
                            var key = props[fromRight ? length : ++index];
                            if (iteratee(iterable[key], key, iterable) === false) {
                                break;
                            }
                        }
                        return object;
                    };
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for arrays with support for
                 * partial deep comparisons.
                 *
                 * @private
                 * @param {Array} array The array to compare.
                 * @param {Array} other The other array to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
                 *  for more details.
                 * @param {Object} stack Tracks traversed `array` and `other` objects.
                 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                 */
                function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
                    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                        arrLength = array.length,
                        othLength = other.length;

                    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                        return false;
                    }
                    // Assume cyclic values are equal.
                    var stacked = stack.get(array);
                    if (stacked && stack.get(other)) {
                        return stacked == other;
                    }
                    var index = -1,
                        result = true,
                        seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

                    stack.set(array, other);
                    stack.set(other, array);

                    // Ignore non-index properties.
                    while (++index < arrLength) {
                        var arrValue = array[index],
                            othValue = other[index];

                        if (customizer) {
                            var compared = isPartial ?
                                customizer(othValue, arrValue, index, other, array, stack) :
                                customizer(arrValue, othValue, index, array, other, stack);
                        }
                        if (compared !== undefined) {
                            if (compared) {
                                continue;
                            }
                            result = false;
                            break;
                        }
                        // Recursively compare arrays (susceptible to call stack limits).
                        if (seen) {
                            if (!arraySome(other, function(othValue, othIndex) {
                                    if (!seen.has(othIndex) &&
                                        (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                                        return seen.add(othIndex);
                                    }
                                })) {
                                result = false;
                                break;
                            }
                        } else if (!(
                                arrValue === othValue ||
                                equalFunc(arrValue, othValue, customizer, bitmask, stack)
                            )) {
                            result = false;
                            break;
                        }
                    }
                    stack['delete'](array);
                    stack['delete'](other);
                    return result;
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for comparing objects of
                 * the same `toStringTag`.
                 *
                 * **Note:** This function only supports comparing values with tags of
                 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {string} tag The `toStringTag` of the objects to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
                 *  for more details.
                 * @param {Object} stack Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
                    switch (tag) {
                        case dataViewTag:
                            if ((object.byteLength != other.byteLength) ||
                                (object.byteOffset != other.byteOffset)) {
                                return false;
                            }
                            object = object.buffer;
                            other = other.buffer;

                        case arrayBufferTag:
                            if ((object.byteLength != other.byteLength) ||
                                !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                                return false;
                            }
                            return true;

                        case boolTag:
                        case dateTag:
                        case numberTag:
                            // Coerce booleans to `1` or `0` and dates to milliseconds.
                            // Invalid dates are coerced to `NaN`.
                            return eq(+object, +other);

                        case errorTag:
                            return object.name == other.name && object.message == other.message;

                        case regexpTag:
                        case stringTag:
                            // Coerce regexes to strings and treat strings, primitives and objects,
                            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                            // for more details.
                            return object == (other + '');

                        case mapTag:
                            var convert = mapToArray;

                        case setTag:
                            var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                            convert || (convert = setToArray);

                            if (object.size != other.size && !isPartial) {
                                return false;
                            }
                            // Assume cyclic values are equal.
                            var stacked = stack.get(object);
                            if (stacked) {
                                return stacked == other;
                            }
                            bitmask |= UNORDERED_COMPARE_FLAG;

                            // Recursively compare objects (susceptible to call stack limits).
                            stack.set(object, other);
                            var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
                            stack['delete'](object);
                            return result;

                        case symbolTag:
                            if (symbolValueOf) {
                                return symbolValueOf.call(object) == symbolValueOf.call(other);
                            }
                    }
                    return false;
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for objects with support for
                 * partial deep comparisons.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
                 *  for more details.
                 * @param {Object} stack Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
                    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                        objProps = keys(object),
                        objLength = objProps.length,
                        othProps = keys(other),
                        othLength = othProps.length;

                    if (objLength != othLength && !isPartial) {
                        return false;
                    }
                    var index = objLength;
                    while (index--) {
                        var key = objProps[index];
                        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                            return false;
                        }
                    }
                    // Assume cyclic values are equal.
                    var stacked = stack.get(object);
                    if (stacked && stack.get(other)) {
                        return stacked == other;
                    }
                    var result = true;
                    stack.set(object, other);
                    stack.set(other, object);

                    var skipCtor = isPartial;
                    while (++index < objLength) {
                        key = objProps[index];
                        var objValue = object[key],
                            othValue = other[key];

                        if (customizer) {
                            var compared = isPartial ?
                                customizer(othValue, objValue, key, other, object, stack) :
                                customizer(objValue, othValue, key, object, other, stack);
                        }
                        // Recursively compare objects (susceptible to call stack limits).
                        if (!(compared === undefined ?
                                (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack)) :
                                compared
                            )) {
                            result = false;
                            break;
                        }
                        skipCtor || (skipCtor = key == 'constructor');
                    }
                    if (result && !skipCtor) {
                        var objCtor = object.constructor,
                            othCtor = other.constructor;

                        // Non `Object` object instances with different constructors are not equal.
                        if (objCtor != othCtor &&
                            ('constructor' in object && 'constructor' in other) &&
                            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                                typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                            result = false;
                        }
                    }
                    stack['delete'](object);
                    stack['delete'](other);
                    return result;
                }

                /**
                 * Creates an array of own enumerable property names and symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names and symbols.
                 */
                function getAllKeys(object) {
                    return baseGetAllKeys(object, keys, getSymbols);
                }

                /**
                 * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
                 * this function returns the custom method, otherwise it returns `baseIteratee`.
                 * If arguments are provided, the chosen function is invoked with them and
                 * its result is returned.
                 *
                 * @private
                 * @param {*} [value] The value to convert to an iteratee.
                 * @param {number} [arity] The arity of the created iteratee.
                 * @returns {Function} Returns the chosen function or its result.
                 */
                function getIteratee() {
                    var result = lodash.iteratee || iteratee;
                    result = result === iteratee ? baseIteratee : result;
                    return arguments.length ? result(arguments[0], arguments[1]) : result;
                }

                /**
                 * Gets the data for `map`.
                 *
                 * @private
                 * @param {Object} map The map to query.
                 * @param {string} key The reference key.
                 * @returns {*} Returns the map data.
                 */
                function getMapData(map, key) {
                    var data = map.__data__;
                    return isKeyable(key) ?
                        data[typeof key == 'string' ? 'string' : 'hash'] :
                        data.map;
                }

                /**
                 * Gets the property names, values, and compare flags of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the match data of `object`.
                 */
                function getMatchData(object) {
                    var result = keys(object),
                        length = result.length;

                    while (length--) {
                        var key = result[length],
                            value = object[key];

                        result[length] = [key, value, isStrictComparable(value)];
                    }
                    return result;
                }

                /**
                 * Gets the native function at `key` of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {string} key The key of the method to get.
                 * @returns {*} Returns the function if it's native, else `undefined`.
                 */
                function getNative(object, key) {
                    var value = getValue(object, key);
                    return baseIsNative(value) ? value : undefined;
                }

                /**
                 * Creates an array of the own enumerable symbol properties of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of symbols.
                 */
                var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

                /**
                 * Gets the `toStringTag` of `value`.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @returns {string} Returns the `toStringTag`.
                 */
                var getTag = baseGetTag;

                // Fallback for data views, maps, sets, and weak maps in IE 11,
                // for data views in Edge < 14, and promises in Node.js.
                if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                    (Map && getTag(new Map) != mapTag) ||
                    (Promise && getTag(Promise.resolve()) != promiseTag) ||
                    (Set && getTag(new Set) != setTag) ||
                    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
                    getTag = function(value) {
                        var result = objectToString.call(value),
                            Ctor = result == objectTag ? value.constructor : undefined,
                            ctorString = Ctor ? toSource(Ctor) : undefined;

                        if (ctorString) {
                            switch (ctorString) {
                                case dataViewCtorString:
                                    return dataViewTag;
                                case mapCtorString:
                                    return mapTag;
                                case promiseCtorString:
                                    return promiseTag;
                                case setCtorString:
                                    return setTag;
                                case weakMapCtorString:
                                    return weakMapTag;
                            }
                        }
                        return result;
                    };
                }

                /**
                 * Checks if `path` exists on `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path to check.
                 * @param {Function} hasFunc The function to check properties.
                 * @returns {boolean} Returns `true` if `path` exists, else `false`.
                 */
                function hasPath(object, path, hasFunc) {
                    path = isKey(path, object) ? [path] : castPath(path);

                    var result,
                        index = -1,
                        length = path.length;

                    while (++index < length) {
                        var key = toKey(path[index]);
                        if (!(result = object != null && hasFunc(object, key))) {
                            break;
                        }
                        object = object[key];
                    }
                    if (result) {
                        return result;
                    }
                    var length = object ? object.length : 0;
                    return !!length && isLength(length) && isIndex(key, length) &&
                        (isArray(object) || isArguments(object));
                }

                /**
                 * Initializes an array clone.
                 *
                 * @private
                 * @param {Array} array The array to clone.
                 * @returns {Array} Returns the initialized clone.
                 */
                function initCloneArray(array) {
                    var length = array.length,
                        result = array.constructor(length);

                    // Add properties assigned by `RegExp#exec`.
                    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                        result.index = array.index;
                        result.input = array.input;
                    }
                    return result;
                }

                /**
                 * Initializes an object clone.
                 *
                 * @private
                 * @param {Object} object The object to clone.
                 * @returns {Object} Returns the initialized clone.
                 */
                function initCloneObject(object) {
                    return (typeof object.constructor == 'function' && !isPrototype(object)) ?
                        baseCreate(getPrototype(object)) :
                        {};
                }

                /**
                 * Initializes an object clone based on its `toStringTag`.
                 *
                 * **Note:** This function only supports cloning values with tags of
                 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                 *
                 * @private
                 * @param {Object} object The object to clone.
                 * @param {string} tag The `toStringTag` of the object to clone.
                 * @param {Function} cloneFunc The function to clone values.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the initialized clone.
                 */
                function initCloneByTag(object, tag, cloneFunc, isDeep) {
                    var Ctor = object.constructor;
                    switch (tag) {
                        case arrayBufferTag:
                            return cloneArrayBuffer(object);

                        case boolTag:
                        case dateTag:
                            return new Ctor(+object);

                        case dataViewTag:
                            return cloneDataView(object, isDeep);

                        case float32Tag:
                        case float64Tag:
                        case int8Tag:
                        case int16Tag:
                        case int32Tag:
                        case uint8Tag:
                        case uint8ClampedTag:
                        case uint16Tag:
                        case uint32Tag:
                            return cloneTypedArray(object, isDeep);

                        case mapTag:
                            return cloneMap(object, isDeep, cloneFunc);

                        case numberTag:
                        case stringTag:
                            return new Ctor(object);

                        case regexpTag:
                            return cloneRegExp(object);

                        case setTag:
                            return cloneSet(object, isDeep, cloneFunc);

                        case symbolTag:
                            return cloneSymbol(object);
                    }
                }

                /**
                 * Checks if `value` is a valid array-like index.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                 */
                function isIndex(value, length) {
                    length = length == null ? MAX_SAFE_INTEGER : length;
                    return !!length &&
                        (typeof value == 'number' || reIsUint.test(value)) &&
                        (value > -1 && value % 1 == 0 && value < length);
                }

                /**
                 * Checks if the given arguments are from an iteratee call.
                 *
                 * @private
                 * @param {*} value The potential iteratee value argument.
                 * @param {*} index The potential iteratee index or key argument.
                 * @param {*} object The potential iteratee object argument.
                 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
                 *  else `false`.
                 */
                function isIterateeCall(value, index, object) {
                    if (!isObject(object)) {
                        return false;
                    }
                    var type = typeof index;
                    if (type == 'number' ?
                        (isArrayLike(object) && isIndex(index, object.length)) :
                        (type == 'string' && index in object)
                    ) {
                        return eq(object[index], value);
                    }
                    return false;
                }

                /**
                 * Checks if `value` is a property name and not a property path.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @param {Object} [object] The object to query keys on.
                 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                 */
                function isKey(value, object) {
                    if (isArray(value)) {
                        return false;
                    }
                    var type = typeof value;
                    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
                        value == null || isSymbol(value)) {
                        return true;
                    }
                    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
                        (object != null && value in Object(object));
                }

                /**
                 * Checks if `value` is suitable for use as unique object key.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                 */
                function isKeyable(value) {
                    var type = typeof value;
                    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean') ?
                        (value !== '__proto__') :
                        (value === null);
                }

                /**
                 * Checks if `func` has its source masked.
                 *
                 * @private
                 * @param {Function} func The function to check.
                 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                 */
                function isMasked(func) {
                    return !!maskSrcKey && (maskSrcKey in func);
                }

                /**
                 * Checks if `value` is likely a prototype object.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                 */
                function isPrototype(value) {
                    var Ctor = value && value.constructor,
                        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

                    return value === proto;
                }

                /**
                 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` if suitable for strict
                 *  equality comparisons, else `false`.
                 */
                function isStrictComparable(value) {
                    return value === value && !isObject(value);
                }

                /**
                 * A specialized version of `matchesProperty` for source values suitable
                 * for strict equality comparisons, i.e. `===`.
                 *
                 * @private
                 * @param {string} key The key of the property to get.
                 * @param {*} srcValue The value to match.
                 * @returns {Function} Returns the new spec function.
                 */
                function matchesStrictComparable(key, srcValue) {
                    return function(object) {
                        if (object == null) {
                            return false;
                        }
                        return object[key] === srcValue &&
                            (srcValue !== undefined || (key in Object(object)));
                    };
                }

                /**
                 * This function is like
                 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                 * except that it includes inherited enumerable properties.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function nativeKeysIn(object) {
                    var result = [];
                    if (object != null) {
                        for (var key in Object(object)) {
                            result.push(key);
                        }
                    }
                    return result;
                }

                /**
                 * Converts `string` to a property path array.
                 *
                 * @private
                 * @param {string} string The string to convert.
                 * @returns {Array} Returns the property path array.
                 */
                var stringToPath = memoize(function(string) {
                    string = toString(string);

                    var result = [];
                    if (reLeadingDot.test(string)) {
                        result.push('');
                    }
                    string.replace(rePropName, function(match, number, quote, string) {
                        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
                    });
                    return result;
                });

                /**
                 * Converts `value` to a string key if it's not a string or symbol.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {string|symbol} Returns the key.
                 */
                function toKey(value) {
                    if (typeof value == 'string' || isSymbol(value)) {
                        return value;
                    }
                    var result = (value + '');
                    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                }

                /**
                 * Converts `func` to its source code.
                 *
                 * @private
                 * @param {Function} func The function to process.
                 * @returns {string} Returns the source code.
                 */
                function toSource(func) {
                    if (func != null) {
                        try {
                            return funcToString.call(func);
                        } catch (e) {}
                        try {
                            return (func + '');
                        } catch (e) {}
                    }
                    return '';
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an array with all falsey values removed. The values `false`, `null`,
                 * `0`, `""`, `undefined`, and `NaN` are falsey.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to compact.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * _.compact([0, 1, false, 2, '', 3]);
                 * // => [1, 2, 3]
                 */
                function compact(array) {
                    var index = -1,
                        length = array ? array.length : 0,
                        resIndex = 0,
                        result = [];

                    while (++index < length) {
                        var value = array[index];
                        if (value) {
                            result[resIndex++] = value;
                        }
                    }
                    return result;
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Iterates over elements of `collection` and invokes `iteratee` for each element.
                 * The iteratee is invoked with three arguments: (value, index|key, collection).
                 * Iteratee functions may exit iteration early by explicitly returning `false`.
                 *
                 * **Note:** As with other "Collections" methods, objects with a "length"
                 * property are iterated like arrays. To avoid this behavior use `_.forIn`
                 * or `_.forOwn` for object iteration.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @alias each
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 * @see _.forEachRight
                 * @example
                 *
                 * _([1, 2]).forEach(function(value) {
                 *   console.log(value);
                 * });
                 * // => Logs `1` then `2`.
                 *
                 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
                 *   console.log(key);
                 * });
                 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                 */
                function forEach(collection, iteratee) {
                    var func = isArray(collection) ? arrayEach : baseEach;
                    return func(collection, getIteratee(iteratee, 3));
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a function that memoizes the result of `func`. If `resolver` is
                 * provided, it determines the cache key for storing the result based on the
                 * arguments provided to the memoized function. By default, the first argument
                 * provided to the memoized function is used as the map cache key. The `func`
                 * is invoked with the `this` binding of the memoized function.
                 *
                 * **Note:** The cache is exposed as the `cache` property on the memoized
                 * function. Its creation may be customized by replacing the `_.memoize.Cache`
                 * constructor with one whose instances implement the
                 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
                 * method interface of `delete`, `get`, `has`, and `set`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to have its output memoized.
                 * @param {Function} [resolver] The function to resolve the cache key.
                 * @returns {Function} Returns the new memoized function.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2 };
                 * var other = { 'c': 3, 'd': 4 };
                 *
                 * var values = _.memoize(_.values);
                 * values(object);
                 * // => [1, 2]
                 *
                 * values(other);
                 * // => [3, 4]
                 *
                 * object.a = 2;
                 * values(object);
                 * // => [1, 2]
                 *
                 * // Modify the result cache.
                 * values.cache.set(object, ['a', 'b']);
                 * values(object);
                 * // => ['a', 'b']
                 *
                 * // Replace `_.memoize.Cache`.
                 * _.memoize.Cache = WeakMap;
                 */
                function memoize(func, resolver) {
                    if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    var memoized = function() {
                        var args = arguments,
                            key = resolver ? resolver.apply(this, args) : args[0],
                            cache = memoized.cache;

                        if (cache.has(key)) {
                            return cache.get(key);
                        }
                        var result = func.apply(this, args);
                        memoized.cache = cache.set(key, result);
                        return result;
                    };
                    memoized.cache = new(memoize.Cache || MapCache);
                    return memoized;
                }

                // Assign cache to `_.memoize`.
                memoize.Cache = MapCache;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a shallow clone of `value`.
                 *
                 * **Note:** This method is loosely based on the
                 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
                 * and supports cloning arrays, array buffers, booleans, date objects, maps,
                 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
                 * arrays. The own enumerable properties of `arguments` objects are cloned
                 * as plain objects. An empty object is returned for uncloneable values such
                 * as error objects, functions, DOM nodes, and WeakMaps.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to clone.
                 * @returns {*} Returns the cloned value.
                 * @see _.cloneDeep
                 * @example
                 *
                 * var objects = [{ 'a': 1 }, { 'b': 2 }];
                 *
                 * var shallow = _.clone(objects);
                 * console.log(shallow[0] === objects[0]);
                 * // => true
                 */
                function clone(value) {
                    return baseClone(value, false, true);
                }

                /**
                 * Performs a
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * comparison between two values to determine if they are equivalent.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 * @example
                 *
                 * var object = { 'a': 1 };
                 * var other = { 'a': 1 };
                 *
                 * _.eq(object, object);
                 * // => true
                 *
                 * _.eq(object, other);
                 * // => false
                 *
                 * _.eq('a', 'a');
                 * // => true
                 *
                 * _.eq('a', Object('a'));
                 * // => false
                 *
                 * _.eq(NaN, NaN);
                 * // => true
                 */
                function eq(value, other) {
                    return value === other || (value !== value && other !== other);
                }

                /**
                 * Checks if `value` is likely an `arguments` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                 *  else `false`.
                 * @example
                 *
                 * _.isArguments(function() { return arguments; }());
                 * // => true
                 *
                 * _.isArguments([1, 2, 3]);
                 * // => false
                 */
                function isArguments(value) {
                    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
                        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
                }

                /**
                 * Checks if `value` is classified as an `Array` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                 * @example
                 *
                 * _.isArray([1, 2, 3]);
                 * // => true
                 *
                 * _.isArray(document.body.children);
                 * // => false
                 *
                 * _.isArray('abc');
                 * // => false
                 *
                 * _.isArray(_.noop);
                 * // => false
                 */
                var isArray = Array.isArray;

                /**
                 * Checks if `value` is array-like. A value is considered array-like if it's
                 * not a function and has a `value.length` that's an integer greater than or
                 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                 * @example
                 *
                 * _.isArrayLike([1, 2, 3]);
                 * // => true
                 *
                 * _.isArrayLike(document.body.children);
                 * // => true
                 *
                 * _.isArrayLike('abc');
                 * // => true
                 *
                 * _.isArrayLike(_.noop);
                 * // => false
                 */
                function isArrayLike(value) {
                    return value != null && isLength(value.length) && !isFunction(value);
                }

                /**
                 * This method is like `_.isArrayLike` except that it also checks if `value`
                 * is an object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an array-like object,
                 *  else `false`.
                 * @example
                 *
                 * _.isArrayLikeObject([1, 2, 3]);
                 * // => true
                 *
                 * _.isArrayLikeObject(document.body.children);
                 * // => true
                 *
                 * _.isArrayLikeObject('abc');
                 * // => false
                 *
                 * _.isArrayLikeObject(_.noop);
                 * // => false
                 */
                function isArrayLikeObject(value) {
                    return isObjectLike(value) && isArrayLike(value);
                }

                /**
                 * Checks if `value` is a buffer.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                 * @example
                 *
                 * _.isBuffer(new Buffer(2));
                 * // => true
                 *
                 * _.isBuffer(new Uint8Array(2));
                 * // => false
                 */
                var isBuffer = nativeIsBuffer || stubFalse;

                /**
                 * Checks if `value` is an empty object, collection, map, or set.
                 *
                 * Objects are considered empty if they have no own enumerable string keyed
                 * properties.
                 *
                 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
                 * jQuery-like collections are considered empty if they have a `length` of `0`.
                 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                 * @example
                 *
                 * _.isEmpty(null);
                 * // => true
                 *
                 * _.isEmpty(true);
                 * // => true
                 *
                 * _.isEmpty(1);
                 * // => true
                 *
                 * _.isEmpty([1, 2, 3]);
                 * // => false
                 *
                 * _.isEmpty({ 'a': 1 });
                 * // => false
                 */
                function isEmpty(value) {
                    if (isArrayLike(value) &&
                        (isArray(value) || typeof value == 'string' ||
                            typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {
                        return !value.length;
                    }
                    var tag = getTag(value);
                    if (tag == mapTag || tag == setTag) {
                        return !value.size;
                    }
                    if (nonEnumShadows || isPrototype(value)) {
                        return !nativeKeys(value).length;
                    }
                    for (var key in value) {
                        if (hasOwnProperty.call(value, key)) {
                            return false;
                        }
                    }
                    return true;
                }

                /**
                 * Checks if `value` is classified as a `Function` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                 * @example
                 *
                 * _.isFunction(_);
                 * // => true
                 *
                 * _.isFunction(/abc/);
                 * // => false
                 */
                function isFunction(value) {
                    // The use of `Object#toString` avoids issues with the `typeof` operator
                    // in Safari 8-9 which returns 'object' for typed array and other constructors.
                    var tag = isObject(value) ? objectToString.call(value) : '';
                    return tag == funcTag || tag == genTag;
                }

                /**
                 * Checks if `value` is a valid array-like length.
                 *
                 * **Note:** This method is loosely based on
                 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                 * @example
                 *
                 * _.isLength(3);
                 * // => true
                 *
                 * _.isLength(Number.MIN_VALUE);
                 * // => false
                 *
                 * _.isLength(Infinity);
                 * // => false
                 *
                 * _.isLength('3');
                 * // => false
                 */
                function isLength(value) {
                    return typeof value == 'number' &&
                        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }

                /**
                 * Checks if `value` is the
                 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                 * @example
                 *
                 * _.isObject({});
                 * // => true
                 *
                 * _.isObject([1, 2, 3]);
                 * // => true
                 *
                 * _.isObject(_.noop);
                 * // => true
                 *
                 * _.isObject(null);
                 * // => false
                 */
                function isObject(value) {
                    var type = typeof value;
                    return !!value && (type == 'object' || type == 'function');
                }

                /**
                 * Checks if `value` is object-like. A value is object-like if it's not `null`
                 * and has a `typeof` result of "object".
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                 * @example
                 *
                 * _.isObjectLike({});
                 * // => true
                 *
                 * _.isObjectLike([1, 2, 3]);
                 * // => true
                 *
                 * _.isObjectLike(_.noop);
                 * // => false
                 *
                 * _.isObjectLike(null);
                 * // => false
                 */
                function isObjectLike(value) {
                    return !!value && typeof value == 'object';
                }

                /**
                 * Checks if `value` is a plain object, that is, an object created by the
                 * `Object` constructor or one with a `[[Prototype]]` of `null`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.8.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 * }
                 *
                 * _.isPlainObject(new Foo);
                 * // => false
                 *
                 * _.isPlainObject([1, 2, 3]);
                 * // => false
                 *
                 * _.isPlainObject({ 'x': 0, 'y': 0 });
                 * // => true
                 *
                 * _.isPlainObject(Object.create(null));
                 * // => true
                 */
                function isPlainObject(value) {
                    if (!isObjectLike(value) ||
                        objectToString.call(value) != objectTag || isHostObject(value)) {
                        return false;
                    }
                    var proto = getPrototype(value);
                    if (proto === null) {
                        return true;
                    }
                    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                    return (typeof Ctor == 'function' &&
                        Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
                }

                /**
                 * Checks if `value` is classified as a `Symbol` primitive or object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
                 * @example
                 *
                 * _.isSymbol(Symbol.iterator);
                 * // => true
                 *
                 * _.isSymbol('abc');
                 * // => false
                 */
                function isSymbol(value) {
                    return typeof value == 'symbol' ||
                        (isObjectLike(value) && objectToString.call(value) == symbolTag);
                }

                /**
                 * Checks if `value` is classified as a typed array.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                 * @example
                 *
                 * _.isTypedArray(new Uint8Array);
                 * // => true
                 *
                 * _.isTypedArray([]);
                 * // => false
                 */
                var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

                /**
                 * Converts `value` to a plain object flattening inherited enumerable string
                 * keyed properties of `value` to own properties of the plain object.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {Object} Returns the converted plain object.
                 * @example
                 *
                 * function Foo() {
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.assign({ 'a': 1 }, new Foo);
                 * // => { 'a': 1, 'b': 2 }
                 *
                 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                 * // => { 'a': 1, 'b': 2, 'c': 3 }
                 */
                function toPlainObject(value) {
                    return copyObject(value, keysIn(value));
                }

                /**
                 * Converts `value` to a string. An empty string is returned for `null`
                 * and `undefined` values. The sign of `-0` is preserved.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to process.
                 * @returns {string} Returns the string.
                 * @example
                 *
                 * _.toString(null);
                 * // => ''
                 *
                 * _.toString(-0);
                 * // => '-0'
                 *
                 * _.toString([1, 2, 3]);
                 * // => '1,2,3'
                 */
                function toString(value) {
                    return value == null ? '' : baseToString(value);
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Gets the value at `path` of `object`. If the resolved value is
                 * `undefined`, the `defaultValue` is returned in its place.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to get.
                 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                 * @returns {*} Returns the resolved value.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                 *
                 * _.get(object, 'a[0].b.c');
                 * // => 3
                 *
                 * _.get(object, ['a', '0', 'b', 'c']);
                 * // => 3
                 *
                 * _.get(object, 'a.b.c', 'default');
                 * // => 'default'
                 */
                function get(object, path, defaultValue) {
                    var result = object == null ? undefined : baseGet(object, path);
                    return result === undefined ? defaultValue : result;
                }

                /**
                 * Checks if `path` is a direct or inherited property of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path to check.
                 * @returns {boolean} Returns `true` if `path` exists, else `false`.
                 * @example
                 *
                 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
                 *
                 * _.hasIn(object, 'a');
                 * // => true
                 *
                 * _.hasIn(object, 'a.b');
                 * // => true
                 *
                 * _.hasIn(object, ['a', 'b']);
                 * // => true
                 *
                 * _.hasIn(object, 'b');
                 * // => false
                 */
                function hasIn(object, path) {
                    return object != null && hasPath(object, path, baseHasIn);
                }

                /**
                 * Creates an array of the own enumerable property names of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects. See the
                 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                 * for more details.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.keys(new Foo);
                 * // => ['a', 'b'] (iteration order is not guaranteed)
                 *
                 * _.keys('hi');
                 * // => ['0', '1']
                 */
                function keys(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                }

                /**
                 * Creates an array of the own and inherited enumerable property names of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.keysIn(new Foo);
                 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                 */
                function keysIn(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                }

                /**
                 * This method is like `_.assign` except that it recursively merges own and
                 * inherited enumerable string keyed properties of source objects into the
                 * destination object. Source properties that resolve to `undefined` are
                 * skipped if a destination value exists. Array and plain object properties
                 * are merged recursively. Other objects and value types are overridden by
                 * assignment. Source objects are applied from left to right. Subsequent
                 * sources overwrite property assignments of previous sources.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.5.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = {
                 *   'a': [{ 'b': 2 }, { 'd': 4 }]
                 * };
                 *
                 * var other = {
                 *   'a': [{ 'c': 3 }, { 'e': 5 }]
                 * };
                 *
                 * _.merge(object, other);
                 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
                 */
                var merge = createAssigner(function(object, source, srcIndex) {
                    baseMerge(object, source, srcIndex);
                });

                /*------------------------------------------------------------------------*/

                /**
                 * This method returns the first argument it receives.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {*} value Any value.
                 * @returns {*} Returns `value`.
                 * @example
                 *
                 * var object = { 'a': 1 };
                 *
                 * console.log(_.identity(object) === object);
                 * // => true
                 */
                function identity(value) {
                    return value;
                }

                /**
                 * Creates a function that invokes `func` with the arguments of the created
                 * function. If `func` is a property name, the created function returns the
                 * property value for a given element. If `func` is an array or object, the
                 * created function returns `true` for elements that contain the equivalent
                 * source properties, otherwise it returns `false`.
                 *
                 * @static
                 * @since 4.0.0
                 * @memberOf _
                 * @category Util
                 * @param {*} [func=_.identity] The value to convert to a callback.
                 * @returns {Function} Returns the callback.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': true },
                 *   { 'user': 'fred',   'age': 40, 'active': false }
                 * ];
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
                 * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.filter(users, _.iteratee(['user', 'fred']));
                 * // => [{ 'user': 'fred', 'age': 40 }]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.map(users, _.iteratee('user'));
                 * // => ['barney', 'fred']
                 *
                 * // Create custom iteratee shorthands.
                 * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
                 *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
                 *     return func.test(string);
                 *   };
                 * });
                 *
                 * _.filter(['abc', 'def'], /ef/);
                 * // => ['def']
                 */
                function iteratee(func) {
                    return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
                }

                /**
                 * Creates a function that returns the value at `path` of a given object.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Util
                 * @param {Array|string} path The path of the property to get.
                 * @returns {Function} Returns the new accessor function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': { 'b': 2 } },
                 *   { 'a': { 'b': 1 } }
                 * ];
                 *
                 * _.map(objects, _.property('a.b'));
                 * // => [2, 1]
                 *
                 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
                 * // => [1, 2]
                 */
                function property(path) {
                    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                }

                /**
                 * This method returns a new empty array.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.13.0
                 * @category Util
                 * @returns {Array} Returns the new empty array.
                 * @example
                 *
                 * var arrays = _.times(2, _.stubArray);
                 *
                 * console.log(arrays);
                 * // => [[], []]
                 *
                 * console.log(arrays[0] === arrays[1]);
                 * // => false
                 */
                function stubArray() {
                    return [];
                }

                /**
                 * This method returns `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.13.0
                 * @category Util
                 * @returns {boolean} Returns `false`.
                 * @example
                 *
                 * _.times(2, _.stubFalse);
                 * // => [false, false]
                 */
                function stubFalse() {
                    return false;
                }

                /*------------------------------------------------------------------------*/

                // Add methods that return wrapped values in chain sequences.
                lodash.compact = compact;
                lodash.iteratee = iteratee;
                lodash.keys = keys;
                lodash.keysIn = keysIn;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.property = property;
                lodash.toPlainObject = toPlainObject;

                /*------------------------------------------------------------------------*/

                // Add methods that return unwrapped values in chain sequences.
                lodash.clone = clone;
                lodash.eq = eq;
                lodash.forEach = forEach;
                lodash.get = get;
                lodash.hasIn = hasIn;
                lodash.identity = identity;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray;
                lodash.isArrayLike = isArrayLike;
                lodash.isArrayLikeObject = isArrayLikeObject;
                lodash.isBuffer = isBuffer;
                lodash.isEmpty = isEmpty;
                lodash.isFunction = isFunction;
                lodash.isLength = isLength;
                lodash.isObject = isObject;
                lodash.isObjectLike = isObjectLike;
                lodash.isPlainObject = isPlainObject;
                lodash.isSymbol = isSymbol;
                lodash.isTypedArray = isTypedArray;
                lodash.stubArray = stubArray;
                lodash.stubFalse = stubFalse;
                lodash.toString = toString;

                // Add aliases.
                lodash.each = forEach;

                /*------------------------------------------------------------------------*/

                /**
                 * The semantic version number.
                 *
                 * @static
                 * @memberOf _
                 * @type {string}
                 */
                lodash.VERSION = VERSION;

                /*--------------------------------------------------------------------------*/

                if (freeModule) {
                    // Export for Node.js.
                    (freeModule.exports = lodash)._ = lodash;
                    // Export for CommonJS support.
                    freeExports._ = lodash;
                }
            }.call(this));

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(4), __webpack_require__(10)(module)))

        /***/
    }),
    /* 31 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";
        /*
         * Generated by PEG.js 0.10.0.
         *
         * http://pegjs.org/
         */



        function peg$subclass(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
        }

        function peg$SyntaxError(message, expected, found, location) {
            this.message = message;
            this.expected = expected;
            this.found = found;
            this.location = location;
            this.name = "SyntaxError";

            if (typeof Error.captureStackTrace === "function") {
                Error.captureStackTrace(this, peg$SyntaxError);
            }
        }

        peg$subclass(peg$SyntaxError, Error);

        peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
                literal: function(expectation) {
                    return "\"" + literalEscape(expectation.text) + "\"";
                },

                "class": function(expectation) {
                    var escapedParts = "",
                        i;

                    for (i = 0; i < expectation.parts.length; i++) {
                        escapedParts += expectation.parts[i] instanceof Array ?
                            classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) :
                            classEscape(expectation.parts[i]);
                    }

                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                },

                any: function(expectation) {
                    return "any character";
                },

                end: function(expectation) {
                    return "end of input";
                },

                other: function(expectation) {
                    return expectation.description;
                }
            };

            function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
            }

            function literalEscape(s) {
                return s
                    .replace(/\\/g, '\\\\')
                    .replace(/"/g, '\\"')
                    .replace(/\0/g, '\\0')
                    .replace(/\t/g, '\\t')
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r')
                    .replace(/[\x00-\x0F]/g, function(ch) {
                        return '\\x0' + hex(ch);
                    })
                    .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                        return '\\x' + hex(ch);
                    });
            }

            function classEscape(s) {
                return s
                    .replace(/\\/g, '\\\\')
                    .replace(/\]/g, '\\]')
                    .replace(/\^/g, '\\^')
                    .replace(/-/g, '\\-')
                    .replace(/\0/g, '\\0')
                    .replace(/\t/g, '\\t')
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r')
                    .replace(/[\x00-\x0F]/g, function(ch) {
                        return '\\x0' + hex(ch);
                    })
                    .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                        return '\\x' + hex(ch);
                    });
            }

            function describeExpectation(expectation) {
                return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }

            function describeExpected(expected) {
                var descriptions = new Array(expected.length),
                    i, j;

                for (i = 0; i < expected.length; i++) {
                    descriptions[i] = describeExpectation(expected[i]);
                }

                descriptions.sort();

                if (descriptions.length > 0) {
                    for (i = 1, j = 1; i < descriptions.length; i++) {
                        if (descriptions[i - 1] !== descriptions[i]) {
                            descriptions[j] = descriptions[i];
                            j++;
                        }
                    }
                    descriptions.length = j;
                }

                switch (descriptions.length) {
                    case 1:
                        return descriptions[0];

                    case 2:
                        return descriptions[0] + " or " + descriptions[1];

                    default:
                        return descriptions.slice(0, -1).join(", ") +
                            ", or " +
                            descriptions[descriptions.length - 1];
                }
            }

            function describeFound(found) {
                return found ? "\"" + literalEscape(found) + "\"" : "end of input";
            }

            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };

        function peg$parse(input, options) {
            options = options !== void 0 ? options : {};

            var peg$FAILED = {},

                peg$startRuleFunctions = {
                    Expression: peg$parseExpression
                },
                peg$startRuleFunction = peg$parseExpression,

                peg$c0 = "==",
                peg$c1 = peg$literalExpectation("==", false),
                peg$c2 = "!=",
                peg$c3 = peg$literalExpectation("!=", false),
                peg$c4 = "<>",
                peg$c5 = peg$literalExpectation("<>", false),
                peg$c6 = ">=",
                peg$c7 = peg$literalExpectation(">=", false),
                peg$c8 = ">",
                peg$c9 = peg$literalExpectation(">", false),
                peg$c10 = "<=",
                peg$c11 = peg$literalExpectation("<=", false),
                peg$c12 = "<",
                peg$c13 = peg$literalExpectation("<", false),
                peg$c14 = "eq",
                peg$c15 = peg$literalExpectation("eq", false),
                peg$c16 = "ne",
                peg$c17 = peg$literalExpectation("ne", false),
                peg$c18 = "&&",
                peg$c19 = peg$literalExpectation("&&", false),
                peg$c20 = "||",
                peg$c21 = peg$literalExpectation("||", false),
                peg$c22 = function(op1, op, op2) {
                    switch (op) {
                        case "==":
                            return "" + (isNaN(+op1) || isNaN(+op2) ? op1 == op2 : +op1 == +op2);
                        case "!=":
                        case "<>":
                            return "" + (isNaN(+op1) || isNaN(+op2) ? op1 != op2 : +op1 != +op2);
                        case ">":
                            return "" + (isNaN(+op1) || isNaN(+op2) ? op1 > op2 : +op1 > +op2);
                        case ">=":
                            return "" + (isNaN(+op1) || isNaN(+op2) ? op1 >= op2 : +op1 >= +op2);
                        case "<":
                            return "" + (isNaN(+op1) || isNaN(+op2) ? op1 < op2 : +op1 < +op2);
                        case "<=":
                            return "" + (isNaN(+op1) || isNaN(+op2) ? op1 <= op2 : +op1 <= +op2);
                        case "eq":
                            return "" + (op1 === op2);
                        case "ne":
                            return "" + (op1 !== op2);
                        case "&&":
                            return "" + (["false", "no", "0", 0, ""].indexOf(op1) < 0 && ["false", "no", "0", 0, ""].indexOf(op2) < 0);
                        case "||":
                            return "" + (["false", "no", "0", 0, ""].indexOf(op1) < 0 || ["false", "no", "0", 0, ""].indexOf(op2) < 0);
                    }
                },
                peg$c23 = ".",
                peg$c24 = peg$literalExpectation(".", false),
                peg$c25 = "+",
                peg$c26 = peg$literalExpectation("+", false),
                peg$c27 = "-",
                peg$c28 = peg$literalExpectation("-", false),
                peg$c29 = function(head, tail) {
                    var result = head,
                        i;

                    for (i = 0; i < tail.length; i++) {
                        if (tail[i][1] === ".") {
                            result = "" + (result + tail[i][3]);
                        }
                        if (tail[i][1] === "+") {
                            result = "" + (+result + +tail[i][3]);
                        }
                        if (tail[i][1] === "-") {
                            result = "" + (result - tail[i][3]);
                        }
                    }

                    return result;
                },
                peg$c30 = "*",
                peg$c31 = peg$literalExpectation("*", false),
                peg$c32 = "/",
                peg$c33 = peg$literalExpectation("/", false),
                peg$c34 = function(head, tail) {
                    var result = head,
                        i;

                    for (i = 0; i < tail.length; i++) {
                        if (tail[i][1] === "*") {
                            result = "" + (result * tail[i][3]);
                        }
                        if (tail[i][1] === "/") {
                            result = "" + (result / tail[i][3]);
                        }
                    }

                    return result;
                },
                peg$c35 = "!",
                peg$c36 = peg$literalExpectation("!", false),
                peg$c37 = function(expr) {
                    return ["false", "no", "0", 0, ""].indexOf(expr) >= 0 ? "true" : "false"
                },
                peg$c38 = "num",
                peg$c39 = peg$literalExpectation("num", false),
                peg$c40 = "str",
                peg$c41 = peg$literalExpectation("str", false),
                peg$c42 = "boolean",
                peg$c43 = peg$literalExpectation("boolean", false),
                peg$c44 = "int",
                peg$c45 = peg$literalExpectation("int", false),
                peg$c46 = "sqrt",
                peg$c47 = peg$literalExpectation("sqrt", false),
                peg$c48 = "tag",
                peg$c49 = peg$literalExpectation("tag", false),
                peg$c50 = "(",
                peg$c51 = peg$literalExpectation("(", false),
                peg$c52 = ")",
                peg$c53 = peg$literalExpectation(")", false),
                peg$c54 = function(fun, expr) {
                    switch (fun) {
                        case "num":
                            return "" + (parseFloat(expr) || "");
                        case "str":
                            return "" + expr;
                        case "boolean":
                            return ["false", "no", "0", 0, ""].indexOf(expr) >= 0 ? "false" : "true";
                        case "int":
                            return "" + (expr < 0 ? Math.ceil(expr) : Math.floor(expr));
                        case "sqrt":
                            return "" + Math.sqrt(expr);
                        case "tag":
                            return module.exports.tag(expr);
                    }
                },
                peg$c55 = "cond(",
                peg$c56 = peg$literalExpectation("cond(", false),
                peg$c57 = ",",
                peg$c58 = peg$literalExpectation(",", false),
                peg$c59 = function(exprCond, exprTrue, exprFalse) {
                    return ["false", "no", "0", 0, ""].indexOf(exprCond) < 0 ? exprTrue : exprFalse
                },
                peg$c60 = "max",
                peg$c61 = peg$literalExpectation("max", false),
                peg$c62 = "min",
                peg$c63 = peg$literalExpectation("min", false),
                peg$c64 = "concat",
                peg$c65 = peg$literalExpectation("concat", false),
                peg$c66 = "any",
                peg$c67 = peg$literalExpectation("any", false),
                peg$c68 = function(fun, head, tail) {
                    switch (fun) {
                        case "max":
                            return "" + tail.reduce(function(acc, val) {
                                return Math.max(+acc, +val[3]);
                            }, +head);
                        case "min":
                            return "" + tail.reduce(function(acc, val) {
                                return Math.min(+acc, +val[3]);
                            }, +head);
                        case "concat":
                            return tail.reduce(function(acc, val) {
                                return acc + val[3];
                            }, "" + head);
                        case "any":
                            return tail.reduce(function(acc, val) {
                                return acc || val[3];
                            }, head);
                    }
                },
                peg$c69 = function(expr) {
                    return expr;
                },
                peg$c70 = peg$otherExpectation("string"),
                peg$c71 = "none",
                peg$c72 = peg$literalExpectation("none", false),
                peg$c73 = function() {
                    return ""
                },
                peg$c74 = /^[0-9]/,
                peg$c75 = peg$classExpectation([
                    ["0", "9"]
                ], false, false),
                peg$c76 = "E",
                peg$c77 = peg$literalExpectation("E", false),
                peg$c78 = function() {
                    return "" + parseFloat(text());
                },
                peg$c79 = "\"",
                peg$c80 = peg$literalExpectation("\"", false),
                peg$c81 = /^[^"]/,
                peg$c82 = peg$classExpectation(["\""], true, false),
                peg$c83 = function(s) {
                    return s.join('');
                },
                peg$c84 = "'",
                peg$c85 = peg$literalExpectation("'", false),
                peg$c86 = /^[^']/,
                peg$c87 = peg$classExpectation(["'"], true, false),
                peg$c88 = peg$otherExpectation("whitespace"),
                peg$c89 = /^[ \t\n\r]/,
                peg$c90 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),

                peg$currPos = 0,
                peg$savedPos = 0,
                peg$posDetailsCache = [{
                    line: 1,
                    column: 1
                }],
                peg$maxFailPos = 0,
                peg$maxFailExpected = [],
                peg$silentFails = 0,

                peg$result;

            if ("startRule" in options) {
                if (!(options.startRule in peg$startRuleFunctions)) {
                    throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
                }

                peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
            }

            function text() {
                return input.substring(peg$savedPos, peg$currPos);
            }

            function location() {
                return peg$computeLocation(peg$savedPos, peg$currPos);
            }

            function expected(description, location) {
                location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

                throw peg$buildStructuredError(
                    [peg$otherExpectation(description)],
                    input.substring(peg$savedPos, peg$currPos),
                    location
                );
            }

            function error(message, location) {
                location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

                throw peg$buildSimpleError(message, location);
            }

            function peg$literalExpectation(text, ignoreCase) {
                return {
                    type: "literal",
                    text: text,
                    ignoreCase: ignoreCase
                };
            }

            function peg$classExpectation(parts, inverted, ignoreCase) {
                return {
                    type: "class",
                    parts: parts,
                    inverted: inverted,
                    ignoreCase: ignoreCase
                };
            }

            function peg$anyExpectation() {
                return {
                    type: "any"
                };
            }

            function peg$endExpectation() {
                return {
                    type: "end"
                };
            }

            function peg$otherExpectation(description) {
                return {
                    type: "other",
                    description: description
                };
            }

            function peg$computePosDetails(pos) {
                var details = peg$posDetailsCache[pos],
                    p;

                if (details) {
                    return details;
                } else {
                    p = pos - 1;
                    while (!peg$posDetailsCache[p]) {
                        p--;
                    }

                    details = peg$posDetailsCache[p];
                    details = {
                        line: details.line,
                        column: details.column
                    };

                    while (p < pos) {
                        if (input.charCodeAt(p) === 10) {
                            details.line++;
                            details.column = 1;
                        } else {
                            details.column++;
                        }

                        p++;
                    }

                    peg$posDetailsCache[pos] = details;
                    return details;
                }
            }

            function peg$computeLocation(startPos, endPos) {
                var startPosDetails = peg$computePosDetails(startPos),
                    endPosDetails = peg$computePosDetails(endPos);

                return {
                    start: {
                        offset: startPos,
                        line: startPosDetails.line,
                        column: startPosDetails.column
                    },
                    end: {
                        offset: endPos,
                        line: endPosDetails.line,
                        column: endPosDetails.column
                    }
                };
            }

            function peg$fail(expected) {
                if (peg$currPos < peg$maxFailPos) {
                    return;
                }

                if (peg$currPos > peg$maxFailPos) {
                    peg$maxFailPos = peg$currPos;
                    peg$maxFailExpected = [];
                }

                peg$maxFailExpected.push(expected);
            }

            function peg$buildSimpleError(message, location) {
                return new peg$SyntaxError(message, null, null, location);
            }

            function peg$buildStructuredError(expected, found, location) {
                return new peg$SyntaxError(
                    peg$SyntaxError.buildMessage(expected, found),
                    expected,
                    found,
                    location
                );
            }

            function peg$parseExpression() {
                var s0, s1, s2, s3, s4, s5;

                s0 = peg$currPos;
                s1 = peg$parseOperand();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c0) {
                            s3 = peg$c0;
                            peg$currPos += 2;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c1);
                            }
                        }
                        if (s3 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c2) {
                                s3 = peg$c2;
                                peg$currPos += 2;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c3);
                                }
                            }
                            if (s3 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c4) {
                                    s3 = peg$c4;
                                    peg$currPos += 2;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c5);
                                    }
                                }
                                if (s3 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c6) {
                                        s3 = peg$c6;
                                        peg$currPos += 2;
                                    } else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c7);
                                        }
                                    }
                                    if (s3 === peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 62) {
                                            s3 = peg$c8;
                                            peg$currPos++;
                                        } else {
                                            s3 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c9);
                                            }
                                        }
                                        if (s3 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c10) {
                                                s3 = peg$c10;
                                                peg$currPos += 2;
                                            } else {
                                                s3 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c11);
                                                }
                                            }
                                            if (s3 === peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 60) {
                                                    s3 = peg$c12;
                                                    peg$currPos++;
                                                } else {
                                                    s3 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c13);
                                                    }
                                                }
                                                if (s3 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 2) === peg$c14) {
                                                        s3 = peg$c14;
                                                        peg$currPos += 2;
                                                    } else {
                                                        s3 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c15);
                                                        }
                                                    }
                                                    if (s3 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 2) === peg$c16) {
                                                            s3 = peg$c16;
                                                            peg$currPos += 2;
                                                        } else {
                                                            s3 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                                peg$fail(peg$c17);
                                                            }
                                                        }
                                                        if (s3 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 2) === peg$c18) {
                                                                s3 = peg$c18;
                                                                peg$currPos += 2;
                                                            } else {
                                                                s3 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c19);
                                                                }
                                                            }
                                                            if (s3 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 2) === peg$c20) {
                                                                    s3 = peg$c20;
                                                                    peg$currPos += 2;
                                                                } else {
                                                                    s3 = peg$FAILED;
                                                                    if (peg$silentFails === 0) {
                                                                        peg$fail(peg$c21);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parse_();
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parseExpression();
                                if (s5 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c22(s1, s3, s5);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$parseOperand();
                }

                return s0;
            }

            function peg$parseOperand() {
                var s0, s1, s2, s3, s4, s5, s6, s7;

                s0 = peg$currPos;
                s1 = peg$parseTerm();
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 46) {
                            s5 = peg$c23;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c24);
                            }
                        }
                        if (s5 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 43) {
                                s5 = peg$c25;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c26);
                                }
                            }
                            if (s5 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 45) {
                                    s5 = peg$c27;
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c28);
                                    }
                                }
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseTerm();
                                if (s7 !== peg$FAILED) {
                                    s4 = [s4, s5, s6, s7];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$currPos;
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 46) {
                                s5 = peg$c23;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c24);
                                }
                            }
                            if (s5 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 43) {
                                    s5 = peg$c25;
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c26);
                                    }
                                }
                                if (s5 === peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 45) {
                                        s5 = peg$c27;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c28);
                                        }
                                    }
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parse_();
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parseTerm();
                                    if (s7 !== peg$FAILED) {
                                        s4 = [s4, s5, s6, s7];
                                        s3 = s4;
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c29(s1, s2);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }

                return s0;
            }

            function peg$parseTerm() {
                var s0, s1, s2, s3, s4, s5, s6, s7;

                s0 = peg$currPos;
                s1 = peg$parseFactor();
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 42) {
                            s5 = peg$c30;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s5 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 47) {
                                s5 = peg$c32;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c33);
                                }
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseFactor();
                                if (s7 !== peg$FAILED) {
                                    s4 = [s4, s5, s6, s7];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$currPos;
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 42) {
                                s5 = peg$c30;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s5 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 47) {
                                    s5 = peg$c32;
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c33);
                                    }
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parse_();
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parseFactor();
                                    if (s7 !== peg$FAILED) {
                                        s4 = [s4, s5, s6, s7];
                                        s3 = s4;
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c34(s1, s2);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }

                return s0;
            }

            function peg$parseFactor() {
                var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 33) {
                    s1 = peg$c35;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c36);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseExpression();
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c37(s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c38) {
                        s1 = peg$c38;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c39);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 3) === peg$c40) {
                            s1 = peg$c40;
                            peg$currPos += 3;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c41);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 7) === peg$c42) {
                                s1 = peg$c42;
                                peg$currPos += 7;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c43);
                                }
                            }
                            if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 3) === peg$c44) {
                                    s1 = peg$c44;
                                    peg$currPos += 3;
                                } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c45);
                                    }
                                }
                                if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 4) === peg$c46) {
                                        s1 = peg$c46;
                                        peg$currPos += 4;
                                    } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c47);
                                        }
                                    }
                                    if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 3) === peg$c48) {
                                            s1 = peg$c48;
                                            peg$currPos += 3;
                                        } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c49);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 40) {
                            s2 = peg$c50;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c51);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseExpression();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parse_();
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 41) {
                                            s6 = peg$c52;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c53);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c54(s1, s4);
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 5) === peg$c55) {
                            s1 = peg$c55;
                            peg$currPos += 5;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c56);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                s3 = peg$parseExpression();
                                if (s3 !== peg$FAILED) {
                                    s4 = peg$parse_();
                                    if (s4 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                            s5 = peg$c57;
                                            peg$currPos++;
                                        } else {
                                            s5 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c58);
                                            }
                                        }
                                        if (s5 !== peg$FAILED) {
                                            s6 = peg$parse_();
                                            if (s6 !== peg$FAILED) {
                                                s7 = peg$parseExpression();
                                                if (s7 !== peg$FAILED) {
                                                    s8 = peg$parse_();
                                                    if (s8 !== peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 44) {
                                                            s9 = peg$c57;
                                                            peg$currPos++;
                                                        } else {
                                                            s9 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                                peg$fail(peg$c58);
                                                            }
                                                        }
                                                        if (s9 !== peg$FAILED) {
                                                            s10 = peg$parse_();
                                                            if (s10 !== peg$FAILED) {
                                                                s11 = peg$parseExpression();
                                                                if (s11 !== peg$FAILED) {
                                                                    s12 = peg$parse_();
                                                                    if (s12 !== peg$FAILED) {
                                                                        if (input.charCodeAt(peg$currPos) === 41) {
                                                                            s13 = peg$c52;
                                                                            peg$currPos++;
                                                                        } else {
                                                                            s13 = peg$FAILED;
                                                                            if (peg$silentFails === 0) {
                                                                                peg$fail(peg$c53);
                                                                            }
                                                                        }
                                                                        if (s13 !== peg$FAILED) {
                                                                            peg$savedPos = s0;
                                                                            s1 = peg$c59(s3, s7, s11);
                                                                            s0 = s1;
                                                                        } else {
                                                                            peg$currPos = s0;
                                                                            s0 = peg$FAILED;
                                                                        }
                                                                    } else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$FAILED;
                                                                    }
                                                                } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 3) === peg$c60) {
                                s1 = peg$c60;
                                peg$currPos += 3;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c61);
                                }
                            }
                            if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 3) === peg$c62) {
                                    s1 = peg$c62;
                                    peg$currPos += 3;
                                } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c63);
                                    }
                                }
                                if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 6) === peg$c64) {
                                        s1 = peg$c64;
                                        peg$currPos += 6;
                                    } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c65);
                                        }
                                    }
                                    if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 3) === peg$c66) {
                                            s1 = peg$c66;
                                            peg$currPos += 3;
                                        } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c67);
                                            }
                                        }
                                    }
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 40) {
                                    s2 = peg$c50;
                                    peg$currPos++;
                                } else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c51);
                                    }
                                }
                                if (s2 !== peg$FAILED) {
                                    s3 = peg$parse_();
                                    if (s3 !== peg$FAILED) {
                                        s4 = peg$parseExpression();
                                        if (s4 !== peg$FAILED) {
                                            s5 = [];
                                            s6 = peg$currPos;
                                            s7 = peg$parse_();
                                            if (s7 !== peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 44) {
                                                    s8 = peg$c57;
                                                    peg$currPos++;
                                                } else {
                                                    s8 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c58);
                                                    }
                                                }
                                                if (s8 !== peg$FAILED) {
                                                    s9 = peg$parse_();
                                                    if (s9 !== peg$FAILED) {
                                                        s10 = peg$parseExpression();
                                                        if (s10 !== peg$FAILED) {
                                                            s7 = [s7, s8, s9, s10];
                                                            s6 = s7;
                                                        } else {
                                                            peg$currPos = s6;
                                                            s6 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s6;
                                                        s6 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s6;
                                                    s6 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s6;
                                                s6 = peg$FAILED;
                                            }
                                            while (s6 !== peg$FAILED) {
                                                s5.push(s6);
                                                s6 = peg$currPos;
                                                s7 = peg$parse_();
                                                if (s7 !== peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 44) {
                                                        s8 = peg$c57;
                                                        peg$currPos++;
                                                    } else {
                                                        s8 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c58);
                                                        }
                                                    }
                                                    if (s8 !== peg$FAILED) {
                                                        s9 = peg$parse_();
                                                        if (s9 !== peg$FAILED) {
                                                            s10 = peg$parseExpression();
                                                            if (s10 !== peg$FAILED) {
                                                                s7 = [s7, s8, s9, s10];
                                                                s6 = s7;
                                                            } else {
                                                                peg$currPos = s6;
                                                                s6 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s6;
                                                            s6 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s6;
                                                        s6 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s6;
                                                    s6 = peg$FAILED;
                                                }
                                            }
                                            if (s5 !== peg$FAILED) {
                                                s6 = peg$parse_();
                                                if (s6 !== peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 41) {
                                                        s7 = peg$c52;
                                                        peg$currPos++;
                                                    } else {
                                                        s7 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c53);
                                                        }
                                                    }
                                                    if (s7 !== peg$FAILED) {
                                                        peg$savedPos = s0;
                                                        s1 = peg$c68(s1, s4, s5);
                                                        s0 = s1;
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 40) {
                                    s1 = peg$c50;
                                    peg$currPos++;
                                } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c51);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    s2 = peg$parse_();
                                    if (s2 !== peg$FAILED) {
                                        s3 = peg$parseExpression();
                                        if (s3 !== peg$FAILED) {
                                            s4 = peg$parse_();
                                            if (s4 !== peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 41) {
                                                    s5 = peg$c52;
                                                    peg$currPos++;
                                                } else {
                                                    s5 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c53);
                                                    }
                                                }
                                                if (s5 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$c69(s3);
                                                    s0 = s1;
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseString();
                                }
                            }
                        }
                    }
                }

                return s0;
            }

            function peg$parseString() {
                var s0, s1, s2, s3, s4, s5, s6, s7, s8;

                peg$silentFails++;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 4) === peg$c71) {
                    s1 = peg$c71;
                    peg$currPos += 4;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c72);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c73();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s1 = peg$c27;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c28);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        s1 = null;
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        if (peg$c74.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c75);
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            while (s3 !== peg$FAILED) {
                                s2.push(s3);
                                if (peg$c74.test(input.charAt(peg$currPos))) {
                                    s3 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c75);
                                    }
                                }
                            }
                        } else {
                            s2 = peg$FAILED;
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 46) {
                                s4 = peg$c23;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c24);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = [];
                                if (peg$c74.test(input.charAt(peg$currPos))) {
                                    s6 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c75);
                                    }
                                }
                                if (s6 !== peg$FAILED) {
                                    while (s6 !== peg$FAILED) {
                                        s5.push(s6);
                                        if (peg$c74.test(input.charAt(peg$currPos))) {
                                            s6 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c75);
                                            }
                                        }
                                    }
                                } else {
                                    s5 = peg$FAILED;
                                }
                                if (s5 !== peg$FAILED) {
                                    s4 = [s4, s5];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                            if (s3 === peg$FAILED) {
                                s3 = null;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 69) {
                                    s5 = peg$c76;
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c77);
                                    }
                                }
                                if (s5 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 45) {
                                        s6 = peg$c27;
                                        peg$currPos++;
                                    } else {
                                        s6 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c28);
                                        }
                                    }
                                    if (s6 === peg$FAILED) {
                                        s6 = null;
                                    }
                                    if (s6 !== peg$FAILED) {
                                        s7 = [];
                                        if (peg$c74.test(input.charAt(peg$currPos))) {
                                            s8 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s8 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c75);
                                            }
                                        }
                                        if (s8 !== peg$FAILED) {
                                            while (s8 !== peg$FAILED) {
                                                s7.push(s8);
                                                if (peg$c74.test(input.charAt(peg$currPos))) {
                                                    s8 = input.charAt(peg$currPos);
                                                    peg$currPos++;
                                                } else {
                                                    s8 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c75);
                                                    }
                                                }
                                            }
                                        } else {
                                            s7 = peg$FAILED;
                                        }
                                        if (s7 !== peg$FAILED) {
                                            s5 = [s5, s6, s7];
                                            s4 = s5;
                                        } else {
                                            peg$currPos = s4;
                                            s4 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s4;
                                        s4 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                                if (s4 === peg$FAILED) {
                                    s4 = null;
                                }
                                if (s4 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c78();
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 34) {
                            s1 = peg$c79;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c80);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = [];
                            if (peg$c81.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c82);
                                }
                            }
                            while (s3 !== peg$FAILED) {
                                s2.push(s3);
                                if (peg$c81.test(input.charAt(peg$currPos))) {
                                    s3 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c82);
                                    }
                                }
                            }
                            if (s2 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 34) {
                                    s3 = peg$c79;
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c80);
                                    }
                                }
                                if (s3 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c83(s2);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 39) {
                                s1 = peg$c84;
                                peg$currPos++;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c85);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                s2 = [];
                                if (peg$c86.test(input.charAt(peg$currPos))) {
                                    s3 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c87);
                                    }
                                }
                                while (s3 !== peg$FAILED) {
                                    s2.push(s3);
                                    if (peg$c86.test(input.charAt(peg$currPos))) {
                                        s3 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c87);
                                        }
                                    }
                                }
                                if (s2 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 39) {
                                        s3 = peg$c84;
                                        peg$currPos++;
                                    } else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c85);
                                        }
                                    }
                                    if (s3 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c83(s2);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                    }
                }
                peg$silentFails--;
                if (s0 === peg$FAILED) {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c70);
                    }
                }

                return s0;
            }

            function peg$parse_() {
                var s0, s1;

                peg$silentFails++;
                s0 = [];
                if (peg$c89.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c90);
                    }
                }
                while (s1 !== peg$FAILED) {
                    s0.push(s1);
                    if (peg$c89.test(input.charAt(peg$currPos))) {
                        s1 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                }
                peg$silentFails--;
                if (s0 === peg$FAILED) {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c88);
                    }
                }

                return s0;
            }

            peg$result = peg$startRuleFunction();

            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                return peg$result;
            } else {
                if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                    peg$fail(peg$endExpectation());
                }

                throw peg$buildStructuredError(
                    peg$maxFailExpected,
                    peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                    peg$maxFailPos < input.length ?
                    peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) :
                    peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
                );
            }
        }

        module.exports = {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
        };


        /***/
    }),
    /* 32 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var Queue = __webpack_require__(33);

        module.exports = polylabel;
        module.exports.default = polylabel;

        function polylabel(polygon, precision, debug) {
            precision = precision || 1.0;

            // find the bounding box of the outer ring
            var minX, minY, maxX, maxY;
            for (var i = 0; i < polygon[0].length; i++) {
                var p = polygon[0][i];
                if (!i || p[0] < minX) minX = p[0];
                if (!i || p[1] < minY) minY = p[1];
                if (!i || p[0] > maxX) maxX = p[0];
                if (!i || p[1] > maxY) maxY = p[1];
            }

            var width = maxX - minX;
            var height = maxY - minY;
            var cellSize = Math.min(width, height);
            var h = cellSize / 2;

            // a priority queue of cells in order of their "potential" (max distance to polygon)
            var cellQueue = new Queue(null, compareMax);

            if (cellSize === 0) return [minX, minY];

            // cover polygon with initial cells
            for (var x = minX; x < maxX; x += cellSize) {
                for (var y = minY; y < maxY; y += cellSize) {
                    cellQueue.push(new Cell(x + h, y + h, h, polygon));
                }
            }

            // take centroid as the first best guess
            var bestCell = getCentroidCell(polygon);

            // special case for rectangular polygons
            var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
            if (bboxCell.d > bestCell.d) bestCell = bboxCell;

            var numProbes = cellQueue.length;

            while (cellQueue.length) {
                // pick the most promising cell from the queue
                var cell = cellQueue.pop();

                // update the best cell if we found a better one
                if (cell.d > bestCell.d) {
                    bestCell = cell;
                    if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);
                }

                // do not drill down further if there's no chance of a better solution
                if (cell.max - bestCell.d <= precision) continue;

                // split the cell into four cells
                h = cell.h / 2;
                cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));
                cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));
                cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));
                cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));
                numProbes += 4;
            }

            if (debug) {
                console.log('num probes: ' + numProbes);
                console.log('best distance: ' + bestCell.d);
            }

            return [bestCell.x, bestCell.y];
        }

        function compareMax(a, b) {
            return b.max - a.max;
        }

        function Cell(x, y, h, polygon) {
            this.x = x; // cell center x
            this.y = y; // cell center y
            this.h = h; // half the cell size
            this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon
            this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell
        }

        // signed distance from point to polygon outline (negative if point is outside)
        function pointToPolygonDist(x, y, polygon) {
            var inside = false;
            var minDistSq = Infinity;

            for (var k = 0; k < polygon.length; k++) {
                var ring = polygon[k];

                for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
                    var a = ring[i];
                    var b = ring[j];

                    if ((a[1] > y !== b[1] > y) &&
                        (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;

                    minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));
                }
            }

            return (inside ? 1 : -1) * Math.sqrt(minDistSq);
        }

        // get polygon centroid
        function getCentroidCell(polygon) {
            var area = 0;
            var x = 0;
            var y = 0;
            var points = polygon[0];

            for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                var a = points[i];
                var b = points[j];
                var f = a[0] * b[1] - b[0] * a[1];
                x += (a[0] + b[0]) * f;
                y += (a[1] + b[1]) * f;
                area += f * 3;
            }
            if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);
            return new Cell(x / area, y / area, 0, polygon);
        }

        // get squared distance from a point to a segment
        function getSegDistSq(px, py, a, b) {

            var x = a[0];
            var y = a[1];
            var dx = b[0] - x;
            var dy = b[1] - y;

            if (dx !== 0 || dy !== 0) {

                var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

                if (t > 1) {
                    x = b[0];
                    y = b[1];

                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }

            dx = px - x;
            dy = py - y;

            return dx * dx + dy * dy;
        }


        /***/
    }),
    /* 33 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        module.exports = TinyQueue;
        module.exports.default = TinyQueue;

        function TinyQueue(data, compare) {
            if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

            this.data = data || [];
            this.length = this.data.length;
            this.compare = compare || defaultCompare;

            if (this.length > 0) {
                for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
            }
        }

        function defaultCompare(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }

        TinyQueue.prototype = {

            push: function(item) {
                this.data.push(item);
                this.length++;
                this._up(this.length - 1);
            },

            pop: function() {
                if (this.length === 0) return undefined;

                var top = this.data[0];
                this.length--;

                if (this.length > 0) {
                    this.data[0] = this.data[this.length];
                    this._down(0);
                }
                this.data.pop();

                return top;
            },

            peek: function() {
                return this.data[0];
            },

            _up: function(pos) {
                var data = this.data;
                var compare = this.compare;
                var item = data[pos];

                while (pos > 0) {
                    var parent = (pos - 1) >> 1;
                    var current = data[parent];
                    if (compare(item, current) >= 0) break;
                    data[pos] = current;
                    pos = parent;
                }

                data[pos] = item;
            },

            _down: function(pos) {
                var data = this.data;
                var compare = this.compare;
                var halfLength = this.length >> 1;
                var item = data[pos];

                while (pos < halfLength) {
                    var left = (pos << 1) + 1;
                    var right = left + 1;
                    var best = data[left];

                    if (right < this.length && compare(data[right], best) < 0) {
                        left = right;
                        best = data[right];
                    }
                    if (compare(best, item) >= 0) break;

                    data[pos] = best;
                    pos = left;
                }

                data[pos] = item;
            }
        };


        /***/
    }),
    /* 34 */
    /***/
    (function(module, exports) {

        module.exports.RADIUS = 6378137;
        module.exports.FLATTENING = 1 / 298.257223563;
        module.exports.POLAR_RADIUS = 6356752.3142;


        /***/
    }),
    /* 35 */
    /***/
    (function(module, exports) {

        // All functions that need access to the editor's state live inside
        // the CodeMirror function. Below that, at the bottom of the file,
        // some utilities are defined.

        // CodeMirror is the only global var we claim
        window.CodeMirror = (function() {
            "use strict";
            // This is the function that produces an editor instance. Its
            // closure is used to store the editor state.
            function CodeMirror(place, givenOptions) {
                // Determine effective options based on given values and defaults.
                var options = {},
                    defaults = CodeMirror.defaults;
                for (var opt in defaults)
                    if (defaults.hasOwnProperty(opt))
                        options[opt] = (givenOptions && givenOptions.hasOwnProperty(opt) ? givenOptions : defaults)[opt];

                var input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em");
                input.setAttribute("wrap", "off");
                input.setAttribute("autocorrect", "off");
                input.setAttribute("autocapitalize", "off");
                // Wraps and hides input textarea
                var inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
                // The empty scrollbar content, used solely for managing the scrollbar thumb.
                var scrollbarInner = elt("div", null, "CodeMirror-scrollbar-inner");
                // The vertical scrollbar. Horizontal scrolling is handled by the scroller itself.
                var scrollbar = elt("div", [scrollbarInner], "CodeMirror-scrollbar");
                // DIVs containing the selection and the actual code
                var lineDiv = elt("div"),
                    selectionDiv = elt("div", null, null, "position: relative; z-index: -1");
                // Blinky cursor, and element used to ensure cursor fits at the end of a line
                var cursor = elt("pre", "\u00a0", "CodeMirror-cursor"),
                    widthForcer = elt("pre", "\u00a0", "CodeMirror-cursor", "visibility: hidden");
                // Used to measure text size
                var measure = elt("div", null, null, "position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden;");
                var lineSpace = elt("div", [measure, cursor, widthForcer, selectionDiv, lineDiv], null, "position: relative; z-index: 0");
                var gutterText = elt("div", null, "CodeMirror-gutter-text"),
                    gutter = elt("div", [gutterText], "CodeMirror-gutter");
                // Moved around its parent to cover visible view
                var mover = elt("div", [gutter, elt("div", [lineSpace], "CodeMirror-lines")], null, "position: relative");
                // Set to the height of the text, causes scrolling
                var sizer = elt("div", [mover], null, "position: relative");
                // Provides scrolling
                var scroller = elt("div", [sizer], "CodeMirror-scroll");
                scroller.setAttribute("tabIndex", "-1");
                // The element in which the editor lives.
                var wrapper = elt("div", [inputDiv, scrollbar, scroller], "CodeMirror" + (options.lineWrapping ? " CodeMirror-wrap" : ""));
                if (place.appendChild) place.appendChild(wrapper);
                else place(wrapper);

                themeChanged();
                keyMapChanged();
                // Needed to hide big blue blinking cursor on Mobile Safari
                if (ios) input.style.width = "0px";
                if (!webkit) scroller.draggable = true;
                lineSpace.style.outline = "none";
                if (options.tabindex != null) input.tabIndex = options.tabindex;
                if (options.autofocus) focusInput();
                if (!options.gutter && !options.lineNumbers) gutter.style.display = "none";
                // Needed to handle Tab key in KHTML
                if (khtml) inputDiv.style.height = "1px", inputDiv.style.position = "absolute";

                // Check for OS X >= 10.7. This has transparent scrollbars, so the
                // overlaying of one scrollbar with another won't work. This is a
                // temporary hack to simply turn off the overlay scrollbar. See
                // issue #727.
                if (mac_geLion) {
                    scrollbar.style.zIndex = -2;
                    scrollbar.style.visibility = "hidden";
                }
                // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
                else if (ie_lt8) scrollbar.style.minWidth = "18px";

                // Delayed object wrap timeouts, making sure only one is active. blinker holds an interval.
                var poll = new Delayed(),
                    highlight = new Delayed(),
                    blinker;

                // mode holds a mode API object. doc is the tree of Line objects,
                // frontier is the point up to which the content has been parsed,
                // and history the undo history (instance of History constructor).
                var mode, doc = new BranchChunk([new LeafChunk([new Line("")])]),
                    frontier = 0,
                    focused;
                loadMode();
                // The selection. These are always maintained to point at valid
                // positions. Inverted is used to remember that the user is
                // selecting bottom-to-top.
                var sel = {
                    from: {
                        line: 0,
                        ch: 0
                    },
                    to: {
                        line: 0,
                        ch: 0
                    },
                    inverted: false
                };
                // Selection-related flags. shiftSelecting obviously tracks
                // whether the user is holding shift.
                var shiftSelecting, lastClick, lastDoubleClick, lastScrollTop = 0,
                    draggingText,
                    overwrite = false,
                    suppressEdits = false,
                    pasteIncoming = false;
                // Variables used by startOperation/endOperation to track what
                // happened during the operation.
                var updateInput, userSelChange, changes, textChanged, selectionChanged,
                    gutterDirty, callbacks;
                // Current visible range (may be bigger than the view window).
                var displayOffset = 0,
                    showingFrom = 0,
                    showingTo = 0,
                    lastSizeC = 0;
                // bracketHighlighted is used to remember that a bracket has been
                // marked.
                var bracketHighlighted;
                // Tracks the maximum line length so that the horizontal scrollbar
                // can be kept static when scrolling.
                var maxLine = getLine(0),
                    updateMaxLine = false,
                    maxLineChanged = true;
                var pollingFast = false; // Ensures slowPoll doesn't cancel fastPoll
                var goalColumn = null;

                // Initialize the content.
                operation(function() {
                    setValue(options.value || "");
                    updateInput = false;
                })();
                var history = new History();

                // Register our event handlers.
                connect(scroller, "mousedown", operation(onMouseDown));
                connect(scroller, "dblclick", operation(onDoubleClick));
                connect(lineSpace, "selectstart", e_preventDefault);
                // Gecko browsers fire contextmenu *after* opening the menu, at
                // which point we can't mess with it anymore. Context menu is
                // handled in onMouseDown for Gecko.
                if (!gecko) connect(scroller, "contextmenu", onContextMenu);
                connect(scroller, "scroll", onScrollMain);
                connect(scrollbar, "scroll", onScrollBar);
                connect(scrollbar, "mousedown", function() {
                    if (focused) setTimeout(focusInput, 0);
                });
                var resizeHandler = connect(window, "resize", function() {
                    if (wrapper.parentNode) updateDisplay(true);
                    else resizeHandler();
                }, true);
                connect(input, "keyup", operation(onKeyUp));
                connect(input, "input", fastPoll);
                connect(input, "keydown", operation(onKeyDown));
                connect(input, "keypress", operation(onKeyPress));
                connect(input, "focus", onFocus);
                connect(input, "blur", onBlur);

                function drag_(e) {
                    if (options.onDragEvent && options.onDragEvent(instance, addStop(e))) return;
                    e_stop(e);
                }
                if (options.dragDrop) {
                    connect(scroller, "dragstart", onDragStart);
                    connect(scroller, "dragenter", drag_);
                    connect(scroller, "dragover", drag_);
                    connect(scroller, "drop", operation(onDrop));
                }
                connect(scroller, "paste", function() {
                    focusInput();
                    fastPoll();
                });
                connect(input, "paste", function() {
                    pasteIncoming = true;
                    fastPoll();
                });
                connect(input, "cut", operation(function() {
                    if (!options.readOnly) replaceSelection("");
                }));

                // Needed to handle Tab key in KHTML
                if (khtml) connect(sizer, "mouseup", function() {
                    if (document.activeElement == input) input.blur();
                    focusInput();
                });

                // IE throws unspecified error in certain cases, when
                // trying to access activeElement before onload
                var hasFocus;
                try {
                    hasFocus = (document.activeElement == input);
                } catch (e) {}
                if (hasFocus || options.autofocus) setTimeout(onFocus, 20);
                else onBlur();

                function isLine(l) {
                    return l >= 0 && l < doc.size;
                }
                // The instance object that we'll return. Mostly calls out to
                // local functions in the CodeMirror function. Some do some extra
                // range checking and/or clipping. operation is used to wrap the
                // call so that changes it makes are tracked, and the display is
                // updated afterwards.
                var instance = wrapper.CodeMirror = {
                    getValue: getValue,
                    setValue: operation(setValue),
                    getSelection: getSelection,
                    replaceSelection: operation(replaceSelection),
                    focus: function() {
                        window.focus();
                        focusInput();
                        onFocus();
                        fastPoll();
                    },
                    setOption: function(option, value) {
                        var oldVal = options[option];
                        options[option] = value;
                        if (option == "mode" || option == "indentUnit") loadMode();
                        else if (option == "readOnly" && value == "nocursor") {
                            onBlur();
                            input.blur();
                        } else if (option == "readOnly" && !value) {
                            resetInput(true);
                        } else if (option == "theme") themeChanged();
                        else if (option == "lineWrapping" && oldVal != value) operation(wrappingChanged)();
                        else if (option == "tabSize") updateDisplay(true);
                        else if (option == "keyMap") keyMapChanged();
                        else if (option == "tabindex") input.tabIndex = value;
                        else if (option == "showCursorWhenSelecting") updateSelection();
                        if (option == "lineNumbers" || option == "gutter" || option == "firstLineNumber" ||
                            option == "theme" || option == "lineNumberFormatter") {
                            gutterChanged();
                            updateDisplay(true);
                        }
                    },
                    getOption: function(option) {
                        return options[option];
                    },
                    getMode: function() {
                        return mode;
                    },
                    undo: operation(undo),
                    redo: operation(redo),
                    indentLine: operation(function(n, dir) {
                        if (typeof dir != "string") {
                            if (dir == null) dir = options.smartIndent ? "smart" : "prev";
                            else dir = dir ? "add" : "subtract";
                        }
                        if (isLine(n)) indentLine(n, dir);
                    }),
                    indentSelection: operation(indentSelected),
                    historySize: function() {
                        return {
                            undo: history.done.length,
                            redo: history.undone.length
                        };
                    },
                    clearHistory: function() {
                        history = new History();
                    },
                    setHistory: function(histData) {
                        history = new History();
                        history.done = histData.done;
                        history.undone = histData.undone;
                    },
                    getHistory: function() {
                        function cp(arr) {
                            for (var i = 0, nw = [], nwelt; i < arr.length; ++i) {
                                nw.push(nwelt = []);
                                for (var j = 0, elt = arr[i]; j < elt.length; ++j) {
                                    var old = [],
                                        cur = elt[j];
                                    nwelt.push({
                                        start: cur.start,
                                        added: cur.added,
                                        old: old
                                    });
                                    for (var k = 0; k < cur.old.length; ++k) old.push(hlText(cur.old[k]));
                                }
                            }
                            return nw;
                        }
                        return {
                            done: cp(history.done),
                            undone: cp(history.undone)
                        };
                    },
                    matchBrackets: operation(function() {
                        matchBrackets(true);
                    }),
                    getTokenAt: operation(function(pos) {
                        pos = clipPos(pos);
                        return getLine(pos.line).getTokenAt(mode, getStateBefore(pos.line), options.tabSize, pos.ch);
                    }),
                    getStateAfter: function(line) {
                        line = clipLine(line == null ? doc.size - 1 : line);
                        return getStateBefore(line + 1);
                    },
                    cursorCoords: function(start, mode) {
                        if (start == null) start = sel.inverted;
                        return this.charCoords(start ? sel.from : sel.to, mode);
                    },
                    charCoords: function(pos, mode) {
                        pos = clipPos(pos);
                        if (mode == "local") return localCoords(pos, false);
                        if (mode == "div") return localCoords(pos, true);
                        return pageCoords(pos);
                    },
                    coordsChar: function(coords) {
                        var off = eltOffset(lineSpace);
                        return coordsChar(coords.x - off.left, coords.y - off.top);
                    },
                    defaultTextHeight: function() {
                        return textHeight();
                    },
                    markText: operation(markText),
                    setBookmark: setBookmark,
                    findMarksAt: findMarksAt,
                    setMarker: operation(addGutterMarker),
                    clearMarker: operation(removeGutterMarker),
                    setLineClass: operation(setLineClass),
                    hideLine: operation(function(h) {
                        return setLineHidden(h, true);
                    }),
                    showLine: operation(function(h) {
                        return setLineHidden(h, false);
                    }),
                    onDeleteLine: function(line, f) {
                        if (typeof line == "number") {
                            if (!isLine(line)) return null;
                            line = getLine(line);
                        }
                        (line.handlers || (line.handlers = [])).push(f);
                        return line;
                    },
                    lineInfo: lineInfo,
                    getViewport: function() {
                        return {
                            from: showingFrom,
                            to: showingTo
                        };
                    },
                    addWidget: function(pos, node, scroll, vert, horiz) {
                        pos = localCoords(clipPos(pos));
                        var top = pos.yBot,
                            left = pos.x;
                        node.style.position = "absolute";
                        sizer.appendChild(node);
                        if (vert == "over") top = pos.y;
                        else if (vert == "near") {
                            var vspace = Math.max(scroller.offsetHeight, doc.height * textHeight()),
                                hspace = Math.max(sizer.clientWidth, lineSpace.clientWidth) - paddingLeft();
                            if (pos.yBot + node.offsetHeight > vspace && pos.y > node.offsetHeight)
                                top = pos.y - node.offsetHeight;
                            if (left + node.offsetWidth > hspace)
                                left = hspace - node.offsetWidth;
                        }
                        node.style.top = (top + paddingTop()) + "px";
                        node.style.left = node.style.right = "";
                        if (horiz == "right") {
                            left = sizer.clientWidth - node.offsetWidth;
                            node.style.right = "0px";
                        } else {
                            if (horiz == "left") left = 0;
                            else if (horiz == "middle") left = (sizer.clientWidth - node.offsetWidth) / 2;
                            node.style.left = (left + paddingLeft()) + "px";
                        }
                        if (scroll)
                            scrollIntoView(left, top, left + node.offsetWidth, top + node.offsetHeight);
                    },

                    lineCount: function() {
                        return doc.size;
                    },
                    clipPos: clipPos,
                    getCursor: function(start) {
                        if (start == null || start == "head") start = sel.inverted;
                        if (start == "anchor") start = !sel.inverted;
                        if (start == "end") start = false;
                        return copyPos(start ? sel.from : sel.to);
                    },
                    somethingSelected: function() {
                        return !posEq(sel.from, sel.to);
                    },
                    setCursor: operation(function(line, ch, user) {
                        if (ch == null && typeof line.line == "number") setCursor(line.line, line.ch, user);
                        else setCursor(line, ch, user);
                    }),
                    setSelection: operation(function(from, to, user) {
                        (user ? setSelectionUser : setSelection)(clipPos(from), clipPos(to || from));
                    }),
                    getLine: function(line) {
                        if (isLine(line)) return getLine(line).text;
                    },
                    getLineHandle: function(line) {
                        if (isLine(line)) return getLine(line);
                    },
                    setLine: operation(function(line, text) {
                        if (isLine(line)) replaceRange(text, {
                            line: line,
                            ch: 0
                        }, {
                            line: line,
                            ch: getLine(line).text.length
                        });
                    }),
                    removeLine: operation(function(line) {
                        if (isLine(line)) replaceRange("", {
                            line: line,
                            ch: 0
                        }, clipPos({
                            line: line + 1,
                            ch: 0
                        }));
                    }),
                    replaceRange: operation(replaceRange),
                    getRange: function(from, to, lineSep) {
                        return getRange(clipPos(from), clipPos(to), lineSep);
                    },

                    triggerOnKeyDown: operation(onKeyDown),
                    execCommand: function(cmd) {
                        return commands[cmd](instance);
                    },
                    // Stuff used by commands, probably not much use to outside code.
                    moveH: operation(moveH),
                    deleteH: operation(deleteH),
                    moveV: operation(moveV),
                    toggleOverwrite: function() {
                        if (overwrite) {
                            overwrite = false;
                            cursor.className = cursor.className.replace(" CodeMirror-overwrite", "");
                        } else {
                            overwrite = true;
                            cursor.className += " CodeMirror-overwrite";
                        }
                    },

                    posFromIndex: function(off) {
                        var lineNo = 0,
                            ch;
                        doc.iter(0, doc.size, function(line) {
                            var sz = line.text.length + 1;
                            if (sz > off) {
                                ch = off;
                                return true;
                            }
                            off -= sz;
                            ++lineNo;
                        });
                        return clipPos({
                            line: lineNo,
                            ch: ch
                        });
                    },
                    indexFromPos: function(coords) {
                        if (coords.line < 0 || coords.ch < 0) return 0;
                        var index = coords.ch;
                        doc.iter(0, coords.line, function(line) {
                            index += line.text.length + 1;
                        });
                        return index;
                    },
                    scrollTo: function(x, y) {
                        if (x != null) scroller.scrollLeft = x;
                        if (y != null) scrollbar.scrollTop = scroller.scrollTop = y;
                        updateDisplay([]);
                    },
                    getScrollInfo: function() {
                        return {
                            x: scroller.scrollLeft,
                            y: scrollbar.scrollTop,
                            height: scrollbar.scrollHeight,
                            width: scroller.scrollWidth
                        };
                    },
                    scrollIntoView: function(pos) {
                        var coords = localCoords(pos ? clipPos(pos) : sel.inverted ? sel.from : sel.to);
                        scrollIntoView(coords.x, coords.y, coords.x, coords.yBot);
                    },

                    setSize: function(width, height) {
                        function interpret(val) {
                            val = String(val);
                            return /^\d+$/.test(val) ? val + "px" : val;
                        }
                        if (width != null) wrapper.style.width = interpret(width);
                        if (height != null) scroller.style.height = interpret(height);
                        instance.refresh();
                    },

                    operation: function(f) {
                        return operation(f)();
                    },
                    compoundChange: function(f) {
                        return compoundChange(f);
                    },
                    refresh: function() {
                        updateDisplay(true, null, lastScrollTop);
                        if (scrollbar.scrollHeight > lastScrollTop)
                            scrollbar.scrollTop = lastScrollTop;
                    },
                    getInputField: function() {
                        return input;
                    },
                    getWrapperElement: function() {
                        return wrapper;
                    },
                    getScrollerElement: function() {
                        return scroller;
                    },
                    getGutterElement: function() {
                        return gutter;
                    }
                };

                function getLine(n) {
                    return getLineAt(doc, n);
                }

                function updateLineHeight(line, height) {
                    gutterDirty = true;
                    var diff = height - line.height;
                    for (var n = line; n; n = n.parent) n.height += diff;
                }

                function lineContent(line, wrapAt) {
                    if (!line.styles)
                        line.highlight(mode, line.stateAfter = getStateBefore(lineNo(line)), options.tabSize);
                    return line.getContent(options.tabSize, wrapAt, options.lineWrapping);
                }

                function setValue(code) {
                    var top = {
                        line: 0,
                        ch: 0
                    };
                    updateLines(top, {
                            line: doc.size - 1,
                            ch: getLine(doc.size - 1).text.length
                        },
                        splitLines(code), top, top);
                    updateInput = true;
                }

                function getValue(lineSep) {
                    var text = [];
                    doc.iter(0, doc.size, function(line) {
                        text.push(line.text);
                    });
                    return text.join(lineSep || "\n");
                }

                function onScrollBar(e) {
                    if (Math.abs(scrollbar.scrollTop - lastScrollTop) > 1) {
                        lastScrollTop = scroller.scrollTop = scrollbar.scrollTop;
                        updateDisplay([]);
                    }
                }

                function onScrollMain(e) {
                    if (options.fixedGutter && gutter.style.left != scroller.scrollLeft + "px")
                        gutter.style.left = scroller.scrollLeft + "px";
                    if (Math.abs(scroller.scrollTop - lastScrollTop) > 1) {
                        lastScrollTop = scroller.scrollTop;
                        if (scrollbar.scrollTop != lastScrollTop)
                            scrollbar.scrollTop = lastScrollTop;
                        updateDisplay([]);
                    }
                    if (options.onScroll) options.onScroll(instance);
                }

                function onMouseDown(e) {
                    setShift(e_prop(e, "shiftKey"));
                    // Check whether this is a click in a widget
                    for (var n = e_target(e); n != wrapper; n = n.parentNode)
                        if (n.parentNode == sizer && n != mover) return;

                    // See if this is a click in the gutter
                    for (var n = e_target(e); n != wrapper; n = n.parentNode)
                        if (n.parentNode == gutterText) {
                            if (options.onGutterClick)
                                options.onGutterClick(instance, indexOf(gutterText.childNodes, n) + showingFrom, e);
                            return e_preventDefault(e);
                        }

                    var start = posFromMouse(e);

                    switch (e_button(e)) {
                        case 3:
                            if (gecko) onContextMenu(e);
                            return;
                        case 2:
                            if (start) setCursor(start.line, start.ch, true);
                            setTimeout(focusInput, 20);
                            e_preventDefault(e);
                            return;
                    }
                    // For button 1, if it was clicked inside the editor
                    // (posFromMouse returning non-null), we have to adjust the
                    // selection.
                    if (!start) {
                        if (e_target(e) == scroller) e_preventDefault(e);
                        return;
                    }

                    if (!focused) onFocus();

                    var now = +new Date,
                        type = "single";
                    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
                        type = "triple";
                        e_preventDefault(e);
                        setTimeout(focusInput, 20);
                        selectLine(start.line);
                    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
                        type = "double";
                        lastDoubleClick = {
                            time: now,
                            pos: start
                        };
                        e_preventDefault(e);
                        var word = findWordAt(start);
                        setSelectionUser(word.from, word.to);
                    } else {
                        lastClick = {
                            time: now,
                            pos: start
                        };
                    }

                    function dragEnd(e2) {
                        if (webkit) scroller.draggable = false;
                        draggingText = false;
                        up();
                        drop();
                        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
                            e_preventDefault(e2);
                            setCursor(start.line, start.ch, true);
                            focusInput();
                        }
                    }
                    var last = start,
                        going;
                    if (options.dragDrop && dragAndDrop && !options.readOnly && !posEq(sel.from, sel.to) &&
                        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {
                        // Let the drag handler handle this.
                        if (webkit) scroller.draggable = true;
                        var up = connect(document, "mouseup", operation(dragEnd), true);
                        var drop = connect(scroller, "drop", operation(dragEnd), true);
                        draggingText = true;
                        // IE's approach to draggable
                        if (scroller.dragDrop) scroller.dragDrop();
                        return;
                    }
                    e_preventDefault(e);
                    if (type == "single") setCursor(start.line, start.ch, true);

                    var startstart = sel.from,
                        startend = sel.to;

                    function doSelect(cur) {
                        if (type == "single") {
                            setSelectionUser(clipPos(start), cur);
                            return;
                        }
                        startstart = clipPos(startstart);
                        startend = clipPos(startend);
                        if (type == "double") {
                            var word = findWordAt(cur);
                            if (posLess(cur, startstart)) setSelectionUser(word.from, startend);
                            else setSelectionUser(startstart, word.to);
                        } else if (type == "triple") {
                            if (posLess(cur, startstart)) setSelectionUser(startend, clipPos({
                                line: cur.line,
                                ch: 0
                            }));
                            else setSelectionUser(startstart, clipPos({
                                line: cur.line + 1,
                                ch: 0
                            }));
                        }
                    }

                    function extend(e) {
                        var cur = posFromMouse(e, true);
                        if (cur && !posEq(cur, last)) {
                            if (!focused) onFocus();
                            last = cur;
                            doSelect(cur);
                            updateInput = false;
                            var visible = visibleLines();
                            if (cur.line >= visible.to || cur.line < visible.from)
                                going = setTimeout(operation(function() {
                                    extend(e);
                                }), 150);
                        }
                    }

                    function done(e) {
                        clearTimeout(going);
                        var cur = posFromMouse(e);
                        if (cur) doSelect(cur);
                        e_preventDefault(e);
                        focusInput();
                        updateInput = true;
                        move();
                        up();
                    }
                    var move = connect(document, "mousemove", operation(function(e) {
                        clearTimeout(going);
                        e_preventDefault(e);
                        if (!ie && !e_button(e)) done(e);
                        else extend(e);
                    }), true);
                    var up = connect(document, "mouseup", operation(done), true);
                }

                function onDoubleClick(e) {
                    for (var n = e_target(e); n != wrapper; n = n.parentNode)
                        if (n.parentNode == gutterText) return e_preventDefault(e);
                    e_preventDefault(e);
                }

                function onDrop(e) {
                    if (options.onDragEvent && options.onDragEvent(instance, addStop(e))) return;
                    e_preventDefault(e);
                    var pos = posFromMouse(e, true),
                        files = e.dataTransfer.files;
                    if (!pos || options.readOnly) return;
                    if (files && files.length && window.FileReader && window.File) {
                        var n = files.length,
                            text = Array(n),
                            read = 0;
                        var loadFile = function(file, i) {
                            var reader = new FileReader;
                            reader.onload = function() {
                                text[i] = reader.result;
                                if (++read == n) {
                                    pos = clipPos(pos);
                                    operation(function() {
                                        var end = replaceRange(text.join(""), pos, pos);
                                        setSelectionUser(pos, end);
                                    })();
                                }
                            };
                            reader.readAsText(file);
                        };
                        for (var i = 0; i < n; ++i) loadFile(files[i], i);
                    } else {
                        // Don't do a replace if the drop happened inside of the selected text.
                        if (draggingText && !(posLess(pos, sel.from) || posLess(sel.to, pos))) return;
                        try {
                            var text = e.dataTransfer.getData("Text");
                            if (text) {
                                compoundChange(function() {
                                    var curFrom = sel.from,
                                        curTo = sel.to;
                                    setSelectionUser(pos, pos);
                                    if (draggingText) replaceRange("", curFrom, curTo);
                                    replaceSelection(text);
                                    focusInput();
                                });
                            }
                        } catch (e) {}
                    }
                }

                function onDragStart(e) {
                    var txt = getSelection();
                    e.dataTransfer.setData("Text", txt);

                    // Use dummy image instead of default browsers image.
                    if (e.dataTransfer.setDragImage)
                        e.dataTransfer.setDragImage(elt('img'), 0, 0);
                }

                function doHandleBinding(bound, dropShift) {
                    if (typeof bound == "string") {
                        bound = commands[bound];
                        if (!bound) return false;
                    }
                    var prevShift = shiftSelecting;
                    try {
                        if (options.readOnly) suppressEdits = true;
                        if (dropShift) shiftSelecting = null;
                        bound(instance);
                    } catch (e) {
                        if (e != Pass) throw e;
                        return false;
                    } finally {
                        shiftSelecting = prevShift;
                        suppressEdits = false;
                    }
                    return true;
                }
                var maybeTransition;

                function handleKeyBinding(e) {
                    // Handle auto keymap transitions
                    var startMap = getKeyMap(options.keyMap),
                        next = startMap.auto;
                    clearTimeout(maybeTransition);
                    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
                        if (getKeyMap(options.keyMap) == startMap) {
                            options.keyMap = (next.call ? next.call(null, instance) : next);
                        }
                    }, 50);

                    var name = keyNames[e_prop(e, "keyCode")],
                        handled = false;
                    if (name == null || e.altGraphKey) return false;
                    if (e_prop(e, "altKey")) name = "Alt-" + name;
                    if (e_prop(e, flipCtrlCmd ? "metaKey" : "ctrlKey")) name = "Ctrl-" + name;
                    if (e_prop(e, flipCtrlCmd ? "ctrlKey" : "metaKey")) name = "Cmd-" + name;

                    var stopped = false;

                    function stop() {
                        stopped = true;
                    }

                    if (e_prop(e, "shiftKey")) {
                        handled = lookupKey("Shift-" + name, options.extraKeys, options.keyMap,
                                function(b) {
                                    return doHandleBinding(b, true);
                                }, stop) ||
                            lookupKey(name, options.extraKeys, options.keyMap, function(b) {
                                if (typeof b == "string" && /^go[A-Z]/.test(b)) return doHandleBinding(b);
                            }, stop);
                    } else {
                        handled = lookupKey(name, options.extraKeys, options.keyMap, doHandleBinding, stop);
                    }
                    if (stopped) handled = false;
                    if (handled) {
                        e_preventDefault(e);
                        restartBlink();
                        if (ie_lt9) {
                            e.oldKeyCode = e.keyCode;
                            e.keyCode = 0;
                        }
                    }
                    return handled;
                }

                function handleCharBinding(e, ch) {
                    var handled = lookupKey("'" + ch + "'", options.extraKeys,
                        options.keyMap,
                        function(b) {
                            return doHandleBinding(b, true);
                        });
                    if (handled) {
                        e_preventDefault(e);
                        restartBlink();
                    }
                    return handled;
                }

                var lastStoppedKey = null;

                function onKeyDown(e) {
                    if (!focused) onFocus();
                    if (ie && e.keyCode == 27) {
                        e.returnValue = false;
                    }
                    if (pollingFast) {
                        if (readInput()) pollingFast = false;
                    }
                    if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;
                    var code = e_prop(e, "keyCode");
                    // IE does strange things with escape.
                    setShift(code == 16 || e_prop(e, "shiftKey"));
                    // First give onKeyEvent option a chance to handle this.
                    var handled = handleKeyBinding(e);
                    if (opera) {
                        lastStoppedKey = handled ? code : null;
                        // Opera has no cut event... we try to at least catch the key combo
                        if (!handled && code == 88 && e_prop(e, mac ? "metaKey" : "ctrlKey"))
                            replaceSelection("");
                    }
                }

                function onKeyPress(e) {
                    if (pollingFast) readInput();
                    if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;
                    var keyCode = e_prop(e, "keyCode"),
                        charCode = e_prop(e, "charCode");
                    if (opera && keyCode == lastStoppedKey) {
                        lastStoppedKey = null;
                        e_preventDefault(e);
                        return;
                    }
                    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(e)) return;
                    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
                    if (options.electricChars && mode.electricChars && options.smartIndent && !options.readOnly) {
                        if (mode.electricChars.indexOf(ch) > -1)
                            setTimeout(operation(function() {
                                indentLine(sel.to.line, "smart");
                            }), 75);
                    }
                    if (handleCharBinding(e, ch)) return;
                    fastPoll();
                }

                function onKeyUp(e) {
                    if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;
                    if (e_prop(e, "keyCode") == 16) shiftSelecting = null;
                }

                function onFocus() {
                    if (options.readOnly == "nocursor") return;
                    if (!focused) {
                        if (options.onFocus) options.onFocus(instance);
                        focused = true;
                        if (scroller.className.search(/\bCodeMirror-focused\b/) == -1)
                            scroller.className += " CodeMirror-focused";
                    }
                    slowPoll();
                    restartBlink();
                }

                function onBlur() {
                    if (focused) {
                        if (options.onBlur) options.onBlur(instance);
                        focused = false;
                        if (bracketHighlighted)
                            operation(function() {
                                if (bracketHighlighted) {
                                    bracketHighlighted();
                                    bracketHighlighted = null;
                                }
                            })();
                        scroller.className = scroller.className.replace(" CodeMirror-focused", "");
                    }
                    clearInterval(blinker);
                    setTimeout(function() {
                        if (!focused) shiftSelecting = null;
                    }, 150);
                }

                // Replace the range from from to to by the strings in newText.
                // Afterwards, set the selection to selFrom, selTo.
                function updateLines(from, to, newText, selFrom, selTo) {
                    if (suppressEdits) return;
                    var old = [];
                    doc.iter(from.line, to.line + 1, function(line) {
                        old.push(newHL(line.text, line.markedSpans));
                    });
                    if (history) {
                        history.addChange(from.line, newText.length, old);
                        while (history.done.length > options.undoDepth) history.done.shift();
                    }
                    var lines = updateMarkedSpans(hlSpans(old[0]), hlSpans(lst(old)), from.ch, to.ch, newText);
                    updateLinesNoUndo(from, to, lines, selFrom, selTo);
                }

                function unredoHelper(from, to) {
                    if (!from.length) return;
                    var set = from.pop(),
                        out = [];
                    for (var i = set.length - 1; i >= 0; i -= 1) {
                        var change = set[i];
                        var replaced = [],
                            end = change.start + change.added;
                        doc.iter(change.start, end, function(line) {
                            replaced.push(newHL(line.text, line.markedSpans));
                        });
                        out.push({
                            start: change.start,
                            added: change.old.length,
                            old: replaced
                        });
                        var pos = {
                            line: change.start + change.old.length - 1,
                            ch: editEnd(hlText(lst(replaced)), hlText(lst(change.old)))
                        };
                        updateLinesNoUndo({
                                line: change.start,
                                ch: 0
                            }, {
                                line: end - 1,
                                ch: getLine(end - 1).text.length
                            },
                            change.old, pos, pos);
                    }
                    updateInput = true;
                    to.push(out);
                }

                function undo() {
                    unredoHelper(history.done, history.undone);
                }

                function redo() {
                    unredoHelper(history.undone, history.done);
                }

                function updateLinesNoUndo(from, to, lines, selFrom, selTo) {
                    if (suppressEdits) return;
                    var recomputeMaxLength = false,
                        maxLineLength = maxLine.text.length;
                    if (!options.lineWrapping)
                        doc.iter(from.line, to.line + 1, function(line) {
                            if (!line.hidden && line.text.length == maxLineLength) {
                                recomputeMaxLength = true;
                                return true;
                            }
                        });
                    if (from.line != to.line || lines.length > 1) gutterDirty = true;

                    var nlines = to.line - from.line,
                        firstLine = getLine(from.line),
                        lastLine = getLine(to.line);
                    var lastHL = lst(lines);

                    // First adjust the line structure
                    if (from.ch == 0 && to.ch == 0 && hlText(lastHL) == "") {
                        // This is a whole-line replace. Treated specially to make
                        // sure line objects move the way they are supposed to.
                        var added = [],
                            prevLine = null;
                        for (var i = 0, e = lines.length - 1; i < e; ++i)
                            added.push(new Line(hlText(lines[i]), hlSpans(lines[i])));
                        lastLine.update(lastLine.text, hlSpans(lastHL));
                        if (nlines) doc.remove(from.line, nlines, callbacks);
                        if (added.length) doc.insert(from.line, added);
                    } else if (firstLine == lastLine) {
                        if (lines.length == 1) {
                            firstLine.update(firstLine.text.slice(0, from.ch) + hlText(lines[0]) + firstLine.text.slice(to.ch), hlSpans(lines[0]));
                        } else {
                            for (var added = [], i = 1, e = lines.length - 1; i < e; ++i)
                                added.push(new Line(hlText(lines[i]), hlSpans(lines[i])));
                            added.push(new Line(hlText(lastHL) + firstLine.text.slice(to.ch), hlSpans(lastHL)));
                            firstLine.update(firstLine.text.slice(0, from.ch) + hlText(lines[0]), hlSpans(lines[0]));
                            doc.insert(from.line + 1, added);
                        }
                    } else if (lines.length == 1) {
                        firstLine.update(firstLine.text.slice(0, from.ch) + hlText(lines[0]) + lastLine.text.slice(to.ch), hlSpans(lines[0]));
                        doc.remove(from.line + 1, nlines, callbacks);
                    } else {
                        var added = [];
                        firstLine.update(firstLine.text.slice(0, from.ch) + hlText(lines[0]), hlSpans(lines[0]));
                        lastLine.update(hlText(lastHL) + lastLine.text.slice(to.ch), hlSpans(lastHL));
                        for (var i = 1, e = lines.length - 1; i < e; ++i)
                            added.push(new Line(hlText(lines[i]), hlSpans(lines[i])));
                        if (nlines > 1) doc.remove(from.line + 1, nlines - 1, callbacks);
                        doc.insert(from.line + 1, added);
                    }
                    if (options.lineWrapping) {
                        var perLine = Math.max(5, scroller.clientWidth / charWidth() - 3);
                        doc.iter(from.line, from.line + lines.length, function(line) {
                            if (line.hidden) return;
                            var guess = Math.ceil(line.text.length / perLine) || 1;
                            if (guess != line.height) updateLineHeight(line, guess);
                        });
                    } else {
                        doc.iter(from.line, from.line + lines.length, function(line) {
                            var l = line.text;
                            if (!line.hidden && l.length > maxLineLength) {
                                maxLine = line;
                                maxLineLength = l.length;
                                maxLineChanged = true;
                                recomputeMaxLength = false;
                            }
                        });
                        if (recomputeMaxLength) updateMaxLine = true;
                    }

                    // Adjust frontier, schedule worker
                    frontier = Math.min(frontier, from.line);
                    startWorker(400);

                    var lendiff = lines.length - nlines - 1;
                    // Remember that these lines changed, for updating the display
                    changes.push({
                        from: from.line,
                        to: to.line + 1,
                        diff: lendiff
                    });
                    if (options.onChange) {
                        // Normalize lines to contain only strings, since that's what
                        // the change event handler expects
                        for (var i = 0; i < lines.length; ++i)
                            if (typeof lines[i] != "string") lines[i] = lines[i].text;
                        var changeObj = {
                            from: from,
                            to: to,
                            text: lines
                        };
                        if (textChanged) {
                            for (var cur = textChanged; cur.next; cur = cur.next) {}
                            cur.next = changeObj;
                        } else textChanged = changeObj;
                    }

                    // Update the selection
                    function updateLine(n) {
                        return n <= Math.min(to.line, to.line + lendiff) ? n : n + lendiff;
                    }
                    setSelection(clipPos(selFrom), clipPos(selTo),
                        updateLine(sel.from.line), updateLine(sel.to.line));
                }

                function needsScrollbar() {
                    var realHeight = doc.height * textHeight() + 2 * paddingTop();
                    return realHeight * .99 > scroller.offsetHeight ? realHeight : false;
                }

                function updateVerticalScroll(scrollTop) {
                    var scrollHeight = needsScrollbar();
                    scrollbar.style.display = scrollHeight ? "block" : "none";
                    if (scrollHeight) {
                        scrollbarInner.style.height = sizer.style.minHeight = scrollHeight + "px";
                        scrollbar.style.height = scroller.clientHeight + "px";
                        if (scrollTop != null) {
                            scrollbar.scrollTop = scroller.scrollTop = scrollTop;
                            // 'Nudge' the scrollbar to work around a Webkit bug where,
                            // in some situations, we'd end up with a scrollbar that
                            // reported its scrollTop (and looked) as expected, but
                            // *behaved* as if it was still in a previous state (i.e.
                            // couldn't scroll up, even though it appeared to be at the
                            // bottom).
                            if (webkit) setTimeout(function() {
                                if (scrollbar.scrollTop != scrollTop) return;
                                scrollbar.scrollTop = scrollTop + (scrollTop ? -1 : 1);
                                scrollbar.scrollTop = scrollTop;
                            }, 0);
                        }
                    } else {
                        sizer.style.minHeight = "";
                    }
                    // Position the mover div to align with the current virtual scroll position
                    mover.style.top = displayOffset * textHeight() + "px";
                }

                function computeMaxLength() {
                    maxLine = getLine(0);
                    maxLineChanged = true;
                    var maxLineLength = maxLine.text.length;
                    doc.iter(1, doc.size, function(line) {
                        var l = line.text;
                        if (!line.hidden && l.length > maxLineLength) {
                            maxLineLength = l.length;
                            maxLine = line;
                        }
                    });
                    updateMaxLine = false;
                }

                function replaceRange(code, from, to) {
                    from = clipPos(from);
                    if (!to) to = from;
                    else to = clipPos(to);
                    code = splitLines(code);

                    function adjustPos(pos) {
                        if (posLess(pos, from)) return pos;
                        if (!posLess(to, pos)) return end;
                        var line = pos.line + code.length - (to.line - from.line) - 1;
                        var ch = pos.ch;
                        if (pos.line == to.line)
                            ch += lst(code).length - (to.ch - (to.line == from.line ? from.ch : 0));
                        return {
                            line: line,
                            ch: ch
                        };
                    }
                    var end;
                    replaceRange1(code, from, to, function(end1) {
                        end = end1;
                        return {
                            from: adjustPos(sel.from),
                            to: adjustPos(sel.to)
                        };
                    });
                    return end;
                }

                function replaceSelection(code, collapse) {
                    replaceRange1(splitLines(code), sel.from, sel.to, function(end) {
                        if (collapse == "end") return {
                            from: end,
                            to: end
                        };
                        else if (collapse == "start") return {
                            from: sel.from,
                            to: sel.from
                        };
                        else return {
                            from: sel.from,
                            to: end
                        };
                    });
                }

                function replaceRange1(code, from, to, computeSel) {
                    var endch = code.length == 1 ? code[0].length + from.ch : lst(code).length;
                    var newSel = computeSel({
                        line: from.line + code.length - 1,
                        ch: endch
                    });
                    updateLines(from, to, code, newSel.from, newSel.to);
                }

                function getRange(from, to, lineSep) {
                    var l1 = from.line,
                        l2 = to.line;
                    if (l1 == l2) return getLine(l1).text.slice(from.ch, to.ch);
                    var code = [getLine(l1).text.slice(from.ch)];
                    doc.iter(l1 + 1, l2, function(line) {
                        code.push(line.text);
                    });
                    code.push(getLine(l2).text.slice(0, to.ch));
                    return code.join(lineSep || "\n");
                }

                function getSelection(lineSep) {
                    return getRange(sel.from, sel.to, lineSep);
                }

                function slowPoll() {
                    if (pollingFast) return;
                    poll.set(options.pollInterval, function() {
                        readInput();
                        if (focused) slowPoll();
                    });
                }

                function fastPoll() {
                    var missed = false;
                    pollingFast = true;

                    function p() {
                        var changed = readInput();
                        if (!changed && !missed) {
                            missed = true;
                            poll.set(60, p);
                        } else {
                            pollingFast = false;
                            slowPoll();
                        }
                    }
                    poll.set(20, p);
                }

                // Previnput is a hack to work with IME. If we reset the textarea
                // on every change, that breaks IME. So we look for changes
                // compared to the previous content instead. (Modern browsers have
                // events that indicate IME taking place, but these are not widely
                // supported or compatible enough yet to rely on.)
                var prevInput = "";

                function readInput() {
                    if (!focused || hasSelection(input) || options.readOnly) return false;
                    var text = input.value;
                    if (text == prevInput) return false;
                    if (!nestedOperation) startOperation();
                    shiftSelecting = null;
                    var same = 0,
                        l = Math.min(prevInput.length, text.length);
                    while (same < l && prevInput[same] == text[same]) ++same;
                    if (same < prevInput.length)
                        sel.from = {
                            line: sel.from.line,
                            ch: sel.from.ch - (prevInput.length - same)
                        };
                    else if (overwrite && posEq(sel.from, sel.to) && !pasteIncoming)
                        sel.to = {
                            line: sel.to.line,
                            ch: Math.min(getLine(sel.to.line).text.length, sel.to.ch + (text.length - same))
                        };
                    replaceSelection(text.slice(same), "end");
                    if (text.length > 1000) {
                        input.value = prevInput = "";
                    } else prevInput = text;
                    if (!nestedOperation) endOperation();
                    pasteIncoming = false;
                    return true;
                }

                function resetInput(user) {
                    if (!posEq(sel.from, sel.to)) {
                        prevInput = "";
                        input.value = getSelection();
                        if (focused) selectInput(input);
                    } else if (user) prevInput = input.value = "";
                }

                function focusInput() {
                    if (options.readOnly != "nocursor" && (ie_lt9 || document.activeElement != input))
                        input.focus();
                }

                function scrollCursorIntoView() {
                    var coords = calculateCursorCoords();
                    scrollIntoView(coords.x, coords.y, coords.x, coords.yBot);
                    if (!focused) return;
                    var box = sizer.getBoundingClientRect(),
                        doScroll = null;
                    if (coords.y + box.top < 0) doScroll = true;
                    else if (coords.y + box.top + textHeight() > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
                    if (doScroll != null) {
                        var hidden = cursor.style.display == "none";
                        if (hidden) {
                            cursor.style.display = "";
                            cursor.style.left = coords.x + "px";
                            cursor.style.top = (coords.y - displayOffset) + "px";
                        }
                        cursor.scrollIntoView(doScroll);
                        if (hidden) cursor.style.display = "none";
                    }
                }

                function calculateCursorCoords() {
                    var cursor = localCoords(sel.inverted ? sel.from : sel.to);
                    var x = options.lineWrapping ? Math.min(cursor.x, lineSpace.offsetWidth) : cursor.x;
                    return {
                        x: x,
                        y: cursor.y,
                        yBot: cursor.yBot
                    };
                }

                function scrollIntoView(x1, y1, x2, y2) {
                    var scrollPos = calculateScrollPos(x1, y1, x2, y2);
                    if (scrollPos.scrollLeft != null) {
                        scroller.scrollLeft = scrollPos.scrollLeft;
                    }
                    if (scrollPos.scrollTop != null) {
                        scrollbar.scrollTop = scroller.scrollTop = scrollPos.scrollTop;
                    }
                }

                function calculateScrollPos(x1, y1, x2, y2) {
                    var pl = paddingLeft(),
                        pt = paddingTop();
                    y1 += pt;
                    y2 += pt;
                    x1 += pl;
                    x2 += pl;
                    var screen = scroller.clientHeight,
                        screentop = scrollbar.scrollTop,
                        result = {};
                    var docBottom = needsScrollbar() || Infinity;
                    var atTop = y1 < pt + 10,
                        atBottom = y2 + pt > docBottom - 10;
                    if (y1 < screentop) result.scrollTop = atTop ? 0 : Math.max(0, y1);
                    else if (y2 > screentop + screen) result.scrollTop = (atBottom ? docBottom : y2) - screen;

                    var screenw = scroller.clientWidth,
                        screenleft = scroller.scrollLeft;
                    var gutterw = options.fixedGutter ? gutter.clientWidth : 0;
                    var atLeft = x1 < gutterw + pl + 10;
                    if (x1 < screenleft + gutterw || atLeft) {
                        if (atLeft) x1 = 0;
                        result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
                    } else if (x2 > screenw + screenleft - 3) {
                        result.scrollLeft = x2 + 10 - screenw;
                    }
                    return result;
                }

                function visibleLines(scrollTop) {
                    var lh = textHeight(),
                        top = (scrollTop != null ? scrollTop : scrollbar.scrollTop) - paddingTop();
                    var fromHeight = Math.max(0, Math.floor(top / lh));
                    var toHeight = Math.ceil((top + scroller.clientHeight) / lh);
                    return {
                        from: lineAtHeight(doc, fromHeight),
                        to: lineAtHeight(doc, toHeight)
                    };
                }
                // Uses a set of changes plus the current scroll position to
                // determine which DOM updates have to be made, and makes the
                // updates.
                function updateDisplay(changes, suppressCallback, scrollTop) {
                    if (!scroller.clientWidth) {
                        showingFrom = showingTo = displayOffset = 0;
                        return;
                    }
                    // Compute the new visible window
                    // If scrollTop is specified, use that to determine which lines
                    // to render instead of the current scrollbar position.
                    var visible = visibleLines(scrollTop);
                    // Bail out if the visible area is already rendered and nothing changed.
                    if (changes !== true && changes.length == 0 && visible.from > showingFrom && visible.to < showingTo) {
                        updateVerticalScroll(scrollTop);
                        return;
                    }
                    var from = Math.max(visible.from - 100, 0),
                        to = Math.min(doc.size, visible.to + 100);
                    if (showingFrom < from && from - showingFrom < 20) from = showingFrom;
                    if (showingTo > to && showingTo - to < 20) to = Math.min(doc.size, showingTo);

                    // Create a range of theoretically intact lines, and punch holes
                    // in that using the change info.
                    var intact = changes === true ? [] :
                        computeIntact([{
                            from: showingFrom,
                            to: showingTo,
                            domStart: 0
                        }], changes);
                    // Clip off the parts that won't be visible
                    var intactLines = 0;
                    for (var i = 0; i < intact.length; ++i) {
                        var range = intact[i];
                        if (range.from < from) {
                            range.domStart += (from - range.from);
                            range.from = from;
                        }
                        if (range.to > to) range.to = to;
                        if (range.from >= range.to) intact.splice(i--, 1);
                        else intactLines += range.to - range.from;
                    }
                    if (intactLines == to - from && from == showingFrom && to == showingTo) {
                        updateVerticalScroll(scrollTop);
                        return;
                    }
                    intact.sort(function(a, b) {
                        return a.domStart - b.domStart;
                    });

                    var th = textHeight(),
                        gutterDisplay = gutter.style.display;
                    lineDiv.style.display = "none";
                    patchDisplay(from, to, intact);
                    lineDiv.style.display = gutter.style.display = "";

                    var different = from != showingFrom || to != showingTo || lastSizeC != scroller.clientHeight + th;
                    // This is just a bogus formula that detects when the editor is
                    // resized or the font size changes.
                    if (different) lastSizeC = scroller.clientHeight + th;
                    if (from != showingFrom || to != showingTo && options.onViewportChange)
                        setTimeout(function() {
                            if (options.onViewportChange) options.onViewportChange(instance, from, to);
                        });
                    showingFrom = from;
                    showingTo = to;
                    displayOffset = heightAtLine(doc, from);
                    startWorker(100);

                    // Since this is all rather error prone, it is honoured with the
                    // only assertion in the whole file.
                    if (lineDiv.childNodes.length != showingTo - showingFrom)
                        throw new Error("BAD PATCH! " + JSON.stringify(intact) + " size=" + (showingTo - showingFrom) +
                            " nodes=" + lineDiv.childNodes.length);

                    function checkHeights() {
                        var curNode = lineDiv.firstChild,
                            heightChanged = false;
                        doc.iter(showingFrom, showingTo, function(line) {
                            // Work around bizarro IE7 bug where, sometimes, our curNode
                            // is magically replaced with a new node in the DOM, leaving
                            // us with a reference to an orphan (nextSibling-less) node.
                            if (!curNode) return;
                            if (!line.hidden) {
                                var height = Math.round(curNode.offsetHeight / th) || 1;
                                if (line.height != height) {
                                    updateLineHeight(line, height);
                                    gutterDirty = heightChanged = true;
                                }
                            }
                            curNode = curNode.nextSibling;
                        });
                        return heightChanged;
                    }

                    if (options.lineWrapping) checkHeights();

                    gutter.style.display = gutterDisplay;
                    if (different || gutterDirty) {
                        // If the gutter grew in size, re-check heights. If those changed, re-draw gutter.
                        updateGutter() && options.lineWrapping && checkHeights() && updateGutter();
                    }
                    updateVerticalScroll(scrollTop);
                    updateSelection();
                    if (!suppressCallback && options.onUpdate) options.onUpdate(instance);
                    return true;
                }

                function computeIntact(intact, changes) {
                    for (var i = 0, l = changes.length || 0; i < l; ++i) {
                        var change = changes[i],
                            intact2 = [],
                            diff = change.diff || 0;
                        for (var j = 0, l2 = intact.length; j < l2; ++j) {
                            var range = intact[j];
                            if (change.to <= range.from && change.diff)
                                intact2.push({
                                    from: range.from + diff,
                                    to: range.to + diff,
                                    domStart: range.domStart
                                });
                            else if (change.to <= range.from || change.from >= range.to)
                                intact2.push(range);
                            else {
                                if (change.from > range.from)
                                    intact2.push({
                                        from: range.from,
                                        to: change.from,
                                        domStart: range.domStart
                                    });
                                if (change.to < range.to)
                                    intact2.push({
                                        from: change.to + diff,
                                        to: range.to + diff,
                                        domStart: range.domStart + (change.to - range.from)
                                    });
                            }
                        }
                        intact = intact2;
                    }
                    return intact;
                }

                function patchDisplay(from, to, intact) {
                    function killNode(node) {
                        var tmp = node.nextSibling;
                        node.parentNode.removeChild(node);
                        return tmp;
                    }
                    // The first pass removes the DOM nodes that aren't intact.
                    if (!intact.length) removeChildren(lineDiv);
                    else {
                        var domPos = 0,
                            curNode = lineDiv.firstChild,
                            n;
                        for (var i = 0; i < intact.length; ++i) {
                            var cur = intact[i];
                            while (cur.domStart > domPos) {
                                curNode = killNode(curNode);
                                domPos++;
                            }
                            for (var j = 0, e = cur.to - cur.from; j < e; ++j) {
                                curNode = curNode.nextSibling;
                                domPos++;
                            }
                        }
                        while (curNode) curNode = killNode(curNode);
                    }
                    // This pass fills in the lines that actually changed.
                    var nextIntact = intact.shift(),
                        curNode = lineDiv.firstChild,
                        j = from;
                    doc.iter(from, to, function(line) {
                        if (nextIntact && nextIntact.to == j) nextIntact = intact.shift();
                        if (!nextIntact || nextIntact.from > j) {
                            if (line.hidden) var lineElement = elt("pre");
                            else {
                                var lineElement = lineContent(line);
                                if (line.className) lineElement.className = line.className;
                                // Kludge to make sure the styled element lies behind the selection (by z-index)
                                if (line.bgClassName) {
                                    var pre = elt("pre", "\u00a0", line.bgClassName, "position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: -2");
                                    lineElement = elt("div", [pre, lineElement], null, "position: relative");
                                }
                            }
                            lineDiv.insertBefore(lineElement, curNode);
                        } else {
                            curNode = curNode.nextSibling;
                        }
                        ++j;
                    });
                }

                function updateGutter() {
                    if (!options.gutter && !options.lineNumbers) return;
                    var hText = mover.offsetHeight,
                        hEditor = scroller.clientHeight;
                    gutter.style.height = (hText - hEditor < 2 ? hEditor : hText) + "px";
                    var fragment = document.createDocumentFragment(),
                        i = showingFrom,
                        normalNode;
                    doc.iter(showingFrom, Math.max(showingTo, showingFrom + 1), function(line) {
                        if (line.hidden) {
                            fragment.appendChild(elt("pre"));
                        } else {
                            var marker = line.gutterMarker;
                            var text = options.lineNumbers ? options.lineNumberFormatter(i + options.firstLineNumber) : null;
                            if (marker && marker.text)
                                text = marker.text.replace("%N%", text != null ? text : "");
                            else if (text == null)
                                text = "\u00a0";
                            var markerElement = fragment.appendChild(elt("pre", null, marker && marker.style));
                            markerElement.innerHTML = text;
                            for (var j = 1; j < line.height; ++j) {
                                markerElement.appendChild(elt("br"));
                                markerElement.appendChild(document.createTextNode("\u00a0"));
                            }
                            if (!marker) normalNode = i;
                        }
                        ++i;
                    });
                    gutter.style.display = "none";
                    removeChildrenAndAdd(gutterText, fragment);
                    // Make sure scrolling doesn't cause number gutter size to pop
                    if (normalNode != null && options.lineNumbers) {
                        var node = gutterText.childNodes[normalNode - showingFrom];
                        var minwidth = String(doc.size).length,
                            val = eltText(node.firstChild),
                            pad = "";
                        while (val.length + pad.length < minwidth) pad += "\u00a0";
                        if (pad) node.insertBefore(document.createTextNode(pad), node.firstChild);
                    }
                    gutter.style.display = "";
                    var resized = Math.abs((parseInt(lineSpace.style.marginLeft) || 0) - gutter.offsetWidth) > 2;
                    lineSpace.style.marginLeft = gutter.offsetWidth + "px";
                    gutterDirty = false;
                    return resized;
                }

                function updateSelection() {
                    var collapsed = posEq(sel.from, sel.to);
                    var fromPos = localCoords(sel.from, true);
                    var toPos = collapsed ? fromPos : localCoords(sel.to, true);
                    var headPos = sel.inverted ? fromPos : toPos,
                        th = textHeight();
                    var wrapOff = eltOffset(wrapper),
                        lineOff = eltOffset(lineDiv);
                    inputDiv.style.top = Math.max(0, Math.min(scroller.offsetHeight, headPos.y + lineOff.top - wrapOff.top)) + "px";
                    inputDiv.style.left = Math.max(0, Math.min(scroller.offsetWidth, headPos.x + lineOff.left - wrapOff.left)) + "px";
                    if (collapsed || options.showCursorWhenSelecting) {
                        cursor.style.top = headPos.y + "px";
                        cursor.style.left = (options.lineWrapping ? Math.min(headPos.x, lineSpace.offsetWidth) : headPos.x) + "px";
                        cursor.style.display = "";
                    } else {
                        cursor.style.display = "none";
                    }
                    if (!collapsed) {
                        var sameLine = fromPos.y == toPos.y,
                            fragment = document.createDocumentFragment();
                        var clientWidth = lineSpace.clientWidth || lineSpace.offsetWidth;
                        var clientHeight = lineSpace.clientHeight || lineSpace.offsetHeight;
                        var add = function(left, top, right, height) {
                            var rstyle = quirksMode ? "width: " + (!right ? clientWidth : clientWidth - right - left) + "px" :
                                "right: " + (right - 1) + "px";
                            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                                "px; top: " + top + "px; " + rstyle + "; height: " + height + "px"));
                        };
                        if (sel.from.ch && fromPos.y >= 0) {
                            var right = sameLine ? clientWidth - toPos.x : 0;
                            add(fromPos.x, fromPos.y, right, th);
                        }
                        var middleStart = Math.max(0, fromPos.y + (sel.from.ch ? th : 0));
                        var middleHeight = Math.min(toPos.y, clientHeight) - middleStart;
                        if (middleHeight > 0.2 * th)
                            add(0, middleStart, 0, middleHeight);
                        if ((!sameLine || !sel.from.ch) && toPos.y < clientHeight - .5 * th)
                            add(0, toPos.y, clientWidth - toPos.x, th);
                        removeChildrenAndAdd(selectionDiv, fragment);
                        selectionDiv.style.display = "";
                    } else {
                        selectionDiv.style.display = "none";
                    }
                }

                function setShift(val) {
                    if (val) shiftSelecting = shiftSelecting || (sel.inverted ? sel.to : sel.from);
                    else shiftSelecting = null;
                }

                function setSelectionUser(from, to) {
                    var sh = shiftSelecting && clipPos(shiftSelecting);
                    if (sh) {
                        if (posLess(sh, from)) from = sh;
                        else if (posLess(to, sh)) to = sh;
                    }
                    setSelection(from, to);
                    userSelChange = true;
                }
                // Update the selection. Last two args are only used by
                // updateLines, since they have to be expressed in the line
                // numbers before the update.
                function setSelection(from, to, oldFrom, oldTo) {
                    goalColumn = null;
                    if (oldFrom == null) {
                        oldFrom = sel.from.line;
                        oldTo = sel.to.line;
                    }
                    if (posEq(sel.from, from) && posEq(sel.to, to)) return;
                    if (posLess(to, from)) {
                        var tmp = to;
                        to = from;
                        from = tmp;
                    }

                    // Skip over hidden lines.
                    if (from.line != oldFrom) {
                        var from1 = skipHidden(from, oldFrom, sel.from.ch);
                        // If there is no non-hidden line left, force visibility on current line
                        if (!from1) setLineHidden(from.line, false);
                        else from = from1;
                    }
                    if (to.line != oldTo) to = skipHidden(to, oldTo, sel.to.ch);

                    if (posEq(from, to)) sel.inverted = false;
                    else if (posEq(from, sel.to)) sel.inverted = false;
                    else if (posEq(to, sel.from)) sel.inverted = true;

                    if (options.autoClearEmptyLines && posEq(sel.from, sel.to)) {
                        var head = sel.inverted ? from : to;
                        if (head.line != sel.from.line && sel.from.line < doc.size) {
                            var oldLine = getLine(sel.from.line);
                            if (/^\s+$/.test(oldLine.text))
                                setTimeout(operation(function() {
                                    if (oldLine.parent && /^\s+$/.test(oldLine.text)) {
                                        var no = lineNo(oldLine);
                                        replaceRange("", {
                                            line: no,
                                            ch: 0
                                        }, {
                                            line: no,
                                            ch: oldLine.text.length
                                        });
                                    }
                                }, 10));
                        }
                    }

                    sel.from = from;
                    sel.to = to;
                    selectionChanged = true;
                }

                function skipHidden(pos, oldLine, oldCh) {
                    function getNonHidden(dir) {
                        var lNo = pos.line + dir,
                            end = dir == 1 ? doc.size : -1;
                        while (lNo != end) {
                            var line = getLine(lNo);
                            if (!line.hidden) {
                                var ch = pos.ch;
                                if (toEnd || ch > oldCh || ch > line.text.length) ch = line.text.length;
                                return {
                                    line: lNo,
                                    ch: ch
                                };
                            }
                            lNo += dir;
                        }
                    }
                    var line = getLine(pos.line);
                    var toEnd = pos.ch == line.text.length && pos.ch != oldCh;
                    if (!line.hidden) return pos;
                    if (pos.line >= oldLine) return getNonHidden(1) || getNonHidden(-1);
                    else return getNonHidden(-1) || getNonHidden(1);
                }

                function setCursor(line, ch, user) {
                    var pos = clipPos({
                        line: line,
                        ch: ch || 0
                    });
                    (user ? setSelectionUser : setSelection)(pos, pos);
                }

                function clipLine(n) {
                    return Math.max(0, Math.min(n, doc.size - 1));
                }

                function clipPos(pos) {
                    if (pos.line < 0) return {
                        line: 0,
                        ch: 0
                    };
                    if (pos.line >= doc.size) return {
                        line: doc.size - 1,
                        ch: getLine(doc.size - 1).text.length
                    };
                    var ch = pos.ch,
                        linelen = getLine(pos.line).text.length;
                    if (ch == null || ch > linelen) return {
                        line: pos.line,
                        ch: linelen
                    };
                    else if (ch < 0) return {
                        line: pos.line,
                        ch: 0
                    };
                    else return pos;
                }

                function findPosH(dir, unit) {
                    var end = sel.inverted ? sel.from : sel.to,
                        line = end.line,
                        ch = end.ch;
                    var lineObj = getLine(line);

                    function findNextLine() {
                        for (var l = line + dir, e = dir < 0 ? -1 : doc.size; l != e; l += dir) {
                            var lo = getLine(l);
                            if (!lo.hidden) {
                                line = l;
                                lineObj = lo;
                                return true;
                            }
                        }
                    }

                    function moveOnce(boundToLine) {
                        if (ch == (dir < 0 ? 0 : lineObj.text.length)) {
                            if (!boundToLine && findNextLine()) ch = dir < 0 ? lineObj.text.length : 0;
                            else return false;
                        } else ch += dir;
                        return true;
                    }
                    if (unit == "char") moveOnce();
                    else if (unit == "column") moveOnce(true);
                    else if (unit == "word") {
                        var sawWord = false;
                        for (;;) {
                            if (dir < 0)
                                if (!moveOnce()) break;
                            if (isWordChar(lineObj.text.charAt(ch))) sawWord = true;
                            else if (sawWord) {
                                if (dir < 0) {
                                    dir = 1;
                                    moveOnce();
                                }
                                break;
                            }
                            if (dir > 0)
                                if (!moveOnce()) break;
                        }
                    }
                    return {
                        line: line,
                        ch: ch
                    };
                }

                function moveH(dir, unit) {
                    var pos = dir < 0 ? sel.from : sel.to;
                    if (shiftSelecting || posEq(sel.from, sel.to)) pos = findPosH(dir, unit);
                    setCursor(pos.line, pos.ch, true);
                }

                function deleteH(dir, unit) {
                    if (!posEq(sel.from, sel.to)) replaceRange("", sel.from, sel.to);
                    else if (dir < 0) replaceRange("", findPosH(dir, unit), sel.to);
                    else replaceRange("", sel.from, findPosH(dir, unit));
                    userSelChange = true;
                }

                function moveV(dir, unit) {
                    var dist = 0,
                        pos = localCoords(sel.inverted ? sel.from : sel.to, true);
                    if (goalColumn != null) pos.x = goalColumn;
                    if (unit == "page") {
                        var screen = Math.min(scroller.clientHeight, window.innerHeight || document.documentElement.clientHeight);
                        var target = coordsChar(pos.x, pos.y + screen * dir);
                    } else if (unit == "line") {
                        var th = textHeight();
                        var target = coordsChar(pos.x, pos.y + .5 * th + dir * th);
                    }
                    if (unit == "page") scrollbar.scrollTop += localCoords(target, true).y - pos.y;
                    setCursor(target.line, target.ch, true);
                    goalColumn = pos.x;
                }

                function findWordAt(pos) {
                    var line = getLine(pos.line).text;
                    var start = pos.ch,
                        end = pos.ch;
                    if (line) {
                        if (pos.after === false || end == line.length) --start;
                        else ++end;
                        var startChar = line.charAt(start);
                        var check = isWordChar(startChar) ? isWordChar :
                            /\s/.test(startChar) ? function(ch) {
                                return /\s/.test(ch);
                            } :
                            function(ch) {
                                return !/\s/.test(ch) && isWordChar(ch);
                            };
                        while (start > 0 && check(line.charAt(start - 1))) --start;
                        while (end < line.length && check(line.charAt(end))) ++end;
                    }
                    return {
                        from: {
                            line: pos.line,
                            ch: start
                        },
                        to: {
                            line: pos.line,
                            ch: end
                        }
                    };
                }

                function selectLine(line) {
                    setSelectionUser({
                        line: line,
                        ch: 0
                    }, clipPos({
                        line: line + 1,
                        ch: 0
                    }));
                }

                function indentSelected(mode) {
                    if (posEq(sel.from, sel.to)) return indentLine(sel.from.line, mode);
                    var e = sel.to.line - (sel.to.ch ? 0 : 1);
                    for (var i = sel.from.line; i <= e; ++i) indentLine(i, mode);
                }

                function indentLine(n, how) {
                    if (!how) how = "add";
                    if (how == "smart") {
                        if (!mode.indent) how = "prev";
                        else var state = getStateBefore(n);
                    }

                    var line = getLine(n),
                        curSpace = line.indentation(options.tabSize),
                        curSpaceString = line.text.match(/^\s*/)[0],
                        indentation;
                    if (how == "smart") {
                        indentation = mode.indent(state, line.text.slice(curSpaceString.length), line.text);
                        if (indentation == Pass) how = "prev";
                    }
                    if (how == "prev") {
                        if (n) indentation = getLine(n - 1).indentation(options.tabSize);
                        else indentation = 0;
                    } else if (how == "add") indentation = curSpace + options.indentUnit;
                    else if (how == "subtract") indentation = curSpace - options.indentUnit;
                    indentation = Math.max(0, indentation);
                    var diff = indentation - curSpace;

                    var indentString = "",
                        pos = 0;
                    if (options.indentWithTabs)
                        for (var i = Math.floor(indentation / options.tabSize); i; --i) {
                            pos += options.tabSize;
                            indentString += "\t";
                        }
                    if (pos < indentation) indentString += spaceStr(indentation - pos);

                    if (indentString != curSpaceString)
                        replaceRange(indentString, {
                            line: n,
                            ch: 0
                        }, {
                            line: n,
                            ch: curSpaceString.length
                        });
                    line.stateAfter = null;
                }

                function loadMode() {
                    mode = CodeMirror.getMode(options, options.mode);
                    doc.iter(0, doc.size, function(line) {
                        line.stateAfter = null;
                    });
                    frontier = 0;
                    startWorker(100);
                }

                function gutterChanged() {
                    var visible = options.gutter || options.lineNumbers;
                    gutter.style.display = visible ? "" : "none";
                    if (visible) gutterDirty = true;
                    else lineDiv.parentNode.style.marginLeft = 0;
                }

                function wrappingChanged(from, to) {
                    if (options.lineWrapping) {
                        wrapper.className += " CodeMirror-wrap";
                        var perLine = scroller.clientWidth / charWidth() - 3;
                        doc.iter(0, doc.size, function(line) {
                            if (line.hidden) return;
                            var guess = Math.ceil(line.text.length / perLine) || 1;
                            if (guess != 1) updateLineHeight(line, guess);
                        });
                        lineSpace.style.minWidth = widthForcer.style.left = "";
                    } else {
                        wrapper.className = wrapper.className.replace(" CodeMirror-wrap", "");
                        computeMaxLength();
                        doc.iter(0, doc.size, function(line) {
                            if (line.height != 1 && !line.hidden) updateLineHeight(line, 1);
                        });
                    }
                    changes.push({
                        from: 0,
                        to: doc.size
                    });
                }

                function themeChanged() {
                    scroller.className = scroller.className.replace(/\s*cm-s-\S+/g, "") +
                        options.theme.replace(/(^|\s)\s*/g, " cm-s-");
                }

                function keyMapChanged() {
                    var style = keyMap[options.keyMap].style;
                    wrapper.className = wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
                        (style ? " cm-keymap-" + style : "");
                }

                function TextMarker(type, style) {
                    this.lines = [];
                    this.type = type;
                    if (style) this.style = style;
                }
                TextMarker.prototype.clear = operation(function() {
                    var min, max;
                    for (var i = 0; i < this.lines.length; ++i) {
                        var line = this.lines[i];
                        var span = getMarkedSpanFor(line.markedSpans, this);
                        if (span.from != null) min = lineNo(line);
                        if (span.to != null) max = lineNo(line);
                        line.markedSpans = removeMarkedSpan(line.markedSpans, span);
                    }
                    if (min != null) changes.push({
                        from: min,
                        to: max + 1
                    });
                    this.lines.length = 0;
                    this.explicitlyCleared = true;
                });
                TextMarker.prototype.find = function() {
                    var from, to;
                    for (var i = 0; i < this.lines.length; ++i) {
                        var line = this.lines[i];
                        var span = getMarkedSpanFor(line.markedSpans, this);
                        if (span.from != null || span.to != null) {
                            var found = lineNo(line);
                            if (span.from != null) from = {
                                line: found,
                                ch: span.from
                            };
                            if (span.to != null) to = {
                                line: found,
                                ch: span.to
                            };
                        }
                    }
                    if (this.type == "bookmark") return from;
                    return from && {
                        from: from,
                        to: to
                    };
                };

                function markText(from, to, className, options) {
                    from = clipPos(from);
                    to = clipPos(to);
                    var marker = new TextMarker("range", className);
                    if (options)
                        for (var opt in options)
                            if (options.hasOwnProperty(opt))
                                marker[opt] = options[opt];
                    var curLine = from.line;
                    doc.iter(curLine, to.line + 1, function(line) {
                        var span = {
                            from: curLine == from.line ? from.ch : null,
                            to: curLine == to.line ? to.ch : null,
                            marker: marker
                        };
                        line.markedSpans = (line.markedSpans || []).concat([span]);
                        marker.lines.push(line);
                        ++curLine;
                    });
                    changes.push({
                        from: from.line,
                        to: to.line + 1
                    });
                    return marker;
                }

                function setBookmark(pos) {
                    pos = clipPos(pos);
                    var marker = new TextMarker("bookmark"),
                        line = getLine(pos.line);
                    history.addChange(pos.line, 1, [newHL(line.text, line.markedSpans)], true);
                    var span = {
                        from: pos.ch,
                        to: pos.ch,
                        marker: marker
                    };
                    line.markedSpans = (line.markedSpans || []).concat([span]);
                    marker.lines.push(line);
                    return marker;
                }

                function findMarksAt(pos) {
                    pos = clipPos(pos);
                    var markers = [],
                        spans = getLine(pos.line).markedSpans;
                    if (spans)
                        for (var i = 0; i < spans.length; ++i) {
                            var span = spans[i];
                            if ((span.from == null || span.from <= pos.ch) &&
                                (span.to == null || span.to >= pos.ch))
                                markers.push(span.marker);
                        }
                    return markers;
                }

                function addGutterMarker(line, text, className) {
                    if (typeof line == "number") line = getLine(clipLine(line));
                    line.gutterMarker = {
                        text: text,
                        style: className
                    };
                    gutterDirty = true;
                    return line;
                }

                function removeGutterMarker(line) {
                    if (typeof line == "number") line = getLine(clipLine(line));
                    line.gutterMarker = null;
                    gutterDirty = true;
                }

                function changeLine(handle, op) {
                    var no = handle,
                        line = handle;
                    if (typeof handle == "number") line = getLine(clipLine(handle));
                    else no = lineNo(handle);
                    if (no == null) return null;
                    if (op(line, no)) changes.push({
                        from: no,
                        to: no + 1
                    });
                    else return null;
                    return line;
                }

                function setLineClass(handle, className, bgClassName) {
                    return changeLine(handle, function(line) {
                        if (line.className != className || line.bgClassName != bgClassName) {
                            line.className = className;
                            line.bgClassName = bgClassName;
                            return true;
                        }
                    });
                }

                function setLineHidden(handle, hidden) {
                    return changeLine(handle, function(line, no) {
                        if (line.hidden != hidden) {
                            line.hidden = hidden;
                            if (!options.lineWrapping) {
                                if (hidden && line.text.length == maxLine.text.length) {
                                    updateMaxLine = true;
                                } else if (!hidden && line.text.length > maxLine.text.length) {
                                    maxLine = line;
                                    updateMaxLine = false;
                                }
                            }
                            updateLineHeight(line, hidden ? 0 : 1);
                            var fline = sel.from.line,
                                tline = sel.to.line;
                            if (hidden && (fline == no || tline == no)) {
                                var from = fline == no ? skipHidden({
                                    line: fline,
                                    ch: 0
                                }, fline, 0) : sel.from;
                                var to = tline == no ? skipHidden({
                                    line: tline,
                                    ch: 0
                                }, tline, 0) : sel.to;
                                // Can't hide the last visible line, we'd have no place to put the cursor
                                if (!to) return;
                                setSelection(from, to);
                            }
                            return (gutterDirty = true);
                        }
                    });
                }

                function lineInfo(line) {
                    if (typeof line == "number") {
                        if (!isLine(line)) return null;
                        var n = line;
                        line = getLine(line);
                        if (!line) return null;
                    } else {
                        var n = lineNo(line);
                        if (n == null) return null;
                    }
                    var marker = line.gutterMarker;
                    return {
                        line: n,
                        handle: line,
                        text: line.text,
                        markerText: marker && marker.text,
                        markerClass: marker && marker.style,
                        lineClass: line.className,
                        bgClass: line.bgClassName
                    };
                }

                function measureLine(line, ch) {
                    if (ch == 0) return {
                        top: 0,
                        left: 0
                    };
                    var pre = lineContent(line, ch);
                    removeChildrenAndAdd(measure, pre);
                    var anchor = pre.anchor;
                    var top = anchor.offsetTop,
                        left = anchor.offsetLeft;
                    // Older IEs report zero offsets for spans directly after a wrap
                    if (ie && top == 0 && left == 0) {
                        var backup = elt("span", "x");
                        anchor.parentNode.insertBefore(backup, anchor.nextSibling);
                        top = backup.offsetTop;
                    }
                    return {
                        top: top,
                        left: left
                    };
                }

                function localCoords(pos, inLineWrap) {
                    var x, lh = textHeight(),
                        y = lh * (heightAtLine(doc, pos.line) - (inLineWrap ? displayOffset : 0));
                    if (pos.ch == 0) x = 0;
                    else {
                        var sp = measureLine(getLine(pos.line), pos.ch);
                        x = sp.left;
                        if (options.lineWrapping) y += Math.max(0, sp.top);
                    }
                    return {
                        x: x,
                        y: y,
                        yBot: y + lh
                    };
                }
                // Coords must be lineSpace-local
                function coordsChar(x, y) {
                    var th = textHeight(),
                        cw = charWidth(),
                        heightPos = displayOffset + Math.floor(y / th);
                    if (heightPos < 0) return {
                        line: 0,
                        ch: 0
                    };
                    var lineNo = lineAtHeight(doc, heightPos);
                    if (lineNo >= doc.size) return {
                        line: doc.size - 1,
                        ch: getLine(doc.size - 1).text.length
                    };
                    var lineObj = getLine(lineNo),
                        text = lineObj.text;
                    var tw = options.lineWrapping,
                        innerOff = tw ? heightPos - heightAtLine(doc, lineNo) : 0;
                    if (x <= 0 && innerOff == 0) return {
                        line: lineNo,
                        ch: 0
                    };
                    var wrongLine = false;

                    function getX(len) {
                        var sp = measureLine(lineObj, len);
                        if (tw) {
                            var off = Math.round(sp.top / th);
                            wrongLine = off != innerOff;
                            return Math.max(0, sp.left + (off - innerOff) * scroller.clientWidth);
                        }
                        return sp.left;
                    }
                    var from = 0,
                        fromX = 0,
                        to = text.length,
                        toX;
                    // Guess a suitable upper bound for our search.
                    var estimated = Math.min(to, Math.ceil((x + innerOff * scroller.clientWidth * .9) / cw));
                    for (;;) {
                        var estX = getX(estimated);
                        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));
                        else {
                            toX = estX;
                            to = estimated;
                            break;
                        }
                    }
                    if (x > toX) return {
                        line: lineNo,
                        ch: to
                    };
                    // Try to guess a suitable lower bound as well.
                    estimated = Math.floor(to * 0.8);
                    estX = getX(estimated);
                    if (estX < x) {
                        from = estimated;
                        fromX = estX;
                    }
                    // Do a binary search between these bounds.
                    for (;;) {
                        if (to - from <= 1) {
                            var after = x - fromX < toX - x;
                            return {
                                line: lineNo,
                                ch: after ? from : to,
                                after: after
                            };
                        }
                        var middle = Math.ceil((from + to) / 2),
                            middleX = getX(middle);
                        if (middleX > x) {
                            to = middle;
                            toX = middleX;
                            if (wrongLine) toX += 1000;
                        } else {
                            from = middle;
                            fromX = middleX;
                        }
                    }
                }

                function pageCoords(pos) {
                    var local = localCoords(pos, true),
                        off = eltOffset(lineSpace);
                    return {
                        x: off.left + local.x,
                        y: off.top + local.y,
                        yBot: off.top + local.yBot
                    };
                }

                var cachedHeight, cachedHeightFor, measurePre;

                function textHeight() {
                    if (measurePre == null) {
                        measurePre = elt("pre");
                        for (var i = 0; i < 49; ++i) {
                            measurePre.appendChild(document.createTextNode("x"));
                            measurePre.appendChild(elt("br"));
                        }
                        measurePre.appendChild(document.createTextNode("x"));
                    }
                    var offsetHeight = lineDiv.clientHeight;
                    if (offsetHeight == cachedHeightFor) return cachedHeight;
                    cachedHeightFor = offsetHeight;
                    removeChildrenAndAdd(measure, measurePre.cloneNode(true));
                    cachedHeight = measure.firstChild.offsetHeight / 50 || 1;
                    removeChildren(measure);
                    return cachedHeight;
                }
                var cachedWidth, cachedWidthFor = 0;

                function charWidth() {
                    if (scroller.clientWidth == cachedWidthFor) return cachedWidth;
                    cachedWidthFor = scroller.clientWidth;
                    var anchor = elt("span", "x");
                    var pre = elt("pre", [anchor]);
                    removeChildrenAndAdd(measure, pre);
                    return (cachedWidth = anchor.offsetWidth || 10);
                }

                function paddingTop() {
                    return lineSpace.offsetTop;
                }

                function paddingLeft() {
                    return lineSpace.offsetLeft;
                }

                function posFromMouse(e, liberal) {
                    var offW = eltOffset(scroller, true),
                        x, y;
                    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
                    try {
                        x = e.clientX;
                        y = e.clientY;
                    } catch (e) {
                        return null;
                    }
                    // This is a mess of a heuristic to try and determine whether a
                    // scroll-bar was clicked or not, and to return null if one was
                    // (and !liberal).
                    if (!liberal && (x - offW.left > scroller.clientWidth || y - offW.top > scroller.clientHeight))
                        return null;
                    var offL = eltOffset(lineSpace, true);
                    return coordsChar(x - offL.left, y - offL.top);
                }
                var detectingSelectAll;

                function onContextMenu(e) {
                    var pos = posFromMouse(e),
                        scrollPos = scrollbar.scrollTop;
                    if (!pos || opera) return; // Opera is difficult.
                    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
                        operation(setCursor)(pos.line, pos.ch);

                    var oldCSS = input.style.cssText;
                    inputDiv.style.position = "absolute";
                    input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
                        "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; " +
                        "border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
                    focusInput();
                    resetInput(true);
                    // Adds "Select all" to context menu in FF
                    if (posEq(sel.from, sel.to)) input.value = prevInput = " ";

                    function rehide() {
                        inputDiv.style.position = "relative";
                        input.style.cssText = oldCSS;
                        if (ie_lt9) scrollbar.scrollTop = scrollPos;
                        slowPoll();

                        // Try to detect the user choosing select-all 
                        if (input.selectionStart != null) {
                            clearTimeout(detectingSelectAll);
                            var extval = input.value = " " + (posEq(sel.from, sel.to) ? "" : input.value),
                                i = 0;
                            prevInput = " ";
                            input.selectionStart = 1;
                            input.selectionEnd = extval.length;
                            detectingSelectAll = setTimeout(function poll() {
                                if (prevInput == " " && input.selectionStart == 0)
                                    operation(commands.selectAll)(instance);
                                else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);
                                else resetInput();
                            }, 200);
                        }
                    }

                    if (gecko) {
                        e_stop(e);
                        var mouseup = connect(window, "mouseup", function() {
                            mouseup();
                            setTimeout(rehide, 20);
                        }, true);
                    } else {
                        setTimeout(rehide, 50);
                    }
                }

                // Cursor-blinking
                function restartBlink() {
                    clearInterval(blinker);
                    var on = true;
                    cursor.style.visibility = "";
                    blinker = setInterval(function() {
                        cursor.style.visibility = (on = !on) ? "" : "hidden";
                    }, options.cursorBlinkRate);
                }

                var matching = {
                    "(": ")>",
                    ")": "(<",
                    "[": "]>",
                    "]": "[<",
                    "{": "}>",
                    "}": "{<"
                };

                function matchBrackets(autoclear) {
                    var head = sel.inverted ? sel.from : sel.to,
                        line = getLine(head.line),
                        pos = head.ch - 1;
                    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];
                    if (!match) return;
                    var ch = match.charAt(0),
                        forward = match.charAt(1) == ">",
                        d = forward ? 1 : -1,
                        st = line.styles;
                    for (var off = pos + 1, i = 0, e = st.length; i < e; i += 2)
                        if ((off -= st[i].length) <= 0) {
                            var style = st[i + 1];
                            break;
                        }

                    var stack = [line.text.charAt(pos)],
                        re = /[(){}[\]]/;

                    function scan(line, from, to) {
                        if (!line.text) return;
                        var st = line.styles,
                            pos = forward ? 0 : line.text.length - 1,
                            cur;
                        for (var i = forward ? 0 : st.length - 2, e = forward ? st.length : -2; i != e; i += 2 * d) {
                            var text = st[i];
                            if (st[i + 1] != style) {
                                pos += d * text.length;
                                continue;
                            }
                            for (var j = forward ? 0 : text.length - 1, te = forward ? text.length : -1; j != te; j += d, pos += d) {
                                if (pos >= from && pos < to && re.test(cur = text.charAt(j))) {
                                    var match = matching[cur];
                                    if (match.charAt(1) == ">" == forward) stack.push(cur);
                                    else if (stack.pop() != match.charAt(0)) return {
                                        pos: pos,
                                        match: false
                                    };
                                    else if (!stack.length) return {
                                        pos: pos,
                                        match: true
                                    };
                                }
                            }
                        }
                    }
                    for (var i = head.line, e = forward ? Math.min(i + 100, doc.size) : Math.max(-1, i - 100); i != e; i += d) {
                        var line = getLine(i),
                            first = i == head.line;
                        var found = scan(line, first && forward ? pos + 1 : 0, first && !forward ? pos : line.text.length);
                        if (found) break;
                    }
                    if (!found) found = {
                        pos: null,
                        match: false
                    };
                    var style = found.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
                    var one = markText({
                            line: head.line,
                            ch: pos
                        }, {
                            line: head.line,
                            ch: pos + 1
                        }, style),
                        two = found.pos != null && markText({
                            line: i,
                            ch: found.pos
                        }, {
                            line: i,
                            ch: found.pos + 1
                        }, style);
                    var clear = operation(function() {
                        one.clear();
                        two && two.clear();
                    });
                    if (autoclear) setTimeout(clear, 800);
                    else bracketHighlighted = clear;
                }

                // Finds the line to start with when starting a parse. Tries to
                // find a line with a stateAfter, so that it can start with a
                // valid state. If that fails, it returns the line with the
                // smallest indentation, which tends to need the least context to
                // parse correctly.
                function findStartLine(n) {
                    var minindent, minline;
                    for (var search = n, lim = n - 40; search > lim; --search) {
                        if (search == 0) return 0;
                        var line = getLine(search - 1);
                        if (line.stateAfter) return search;
                        var indented = line.indentation(options.tabSize);
                        if (minline == null || minindent > indented) {
                            minline = search - 1;
                            minindent = indented;
                        }
                    }
                    return minline;
                }

                function getStateBefore(n) {
                    var pos = findStartLine(n),
                        state = pos && getLine(pos - 1).stateAfter;
                    if (!state) state = startState(mode);
                    else state = copyState(mode, state);
                    doc.iter(pos, n, function(line) {
                        line.process(mode, state, options.tabSize);
                        line.stateAfter = (pos == n - 1 || pos % 5 == 0) ? copyState(mode, state) : null;
                    });
                    return state;
                }

                function highlightWorker() {
                    if (frontier >= showingTo) return;
                    var end = +new Date + options.workTime,
                        state = copyState(mode, getStateBefore(frontier));
                    var startFrontier = frontier;
                    doc.iter(frontier, showingTo, function(line) {
                        if (frontier >= showingFrom) { // Visible
                            line.highlight(mode, state, options.tabSize);
                            line.stateAfter = copyState(mode, state);
                        } else {
                            line.process(mode, state, options.tabSize);
                            line.stateAfter = frontier % 5 == 0 ? copyState(mode, state) : null;
                        }
                        ++frontier;
                        if (+new Date > end) {
                            startWorker(options.workDelay);
                            return true;
                        }
                    });
                    if (showingTo > startFrontier && frontier >= showingFrom)
                        operation(function() {
                            changes.push({
                                from: startFrontier,
                                to: frontier
                            });
                        })();
                }

                function startWorker(time) {
                    if (frontier < showingTo)
                        highlight.set(time, highlightWorker);
                }

                // Operations are used to wrap changes in such a way that each
                // change won't have to update the cursor and display (which would
                // be awkward, slow, and error-prone), but instead updates are
                // batched and then all combined and executed at once.
                function startOperation() {
                    updateInput = userSelChange = textChanged = null;
                    changes = [];
                    selectionChanged = false;
                    callbacks = [];
                }

                function endOperation() {
                    if (updateMaxLine) computeMaxLength();
                    if (maxLineChanged && !options.lineWrapping) {
                        var cursorWidth = widthForcer.offsetWidth,
                            left = measureLine(maxLine, maxLine.text.length).left;
                        if (!ie_lt8) {
                            widthForcer.style.left = left + "px";
                            lineSpace.style.minWidth = (left + cursorWidth) + "px";
                        }
                        maxLineChanged = false;
                    }
                    var newScrollPos, updated;
                    if (selectionChanged) {
                        var coords = calculateCursorCoords();
                        newScrollPos = calculateScrollPos(coords.x, coords.y, coords.x, coords.yBot);
                    }
                    if (changes.length || newScrollPos && newScrollPos.scrollTop != null)
                        updated = updateDisplay(changes, true, newScrollPos && newScrollPos.scrollTop);
                    if (!updated) {
                        if (selectionChanged) updateSelection();
                        if (gutterDirty) updateGutter();
                    }
                    if (newScrollPos) scrollCursorIntoView();
                    if (selectionChanged) restartBlink();

                    if (focused && (updateInput === true || (updateInput !== false && selectionChanged)))
                        resetInput(userSelChange);

                    if (selectionChanged && options.matchBrackets)
                        setTimeout(operation(function() {
                            if (bracketHighlighted) {
                                bracketHighlighted();
                                bracketHighlighted = null;
                            }
                            if (posEq(sel.from, sel.to)) matchBrackets(false);
                        }), 20);
                    var sc = selectionChanged,
                        cbs = callbacks; // these can be reset by callbacks
                    if (textChanged && options.onChange && instance)
                        options.onChange(instance, textChanged);
                    if (sc && options.onCursorActivity)
                        options.onCursorActivity(instance);
                    for (var i = 0; i < cbs.length; ++i) cbs[i](instance);
                    if (updated && options.onUpdate) options.onUpdate(instance);
                }
                var nestedOperation = 0;

                function operation(f) {
                    return function() {
                        if (!nestedOperation++) startOperation();
                        try {
                            var result = f.apply(this, arguments);
                        } finally {
                            if (!--nestedOperation) endOperation();
                        }
                        return result;
                    };
                }

                function compoundChange(f) {
                    history.startCompound();
                    try {
                        return f();
                    } finally {
                        history.endCompound();
                    }
                }

                for (var ext in extensions)
                    if (extensions.propertyIsEnumerable(ext) &&
                        !instance.propertyIsEnumerable(ext))
                        instance[ext] = extensions[ext];
                for (var i = 0; i < initHooks.length; ++i) initHooks[i](instance);
                return instance;
            } // (end of function CodeMirror)

            // The default configuration options.
            CodeMirror.defaults = {
                value: "",
                mode: null,
                theme: "default",
                indentUnit: 2,
                indentWithTabs: false,
                smartIndent: true,
                tabSize: 4,
                keyMap: "default",
                extraKeys: null,
                electricChars: true,
                autoClearEmptyLines: false,
                onKeyEvent: null,
                onDragEvent: null,
                lineWrapping: false,
                lineNumbers: false,
                gutter: false,
                fixedGutter: false,
                firstLineNumber: 1,
                showCursorWhenSelecting: false,
                readOnly: false,
                dragDrop: true,
                onChange: null,
                onCursorActivity: null,
                onViewportChange: null,
                onGutterClick: null,
                onUpdate: null,
                onFocus: null,
                onBlur: null,
                onScroll: null,
                matchBrackets: false,
                cursorBlinkRate: 530,
                workTime: 100,
                workDelay: 200,
                pollInterval: 100,
                undoDepth: 40,
                tabindex: null,
                autofocus: null,
                lineNumberFormatter: function(integer) {
                    return integer;
                }
            };

            var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
            var mac = ios || /Mac/.test(navigator.platform);
            var win = /Win/.test(navigator.platform);

            // Known modes, by name and by MIME
            var modes = CodeMirror.modes = {},
                mimeModes = CodeMirror.mimeModes = {};
            CodeMirror.defineMode = function(name, mode) {
                if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
                if (arguments.length > 2) {
                    mode.dependencies = [];
                    for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
                }
                modes[name] = mode;
            };
            CodeMirror.defineMIME = function(mime, spec) {
                mimeModes[mime] = spec;
            };
            CodeMirror.resolveMode = function(spec) {
                if (typeof spec == "string" && mimeModes.hasOwnProperty(spec))
                    spec = mimeModes[spec];
                else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
                    return CodeMirror.resolveMode("application/xml");
                if (typeof spec == "string") return {
                    name: spec
                };
                else return spec || {
                    name: "null"
                };
            };
            CodeMirror.getMode = function(options, spec) {
                var spec = CodeMirror.resolveMode(spec);
                var mfactory = modes[spec.name];
                if (!mfactory) return CodeMirror.getMode(options, "text/plain");
                var modeObj = mfactory(options, spec);
                if (modeExtensions.hasOwnProperty(spec.name)) {
                    var exts = modeExtensions[spec.name];
                    for (var prop in exts) {
                        if (!exts.hasOwnProperty(prop)) continue;
                        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
                        modeObj[prop] = exts[prop];
                    }
                }
                modeObj.name = spec.name;
                return modeObj;
            };
            CodeMirror.listModes = function() {
                var list = [];
                for (var m in modes)
                    if (modes.propertyIsEnumerable(m)) list.push(m);
                return list;
            };
            CodeMirror.listMIMEs = function() {
                var list = [];
                for (var m in mimeModes)
                    if (mimeModes.propertyIsEnumerable(m)) list.push({
                        mime: m,
                        mode: mimeModes[m]
                    });
                return list;
            };

            var extensions = CodeMirror.extensions = {};
            CodeMirror.defineExtension = function(name, func) {
                extensions[name] = func;
            };

            var initHooks = [];
            CodeMirror.defineInitHook = function(f) {
                initHooks.push(f);
            };

            var modeExtensions = CodeMirror.modeExtensions = {};
            CodeMirror.extendMode = function(mode, properties) {
                var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
                for (var prop in properties)
                    if (properties.hasOwnProperty(prop))
                        exts[prop] = properties[prop];
            };

            var commands = CodeMirror.commands = {
                selectAll: function(cm) {
                    cm.setSelection({
                        line: 0,
                        ch: 0
                    }, {
                        line: cm.lineCount() - 1
                    });
                },
                killLine: function(cm) {
                    var from = cm.getCursor(true),
                        to = cm.getCursor(false),
                        sel = !posEq(from, to);
                    if (!sel && cm.getLine(from.line).length == from.ch) cm.replaceRange("", from, {
                        line: from.line + 1,
                        ch: 0
                    });
                    else cm.replaceRange("", from, sel ? to : {
                        line: from.line
                    });
                },
                deleteLine: function(cm) {
                    var l = cm.getCursor().line;
                    cm.replaceRange("", {
                        line: l,
                        ch: 0
                    }, {
                        line: l
                    });
                },
                undo: function(cm) {
                    cm.undo();
                },
                redo: function(cm) {
                    cm.redo();
                },
                goDocStart: function(cm) {
                    cm.setCursor(0, 0, true);
                },
                goDocEnd: function(cm) {
                    cm.setSelection({
                        line: cm.lineCount() - 1
                    }, null, true);
                },
                goLineStart: function(cm) {
                    cm.setCursor(cm.getCursor().line, 0, true);
                },
                goLineStartSmart: function(cm) {
                    var cur = cm.getCursor();
                    var text = cm.getLine(cur.line),
                        firstNonWS = Math.max(0, text.search(/\S/));
                    cm.setCursor(cur.line, cur.ch <= firstNonWS && cur.ch ? 0 : firstNonWS, true);
                },
                goLineEnd: function(cm) {
                    cm.setSelection({
                        line: cm.getCursor().line
                    }, null, true);
                },
                goLineUp: function(cm) {
                    cm.moveV(-1, "line");
                },
                goLineDown: function(cm) {
                    cm.moveV(1, "line");
                },
                goPageUp: function(cm) {
                    cm.moveV(-1, "page");
                },
                goPageDown: function(cm) {
                    cm.moveV(1, "page");
                },
                goCharLeft: function(cm) {
                    cm.moveH(-1, "char");
                },
                goCharRight: function(cm) {
                    cm.moveH(1, "char");
                },
                goColumnLeft: function(cm) {
                    cm.moveH(-1, "column");
                },
                goColumnRight: function(cm) {
                    cm.moveH(1, "column");
                },
                goWordLeft: function(cm) {
                    cm.moveH(-1, "word");
                },
                goWordRight: function(cm) {
                    cm.moveH(1, "word");
                },
                delCharLeft: function(cm) {
                    cm.deleteH(-1, "char");
                },
                delCharRight: function(cm) {
                    cm.deleteH(1, "char");
                },
                delWordLeft: function(cm) {
                    cm.deleteH(-1, "word");
                },
                delWordRight: function(cm) {
                    cm.deleteH(1, "word");
                },
                indentAuto: function(cm) {
                    cm.indentSelection("smart");
                },
                indentMore: function(cm) {
                    cm.indentSelection("add");
                },
                indentLess: function(cm) {
                    cm.indentSelection("subtract");
                },
                insertTab: function(cm) {
                    cm.replaceSelection("\t", "end");
                },
                defaultTab: function(cm) {
                    if (cm.somethingSelected()) cm.indentSelection("add");
                    else cm.replaceSelection("\t", "end");
                },
                transposeChars: function(cm) {
                    var cur = cm.getCursor(),
                        line = cm.getLine(cur.line);
                    if (cur.ch > 0 && cur.ch < line.length - 1)
                        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), {
                            line: cur.line,
                            ch: cur.ch - 1
                        }, {
                            line: cur.line,
                            ch: cur.ch + 1
                        });
                },
                newlineAndIndent: function(cm) {
                    cm.replaceSelection("\n", "end");
                    cm.indentLine(cm.getCursor().line);
                },
                toggleOverwrite: function(cm) {
                    cm.toggleOverwrite();
                }
            };

            var keyMap = CodeMirror.keyMap = {};
            keyMap.basic = {
                "Left": "goCharLeft",
                "Right": "goCharRight",
                "Up": "goLineUp",
                "Down": "goLineDown",
                "End": "goLineEnd",
                "Home": "goLineStartSmart",
                "PageUp": "goPageUp",
                "PageDown": "goPageDown",
                "Delete": "delCharRight",
                "Backspace": "delCharLeft",
                "Tab": "defaultTab",
                "Shift-Tab": "indentAuto",
                "Enter": "newlineAndIndent",
                "Insert": "toggleOverwrite"
            };
            // Note that the save and find-related commands aren't defined by
            // default. Unknown commands are simply ignored.
            keyMap.pcDefault = {
                "Ctrl-A": "selectAll",
                "Ctrl-D": "deleteLine",
                "Ctrl-Z": "undo",
                "Shift-Ctrl-Z": "redo",
                "Ctrl-Y": "redo",
                "Ctrl-Home": "goDocStart",
                "Alt-Up": "goDocStart",
                "Ctrl-End": "goDocEnd",
                "Ctrl-Down": "goDocEnd",
                "Ctrl-Left": "goWordLeft",
                "Ctrl-Right": "goWordRight",
                "Alt-Left": "goLineStart",
                "Alt-Right": "goLineEnd",
                "Ctrl-Backspace": "delWordLeft",
                "Ctrl-Delete": "delWordRight",
                "Ctrl-S": "save",
                "Ctrl-F": "find",
                "Ctrl-G": "findNext",
                "Shift-Ctrl-G": "findPrev",
                "Shift-Ctrl-F": "replace",
                "Shift-Ctrl-R": "replaceAll",
                "Ctrl-[": "indentLess",
                "Ctrl-]": "indentMore",
                fallthrough: "basic"
            };
            keyMap.macDefault = {
                "Cmd-A": "selectAll",
                "Cmd-D": "deleteLine",
                "Cmd-Z": "undo",
                "Shift-Cmd-Z": "redo",
                "Cmd-Y": "redo",
                "Cmd-Up": "goDocStart",
                "Cmd-End": "goDocEnd",
                "Cmd-Down": "goDocEnd",
                "Alt-Left": "goWordLeft",
                "Alt-Right": "goWordRight",
                "Cmd-Left": "goLineStart",
                "Cmd-Right": "goLineEnd",
                "Alt-Backspace": "delWordLeft",
                "Ctrl-Alt-Backspace": "delWordRight",
                "Alt-Delete": "delWordRight",
                "Cmd-S": "save",
                "Cmd-F": "find",
                "Cmd-G": "findNext",
                "Shift-Cmd-G": "findPrev",
                "Cmd-Alt-F": "replace",
                "Shift-Cmd-Alt-F": "replaceAll",
                "Cmd-[": "indentLess",
                "Cmd-]": "indentMore",
                fallthrough: ["basic", "emacsy"]
            };
            keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
            keyMap.emacsy = {
                "Ctrl-F": "goCharRight",
                "Ctrl-B": "goCharLeft",
                "Ctrl-P": "goLineUp",
                "Ctrl-N": "goLineDown",
                "Alt-F": "goWordRight",
                "Alt-B": "goWordLeft",
                "Ctrl-A": "goLineStart",
                "Ctrl-E": "goLineEnd",
                "Ctrl-V": "goPageDown",
                "Shift-Ctrl-V": "goPageUp",
                "Ctrl-D": "delCharRight",
                "Ctrl-H": "delCharLeft",
                "Alt-D": "delWordRight",
                "Alt-Backspace": "delWordLeft",
                "Ctrl-K": "killLine",
                "Ctrl-T": "transposeChars"
            };

            function getKeyMap(val) {
                if (typeof val == "string") return keyMap[val];
                else return val;
            }

            function lookupKey(name, extraMap, map, handle, stop) {
                function lookup(map) {
                    map = getKeyMap(map);
                    var found = map[name];
                    if (found === false) {
                        if (stop) stop();
                        return true;
                    }
                    if (found != null && handle(found)) return true;
                    if (map.nofallthrough) {
                        if (stop) stop();
                        return true;
                    }
                    var fallthrough = map.fallthrough;
                    if (fallthrough == null) return false;
                    if (Object.prototype.toString.call(fallthrough) != "[object Array]")
                        return lookup(fallthrough);
                    for (var i = 0, e = fallthrough.length; i < e; ++i) {
                        if (lookup(fallthrough[i])) return true;
                    }
                    return false;
                }
                if (extraMap && lookup(extraMap)) return true;
                return lookup(map);
            }

            function isModifierKey(event) {
                var name = keyNames[e_prop(event, "keyCode")];
                return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
            }
            CodeMirror.isModifierKey = isModifierKey;

            CodeMirror.fromTextArea = function(textarea, options) {
                if (!options) options = {};
                options.value = textarea.value;
                if (!options.tabindex && textarea.tabindex)
                    options.tabindex = textarea.tabindex;
                // Set autofocus to true if this textarea is focused, or if it has
                // autofocus and no other element is focused.
                if (options.autofocus == null) {
                    var hasFocus = document.body;
                    // doc.activeElement occasionally throws on IE
                    try {
                        hasFocus = document.activeElement;
                    } catch (e) {}
                    options.autofocus = hasFocus == textarea ||
                        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
                }

                function save() {
                    textarea.value = instance.getValue();
                }
                if (textarea.form) {
                    // Deplorable hack to make the submit method do the right thing.
                    var rmSubmit = connect(textarea.form, "submit", save, true);
                    var form = textarea.form,
                        realSubmit = form.submit;
                    textarea.form.submit = function wrappedSubmit() {
                        save();
                        form.submit = realSubmit;
                        form.submit();
                        form.submit = wrappedSubmit;
                    };
                }

                textarea.style.display = "none";
                var instance = CodeMirror(function(node) {
                    textarea.parentNode.insertBefore(node, textarea.nextSibling);
                }, options);
                instance.save = save;
                instance.getTextArea = function() {
                    return textarea;
                };
                instance.toTextArea = function() {
                    save();
                    textarea.parentNode.removeChild(instance.getWrapperElement());
                    textarea.style.display = "";
                    if (textarea.form) {
                        rmSubmit();
                        if (typeof textarea.form.submit == "function")
                            textarea.form.submit = realSubmit;
                    }
                };
                return instance;
            };

            var gecko = /gecko\/\d/i.test(navigator.userAgent);
            var ie = /MSIE \d/.test(navigator.userAgent);
            var ie_lt8 = /MSIE [1-7]\b/.test(navigator.userAgent);
            var ie_lt9 = /MSIE [1-8]\b/.test(navigator.userAgent);
            var quirksMode = ie && document.documentMode == 5;
            var webkit = /WebKit\//.test(navigator.userAgent);
            var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
            var chrome = /Chrome\//.test(navigator.userAgent);
            var opera = /Opera\//.test(navigator.userAgent);
            var safari = /Apple Computer/.test(navigator.vendor);
            var khtml = /KHTML\//.test(navigator.userAgent);
            var mac_geLion = /Mac OS X 10\D([7-9]|\d\d)\D/.test(navigator.userAgent);

            var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
            if (opera_version) opera_version = Number(opera_version[1]);
            // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
            var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));

            // Utility functions for working with state. Exported because modes
            // sometimes need to do this.
            function copyState(mode, state) {
                if (state === true) return state;
                if (mode.copyState) return mode.copyState(state);
                var nstate = {};
                for (var n in state) {
                    var val = state[n];
                    if (val instanceof Array) val = val.concat([]);
                    nstate[n] = val;
                }
                return nstate;
            }
            CodeMirror.copyState = copyState;

            function startState(mode, a1, a2) {
                return mode.startState ? mode.startState(a1, a2) : true;
            }
            CodeMirror.startState = startState;
            CodeMirror.innerMode = function(mode, state) {
                while (mode.innerMode) {
                    var info = mode.innerMode(state);
                    state = info.state;
                    mode = info.mode;
                }
                return info || {
                    mode: mode,
                    state: state
                };
            };

            // The character stream used by a mode's parser.
            function StringStream(string, tabSize) {
                this.pos = this.start = 0;
                this.string = string;
                this.tabSize = tabSize || 8;
            }
            StringStream.prototype = {
                eol: function() {
                    return this.pos >= this.string.length;
                },
                sol: function() {
                    return this.pos == 0;
                },
                peek: function() {
                    return this.string.charAt(this.pos) || undefined;
                },
                next: function() {
                    if (this.pos < this.string.length)
                        return this.string.charAt(this.pos++);
                },
                eat: function(match) {
                    var ch = this.string.charAt(this.pos);
                    if (typeof match == "string") var ok = ch == match;
                    else var ok = ch && (match.test ? match.test(ch) : match(ch));
                    if (ok) {
                        ++this.pos;
                        return ch;
                    }
                },
                eatWhile: function(match) {
                    var start = this.pos;
                    while (this.eat(match)) {}
                    return this.pos > start;
                },
                eatSpace: function() {
                    var start = this.pos;
                    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
                    return this.pos > start;
                },
                skipToEnd: function() {
                    this.pos = this.string.length;
                },
                skipTo: function(ch) {
                    var found = this.string.indexOf(ch, this.pos);
                    if (found > -1) {
                        this.pos = found;
                        return true;
                    }
                },
                backUp: function(n) {
                    this.pos -= n;
                },
                column: function() {
                    return countColumn(this.string, this.start, this.tabSize);
                },
                indentation: function() {
                    return countColumn(this.string, null, this.tabSize);
                },
                match: function(pattern, consume, caseInsensitive) {
                    if (typeof pattern == "string") {
                        var cased = function(str) {
                            return caseInsensitive ? str.toLowerCase() : str;
                        };
                        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {
                            if (consume !== false) this.pos += pattern.length;
                            return true;
                        }
                    } else {
                        var match = this.string.slice(this.pos).match(pattern);
                        if (match && match.index > 0) return null;
                        if (match && consume !== false) this.pos += match[0].length;
                        return match;
                    }
                },
                current: function() {
                    return this.string.slice(this.start, this.pos);
                }
            };
            CodeMirror.StringStream = StringStream;

            function MarkedSpan(from, to, marker) {
                this.from = from;
                this.to = to;
                this.marker = marker;
            }

            function getMarkedSpanFor(spans, marker) {
                if (spans)
                    for (var i = 0; i < spans.length; ++i) {
                        var span = spans[i];
                        if (span.marker == marker) return span;
                    }
            }

            function removeMarkedSpan(spans, span) {
                var r;
                for (var i = 0; i < spans.length; ++i)
                    if (spans[i] != span)(r || (r = [])).push(spans[i]);
                return r;
            }

            function markedSpansBefore(old, startCh, endCh) {
                if (old)
                    for (var i = 0, nw; i < old.length; ++i) {
                        var span = old[i],
                            marker = span.marker;
                        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                        if (startsBefore || marker.type == "bookmark" && span.from == startCh && span.from != endCh) {
                            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                            (nw || (nw = [])).push({
                                from: span.from,
                                to: endsAfter ? null : span.to,
                                marker: marker
                            });
                        }
                    }
                return nw;
            }

            function markedSpansAfter(old, endCh) {
                if (old)
                    for (var i = 0, nw; i < old.length; ++i) {
                        var span = old[i],
                            marker = span.marker;
                        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                        if (endsAfter || marker.type == "bookmark" && span.from == endCh) {
                            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                            (nw || (nw = [])).push({
                                from: startsBefore ? null : span.from - endCh,
                                to: span.to == null ? null : span.to - endCh,
                                marker: marker
                            });
                        }
                    }
                return nw;
            }

            function updateMarkedSpans(oldFirst, oldLast, startCh, endCh, newText) {
                if (!oldFirst && !oldLast) return newText;
                // Get the spans that 'stick out' on both sides
                var first = markedSpansBefore(oldFirst, startCh);
                var last = markedSpansAfter(oldLast, endCh);

                // Next, merge those two ends
                var sameLine = newText.length == 1,
                    offset = lst(newText).length + (sameLine ? startCh : 0);
                if (first) {
                    // Fix up .to properties of first
                    for (var i = 0; i < first.length; ++i) {
                        var span = first[i];
                        if (span.to == null) {
                            var found = getMarkedSpanFor(last, span.marker);
                            if (!found) span.to = startCh;
                            else if (sameLine) span.to = found.to == null ? null : found.to + offset;
                        }
                    }
                }
                if (last) {
                    // Fix up .from in last (or move them into first in case of sameLine)
                    for (var i = 0; i < last.length; ++i) {
                        var span = last[i];
                        if (span.to != null) span.to += offset;
                        if (span.from == null) {
                            var found = getMarkedSpanFor(first, span.marker);
                            if (!found) {
                                span.from = offset;
                                if (sameLine)(first || (first = [])).push(span);
                            }
                        } else {
                            span.from += offset;
                            if (sameLine)(first || (first = [])).push(span);
                        }
                    }
                }

                var newMarkers = [newHL(newText[0], first)];
                if (!sameLine) {
                    // Fill gap with whole-line-spans
                    var gap = newText.length - 2,
                        gapMarkers;
                    if (gap > 0 && first)
                        for (var i = 0; i < first.length; ++i)
                            if (first[i].to == null)
                                (gapMarkers || (gapMarkers = [])).push({
                                    from: null,
                                    to: null,
                                    marker: first[i].marker
                                });
                    for (var i = 0; i < gap; ++i)
                        newMarkers.push(newHL(newText[i + 1], gapMarkers));
                    newMarkers.push(newHL(lst(newText), last));
                }
                return newMarkers;
            }

            // hl stands for history-line, a data structure that can be either a
            // string (line without markers) or a {text, markedSpans} object.
            function hlText(val) {
                return typeof val == "string" ? val : val.text;
            }

            function hlSpans(val) {
                if (typeof val == "string") return null;
                var spans = val.markedSpans,
                    out = null;
                for (var i = 0; i < spans.length; ++i) {
                    if (spans[i].marker.explicitlyCleared) {
                        if (!out) out = spans.slice(0, i);
                    } else if (out) out.push(spans[i]);
                }
                return !out ? spans : out.length ? out : null;
            }

            function newHL(text, spans) {
                return spans ? {
                    text: text,
                    markedSpans: spans
                } : text;
            }

            function detachMarkedSpans(line) {
                var spans = line.markedSpans;
                if (!spans) return;
                for (var i = 0; i < spans.length; ++i) {
                    var lines = spans[i].marker.lines;
                    var ix = indexOf(lines, line);
                    lines.splice(ix, 1);
                }
                line.markedSpans = null;
            }

            function attachMarkedSpans(line, spans) {
                if (!spans) return;
                for (var i = 0; i < spans.length; ++i)
                    var marker = spans[i].marker.lines.push(line);
                line.markedSpans = spans;
            }

            // When measuring the position of the end of a line, different
            // browsers require different approaches. If an empty span is added,
            // many browsers report bogus offsets. Of those, some (Webkit,
            // recent IE) will accept a space without moving the whole span to
            // the next line when wrapping it, others work with a zero-width
            // space.
            var eolSpanContent = " ";
            if (gecko || (ie && !ie_lt8)) eolSpanContent = "\u200b";
            else if (opera) eolSpanContent = "";

            // Line objects. These hold state related to a line, including
            // highlighting info (the styles array).
            function Line(text, markedSpans) {
                this.text = text;
                this.height = 1;
                attachMarkedSpans(this, markedSpans);
            }
            Line.prototype = {
                update: function(text, markedSpans) {
                    this.text = text;
                    this.stateAfter = this.styles = null;
                    detachMarkedSpans(this);
                    attachMarkedSpans(this, markedSpans);
                },
                // Run the given mode's parser over a line, update the styles
                // array, which contains alternating fragments of text and CSS
                // classes.
                highlight: function(mode, state, tabSize) {
                    var stream = new StringStream(this.text, tabSize),
                        st = this.styles || (this.styles = []);
                    var pos = st.length = 0;
                    if (this.text == "" && mode.blankLine) mode.blankLine(state);
                    while (!stream.eol()) {
                        var style = mode.token(stream, state),
                            substr = stream.current();
                        stream.start = stream.pos;
                        if (pos && st[pos - 1] == style) {
                            st[pos - 2] += substr;
                        } else if (substr) {
                            st[pos++] = substr;
                            st[pos++] = style;
                        }
                        // Give up when line is ridiculously long
                        if (stream.pos > 5000) {
                            st[pos++] = this.text.slice(stream.pos);
                            st[pos++] = null;
                            break;
                        }
                    }
                },
                process: function(mode, state, tabSize) {
                    var stream = new StringStream(this.text, tabSize);
                    if (this.text == "" && mode.blankLine) mode.blankLine(state);
                    while (!stream.eol() && stream.pos <= 5000) {
                        mode.token(stream, state);
                        stream.start = stream.pos;
                    }
                },
                // Fetch the parser token for a given character. Useful for hacks
                // that want to inspect the mode state (say, for completion).
                getTokenAt: function(mode, state, tabSize, ch) {
                    var txt = this.text,
                        stream = new StringStream(txt, tabSize);
                    while (stream.pos < ch && !stream.eol()) {
                        stream.start = stream.pos;
                        var style = mode.token(stream, state);
                    }
                    return {
                        start: stream.start,
                        end: stream.pos,
                        string: stream.current(),
                        className: style || null,
                        state: state
                    };
                },
                indentation: function(tabSize) {
                    return countColumn(this.text, null, tabSize);
                },
                // Produces an HTML fragment for the line, taking selection,
                // marking, and highlighting into account.
                getContent: function(tabSize, wrapAt, compensateForWrapping) {
                    var first = true,
                        col = 0,
                        specials = /[\t\u0000-\u0019\u200b\u2028\u2029\uFEFF]/g;
                    var pre = elt("pre");

                    function span_(html, text, style) {
                        if (!text) return;
                        // Work around a bug where, in some compat modes, IE ignores leading spaces
                        if (first && ie && text.charAt(0) == " ") text = "\u00a0" + text.slice(1);
                        first = false;
                        if (!specials.test(text)) {
                            col += text.length;
                            var content = document.createTextNode(text);
                        } else {
                            var content = document.createDocumentFragment(),
                                pos = 0;
                            while (true) {
                                specials.lastIndex = pos;
                                var m = specials.exec(text);
                                var skipped = m ? m.index - pos : text.length - pos;
                                if (skipped) {
                                    content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
                                    col += skipped;
                                }
                                if (!m) break;
                                pos += skipped + 1;
                                if (m[0] == "\t") {
                                    var tabWidth = tabSize - col % tabSize;
                                    content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                                    col += tabWidth;
                                } else {
                                    var token = elt("span", "\u2022", "cm-invalidchar");
                                    token.title = "\\u" + m[0].charCodeAt(0).toString(16);
                                    content.appendChild(token);
                                    col += 1;
                                }
                            }
                        }
                        if (style) html.appendChild(elt("span", [content], style));
                        else html.appendChild(content);
                    }
                    var span = span_;
                    if (wrapAt != null) {
                        var outPos = 0,
                            anchor = pre.anchor = elt("span");
                        span = function(html, text, style) {
                            var l = text.length;
                            if (wrapAt >= outPos && wrapAt < outPos + l) {
                                var cut = wrapAt - outPos;
                                if (cut) {
                                    span_(html, text.slice(0, cut), style);
                                    // See comment at the definition of spanAffectsWrapping
                                    if (compensateForWrapping) {
                                        var view = text.slice(cut - 1, cut + 1);
                                        if (spanAffectsWrapping.test(view)) html.appendChild(elt("wbr"));
                                        else if (!ie_lt8 && /\w\w/.test(view)) html.appendChild(document.createTextNode("\u200d"));
                                    }
                                }
                                html.appendChild(anchor);
                                span_(anchor, opera ? text.slice(cut, cut + 1) : text.slice(cut), style);
                                if (opera) span_(html, text.slice(cut + 1), style);
                                wrapAt--;
                                outPos += l;
                            } else {
                                outPos += l;
                                span_(html, text, style);
                                if (outPos == wrapAt && outPos == len) {
                                    setTextContent(anchor, eolSpanContent);
                                    html.appendChild(anchor);
                                }
                                // Stop outputting HTML when gone sufficiently far beyond measure
                                else if (outPos > wrapAt + 10 && /\s/.test(text)) span = function() {};
                            }
                        };
                    }

                    var st = this.styles,
                        allText = this.text,
                        marked = this.markedSpans;
                    var len = allText.length;

                    function styleToClass(style) {
                        if (!style) return null;
                        return "cm-" + style.replace(/ +/g, " cm-");
                    }
                    if (!allText && wrapAt == null) {
                        span(pre, " ");
                    } else if (!marked || !marked.length) {
                        for (var i = 0, ch = 0; ch < len; i += 2) {
                            var str = st[i],
                                style = st[i + 1],
                                l = str.length;
                            if (ch + l > len) str = str.slice(0, len - ch);
                            ch += l;
                            span(pre, str, styleToClass(style));
                        }
                    } else {
                        marked.sort(function(a, b) {
                            return a.from - b.from;
                        });
                        var pos = 0,
                            i = 0,
                            text = "",
                            style, sg = 0;
                        var nextChange = marked[0].from || 0,
                            marks = [],
                            markpos = 0;
                        var advanceMarks = function() {
                            var m;
                            while (markpos < marked.length &&
                                ((m = marked[markpos]).from == pos || m.from == null)) {
                                if (m.marker.type == "range") marks.push(m);
                                ++markpos;
                            }
                            nextChange = markpos < marked.length ? marked[markpos].from : Infinity;
                            for (var i = 0; i < marks.length; ++i) {
                                var to = marks[i].to;
                                if (to == null) to = Infinity;
                                if (to == pos) marks.splice(i--, 1);
                                else nextChange = Math.min(to, nextChange);
                            }
                        };
                        var m = 0;
                        while (pos < len) {
                            if (nextChange == pos) advanceMarks();
                            var upto = Math.min(len, nextChange);
                            while (true) {
                                if (text) {
                                    var end = pos + text.length;
                                    var appliedStyle = style;
                                    for (var j = 0; j < marks.length; ++j) {
                                        var mark = marks[j];
                                        appliedStyle = (appliedStyle ? appliedStyle + " " : "") + mark.marker.style;
                                        if (mark.marker.endStyle && mark.to === Math.min(end, upto)) appliedStyle += " " + mark.marker.endStyle;
                                        if (mark.marker.startStyle && mark.from === pos) appliedStyle += " " + mark.marker.startStyle;
                                    }
                                    span(pre, end > upto ? text.slice(0, upto - pos) : text, appliedStyle);
                                    if (end >= upto) {
                                        text = text.slice(upto - pos);
                                        pos = upto;
                                        break;
                                    }
                                    pos = end;
                                }
                                text = st[i++];
                                style = styleToClass(st[i++]);
                            }
                        }
                    }
                    return pre;
                },
                cleanUp: function() {
                    this.parent = null;
                    detachMarkedSpans(this);
                }
            };

            // Data structure that holds the sequence of lines.
            function LeafChunk(lines) {
                this.lines = lines;
                this.parent = null;
                for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
                    lines[i].parent = this;
                    height += lines[i].height;
                }
                this.height = height;
            }
            LeafChunk.prototype = {
                chunkSize: function() {
                    return this.lines.length;
                },
                remove: function(at, n, callbacks) {
                    for (var i = at, e = at + n; i < e; ++i) {
                        var line = this.lines[i];
                        this.height -= line.height;
                        line.cleanUp();
                        if (line.handlers)
                            for (var j = 0; j < line.handlers.length; ++j) callbacks.push(line.handlers[j]);
                    }
                    this.lines.splice(at, n);
                },
                collapse: function(lines) {
                    lines.splice.apply(lines, [lines.length, 0].concat(this.lines));
                },
                insertHeight: function(at, lines, height) {
                    this.height += height;
                    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                    for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;
                },
                iterN: function(at, n, op) {
                    for (var e = at + n; at < e; ++at)
                        if (op(this.lines[at])) return true;
                }
            };

            function BranchChunk(children) {
                this.children = children;
                var size = 0,
                    height = 0;
                for (var i = 0, e = children.length; i < e; ++i) {
                    var ch = children[i];
                    size += ch.chunkSize();
                    height += ch.height;
                    ch.parent = this;
                }
                this.size = size;
                this.height = height;
                this.parent = null;
            }
            BranchChunk.prototype = {
                chunkSize: function() {
                    return this.size;
                },
                remove: function(at, n, callbacks) {
                    this.size -= n;
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i],
                            sz = child.chunkSize();
                        if (at < sz) {
                            var rm = Math.min(n, sz - at),
                                oldHeight = child.height;
                            child.remove(at, rm, callbacks);
                            this.height -= oldHeight - child.height;
                            if (sz == rm) {
                                this.children.splice(i--, 1);
                                child.parent = null;
                            }
                            if ((n -= rm) == 0) break;
                            at = 0;
                        } else at -= sz;
                    }
                    if (this.size - n < 25) {
                        var lines = [];
                        this.collapse(lines);
                        this.children = [new LeafChunk(lines)];
                        this.children[0].parent = this;
                    }
                },
                collapse: function(lines) {
                    for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);
                },
                insert: function(at, lines) {
                    var height = 0;
                    for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;
                    this.insertHeight(at, lines, height);
                },
                insertHeight: function(at, lines, height) {
                    this.size += lines.length;
                    this.height += height;
                    for (var i = 0, e = this.children.length; i < e; ++i) {
                        var child = this.children[i],
                            sz = child.chunkSize();
                        if (at <= sz) {
                            child.insertHeight(at, lines, height);
                            if (child.lines && child.lines.length > 50) {
                                while (child.lines.length > 50) {
                                    var spilled = child.lines.splice(child.lines.length - 25, 25);
                                    var newleaf = new LeafChunk(spilled);
                                    child.height -= newleaf.height;
                                    this.children.splice(i + 1, 0, newleaf);
                                    newleaf.parent = this;
                                }
                                this.maybeSpill();
                            }
                            break;
                        }
                        at -= sz;
                    }
                },
                maybeSpill: function() {
                    if (this.children.length <= 10) return;
                    var me = this;
                    do {
                        var spilled = me.children.splice(me.children.length - 5, 5);
                        var sibling = new BranchChunk(spilled);
                        if (!me.parent) { // Become the parent node
                            var copy = new BranchChunk(me.children);
                            copy.parent = me;
                            me.children = [copy, sibling];
                            me = copy;
                        } else {
                            me.size -= sibling.size;
                            me.height -= sibling.height;
                            var myIndex = indexOf(me.parent.children, me);
                            me.parent.children.splice(myIndex + 1, 0, sibling);
                        }
                        sibling.parent = me.parent;
                    } while (me.children.length > 10);
                    me.parent.maybeSpill();
                },
                iter: function(from, to, op) {
                    this.iterN(from, to - from, op);
                },
                iterN: function(at, n, op) {
                    for (var i = 0, e = this.children.length; i < e; ++i) {
                        var child = this.children[i],
                            sz = child.chunkSize();
                        if (at < sz) {
                            var used = Math.min(n, sz - at);
                            if (child.iterN(at, used, op)) return true;
                            if ((n -= used) == 0) break;
                            at = 0;
                        } else at -= sz;
                    }
                }
            };

            function getLineAt(chunk, n) {
                while (!chunk.lines) {
                    for (var i = 0;; ++i) {
                        var child = chunk.children[i],
                            sz = child.chunkSize();
                        if (n < sz) {
                            chunk = child;
                            break;
                        }
                        n -= sz;
                    }
                }
                return chunk.lines[n];
            }

            function lineNo(line) {
                if (line.parent == null) return null;
                var cur = line.parent,
                    no = indexOf(cur.lines, line);
                for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
                    for (var i = 0;; ++i) {
                        if (chunk.children[i] == cur) break;
                        no += chunk.children[i].chunkSize();
                    }
                }
                return no;
            }

            function lineAtHeight(chunk, h) {
                var n = 0;
                outer: do {
                    for (var i = 0, e = chunk.children.length; i < e; ++i) {
                        var child = chunk.children[i],
                            ch = child.height;
                        if (h < ch) {
                            chunk = child;
                            continue outer;
                        }
                        h -= ch;
                        n += child.chunkSize();
                    }
                    return n;
                } while (!chunk.lines);
                for (var i = 0, e = chunk.lines.length; i < e; ++i) {
                    var line = chunk.lines[i],
                        lh = line.height;
                    if (h < lh) break;
                    h -= lh;
                }
                return n + i;
            }

            function heightAtLine(chunk, n) {
                var h = 0;
                outer: do {
                    for (var i = 0, e = chunk.children.length; i < e; ++i) {
                        var child = chunk.children[i],
                            sz = child.chunkSize();
                        if (n < sz) {
                            chunk = child;
                            continue outer;
                        }
                        n -= sz;
                        h += child.height;
                    }
                    return h;
                } while (!chunk.lines);
                for (var i = 0; i < n; ++i) h += chunk.lines[i].height;
                return h;
            }

            // The history object 'chunks' changes that are made close together
            // and at almost the same time into bigger undoable units.
            function History() {
                this.time = 0;
                this.done = [];
                this.undone = [];
                this.compound = 0;
                this.closed = false;
            }
            History.prototype = {
                addChange: function(start, added, old) {
                    this.undone.length = 0;
                    var time = +new Date,
                        cur = lst(this.done),
                        last = cur && lst(cur);
                    var dtime = time - this.time;

                    if (cur && !this.closed && this.compound) {
                        cur.push({
                            start: start,
                            added: added,
                            old: old
                        });
                    } else if (dtime > 400 || !last || this.closed ||
                        last.start > start + old.length || last.start + last.added < start) {
                        this.done.push([{
                            start: start,
                            added: added,
                            old: old
                        }]);
                        this.closed = false;
                    } else {
                        var startBefore = Math.max(0, last.start - start),
                            endAfter = Math.max(0, (start + old.length) - (last.start + last.added));
                        for (var i = startBefore; i > 0; --i) last.old.unshift(old[i - 1]);
                        for (var i = endAfter; i > 0; --i) last.old.push(old[old.length - i]);
                        if (startBefore) last.start = start;
                        last.added += added - (old.length - startBefore - endAfter);
                    }
                    this.time = time;
                },
                startCompound: function() {
                    if (!this.compound++) this.closed = true;
                },
                endCompound: function() {
                    if (!--this.compound) this.closed = true;
                }
            };

            function stopMethod() {
                e_stop(this);
            }
            // Ensure an event has a stop method.
            function addStop(event) {
                if (!event.stop) event.stop = stopMethod;
                return event;
            }

            function e_preventDefault(e) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }

            function e_stopPropagation(e) {
                if (e.stopPropagation) e.stopPropagation();
                else e.cancelBubble = true;
            }

            function e_stop(e) {
                e_preventDefault(e);
                e_stopPropagation(e);
            }
            CodeMirror.e_stop = e_stop;
            CodeMirror.e_preventDefault = e_preventDefault;
            CodeMirror.e_stopPropagation = e_stopPropagation;

            function e_target(e) {
                return e.target || e.srcElement;
            }

            function e_button(e) {
                var b = e.which;
                if (b == null) {
                    if (e.button & 1) b = 1;
                    else if (e.button & 2) b = 3;
                    else if (e.button & 4) b = 2;
                }
                if (mac && e.ctrlKey && b == 1) b = 3;
                return b;
            }

            // Allow 3rd-party code to override event properties by adding an override
            // object to an event object.
            function e_prop(e, prop) {
                var overridden = e.override && e.override.hasOwnProperty(prop);
                return overridden ? e.override[prop] : e[prop];
            }

            // Event handler registration. If disconnect is true, it'll return a
            // function that unregisters the handler.
            function connect(node, type, handler, disconnect) {
                if (typeof node.addEventListener == "function") {
                    node.addEventListener(type, handler, false);
                    if (disconnect) return function() {
                        node.removeEventListener(type, handler, false);
                    };
                } else {
                    var wrapHandler = function(event) {
                        handler(event || window.event);
                    };
                    node.attachEvent("on" + type, wrapHandler);
                    if (disconnect) return function() {
                        node.detachEvent("on" + type, wrapHandler);
                    };
                }
            }
            CodeMirror.connect = connect;

            function Delayed() {
                this.id = null;
            }
            Delayed.prototype = {
                set: function(ms, f) {
                    clearTimeout(this.id);
                    this.id = setTimeout(f, ms);
                }
            };

            var Pass = CodeMirror.Pass = {
                toString: function() {
                    return "CodeMirror.Pass";
                }
            };

            // Detect drag-and-drop
            var dragAndDrop = function() {
                // There is *some* kind of drag-and-drop support in IE6-8, but I
                // couldn't get it to work yet.
                if (ie_lt9) return false;
                var div = elt('div');
                return "draggable" in div || "dragDrop" in div;
            }();

            // Feature-detect whether newlines in textareas are converted to \r\n
            var lineSep = function() {
                var te = elt("textarea");
                te.value = "foo\nbar";
                if (te.value.indexOf("\r") > -1) return "\r\n";
                return "\n";
            }();

            // For a reason I have yet to figure out, some browsers disallow
            // word wrapping between certain characters *only* if a new inline
            // element is started between them. This makes it hard to reliably
            // measure the position of things, since that requires inserting an
            // extra span. This terribly fragile set of regexps matches the
            // character combinations that suffer from this phenomenon on the
            // various browsers.
            var spanAffectsWrapping = /^$/; // Won't match any two-character string
            if (gecko) spanAffectsWrapping = /$'/;
            else if (safari) spanAffectsWrapping = /\-[^ \-?]|\?[^ !'\"\),.\-\/:;\?\]\}]/;
            else if (chrome) spanAffectsWrapping = /\-[^ \-\.?]|\?[^ \-\.?\]\}:;!'\"\),\/]|[\.!\"#&%\)*+,:;=>\]|\}~][\(\{\[<]|\$'/;

            // Counts the column offset in a string, taking tabs into account.
            // Used mostly to find indentation.
            function countColumn(string, end, tabSize) {
                if (end == null) {
                    end = string.search(/[^\s\u00a0]/);
                    if (end == -1) end = string.length;
                }
                for (var i = 0, n = 0; i < end; ++i) {
                    if (string.charAt(i) == "\t") n += tabSize - (n % tabSize);
                    else ++n;
                }
                return n;
            }

            function eltOffset(node, screen) {
                // Take the parts of bounding client rect that we are interested in so we are able to edit if need be,
                // since the returned value cannot be changed externally (they are kept in sync as the element moves within the page)
                try {
                    var box = node.getBoundingClientRect();
                    box = {
                        top: box.top,
                        left: box.left
                    };
                } catch (e) {
                    box = {
                        top: 0,
                        left: 0
                    };
                }
                if (!screen) {
                    // Get the toplevel scroll, working around browser differences.
                    if (window.pageYOffset == null) {
                        var t = document.documentElement || document.body.parentNode;
                        if (t.scrollTop == null) t = document.body;
                        box.top += t.scrollTop;
                        box.left += t.scrollLeft;
                    } else {
                        box.top += window.pageYOffset;
                        box.left += window.pageXOffset;
                    }
                }
                return box;
            }

            function eltText(node) {
                return node.textContent || node.innerText || node.nodeValue || "";
            }

            var spaceStrs = [""];

            function spaceStr(n) {
                while (spaceStrs.length <= n)
                    spaceStrs.push(lst(spaceStrs) + " ");
                return spaceStrs[n];
            }

            function lst(arr) {
                return arr[arr.length - 1];
            }

            function selectInput(node) {
                if (ios) { // Mobile Safari apparently has a bug where select() is broken.
                    node.selectionStart = 0;
                    node.selectionEnd = node.value.length;
                } else node.select();
            }

            // Operations on {line, ch} objects.
            function posEq(a, b) {
                return a.line == b.line && a.ch == b.ch;
            }

            function posLess(a, b) {
                return a.line < b.line || (a.line == b.line && a.ch < b.ch);
            }

            function copyPos(x) {
                return {
                    line: x.line,
                    ch: x.ch
                };
            }

            function elt(tag, content, className, style) {
                var e = document.createElement(tag);
                if (className) e.className = className;
                if (style) e.style.cssText = style;
                if (typeof content == "string") setTextContent(e, content);
                else if (content)
                    for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
                return e;
            }

            function removeChildren(e) {
                e.innerHTML = "";
                return e;
            }

            function removeChildrenAndAdd(parent, e) {
                removeChildren(parent).appendChild(e);
            }

            function setTextContent(e, str) {
                if (ie_lt9) {
                    e.innerHTML = "";
                    e.appendChild(document.createTextNode(str));
                } else e.textContent = str;
            }

            // Used to position the cursor after an undo/redo by finding the
            // last edited character.
            function editEnd(from, to) {
                if (!to) return 0;
                if (!from) return to.length;
                for (var i = from.length, j = to.length; i >= 0 && j >= 0; --i, --j)
                    if (from.charAt(i) != to.charAt(j)) break;
                return j + 1;
            }

            function indexOf(collection, elt) {
                if (collection.indexOf) return collection.indexOf(elt);
                for (var i = 0, e = collection.length; i < e; ++i)
                    if (collection[i] == elt) return i;
                return -1;
            }
            var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc]/;

            function isWordChar(ch) {
                return /\w/.test(ch) || ch > "\x80" &&
                    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
            }

            // See if "".split is the broken IE version, if so, provide an
            // alternative way to split lines.
            var splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
                var pos = 0,
                    result = [],
                    l = string.length;
                while (pos <= l) {
                    var nl = string.indexOf("\n", pos);
                    if (nl == -1) nl = string.length;
                    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
                    var rt = line.indexOf("\r");
                    if (rt != -1) {
                        result.push(line.slice(0, rt));
                        pos += rt + 1;
                    } else {
                        result.push(line);
                        pos = nl + 1;
                    }
                }
                return result;
            } : function(string) {
                return string.split(/\r\n?|\n/);
            };
            CodeMirror.splitLines = splitLines;

            var hasSelection = window.getSelection ? function(te) {
                try {
                    return te.selectionStart != te.selectionEnd;
                } catch (e) {
                    return false;
                }
            } : function(te) {
                try {
                    var range = te.ownerDocument.selection.createRange();
                } catch (e) {}
                if (!range || range.parentElement() != te) return false;
                return range.compareEndPoints("StartToEnd", range) != 0;
            };

            CodeMirror.defineMode("null", function() {
                return {
                    token: function(stream) {
                        stream.skipToEnd();
                    }
                };
            });
            CodeMirror.defineMIME("text/plain", "null");

            var keyNames = {
                3: "Enter",
                8: "Backspace",
                9: "Tab",
                13: "Enter",
                16: "Shift",
                17: "Ctrl",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Esc",
                32: "Space",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "Left",
                38: "Up",
                39: "Right",
                40: "Down",
                44: "PrintScrn",
                45: "Insert",
                46: "Delete",
                59: ";",
                91: "Mod",
                92: "Mod",
                93: "Mod",
                109: "-",
                107: "=",
                127: "Delete",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'",
                63276: "PageUp",
                63277: "PageDown",
                63275: "End",
                63273: "Home",
                63234: "Left",
                63232: "Up",
                63235: "Right",
                63233: "Down",
                63302: "Insert",
                63272: "Delete"
            };
            CodeMirror.keyNames = keyNames;
            (function() {
                // Number keys
                for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);
                // Alphabetic keys
                for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
                // Function keys
                for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
            })();

            CodeMirror.version = "2.38";

            return CodeMirror;
        })();


        /*** EXPORTS FROM exports-loader ***/
        module.exports = window.CodeMirror;

        /***/
    }),
    /* 36 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global) {
            var require;
            var require;
            /*
              html2canvas 0.5.0-beta4 <http://html2canvas.hertzen.com>
              Copyright (c) 2016 Niklas von Hertzen

              Released under  License
            */

            (function(f) {
                if (true) {
                    module.exports = f()
                } else if (typeof define === "function" && define.amd) {
                    define([], f)
                } else {
                    var g;
                    if (typeof window !== "undefined") {
                        g = window
                    } else if (typeof global !== "undefined") {
                        g = global
                    } else if (typeof self !== "undefined") {
                        g = self
                    } else {
                        g = this
                    }
                    g.html2canvas = f()
                }
            })(function() {
                var define, module, exports;
                return (function e(t, n, r) {
                    function s(o, u) {
                        if (!n[o]) {
                            if (!t[o]) {
                                var a = typeof require == "function" && require;
                                if (!u && a) return require(o, !0);
                                if (i) return i(o, !0);
                                var f = new Error("Cannot find module '" + o + "'");
                                throw f.code = "MODULE_NOT_FOUND", f
                            }
                            var l = n[o] = {
                                exports: {}
                            };
                            t[o][0].call(l.exports, function(e) {
                                var n = t[o][1][e];
                                return s(n ? n : e)
                            }, l, l.exports, e, t, n, r)
                        }
                        return n[o].exports
                    }
                    var i = typeof require == "function" && require;
                    for (var o = 0; o < r.length; o++) s(r[o]);
                    return s
                })({
                    1: [function(_dereq_, module, exports) {
                        (function(global) {
                            /*! https://mths.be/punycode v1.4.0 by @mathias */
                            ;
                            (function(root) {

                                /** Detect free variables */
                                var freeExports = typeof exports == 'object' && exports &&
                                    !exports.nodeType && exports;
                                var freeModule = typeof module == 'object' && module &&
                                    !module.nodeType && module;
                                var freeGlobal = typeof global == 'object' && global;
                                if (
                                    freeGlobal.global === freeGlobal ||
                                    freeGlobal.window === freeGlobal ||
                                    freeGlobal.self === freeGlobal
                                ) {
                                    root = freeGlobal;
                                }

                                /**
                                 * The `punycode` object.
                                 * @name punycode
                                 * @type Object
                                 */
                                var punycode,

                                    /** Highest positive signed 32-bit float value */
                                    maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

                                    /** Bootstring parameters */
                                    base = 36,
                                    tMin = 1,
                                    tMax = 26,
                                    skew = 38,
                                    damp = 700,
                                    initialBias = 72,
                                    initialN = 128, // 0x80
                                    delimiter = '-', // '\x2D'

                                    /** Regular expressions */
                                    regexPunycode = /^xn--/,
                                    regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                                    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

                                    /** Error messages */
                                    errors = {
                                        'overflow': 'Overflow: input needs wider integers to process',
                                        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                                        'invalid-input': 'Invalid input'
                                    },

                                    /** Convenience shortcuts */
                                    baseMinusTMin = base - tMin,
                                    floor = Math.floor,
                                    stringFromCharCode = String.fromCharCode,

                                    /** Temporary variable */
                                    key;

                                /*--------------------------------------------------------------------------*/

                                /**
                                 * A generic error utility function.
                                 * @private
                                 * @param {String} type The error type.
                                 * @returns {Error} Throws a `RangeError` with the applicable error message.
                                 */
                                function error(type) {
                                    throw new RangeError(errors[type]);
                                }

                                /**
                                 * A generic `Array#map` utility function.
                                 * @private
                                 * @param {Array} array The array to iterate over.
                                 * @param {Function} callback The function that gets called for every array
                                 * item.
                                 * @returns {Array} A new array of values returned by the callback function.
                                 */
                                function map(array, fn) {
                                    var length = array.length;
                                    var result = [];
                                    while (length--) {
                                        result[length] = fn(array[length]);
                                    }
                                    return result;
                                }

                                /**
                                 * A simple `Array#map`-like wrapper to work with domain name strings or email
                                 * addresses.
                                 * @private
                                 * @param {String} domain The domain name or email address.
                                 * @param {Function} callback The function that gets called for every
                                 * character.
                                 * @returns {Array} A new string of characters returned by the callback
                                 * function.
                                 */
                                function mapDomain(string, fn) {
                                    var parts = string.split('@');
                                    var result = '';
                                    if (parts.length > 1) {
                                        // In email addresses, only the domain name should be punycoded. Leave
                                        // the local part (i.e. everything up to `@`) intact.
                                        result = parts[0] + '@';
                                        string = parts[1];
                                    }
                                    // Avoid `split(regex)` for IE8 compatibility. See #17.
                                    string = string.replace(regexSeparators, '\x2E');
                                    var labels = string.split('.');
                                    var encoded = map(labels, fn).join('.');
                                    return result + encoded;
                                }

                                /**
                                 * Creates an array containing the numeric code points of each Unicode
                                 * character in the string. While JavaScript uses UCS-2 internally,
                                 * this function will convert a pair of surrogate halves (each of which
                                 * UCS-2 exposes as separate characters) into a single code point,
                                 * matching UTF-16.
                                 * @see `punycode.ucs2.encode`
                                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                                 * @memberOf punycode.ucs2
                                 * @name decode
                                 * @param {String} string The Unicode input string (UCS-2).
                                 * @returns {Array} The new array of code points.
                                 */
                                function ucs2decode(string) {
                                    var output = [],
                                        counter = 0,
                                        length = string.length,
                                        value,
                                        extra;
                                    while (counter < length) {
                                        value = string.charCodeAt(counter++);
                                        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                                            // high surrogate, and there is a next character
                                            extra = string.charCodeAt(counter++);
                                            if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                                                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                                            } else {
                                                // unmatched surrogate; only append this code unit, in case the next
                                                // code unit is the high surrogate of a surrogate pair
                                                output.push(value);
                                                counter--;
                                            }
                                        } else {
                                            output.push(value);
                                        }
                                    }
                                    return output;
                                }

                                /**
                                 * Creates a string based on an array of numeric code points.
                                 * @see `punycode.ucs2.decode`
                                 * @memberOf punycode.ucs2
                                 * @name encode
                                 * @param {Array} codePoints The array of numeric code points.
                                 * @returns {String} The new Unicode string (UCS-2).
                                 */
                                function ucs2encode(array) {
                                    return map(array, function(value) {
                                        var output = '';
                                        if (value > 0xFFFF) {
                                            value -= 0x10000;
                                            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                                            value = 0xDC00 | value & 0x3FF;
                                        }
                                        output += stringFromCharCode(value);
                                        return output;
                                    }).join('');
                                }

                                /**
                                 * Converts a basic code point into a digit/integer.
                                 * @see `digitToBasic()`
                                 * @private
                                 * @param {Number} codePoint The basic numeric code point value.
                                 * @returns {Number} The numeric value of a basic code point (for use in
                                 * representing integers) in the range `0` to `base - 1`, or `base` if
                                 * the code point does not represent a value.
                                 */
                                function basicToDigit(codePoint) {
                                    if (codePoint - 48 < 10) {
                                        return codePoint - 22;
                                    }
                                    if (codePoint - 65 < 26) {
                                        return codePoint - 65;
                                    }
                                    if (codePoint - 97 < 26) {
                                        return codePoint - 97;
                                    }
                                    return base;
                                }

                                /**
                                 * Converts a digit/integer into a basic code point.
                                 * @see `basicToDigit()`
                                 * @private
                                 * @param {Number} digit The numeric value of a basic code point.
                                 * @returns {Number} The basic code point whose value (when used for
                                 * representing integers) is `digit`, which needs to be in the range
                                 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                                 * used; else, the lowercase form is used. The behavior is undefined
                                 * if `flag` is non-zero and `digit` has no uppercase form.
                                 */
                                function digitToBasic(digit, flag) {
                                    //  0..25 map to ASCII a..z or A..Z
                                    // 26..35 map to ASCII 0..9
                                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                                }

                                /**
                                 * Bias adaptation function as per section 3.4 of RFC 3492.
                                 * https://tools.ietf.org/html/rfc3492#section-3.4
                                 * @private
                                 */
                                function adapt(delta, numPoints, firstTime) {
                                    var k = 0;
                                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                                    delta += floor(delta / numPoints);
                                    for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base) {
                                        delta = floor(delta / baseMinusTMin);
                                    }
                                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                                }

                                /**
                                 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                                 * symbols.
                                 * @memberOf punycode
                                 * @param {String} input The Punycode string of ASCII-only symbols.
                                 * @returns {String} The resulting string of Unicode symbols.
                                 */
                                function decode(input) {
                                    // Don't use UCS-2
                                    var output = [],
                                        inputLength = input.length,
                                        out,
                                        i = 0,
                                        n = initialN,
                                        bias = initialBias,
                                        basic,
                                        j,
                                        index,
                                        oldi,
                                        w,
                                        k,
                                        digit,
                                        t,
                                        /** Cached calculation results */
                                        baseMinusT;

                                    // Handle the basic code points: let `basic` be the number of input code
                                    // points before the last delimiter, or `0` if there is none, then copy
                                    // the first basic code points to the output.

                                    basic = input.lastIndexOf(delimiter);
                                    if (basic < 0) {
                                        basic = 0;
                                    }

                                    for (j = 0; j < basic; ++j) {
                                        // if it's not a basic code point
                                        if (input.charCodeAt(j) >= 0x80) {
                                            error('not-basic');
                                        }
                                        output.push(input.charCodeAt(j));
                                    }

                                    // Main decoding loop: start just after the last delimiter if any basic code
                                    // points were copied; start at the beginning otherwise.

                                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */ ) {

                                        // `index` is the index of the next character to be consumed.
                                        // Decode a generalized variable-length integer into `delta`,
                                        // which gets added to `i`. The overflow checking is easier
                                        // if we increase `i` as we go, then subtract off its starting
                                        // value at the end to obtain `delta`.
                                        for (oldi = i, w = 1, k = base; /* no condition */ ; k += base) {

                                            if (index >= inputLength) {
                                                error('invalid-input');
                                            }

                                            digit = basicToDigit(input.charCodeAt(index++));

                                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                                error('overflow');
                                            }

                                            i += digit * w;
                                            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

                                            if (digit < t) {
                                                break;
                                            }

                                            baseMinusT = base - t;
                                            if (w > floor(maxInt / baseMinusT)) {
                                                error('overflow');
                                            }

                                            w *= baseMinusT;

                                        }

                                        out = output.length + 1;
                                        bias = adapt(i - oldi, out, oldi == 0);

                                        // `i` was supposed to wrap around from `out` to `0`,
                                        // incrementing `n` each time, so we'll fix that now:
                                        if (floor(i / out) > maxInt - n) {
                                            error('overflow');
                                        }

                                        n += floor(i / out);
                                        i %= out;

                                        // Insert `n` at position `i` of the output
                                        output.splice(i++, 0, n);

                                    }

                                    return ucs2encode(output);
                                }

                                /**
                                 * Converts a string of Unicode symbols (e.g. a domain name label) to a
                                 * Punycode string of ASCII-only symbols.
                                 * @memberOf punycode
                                 * @param {String} input The string of Unicode symbols.
                                 * @returns {String} The resulting Punycode string of ASCII-only symbols.
                                 */
                                function encode(input) {
                                    var n,
                                        delta,
                                        handledCPCount,
                                        basicLength,
                                        bias,
                                        j,
                                        m,
                                        q,
                                        k,
                                        t,
                                        currentValue,
                                        output = [],
                                        /** `inputLength` will hold the number of code points in `input`. */
                                        inputLength,
                                        /** Cached calculation results */
                                        handledCPCountPlusOne,
                                        baseMinusT,
                                        qMinusT;

                                    // Convert the input in UCS-2 to Unicode
                                    input = ucs2decode(input);

                                    // Cache the length
                                    inputLength = input.length;

                                    // Initialize the state
                                    n = initialN;
                                    delta = 0;
                                    bias = initialBias;

                                    // Handle the basic code points
                                    for (j = 0; j < inputLength; ++j) {
                                        currentValue = input[j];
                                        if (currentValue < 0x80) {
                                            output.push(stringFromCharCode(currentValue));
                                        }
                                    }

                                    handledCPCount = basicLength = output.length;

                                    // `handledCPCount` is the number of code points that have been handled;
                                    // `basicLength` is the number of basic code points.

                                    // Finish the basic string - if it is not empty - with a delimiter
                                    if (basicLength) {
                                        output.push(delimiter);
                                    }

                                    // Main encoding loop:
                                    while (handledCPCount < inputLength) {

                                        // All non-basic code points < n have been handled already. Find the next
                                        // larger one:
                                        for (m = maxInt, j = 0; j < inputLength; ++j) {
                                            currentValue = input[j];
                                            if (currentValue >= n && currentValue < m) {
                                                m = currentValue;
                                            }
                                        }

                                        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                                        // but guard against overflow
                                        handledCPCountPlusOne = handledCPCount + 1;
                                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                            error('overflow');
                                        }

                                        delta += (m - n) * handledCPCountPlusOne;
                                        n = m;

                                        for (j = 0; j < inputLength; ++j) {
                                            currentValue = input[j];

                                            if (currentValue < n && ++delta > maxInt) {
                                                error('overflow');
                                            }

                                            if (currentValue == n) {
                                                // Represent delta as a generalized variable-length integer
                                                for (q = delta, k = base; /* no condition */ ; k += base) {
                                                    t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                                    if (q < t) {
                                                        break;
                                                    }
                                                    qMinusT = q - t;
                                                    baseMinusT = base - t;
                                                    output.push(
                                                        stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                                                    );
                                                    q = floor(qMinusT / baseMinusT);
                                                }

                                                output.push(stringFromCharCode(digitToBasic(q, 0)));
                                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                                delta = 0;
                                                ++handledCPCount;
                                            }
                                        }

                                        ++delta;
                                        ++n;

                                    }
                                    return output.join('');
                                }

                                /**
                                 * Converts a Punycode string representing a domain name or an email address
                                 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                                 * it doesn't matter if you call it on a string that has already been
                                 * converted to Unicode.
                                 * @memberOf punycode
                                 * @param {String} input The Punycoded domain name or email address to
                                 * convert to Unicode.
                                 * @returns {String} The Unicode representation of the given Punycode
                                 * string.
                                 */
                                function toUnicode(input) {
                                    return mapDomain(input, function(string) {
                                        return regexPunycode.test(string) ?
                                            decode(string.slice(4).toLowerCase()) :
                                            string;
                                    });
                                }

                                /**
                                 * Converts a Unicode string representing a domain name or an email address to
                                 * Punycode. Only the non-ASCII parts of the domain name will be converted,
                                 * i.e. it doesn't matter if you call it with a domain that's already in
                                 * ASCII.
                                 * @memberOf punycode
                                 * @param {String} input The domain name or email address to convert, as a
                                 * Unicode string.
                                 * @returns {String} The Punycode representation of the given domain name or
                                 * email address.
                                 */
                                function toASCII(input) {
                                    return mapDomain(input, function(string) {
                                        return regexNonASCII.test(string) ?
                                            'xn--' + encode(string) :
                                            string;
                                    });
                                }

                                /*--------------------------------------------------------------------------*/

                                /** Define the public API */
                                punycode = {
                                    /**
                                     * A string representing the current Punycode.js version number.
                                     * @memberOf punycode
                                     * @type String
                                     */
                                    'version': '1.3.2',
                                    /**
                                     * An object of methods to convert from JavaScript's internal character
                                     * representation (UCS-2) to Unicode code points, and back.
                                     * @see <https://mathiasbynens.be/notes/javascript-encoding>
                                     * @memberOf punycode
                                     * @type Object
                                     */
                                    'ucs2': {
                                        'decode': ucs2decode,
                                        'encode': ucs2encode
                                    },
                                    'decode': decode,
                                    'encode': encode,
                                    'toASCII': toASCII,
                                    'toUnicode': toUnicode
                                };

                                /** Expose `punycode` */
                                // Some AMD build optimizers, like r.js, check for specific condition patterns
                                // like the following:
                                if (
                                    typeof define == 'function' &&
                                    typeof define.amd == 'object' &&
                                    define.amd
                                ) {
                                    define('punycode', function() {
                                        return punycode;
                                    });
                                } else if (freeExports && freeModule) {
                                    if (module.exports == freeExports) {
                                        // in Node.js, io.js, or RingoJS v0.8.0+
                                        freeModule.exports = punycode;
                                    } else {
                                        // in Narwhal or RingoJS v0.7.0-
                                        for (key in punycode) {
                                            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                                        }
                                    }
                                } else {
                                    // in Rhino or a web browser
                                    root.punycode = punycode;
                                }

                            }(this));

                        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }, {}],
                    2: [function(_dereq_, module, exports) {
                        var log = _dereq_('./log');

                        function restoreOwnerScroll(ownerDocument, x, y) {
                            if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
                                ownerDocument.defaultView.scrollTo(x, y);
                            }
                        }

                        function cloneCanvasContents(canvas, clonedCanvas) {
                            try {
                                if (clonedCanvas) {
                                    clonedCanvas.width = canvas.width;
                                    clonedCanvas.height = canvas.height;
                                    clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                                }
                            } catch (e) {
                                log("Unable to copy canvas content from", canvas, e);
                            }
                        }

                        function cloneNode(node, javascriptEnabled) {
                            var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);

                            var child = node.firstChild;
                            while (child) {
                                if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {
                                    clone.appendChild(cloneNode(child, javascriptEnabled));
                                }
                                child = child.nextSibling;
                            }

                            if (node.nodeType === 1) {
                                clone._scrollTop = node.scrollTop;
                                clone._scrollLeft = node.scrollLeft;
                                if (node.nodeName === "CANVAS") {
                                    cloneCanvasContents(node, clone);
                                } else if (node.nodeName === "TEXTAREA" || node.nodeName === "SELECT") {
                                    clone.value = node.value;
                                }
                            }

                            return clone;
                        }

                        function initNode(node) {
                            if (node.nodeType === 1) {
                                node.scrollTop = node._scrollTop;
                                node.scrollLeft = node._scrollLeft;

                                var child = node.firstChild;
                                while (child) {
                                    initNode(child);
                                    child = child.nextSibling;
                                }
                            }
                        }

                        module.exports = function(ownerDocument, containerDocument, width, height, options, x, y) {
                            var documentElement = cloneNode(ownerDocument.documentElement, options.javascriptEnabled);
                            var container = containerDocument.createElement("iframe");

                            container.className = "html2canvas-container";
                            container.style.visibility = "hidden";
                            container.style.position = "fixed";
                            container.style.left = "-10000px";
                            container.style.top = "0px";
                            container.style.border = "0";
                            container.width = width;
                            container.height = height;
                            container.scrolling = "no"; // ios won't scroll without it
                            containerDocument.body.appendChild(container);

                            return new Promise(function(resolve) {
                                var documentClone = container.contentWindow.document;

                                /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
                                 if window url is about:blank, we can assign the url to current by writing onto the document
                                 */
                                container.contentWindow.onload = container.onload = function() {
                                    var interval = setInterval(function() {
                                        if (documentClone.body.childNodes.length > 0) {
                                            initNode(documentClone.documentElement);
                                            clearInterval(interval);
                                            if (options.type === "view") {
                                                container.contentWindow.scrollTo(x, y);
                                                if ((/(iPad|iPhone|iPod)/g).test(navigator.userAgent) && (container.contentWindow.scrollY !== y || container.contentWindow.scrollX !== x)) {
                                                    documentClone.documentElement.style.top = (-y) + "px";
                                                    documentClone.documentElement.style.left = (-x) + "px";
                                                    documentClone.documentElement.style.position = 'absolute';
                                                }
                                            }
                                            resolve(container);
                                        }
                                    }, 50);
                                };

                                documentClone.open();
                                documentClone.write("<!DOCTYPE html><html></html>");
                                // Chrome scrolls the parent document for some reason after the write to the cloned window???
                                restoreOwnerScroll(ownerDocument, x, y);
                                documentClone.replaceChild(documentClone.adoptNode(documentElement), documentClone.documentElement);
                                documentClone.close();
                            });
                        };

                    }, {
                        "./log": 13
                    }],
                    3: [function(_dereq_, module, exports) {
                        // http://dev.w3.org/csswg/css-color/

                        function Color(value) {
                            this.r = 0;
                            this.g = 0;
                            this.b = 0;
                            this.a = null;
                            var result = this.fromArray(value) ||
                                this.namedColor(value) ||
                                this.rgb(value) ||
                                this.rgba(value) ||
                                this.hex6(value) ||
                                this.hex3(value);
                        }

                        Color.prototype.darken = function(amount) {
                            var a = 1 - amount;
                            return new Color([
                                Math.round(this.r * a),
                                Math.round(this.g * a),
                                Math.round(this.b * a),
                                this.a
                            ]);
                        };

                        Color.prototype.isTransparent = function() {
                            return this.a === 0;
                        };

                        Color.prototype.isBlack = function() {
                            return this.r === 0 && this.g === 0 && this.b === 0;
                        };

                        Color.prototype.fromArray = function(array) {
                            if (Array.isArray(array)) {
                                this.r = Math.min(array[0], 255);
                                this.g = Math.min(array[1], 255);
                                this.b = Math.min(array[2], 255);
                                if (array.length > 3) {
                                    this.a = array[3];
                                }
                            }

                            return (Array.isArray(array));
                        };

                        var _hex3 = /^#([a-f0-9]{3})$/i;

                        Color.prototype.hex3 = function(value) {
                            var match = null;
                            if ((match = value.match(_hex3)) !== null) {
                                this.r = parseInt(match[1][0] + match[1][0], 16);
                                this.g = parseInt(match[1][1] + match[1][1], 16);
                                this.b = parseInt(match[1][2] + match[1][2], 16);
                            }
                            return match !== null;
                        };

                        var _hex6 = /^#([a-f0-9]{6})$/i;

                        Color.prototype.hex6 = function(value) {
                            var match = null;
                            if ((match = value.match(_hex6)) !== null) {
                                this.r = parseInt(match[1].substring(0, 2), 16);
                                this.g = parseInt(match[1].substring(2, 4), 16);
                                this.b = parseInt(match[1].substring(4, 6), 16);
                            }
                            return match !== null;
                        };


                        var _rgb = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;

                        Color.prototype.rgb = function(value) {
                            var match = null;
                            if ((match = value.match(_rgb)) !== null) {
                                this.r = Number(match[1]);
                                this.g = Number(match[2]);
                                this.b = Number(match[3]);
                            }
                            return match !== null;
                        };

                        var _rgba = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?\.?\d+)\s*\)$/;

                        Color.prototype.rgba = function(value) {
                            var match = null;
                            if ((match = value.match(_rgba)) !== null) {
                                this.r = Number(match[1]);
                                this.g = Number(match[2]);
                                this.b = Number(match[3]);
                                this.a = Number(match[4]);
                            }
                            return match !== null;
                        };

                        Color.prototype.toString = function() {
                            return this.a !== null && this.a !== 1 ?
                                "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")" :
                                "rgb(" + [this.r, this.g, this.b].join(",") + ")";
                        };

                        Color.prototype.namedColor = function(value) {
                            value = value.toLowerCase();
                            var color = colors[value];
                            if (color) {
                                this.r = color[0];
                                this.g = color[1];
                                this.b = color[2];
                            } else if (value === "transparent") {
                                this.r = this.g = this.b = this.a = 0;
                                return true;
                            }

                            return !!color;
                        };

                        Color.prototype.isColor = true;

                        // JSON.stringify([].slice.call($$('.named-color-table tr'), 1).map(function(row) { return [row.childNodes[3].textContent, row.childNodes[5].textContent.trim().split(",").map(Number)] }).reduce(function(data, row) {data[row[0]] = row[1]; return data}, {}))
                        var colors = {
                            "aliceblue": [240, 248, 255],
                            "antiquewhite": [250, 235, 215],
                            "aqua": [0, 255, 255],
                            "aquamarine": [127, 255, 212],
                            "azure": [240, 255, 255],
                            "beige": [245, 245, 220],
                            "bisque": [255, 228, 196],
                            "black": [0, 0, 0],
                            "blanchedalmond": [255, 235, 205],
                            "blue": [0, 0, 255],
                            "blueviolet": [138, 43, 226],
                            "brown": [165, 42, 42],
                            "burlywood": [222, 184, 135],
                            "cadetblue": [95, 158, 160],
                            "chartreuse": [127, 255, 0],
                            "chocolate": [210, 105, 30],
                            "coral": [255, 127, 80],
                            "cornflowerblue": [100, 149, 237],
                            "cornsilk": [255, 248, 220],
                            "crimson": [220, 20, 60],
                            "cyan": [0, 255, 255],
                            "darkblue": [0, 0, 139],
                            "darkcyan": [0, 139, 139],
                            "darkgoldenrod": [184, 134, 11],
                            "darkgray": [169, 169, 169],
                            "darkgreen": [0, 100, 0],
                            "darkgrey": [169, 169, 169],
                            "darkkhaki": [189, 183, 107],
                            "darkmagenta": [139, 0, 139],
                            "darkolivegreen": [85, 107, 47],
                            "darkorange": [255, 140, 0],
                            "darkorchid": [153, 50, 204],
                            "darkred": [139, 0, 0],
                            "darksalmon": [233, 150, 122],
                            "darkseagreen": [143, 188, 143],
                            "darkslateblue": [72, 61, 139],
                            "darkslategray": [47, 79, 79],
                            "darkslategrey": [47, 79, 79],
                            "darkturquoise": [0, 206, 209],
                            "darkviolet": [148, 0, 211],
                            "deeppink": [255, 20, 147],
                            "deepskyblue": [0, 191, 255],
                            "dimgray": [105, 105, 105],
                            "dimgrey": [105, 105, 105],
                            "dodgerblue": [30, 144, 255],
                            "firebrick": [178, 34, 34],
                            "floralwhite": [255, 250, 240],
                            "forestgreen": [34, 139, 34],
                            "fuchsia": [255, 0, 255],
                            "gainsboro": [220, 220, 220],
                            "ghostwhite": [248, 248, 255],
                            "gold": [255, 215, 0],
                            "goldenrod": [218, 165, 32],
                            "gray": [128, 128, 128],
                            "green": [0, 128, 0],
                            "greenyellow": [173, 255, 47],
                            "grey": [128, 128, 128],
                            "honeydew": [240, 255, 240],
                            "hotpink": [255, 105, 180],
                            "indianred": [205, 92, 92],
                            "indigo": [75, 0, 130],
                            "ivory": [255, 255, 240],
                            "khaki": [240, 230, 140],
                            "lavender": [230, 230, 250],
                            "lavenderblush": [255, 240, 245],
                            "lawngreen": [124, 252, 0],
                            "lemonchiffon": [255, 250, 205],
                            "lightblue": [173, 216, 230],
                            "lightcoral": [240, 128, 128],
                            "lightcyan": [224, 255, 255],
                            "lightgoldenrodyellow": [250, 250, 210],
                            "lightgray": [211, 211, 211],
                            "lightgreen": [144, 238, 144],
                            "lightgrey": [211, 211, 211],
                            "lightpink": [255, 182, 193],
                            "lightsalmon": [255, 160, 122],
                            "lightseagreen": [32, 178, 170],
                            "lightskyblue": [135, 206, 250],
                            "lightslategray": [119, 136, 153],
                            "lightslategrey": [119, 136, 153],
                            "lightsteelblue": [176, 196, 222],
                            "lightyellow": [255, 255, 224],
                            "lime": [0, 255, 0],
                            "limegreen": [50, 205, 50],
                            "linen": [250, 240, 230],
                            "magenta": [255, 0, 255],
                            "maroon": [128, 0, 0],
                            "mediumaquamarine": [102, 205, 170],
                            "mediumblue": [0, 0, 205],
                            "mediumorchid": [186, 85, 211],
                            "mediumpurple": [147, 112, 219],
                            "mediumseagreen": [60, 179, 113],
                            "mediumslateblue": [123, 104, 238],
                            "mediumspringgreen": [0, 250, 154],
                            "mediumturquoise": [72, 209, 204],
                            "mediumvioletred": [199, 21, 133],
                            "midnightblue": [25, 25, 112],
                            "mintcream": [245, 255, 250],
                            "mistyrose": [255, 228, 225],
                            "moccasin": [255, 228, 181],
                            "navajowhite": [255, 222, 173],
                            "navy": [0, 0, 128],
                            "oldlace": [253, 245, 230],
                            "olive": [128, 128, 0],
                            "olivedrab": [107, 142, 35],
                            "orange": [255, 165, 0],
                            "orangered": [255, 69, 0],
                            "orchid": [218, 112, 214],
                            "palegoldenrod": [238, 232, 170],
                            "palegreen": [152, 251, 152],
                            "paleturquoise": [175, 238, 238],
                            "palevioletred": [219, 112, 147],
                            "papayawhip": [255, 239, 213],
                            "peachpuff": [255, 218, 185],
                            "peru": [205, 133, 63],
                            "pink": [255, 192, 203],
                            "plum": [221, 160, 221],
                            "powderblue": [176, 224, 230],
                            "purple": [128, 0, 128],
                            "rebeccapurple": [102, 51, 153],
                            "red": [255, 0, 0],
                            "rosybrown": [188, 143, 143],
                            "royalblue": [65, 105, 225],
                            "saddlebrown": [139, 69, 19],
                            "salmon": [250, 128, 114],
                            "sandybrown": [244, 164, 96],
                            "seagreen": [46, 139, 87],
                            "seashell": [255, 245, 238],
                            "sienna": [160, 82, 45],
                            "silver": [192, 192, 192],
                            "skyblue": [135, 206, 235],
                            "slateblue": [106, 90, 205],
                            "slategray": [112, 128, 144],
                            "slategrey": [112, 128, 144],
                            "snow": [255, 250, 250],
                            "springgreen": [0, 255, 127],
                            "steelblue": [70, 130, 180],
                            "tan": [210, 180, 140],
                            "teal": [0, 128, 128],
                            "thistle": [216, 191, 216],
                            "tomato": [255, 99, 71],
                            "turquoise": [64, 224, 208],
                            "violet": [238, 130, 238],
                            "wheat": [245, 222, 179],
                            "white": [255, 255, 255],
                            "whitesmoke": [245, 245, 245],
                            "yellow": [255, 255, 0],
                            "yellowgreen": [154, 205, 50]
                        };

                        module.exports = Color;

                    }, {}],
                    4: [function(_dereq_, module, exports) {
                        var Support = _dereq_('./support');
                        var CanvasRenderer = _dereq_('./renderers/canvas');
                        var ImageLoader = _dereq_('./imageloader');
                        var NodeParser = _dereq_('./nodeparser');
                        var NodeContainer = _dereq_('./nodecontainer');
                        var log = _dereq_('./log');
                        var utils = _dereq_('./utils');
                        var createWindowClone = _dereq_('./clone');
                        var loadUrlDocument = _dereq_('./proxy').loadUrlDocument;
                        var getBounds = utils.getBounds;

                        var html2canvasNodeAttribute = "data-html2canvas-node";
                        var html2canvasCloneIndex = 0;

                        function html2canvas(nodeList, options) {
                            var index = html2canvasCloneIndex++;
                            options = options || {};
                            if (options.logging) {
                                log.options.logging = true;
                                log.options.start = Date.now();
                            }

                            options.async = typeof(options.async) === "undefined" ? true : options.async;
                            options.allowTaint = typeof(options.allowTaint) === "undefined" ? false : options.allowTaint;
                            options.removeContainer = typeof(options.removeContainer) === "undefined" ? true : options.removeContainer;
                            options.javascriptEnabled = typeof(options.javascriptEnabled) === "undefined" ? false : options.javascriptEnabled;
                            options.imageTimeout = typeof(options.imageTimeout) === "undefined" ? 10000 : options.imageTimeout;
                            options.renderer = typeof(options.renderer) === "function" ? options.renderer : CanvasRenderer;
                            options.strict = !!options.strict;

                            if (typeof(nodeList) === "string") {
                                if (typeof(options.proxy) !== "string") {
                                    return Promise.reject("Proxy must be used when rendering url");
                                }
                                var width = options.width != null ? options.width : window.innerWidth;
                                var height = options.height != null ? options.height : window.innerHeight;
                                return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function(container) {
                                    return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);
                                });
                            }

                            var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];
                            node.setAttribute(html2canvasNodeAttribute + index, index);
                            return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight, index).then(function(canvas) {
                                if (typeof(options.onrendered) === "function") {
                                    log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
                                    options.onrendered(canvas);
                                }
                                return canvas;
                            });
                        }

                        html2canvas.CanvasRenderer = CanvasRenderer;
                        html2canvas.NodeContainer = NodeContainer;
                        html2canvas.log = log;
                        html2canvas.utils = utils;

                        var html2canvasExport = (typeof(document) === "undefined" || typeof(Object.create) !== "function" || typeof(document.createElement("canvas").getContext) !== "function") ? function() {
                            return Promise.reject("No canvas support");
                        } : html2canvas;

                        module.exports = html2canvasExport;

                        if (typeof(define) === 'function' && define.amd) {
                            define('html2canvas', [], function() {
                                return html2canvasExport;
                            });
                        }

                        function renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {
                            return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then(function(container) {
                                log("Document cloned");
                                var attributeName = html2canvasNodeAttribute + html2canvasIndex;
                                var selector = "[" + attributeName + "='" + html2canvasIndex + "']";
                                document.querySelector(selector).removeAttribute(attributeName);
                                var clonedWindow = container.contentWindow;
                                var node = clonedWindow.document.querySelector(selector);
                                var oncloneHandler = (typeof(options.onclone) === "function") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
                                return oncloneHandler.then(function() {
                                    return renderWindow(node, container, options, windowWidth, windowHeight);
                                });
                            });
                        }

                        function renderWindow(node, container, options, windowWidth, windowHeight) {
                            var clonedWindow = container.contentWindow;
                            var support = new Support(clonedWindow.document);
                            var imageLoader = new ImageLoader(options, support);
                            var bounds = getBounds(node);
                            var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
                            var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
                            var renderer = new options.renderer(width, height, imageLoader, options, document);
                            var parser = new NodeParser(node, renderer, support, imageLoader, options);
                            return parser.ready.then(function() {
                                log("Finished rendering");
                                var canvas;

                                if (options.type === "view") {
                                    canvas = crop(renderer.canvas, {
                                        width: renderer.canvas.width,
                                        height: renderer.canvas.height,
                                        top: 0,
                                        left: 0,
                                        x: 0,
                                        y: 0
                                    });
                                } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {
                                    canvas = renderer.canvas;
                                } else {
                                    canvas = crop(renderer.canvas, {
                                        width: options.width != null ? options.width : bounds.width,
                                        height: options.height != null ? options.height : bounds.height,
                                        top: bounds.top,
                                        left: bounds.left,
                                        x: 0,
                                        y: 0
                                    });
                                }

                                cleanupContainer(container, options);
                                return canvas;
                            });
                        }

                        function cleanupContainer(container, options) {
                            if (options.removeContainer) {
                                container.parentNode.removeChild(container);
                                log("Cleaned up container");
                            }
                        }

                        function crop(canvas, bounds) {
                            var croppedCanvas = document.createElement("canvas");
                            var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));
                            var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));
                            var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));
                            var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));
                            croppedCanvas.width = bounds.width;
                            croppedCanvas.height = bounds.height;
                            var width = x2 - x1;
                            var height = y2 - y1;
                            log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", width, "height:", height);
                            log("Resulting crop with width", bounds.width, "and height", bounds.height, "with x", x1, "and y", y1);
                            croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, width, height, bounds.x, bounds.y, width, height);
                            return croppedCanvas;
                        }

                        function documentWidth(doc) {
                            return Math.max(
                                Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
                                Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
                                Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
                            );
                        }

                        function documentHeight(doc) {
                            return Math.max(
                                Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
                                Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
                                Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
                            );
                        }

                        function absoluteUrl(url) {
                            var link = document.createElement("a");
                            link.href = url;
                            link.href = link.href;
                            return link;
                        }

                    }, {
                        "./clone": 2,
                        "./imageloader": 11,
                        "./log": 13,
                        "./nodecontainer": 14,
                        "./nodeparser": 15,
                        "./proxy": 16,
                        "./renderers/canvas": 20,
                        "./support": 22,
                        "./utils": 26
                    }],
                    5: [function(_dereq_, module, exports) {
                        var log = _dereq_('./log');
                        var smallImage = _dereq_('./utils').smallImage;

                        function DummyImageContainer(src) {
                            this.src = src;
                            log("DummyImageContainer for", src);
                            if (!this.promise || !this.image) {
                                log("Initiating DummyImageContainer");
                                DummyImageContainer.prototype.image = new Image();
                                var image = this.image;
                                DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {
                                    image.onload = resolve;
                                    image.onerror = reject;
                                    image.src = smallImage();
                                    if (image.complete === true) {
                                        resolve(image);
                                    }
                                });
                            }
                        }

                        module.exports = DummyImageContainer;

                    }, {
                        "./log": 13,
                        "./utils": 26
                    }],
                    6: [function(_dereq_, module, exports) {
                        var smallImage = _dereq_('./utils').smallImage;

                        function Font(family, size) {
                            var container = document.createElement('div'),
                                img = document.createElement('img'),
                                span = document.createElement('span'),
                                sampleText = 'Hidden Text',
                                baseline,
                                middle;

                            container.style.visibility = "hidden";
                            container.style.fontFamily = family;
                            container.style.fontSize = size;
                            container.style.margin = 0;
                            container.style.padding = 0;

                            document.body.appendChild(container);

                            img.src = smallImage();
                            img.width = 1;
                            img.height = 1;

                            img.style.margin = 0;
                            img.style.padding = 0;
                            img.style.verticalAlign = "baseline";

                            span.style.fontFamily = family;
                            span.style.fontSize = size;
                            span.style.margin = 0;
                            span.style.padding = 0;

                            span.appendChild(document.createTextNode(sampleText));
                            container.appendChild(span);
                            container.appendChild(img);
                            baseline = (img.offsetTop - span.offsetTop) + 1;

                            container.removeChild(span);
                            container.appendChild(document.createTextNode(sampleText));

                            container.style.lineHeight = "normal";
                            img.style.verticalAlign = "super";

                            middle = (img.offsetTop - container.offsetTop) + 1;

                            document.body.removeChild(container);

                            this.baseline = baseline;
                            this.lineWidth = 1;
                            this.middle = middle;
                        }

                        module.exports = Font;

                    }, {
                        "./utils": 26
                    }],
                    7: [function(_dereq_, module, exports) {
                        var Font = _dereq_('./font');

                        function FontMetrics() {
                            this.data = {};
                        }

                        FontMetrics.prototype.getMetrics = function(family, size) {
                            if (this.data[family + "-" + size] === undefined) {
                                this.data[family + "-" + size] = new Font(family, size);
                            }
                            return this.data[family + "-" + size];
                        };

                        module.exports = FontMetrics;

                    }, {
                        "./font": 6
                    }],
                    8: [function(_dereq_, module, exports) {
                        var utils = _dereq_('./utils');
                        var getBounds = utils.getBounds;
                        var loadUrlDocument = _dereq_('./proxy').loadUrlDocument;

                        function FrameContainer(container, sameOrigin, options) {
                            this.image = null;
                            this.src = container;
                            var self = this;
                            var bounds = getBounds(container);
                            this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {
                                if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
                                    container.contentWindow.onload = container.onload = function() {
                                        resolve(container);
                                    };
                                } else {
                                    resolve(container);
                                }
                            })).then(function(container) {
                                var html2canvas = _dereq_('./core');
                                return html2canvas(container.contentWindow.document.documentElement, {
                                    type: 'view',
                                    width: container.width,
                                    height: container.height,
                                    proxy: options.proxy,
                                    javascriptEnabled: options.javascriptEnabled,
                                    removeContainer: options.removeContainer,
                                    allowTaint: options.allowTaint,
                                    imageTimeout: options.imageTimeout / 2
                                });
                            }).then(function(canvas) {
                                return self.image = canvas;
                            });
                        }

                        FrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {
                            var container = this.src;
                            return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
                        };

                        module.exports = FrameContainer;

                    }, {
                        "./core": 4,
                        "./proxy": 16,
                        "./utils": 26
                    }],
                    9: [function(_dereq_, module, exports) {
                        function GradientContainer(imageData) {
                            this.src = imageData.value;
                            this.colorStops = [];
                            this.type = null;
                            this.x0 = 0.5;
                            this.y0 = 0.5;
                            this.x1 = 0.5;
                            this.y1 = 0.5;
                            this.promise = Promise.resolve(true);
                        }

                        GradientContainer.TYPES = {
                            LINEAR: 1,
                            RADIAL: 2
                        };

                        // TODO: support hsl[a], negative %/length values
                        // TODO: support <angle> (e.g. -?\d{1,3}(?:\.\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )
                        GradientContainer.REGEXP_COLORSTOP = /^\s*(rgba?\(\s*\d{1,3},\s*\d{1,3},\s*\d{1,3}(?:,\s*[0-9\.]+)?\s*\)|[a-z]{3,20}|#[a-f0-9]{3,6})(?:\s+(\d{1,3}(?:\.\d+)?)(%|px)?)?(?:\s|$)/i;

                        module.exports = GradientContainer;

                    }, {}],
                    10: [function(_dereq_, module, exports) {
                        function ImageContainer(src, cors) {
                            this.src = src;
                            this.image = new Image();
                            var self = this;
                            this.tainted = null;
                            this.promise = new Promise(function(resolve, reject) {
                                self.image.onload = resolve;
                                self.image.onerror = reject;
                                if (cors) {
                                    self.image.crossOrigin = "anonymous";
                                }
                                self.image.src = src;
                                if (self.image.complete === true) {
                                    resolve(self.image);
                                }
                            });
                        }

                        module.exports = ImageContainer;

                    }, {}],
                    11: [function(_dereq_, module, exports) {
                        var log = _dereq_('./log');
                        var ImageContainer = _dereq_('./imagecontainer');
                        var DummyImageContainer = _dereq_('./dummyimagecontainer');
                        var ProxyImageContainer = _dereq_('./proxyimagecontainer');
                        var FrameContainer = _dereq_('./framecontainer');
                        var SVGContainer = _dereq_('./svgcontainer');
                        var SVGNodeContainer = _dereq_('./svgnodecontainer');
                        var LinearGradientContainer = _dereq_('./lineargradientcontainer');
                        var WebkitGradientContainer = _dereq_('./webkitgradientcontainer');
                        var bind = _dereq_('./utils').bind;

                        function ImageLoader(options, support) {
                            this.link = null;
                            this.options = options;
                            this.support = support;
                            this.origin = this.getOrigin(window.location.href);
                        }

                        ImageLoader.prototype.findImages = function(nodes) {
                            var images = [];
                            nodes.reduce(function(imageNodes, container) {
                                switch (container.node.nodeName) {
                                    case "IMG":
                                        return imageNodes.concat([{
                                            args: [container.node.src],
                                            method: "url"
                                        }]);
                                    case "svg":
                                    case "IFRAME":
                                        return imageNodes.concat([{
                                            args: [container.node],
                                            method: container.node.nodeName
                                        }]);
                                }
                                return imageNodes;
                            }, []).forEach(this.addImage(images, this.loadImage), this);
                            return images;
                        };

                        ImageLoader.prototype.findBackgroundImage = function(images, container) {
                            container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
                            return images;
                        };

                        ImageLoader.prototype.addImage = function(images, callback) {
                            return function(newImage) {
                                newImage.args.forEach(function(image) {
                                    if (!this.imageExists(images, image)) {
                                        images.splice(0, 0, callback.call(this, newImage));
                                        log('Added image #' + (images.length), typeof(image) === "string" ? image.substring(0, 100) : image);
                                    }
                                }, this);
                            };
                        };

                        ImageLoader.prototype.hasImageBackground = function(imageData) {
                            return imageData.method !== "none";
                        };

                        ImageLoader.prototype.loadImage = function(imageData) {
                            if (imageData.method === "url") {
                                var src = imageData.args[0];
                                if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
                                    return new SVGContainer(src);
                                } else if (src.match(/data:image\/.*;base64,/i)) {
                                    return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
                                } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
                                    return new ImageContainer(src, false);
                                } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
                                    return new ImageContainer(src, true);
                                } else if (this.options.proxy) {
                                    return new ProxyImageContainer(src, this.options.proxy);
                                } else {
                                    return new DummyImageContainer(src);
                                }
                            } else if (imageData.method === "linear-gradient") {
                                return new LinearGradientContainer(imageData);
                            } else if (imageData.method === "gradient") {
                                return new WebkitGradientContainer(imageData);
                            } else if (imageData.method === "svg") {
                                return new SVGNodeContainer(imageData.args[0], this.support.svg);
                            } else if (imageData.method === "IFRAME") {
                                return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
                            } else {
                                return new DummyImageContainer(imageData);
                            }
                        };

                        ImageLoader.prototype.isSVG = function(src) {
                            return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
                        };

                        ImageLoader.prototype.imageExists = function(images, src) {
                            return images.some(function(image) {
                                return image.src === src;
                            });
                        };

                        ImageLoader.prototype.isSameOrigin = function(url) {
                            return (this.getOrigin(url) === this.origin);
                        };

                        ImageLoader.prototype.getOrigin = function(url) {
                            var link = this.link || (this.link = document.createElement("a"));
                            link.href = url;
                            link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
                            return link.protocol + link.hostname + link.port;
                        };

                        ImageLoader.prototype.getPromise = function(container) {
                            return this.timeout(container, this.options.imageTimeout)['catch'](function() {
                                var dummy = new DummyImageContainer(container.src);
                                return dummy.promise.then(function(image) {
                                    container.image = image;
                                });
                            });
                        };

                        ImageLoader.prototype.get = function(src) {
                            var found = null;
                            return this.images.some(function(img) {
                                return (found = img).src === src;
                            }) ? found : null;
                        };

                        ImageLoader.prototype.fetch = function(nodes) {
                            this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
                            this.images.forEach(function(image, index) {
                                image.promise.then(function() {
                                    log("Succesfully loaded image #" + (index + 1), image);
                                }, function(e) {
                                    log("Failed loading image #" + (index + 1), image, e);
                                });
                            });
                            this.ready = Promise.all(this.images.map(this.getPromise, this));
                            log("Finished searching images");
                            return this;
                        };

                        ImageLoader.prototype.timeout = function(container, timeout) {
                            var timer;
                            var promise = Promise.race([container.promise, new Promise(function(res, reject) {
                                timer = setTimeout(function() {
                                    log("Timed out loading image", container);
                                    reject(container);
                                }, timeout);
                            })]).then(function(container) {
                                clearTimeout(timer);
                                return container;
                            });
                            promise['catch'](function() {
                                clearTimeout(timer);
                            });
                            return promise;
                        };

                        module.exports = ImageLoader;

                    }, {
                        "./dummyimagecontainer": 5,
                        "./framecontainer": 8,
                        "./imagecontainer": 10,
                        "./lineargradientcontainer": 12,
                        "./log": 13,
                        "./proxyimagecontainer": 17,
                        "./svgcontainer": 23,
                        "./svgnodecontainer": 24,
                        "./utils": 26,
                        "./webkitgradientcontainer": 27
                    }],
                    12: [function(_dereq_, module, exports) {
                        var GradientContainer = _dereq_('./gradientcontainer');
                        var Color = _dereq_('./color');

                        function LinearGradientContainer(imageData) {
                            GradientContainer.apply(this, arguments);
                            this.type = GradientContainer.TYPES.LINEAR;

                            var hasDirection = LinearGradientContainer.REGEXP_DIRECTION.test(imageData.args[0]) ||
                                !GradientContainer.REGEXP_COLORSTOP.test(imageData.args[0]);

                            if (hasDirection) {
                                imageData.args[0].split(/\s+/).reverse().forEach(function(position, index) {
                                    switch (position) {
                                        case "left":
                                            this.x0 = 0;
                                            this.x1 = 1;
                                            break;
                                        case "top":
                                            this.y0 = 0;
                                            this.y1 = 1;
                                            break;
                                        case "right":
                                            this.x0 = 1;
                                            this.x1 = 0;
                                            break;
                                        case "bottom":
                                            this.y0 = 1;
                                            this.y1 = 0;
                                            break;
                                        case "to":
                                            var y0 = this.y0;
                                            var x0 = this.x0;
                                            this.y0 = this.y1;
                                            this.x0 = this.x1;
                                            this.x1 = x0;
                                            this.y1 = y0;
                                            break;
                                        case "center":
                                            break; // centered by default
                                            // Firefox internally converts position keywords to percentages:
                                            // http://www.w3.org/TR/2010/WD-CSS2-20101207/colors.html#propdef-background-position
                                        default: // percentage or absolute length
                                            // TODO: support absolute start point positions (e.g., use bounds to convert px to a ratio)
                                            var ratio = parseFloat(position, 10) * 1e-2;
                                            if (isNaN(ratio)) { // invalid or unhandled value
                                                break;
                                            }
                                            if (index === 0) {
                                                this.y0 = ratio;
                                                this.y1 = 1 - this.y0;
                                            } else {
                                                this.x0 = ratio;
                                                this.x1 = 1 - this.x0;
                                            }
                                            break;
                                    }
                                }, this);
                            } else {
                                this.y0 = 0;
                                this.y1 = 1;
                            }

                            this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {
                                var colorStopMatch = colorStop.match(GradientContainer.REGEXP_COLORSTOP);
                                var value = +colorStopMatch[2];
                                var unit = value === 0 ? "%" : colorStopMatch[3]; // treat "0" as "0%"
                                return {
                                    color: new Color(colorStopMatch[1]),
                                    // TODO: support absolute stop positions (e.g., compute gradient line length & convert px to ratio)
                                    stop: unit === "%" ? value / 100 : null
                                };
                            });

                            if (this.colorStops[0].stop === null) {
                                this.colorStops[0].stop = 0;
                            }

                            if (this.colorStops[this.colorStops.length - 1].stop === null) {
                                this.colorStops[this.colorStops.length - 1].stop = 1;
                            }

                            // calculates and fills-in explicit stop positions when omitted from rule
                            this.colorStops.forEach(function(colorStop, index) {
                                if (colorStop.stop === null) {
                                    this.colorStops.slice(index).some(function(find, count) {
                                        if (find.stop !== null) {
                                            colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;
                                            return true;
                                        } else {
                                            return false;
                                        }
                                    }, this);
                                }
                            }, this);
                        }

                        LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);

                        // TODO: support <angle> (e.g. -?\d{1,3}(?:\.\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )
                        LinearGradientContainer.REGEXP_DIRECTION = /^\s*(?:to|left|right|top|bottom|center|\d{1,3}(?:\.\d+)?%?)(?:\s|$)/i;

                        module.exports = LinearGradientContainer;

                    }, {
                        "./color": 3,
                        "./gradientcontainer": 9
                    }],
                    13: [function(_dereq_, module, exports) {
                        var logger = function() {
                            if (logger.options.logging && window.console && window.console.log) {
                                Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - logger.options.start) + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
                            }
                        };

                        logger.options = {
                            logging: false
                        };
                        module.exports = logger;

                    }, {}],
                    14: [function(_dereq_, module, exports) {
                        var Color = _dereq_('./color');
                        var utils = _dereq_('./utils');
                        var getBounds = utils.getBounds;
                        var parseBackgrounds = utils.parseBackgrounds;
                        var offsetBounds = utils.offsetBounds;

                        function NodeContainer(node, parent) {
                            this.node = node;
                            this.parent = parent;
                            this.stack = null;
                            this.bounds = null;
                            this.borders = null;
                            this.clip = [];
                            this.backgroundClip = [];
                            this.offsetBounds = null;
                            this.visible = null;
                            this.computedStyles = null;
                            this.colors = {};
                            this.styles = {};
                            this.backgroundImages = null;
                            this.transformData = null;
                            this.transformMatrix = null;
                            this.isPseudoElement = false;
                            this.opacity = null;
                        }

                        NodeContainer.prototype.cloneTo = function(stack) {
                            stack.visible = this.visible;
                            stack.borders = this.borders;
                            stack.bounds = this.bounds;
                            stack.clip = this.clip;
                            stack.backgroundClip = this.backgroundClip;
                            stack.computedStyles = this.computedStyles;
                            stack.styles = this.styles;
                            stack.backgroundImages = this.backgroundImages;
                            stack.opacity = this.opacity;
                        };

                        NodeContainer.prototype.getOpacity = function() {
                            return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;
                        };

                        NodeContainer.prototype.assignStack = function(stack) {
                            this.stack = stack;
                            stack.children.push(this);
                        };

                        NodeContainer.prototype.isElementVisible = function() {
                            return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (
                                this.css('display') !== "none" &&
                                this.css('visibility') !== "hidden" &&
                                !this.node.hasAttribute("data-html2canvas-ignore") &&
                                (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden")
                            );
                        };

                        NodeContainer.prototype.css = function(attribute) {
                            if (!this.computedStyles) {
                                this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
                            }

                            return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
                        };

                        NodeContainer.prototype.prefixedCss = function(attribute) {
                            var prefixes = ["webkit", "moz", "ms", "o"];
                            var value = this.css(attribute);
                            if (value === undefined) {
                                prefixes.some(function(prefix) {
                                    value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
                                    return value !== undefined;
                                }, this);
                            }
                            return value === undefined ? null : value;
                        };

                        NodeContainer.prototype.computedStyle = function(type) {
                            return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
                        };

                        NodeContainer.prototype.cssInt = function(attribute) {
                            var value = parseInt(this.css(attribute), 10);
                            return (isNaN(value)) ? 0 : value; // borders in old IE are throwing 'medium' for demo.html
                        };

                        NodeContainer.prototype.color = function(attribute) {
                            return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));
                        };

                        NodeContainer.prototype.cssFloat = function(attribute) {
                            var value = parseFloat(this.css(attribute));
                            return (isNaN(value)) ? 0 : value;
                        };

                        NodeContainer.prototype.fontWeight = function() {
                            var weight = this.css("fontWeight");
                            switch (parseInt(weight, 10)) {
                                case 401:
                                    weight = "bold";
                                    break;
                                case 400:
                                    weight = "normal";
                                    break;
                            }
                            return weight;
                        };

                        NodeContainer.prototype.parseClip = function() {
                            var matches = this.css('clip').match(this.CLIP);
                            if (matches) {
                                return {
                                    top: parseInt(matches[1], 10),
                                    right: parseInt(matches[2], 10),
                                    bottom: parseInt(matches[3], 10),
                                    left: parseInt(matches[4], 10)
                                };
                            }
                            return null;
                        };

                        NodeContainer.prototype.parseBackgroundImages = function() {
                            return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
                        };

                        NodeContainer.prototype.cssList = function(property, index) {
                            var value = (this.css(property) || '').split(',');
                            value = value[index || 0] || value[0] || 'auto';
                            value = value.trim().split(' ');
                            if (value.length === 1) {
                                value = [value[0], isPercentage(value[0]) ? 'auto' : value[0]];
                            }
                            return value;
                        };

                        NodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {
                            var size = this.cssList("backgroundSize", index);
                            var width, height;

                            if (isPercentage(size[0])) {
                                width = bounds.width * parseFloat(size[0]) / 100;
                            } else if (/contain|cover/.test(size[0])) {
                                var targetRatio = bounds.width / bounds.height,
                                    currentRatio = image.width / image.height;
                                return (targetRatio < currentRatio ^ size[0] === 'contain') ? {
                                    width: bounds.height * currentRatio,
                                    height: bounds.height
                                } : {
                                    width: bounds.width,
                                    height: bounds.width / currentRatio
                                };
                            } else {
                                width = parseInt(size[0], 10);
                            }

                            if (size[0] === 'auto' && size[1] === 'auto') {
                                height = image.height;
                            } else if (size[1] === 'auto') {
                                height = width / image.width * image.height;
                            } else if (isPercentage(size[1])) {
                                height = bounds.height * parseFloat(size[1]) / 100;
                            } else {
                                height = parseInt(size[1], 10);
                            }

                            if (size[0] === 'auto') {
                                width = height / image.height * image.width;
                            }

                            return {
                                width: width,
                                height: height
                            };
                        };

                        NodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {
                            var position = this.cssList('backgroundPosition', index);
                            var left, top;

                            if (isPercentage(position[0])) {
                                left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
                            } else {
                                left = parseInt(position[0], 10);
                            }

                            if (position[1] === 'auto') {
                                top = left / image.width * image.height;
                            } else if (isPercentage(position[1])) {
                                top = (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
                            } else {
                                top = parseInt(position[1], 10);
                            }

                            if (position[0] === 'auto') {
                                left = top / image.height * image.width;
                            }

                            return {
                                left: left,
                                top: top
                            };
                        };

                        NodeContainer.prototype.parseBackgroundRepeat = function(index) {
                            return this.cssList("backgroundRepeat", index)[0];
                        };

                        NodeContainer.prototype.parseTextShadows = function() {
                            var textShadow = this.css("textShadow");
                            var results = [];

                            if (textShadow && textShadow !== 'none') {
                                var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
                                for (var i = 0; shadows && (i < shadows.length); i++) {
                                    var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
                                    results.push({
                                        color: new Color(s[0]),
                                        offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
                                        offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
                                        blur: s[3] ? s[3].replace('px', '') : 0
                                    });
                                }
                            }
                            return results;
                        };

                        NodeContainer.prototype.parseTransform = function() {
                            if (!this.transformData) {
                                if (this.hasTransform()) {
                                    var offset = this.parseBounds();
                                    var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
                                    origin[0] += offset.left;
                                    origin[1] += offset.top;
                                    this.transformData = {
                                        origin: origin,
                                        matrix: this.parseTransformMatrix()
                                    };
                                } else {
                                    this.transformData = {
                                        origin: [0, 0],
                                        matrix: [1, 0, 0, 1, 0, 0]
                                    };
                                }
                            }
                            return this.transformData;
                        };

                        NodeContainer.prototype.parseTransformMatrix = function() {
                            if (!this.transformMatrix) {
                                var transform = this.prefixedCss("transform");
                                var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
                                this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
                            }
                            return this.transformMatrix;
                        };

                        NodeContainer.prototype.parseBounds = function() {
                            return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
                        };

                        NodeContainer.prototype.hasTransform = function() {
                            return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || (this.parent && this.parent.hasTransform());
                        };

                        NodeContainer.prototype.getValue = function() {
                            var value = this.node.value || "";
                            if (this.node.tagName === "SELECT") {
                                value = selectionValue(this.node);
                            } else if (this.node.type === "password") {
                                value = Array(value.length + 1).join('\u2022'); // jshint ignore:line
                            }
                            return value.length === 0 ? (this.node.placeholder || "") : value;
                        };

                        NodeContainer.prototype.MATRIX_PROPERTY = /(matrix|matrix3d)\((.+)\)/;
                        NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
                        NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
                        NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

                        function selectionValue(node) {
                            var option = node.options[node.selectedIndex || 0];
                            return option ? (option.text || "") : "";
                        }

                        function parseMatrix(match) {
                            if (match && match[1] === "matrix") {
                                return match[2].split(",").map(function(s) {
                                    return parseFloat(s.trim());
                                });
                            } else if (match && match[1] === "matrix3d") {
                                var matrix3d = match[2].split(",").map(function(s) {
                                    return parseFloat(s.trim());
                                });
                                return [matrix3d[0], matrix3d[1], matrix3d[4], matrix3d[5], matrix3d[12], matrix3d[13]];
                            }
                        }

                        function isPercentage(value) {
                            return value.toString().indexOf("%") !== -1;
                        }

                        function removePx(str) {
                            return str.replace("px", "");
                        }

                        function asFloat(str) {
                            return parseFloat(str);
                        }

                        module.exports = NodeContainer;

                    }, {
                        "./color": 3,
                        "./utils": 26
                    }],
                    15: [function(_dereq_, module, exports) {
                        var log = _dereq_('./log');
                        var punycode = _dereq_('punycode');
                        var NodeContainer = _dereq_('./nodecontainer');
                        var TextContainer = _dereq_('./textcontainer');
                        var PseudoElementContainer = _dereq_('./pseudoelementcontainer');
                        var FontMetrics = _dereq_('./fontmetrics');
                        var Color = _dereq_('./color');
                        var StackingContext = _dereq_('./stackingcontext');
                        var utils = _dereq_('./utils');
                        var bind = utils.bind;
                        var getBounds = utils.getBounds;
                        var parseBackgrounds = utils.parseBackgrounds;
                        var offsetBounds = utils.offsetBounds;

                        function NodeParser(element, renderer, support, imageLoader, options) {
                            log("Starting NodeParser");
                            this.renderer = renderer;
                            this.options = options;
                            this.range = null;
                            this.support = support;
                            this.renderQueue = [];
                            this.stack = new StackingContext(true, 1, element.ownerDocument, null);
                            var parent = new NodeContainer(element, null);
                            if (options.background) {
                                renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));
                            }
                            if (element === element.ownerDocument.documentElement) {
                                // http://www.w3.org/TR/css3-background/#special-backgrounds
                                var canvasBackground = new NodeContainer(parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
                                renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));
                            }
                            parent.visibile = parent.isElementVisible();
                            this.createPseudoHideStyles(element.ownerDocument);
                            this.disableAnimations(element.ownerDocument);
                            this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {
                                return container.visible = container.isElementVisible();
                            }).map(this.getPseudoElements, this));
                            this.fontMetrics = new FontMetrics();
                            log("Fetched nodes, total:", this.nodes.length);
                            log("Calculate overflow clips");
                            this.calculateOverflowClips();
                            log("Start fetching images");
                            this.images = imageLoader.fetch(this.nodes.filter(isElement));
                            this.ready = this.images.ready.then(bind(function() {
                                log("Images loaded, starting parsing");
                                log("Creating stacking contexts");
                                this.createStackingContexts();
                                log("Sorting stacking contexts");
                                this.sortStackingContexts(this.stack);
                                this.parse(this.stack);
                                log("Render queue created with " + this.renderQueue.length + " items");
                                return new Promise(bind(function(resolve) {
                                    if (!options.async) {
                                        this.renderQueue.forEach(this.paint, this);
                                        resolve();
                                    } else if (typeof(options.async) === "function") {
                                        options.async.call(this, this.renderQueue, resolve);
                                    } else if (this.renderQueue.length > 0) {
                                        this.renderIndex = 0;
                                        this.asyncRenderer(this.renderQueue, resolve);
                                    } else {
                                        resolve();
                                    }
                                }, this));
                            }, this));
                        }

                        NodeParser.prototype.calculateOverflowClips = function() {
                            this.nodes.forEach(function(container) {
                                if (isElement(container)) {
                                    if (isPseudoElement(container)) {
                                        container.appendToDOM();
                                    }
                                    container.borders = this.parseBorders(container);
                                    var clip = (container.css('overflow') === "hidden") ? [container.borders.clip] : [];
                                    var cssClip = container.parseClip();
                                    if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
                                        clip.push([
                                            ["rect",
                                                container.bounds.left + cssClip.left,
                                                container.bounds.top + cssClip.top,
                                                cssClip.right - cssClip.left,
                                                cssClip.bottom - cssClip.top
                                            ]
                                        ]);
                                    }
                                    container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
                                    container.backgroundClip = (container.css('overflow') !== "hidden") ? container.clip.concat([container.borders.clip]) : container.clip;
                                    if (isPseudoElement(container)) {
                                        container.cleanDOM();
                                    }
                                } else if (isTextNode(container)) {
                                    container.clip = hasParentClip(container) ? container.parent.clip : [];
                                }
                                if (!isPseudoElement(container)) {
                                    container.bounds = null;
                                }
                            }, this);
                        };

                        function hasParentClip(container) {
                            return container.parent && container.parent.clip.length;
                        }

                        NodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {
                            asyncTimer = asyncTimer || Date.now();
                            this.paint(queue[this.renderIndex++]);
                            if (queue.length === this.renderIndex) {
                                resolve();
                            } else if (asyncTimer + 20 > Date.now()) {
                                this.asyncRenderer(queue, resolve, asyncTimer);
                            } else {
                                setTimeout(bind(function() {
                                    this.asyncRenderer(queue, resolve);
                                }, this), 0);
                            }
                        };

                        NodeParser.prototype.createPseudoHideStyles = function(document) {
                            this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' +
                                '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
                        };

                        NodeParser.prototype.disableAnimations = function(document) {
                            this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' +
                                '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
                        };

                        NodeParser.prototype.createStyles = function(document, styles) {
                            var hidePseudoElements = document.createElement('style');
                            hidePseudoElements.innerHTML = styles;
                            document.body.appendChild(hidePseudoElements);
                        };

                        NodeParser.prototype.getPseudoElements = function(container) {
                            var nodes = [
                                [container]
                            ];
                            if (container.node.nodeType === Node.ELEMENT_NODE) {
                                var before = this.getPseudoElement(container, ":before");
                                var after = this.getPseudoElement(container, ":after");

                                if (before) {
                                    nodes.push(before);
                                }

                                if (after) {
                                    nodes.push(after);
                                }
                            }
                            return flatten(nodes);
                        };

                        function toCamelCase(str) {
                            return str.replace(/(\-[a-z])/g, function(match) {
                                return match.toUpperCase().replace('-', '');
                            });
                        }

                        NodeParser.prototype.getPseudoElement = function(container, type) {
                            var style = container.computedStyle(type);
                            if (!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
                                return null;
                            }

                            var content = stripQuotes(style.content);
                            var isImage = content.substr(0, 3) === 'url';
                            var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
                            var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);

                            for (var i = style.length - 1; i >= 0; i--) {
                                var property = toCamelCase(style.item(i));
                                pseudoNode.style[property] = style[property];
                            }

                            pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;

                            if (isImage) {
                                pseudoNode.src = parseBackgrounds(content)[0].args[0];
                                return [pseudoContainer];
                            } else {
                                var text = document.createTextNode(content);
                                pseudoNode.appendChild(text);
                                return [pseudoContainer, new TextContainer(text, pseudoContainer)];
                            }
                        };


                        NodeParser.prototype.getChildren = function(parentContainer) {
                            return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {
                                var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
                                return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;
                            }, this));
                        };

                        NodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {
                            var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
                            container.cloneTo(stack);
                            var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
                            parentStack.contexts.push(stack);
                            container.stack = stack;
                        };

                        NodeParser.prototype.createStackingContexts = function() {
                            this.nodes.forEach(function(container) {
                                if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
                                    this.newStackingContext(container, true);
                                } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {
                                    this.newStackingContext(container, false);
                                } else {
                                    container.assignStack(container.parent.stack);
                                }
                            }, this);
                        };

                        NodeParser.prototype.isBodyWithTransparentRoot = function(container) {
                            return container.node.nodeName === "BODY" && container.parent.color('backgroundColor').isTransparent();
                        };

                        NodeParser.prototype.isRootElement = function(container) {
                            return container.parent === null;
                        };

                        NodeParser.prototype.sortStackingContexts = function(stack) {
                            stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
                            stack.contexts.forEach(this.sortStackingContexts, this);
                        };

                        NodeParser.prototype.parseTextBounds = function(container) {
                            return function(text, index, textList) {
                                if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
                                    if (this.support.rangeBounds && !container.parent.hasTransform()) {
                                        var offset = textList.slice(0, index).join("").length;
                                        return this.getRangeBounds(container.node, offset, text.length);
                                    } else if (container.node && typeof(container.node.data) === "string") {
                                        var replacementNode = container.node.splitText(text.length);
                                        var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
                                        container.node = replacementNode;
                                        return bounds;
                                    }
                                } else if (!this.support.rangeBounds || container.parent.hasTransform()) {
                                    container.node = container.node.splitText(text.length);
                                }
                                return {};
                            };
                        };

                        NodeParser.prototype.getWrapperBounds = function(node, transform) {
                            var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
                            var parent = node.parentNode,
                                backupText = node.cloneNode(true);

                            wrapper.appendChild(node.cloneNode(true));
                            parent.replaceChild(wrapper, node);
                            var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
                            parent.replaceChild(backupText, wrapper);
                            return bounds;
                        };

                        NodeParser.prototype.getRangeBounds = function(node, offset, length) {
                            var range = this.range || (this.range = node.ownerDocument.createRange());
                            range.setStart(node, offset);
                            range.setEnd(node, offset + length);
                            return range.getBoundingClientRect();
                        };

                        function ClearTransform() {}

                        NodeParser.prototype.parse = function(stack) {
                            // http://www.w3.org/TR/CSS21/visuren.html#z-index
                            var negativeZindex = stack.contexts.filter(negativeZIndex); // 2. the child stacking contexts with negative stack levels (most negative first).
                            var descendantElements = stack.children.filter(isElement);
                            var descendantNonFloats = descendantElements.filter(not(isFloating));
                            var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); // 3 the in-flow, non-inline-level, non-positioned descendants.
                            var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); // 4. the non-positioned floats.
                            var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
                            var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.
                            var text = stack.children.filter(isTextNode).filter(hasText);
                            var positiveZindex = stack.contexts.filter(positiveZIndex); // 7. the child stacking contexts with positive stack levels (least positive first).
                            negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats)
                                .concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {
                                    this.renderQueue.push(container);
                                    if (isStackingContext(container)) {
                                        this.parse(container);
                                        this.renderQueue.push(new ClearTransform());
                                    }
                                }, this);
                        };

                        NodeParser.prototype.paint = function(container) {
                            try {
                                if (container instanceof ClearTransform) {
                                    this.renderer.ctx.restore();
                                } else if (isTextNode(container)) {
                                    if (isPseudoElement(container.parent)) {
                                        container.parent.appendToDOM();
                                    }
                                    this.paintText(container);
                                    if (isPseudoElement(container.parent)) {
                                        container.parent.cleanDOM();
                                    }
                                } else {
                                    this.paintNode(container);
                                }
                            } catch (e) {
                                log(e);
                                if (this.options.strict) {
                                    throw e;
                                }
                            }
                        };

                        NodeParser.prototype.paintNode = function(container) {
                            if (isStackingContext(container)) {
                                this.renderer.setOpacity(container.opacity);
                                this.renderer.ctx.save();
                                if (container.hasTransform()) {
                                    this.renderer.setTransform(container.parseTransform());
                                }
                            }

                            if (container.node.nodeName === "INPUT" && container.node.type === "checkbox") {
                                this.paintCheckbox(container);
                            } else if (container.node.nodeName === "INPUT" && container.node.type === "radio") {
                                this.paintRadio(container);
                            } else {
                                this.paintElement(container);
                            }
                        };

                        NodeParser.prototype.paintElement = function(container) {
                            var bounds = container.parseBounds();
                            this.renderer.clip(container.backgroundClip, function() {
                                this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
                            }, this);

                            this.renderer.clip(container.clip, function() {
                                this.renderer.renderBorders(container.borders.borders);
                            }, this);

                            this.renderer.clip(container.backgroundClip, function() {
                                switch (container.node.nodeName) {
                                    case "svg":
                                    case "IFRAME":
                                        var imgContainer = this.images.get(container.node);
                                        if (imgContainer) {
                                            this.renderer.renderImage(container, bounds, container.borders, imgContainer);
                                        } else {
                                            log("Error loading <" + container.node.nodeName + ">", container.node);
                                        }
                                        break;
                                    case "IMG":
                                        var imageContainer = this.images.get(container.node.src);
                                        if (imageContainer) {
                                            this.renderer.renderImage(container, bounds, container.borders, imageContainer);
                                        } else {
                                            log("Error loading <img>", container.node.src);
                                        }
                                        break;
                                    case "CANVAS":
                                        this.renderer.renderImage(container, bounds, container.borders, {
                                            image: container.node
                                        });
                                        break;
                                    case "SELECT":
                                    case "INPUT":
                                    case "TEXTAREA":
                                        this.paintFormValue(container);
                                        break;
                                }
                            }, this);
                        };

                        NodeParser.prototype.paintCheckbox = function(container) {
                            var b = container.parseBounds();

                            var size = Math.min(b.width, b.height);
                            var bounds = {
                                width: size - 1,
                                height: size - 1,
                                top: b.top,
                                left: b.left
                            };
                            var r = [3, 3];
                            var radius = [r, r, r, r];
                            var borders = [1, 1, 1, 1].map(function(w) {
                                return {
                                    color: new Color('#A5A5A5'),
                                    width: w
                                };
                            });

                            var borderPoints = calculateCurvePoints(bounds, radius, borders);

                            this.renderer.clip(container.backgroundClip, function() {
                                this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color("#DEDEDE"));
                                this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius));
                                if (container.node.checked) {
                                    this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', (size - 3) + "px", 'arial');
                                    this.renderer.text("\u2714", bounds.left + size / 6, bounds.top + size - 1);
                                }
                            }, this);
                        };

                        NodeParser.prototype.paintRadio = function(container) {
                            var bounds = container.parseBounds();

                            var size = Math.min(bounds.width, bounds.height) - 2;

                            this.renderer.clip(container.backgroundClip, function() {
                                this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5'));
                                if (container.node.checked) {
                                    this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));
                                }
                            }, this);
                        };

                        NodeParser.prototype.paintFormValue = function(container) {
                            var value = container.getValue();
                            if (value.length > 0) {
                                var document = container.node.ownerDocument;
                                var wrapper = document.createElement('html2canvaswrapper');
                                var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color',
                                    'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom',
                                    'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth',
                                    'boxSizing', 'whiteSpace', 'wordWrap'
                                ];

                                properties.forEach(function(property) {
                                    try {
                                        wrapper.style[property] = container.css(property);
                                    } catch (e) {
                                        // Older IE has issues with "border"
                                        log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
                                    }
                                });
                                var bounds = container.parseBounds();
                                wrapper.style.position = "fixed";
                                wrapper.style.left = bounds.left + "px";
                                wrapper.style.top = bounds.top + "px";
                                wrapper.textContent = value;
                                document.body.appendChild(wrapper);
                                this.paintText(new TextContainer(wrapper.firstChild, container));
                                document.body.removeChild(wrapper);
                            }
                        };

                        NodeParser.prototype.paintText = function(container) {
                            container.applyTextTransform();
                            var characters = punycode.ucs2.decode(container.node.data);
                            var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {
                                return punycode.ucs2.encode([character]);
                            });

                            var weight = container.parent.fontWeight();
                            var size = container.parent.css('fontSize');
                            var family = container.parent.css('fontFamily');
                            var shadows = container.parent.parseTextShadows();

                            this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
                            if (shadows.length) {
                                // TODO: support multiple text shadows
                                this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
                            } else {
                                this.renderer.clearShadow();
                            }

                            this.renderer.clip(container.parent.clip, function() {
                                textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {
                                    if (bounds) {
                                        this.renderer.text(textList[index], bounds.left, bounds.bottom);
                                        this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
                                    }
                                }, this);
                            }, this);
                        };

                        NodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {
                            switch (container.css("textDecoration").split(" ")[0]) {
                                case "underline":
                                    // Draws a line at the baseline of the font
                                    // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
                                    this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color("color"));
                                    break;
                                case "overline":
                                    this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color("color"));
                                    break;
                                case "line-through":
                                    // TODO try and find exact position for line-through
                                    this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color("color"));
                                    break;
                            }
                        };

                        var borderColorTransforms = {
                            inset: [
                                ["darken", 0.60],
                                ["darken", 0.10],
                                ["darken", 0.10],
                                ["darken", 0.60]
                            ]
                        };

                        NodeParser.prototype.parseBorders = function(container) {
                            var nodeBounds = container.parseBounds();
                            var radius = getBorderRadiusData(container);
                            var borders = ["Top", "Right", "Bottom", "Left"].map(function(side, index) {
                                var style = container.css('border' + side + 'Style');
                                var color = container.color('border' + side + 'Color');
                                if (style === "inset" && color.isBlack()) {
                                    color = new Color([255, 255, 255, color.a]); // this is wrong, but
                                }
                                var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null;
                                return {
                                    width: container.cssInt('border' + side + 'Width'),
                                    color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color,
                                    args: null
                                };
                            });
                            var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);

                            return {
                                clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
                                borders: calculateBorders(borders, nodeBounds, borderPoints, radius)
                            };
                        };

                        function calculateBorders(borders, nodeBounds, borderPoints, radius) {
                            return borders.map(function(border, borderSide) {
                                if (border.width > 0) {
                                    var bx = nodeBounds.left;
                                    var by = nodeBounds.top;
                                    var bw = nodeBounds.width;
                                    var bh = nodeBounds.height - (borders[2].width);

                                    switch (borderSide) {
                                        case 0:
                                            // top border
                                            bh = borders[0].width;
                                            border.args = drawSide({
                                                    c1: [bx, by],
                                                    c2: [bx + bw, by],
                                                    c3: [bx + bw - borders[1].width, by + bh],
                                                    c4: [bx + borders[3].width, by + bh]
                                                }, radius[0], radius[1],
                                                borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                                            break;
                                        case 1:
                                            // right border
                                            bx = nodeBounds.left + nodeBounds.width - (borders[1].width);
                                            bw = borders[1].width;

                                            border.args = drawSide({
                                                    c1: [bx + bw, by],
                                                    c2: [bx + bw, by + bh + borders[2].width],
                                                    c3: [bx, by + bh],
                                                    c4: [bx, by + borders[0].width]
                                                }, radius[1], radius[2],
                                                borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                                            break;
                                        case 2:
                                            // bottom border
                                            by = (by + nodeBounds.height) - (borders[2].width);
                                            bh = borders[2].width;
                                            border.args = drawSide({
                                                    c1: [bx + bw, by + bh],
                                                    c2: [bx, by + bh],
                                                    c3: [bx + borders[3].width, by],
                                                    c4: [bx + bw - borders[3].width, by]
                                                }, radius[2], radius[3],
                                                borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                                            break;
                                        case 3:
                                            // left border
                                            bw = borders[3].width;
                                            border.args = drawSide({
                                                    c1: [bx, by + bh + borders[2].width],
                                                    c2: [bx, by],
                                                    c3: [bx + bw, by + borders[0].width],
                                                    c4: [bx + bw, by + bh]
                                                }, radius[3], radius[0],
                                                borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                                            break;
                                    }
                                }
                                return border;
                            });
                        }

                        NodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {
                            var backgroundClip = container.css('backgroundClip'),
                                borderArgs = [];

                            switch (backgroundClip) {
                                case "content-box":
                                case "padding-box":
                                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
                                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
                                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
                                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
                                    break;

                                default:
                                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
                                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
                                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
                                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
                                    break;
                            }

                            return borderArgs;
                        };

                        function getCurvePoints(x, y, r1, r2) {
                            var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
                            var ox = (r1) * kappa, // control point offset horizontal
                                oy = (r2) * kappa, // control point offset vertical
                                xm = x + r1, // x-middle
                                ym = y + r2; // y-middle
                            return {
                                topLeft: bezierCurve({
                                    x: x,
                                    y: ym
                                }, {
                                    x: x,
                                    y: ym - oy
                                }, {
                                    x: xm - ox,
                                    y: y
                                }, {
                                    x: xm,
                                    y: y
                                }),
                                topRight: bezierCurve({
                                    x: x,
                                    y: y
                                }, {
                                    x: x + ox,
                                    y: y
                                }, {
                                    x: xm,
                                    y: ym - oy
                                }, {
                                    x: xm,
                                    y: ym
                                }),
                                bottomRight: bezierCurve({
                                    x: xm,
                                    y: y
                                }, {
                                    x: xm,
                                    y: y + oy
                                }, {
                                    x: x + ox,
                                    y: ym
                                }, {
                                    x: x,
                                    y: ym
                                }),
                                bottomLeft: bezierCurve({
                                    x: xm,
                                    y: ym
                                }, {
                                    x: xm - ox,
                                    y: ym
                                }, {
                                    x: x,
                                    y: y + oy
                                }, {
                                    x: x,
                                    y: y
                                })
                            };
                        }

                        function calculateCurvePoints(bounds, borderRadius, borders) {
                            var x = bounds.left,
                                y = bounds.top,
                                width = bounds.width,
                                height = bounds.height,

                                tlh = borderRadius[0][0] < width / 2 ? borderRadius[0][0] : width / 2,
                                tlv = borderRadius[0][1] < height / 2 ? borderRadius[0][1] : height / 2,
                                trh = borderRadius[1][0] < width / 2 ? borderRadius[1][0] : width / 2,
                                trv = borderRadius[1][1] < height / 2 ? borderRadius[1][1] : height / 2,
                                brh = borderRadius[2][0] < width / 2 ? borderRadius[2][0] : width / 2,
                                brv = borderRadius[2][1] < height / 2 ? borderRadius[2][1] : height / 2,
                                blh = borderRadius[3][0] < width / 2 ? borderRadius[3][0] : width / 2,
                                blv = borderRadius[3][1] < height / 2 ? borderRadius[3][1] : height / 2;

                            var topWidth = width - trh,
                                rightHeight = height - brv,
                                bottomWidth = width - brh,
                                leftHeight = height - blv;

                            return {
                                topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
                                topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
                                topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
                                topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 : trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
                                bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
                                bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width), brv - borders[2].width).bottomRight.subdivide(0.5),
                                bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
                                bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
                            };
                        }

                        function bezierCurve(start, startControl, endControl, end) {
                            var lerp = function(a, b, t) {
                                return {
                                    x: a.x + (b.x - a.x) * t,
                                    y: a.y + (b.y - a.y) * t
                                };
                            };

                            return {
                                start: start,
                                startControl: startControl,
                                endControl: endControl,
                                end: end,
                                subdivide: function(t) {
                                    var ab = lerp(start, startControl, t),
                                        bc = lerp(startControl, endControl, t),
                                        cd = lerp(endControl, end, t),
                                        abbc = lerp(ab, bc, t),
                                        bccd = lerp(bc, cd, t),
                                        dest = lerp(abbc, bccd, t);
                                    return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
                                },
                                curveTo: function(borderArgs) {
                                    borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
                                },
                                curveToReversed: function(borderArgs) {
                                    borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
                                }
                            };
                        }

                        function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
                            var borderArgs = [];

                            if (radius1[0] > 0 || radius1[1] > 0) {
                                borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
                                outer1[1].curveTo(borderArgs);
                            } else {
                                borderArgs.push(["line", borderData.c1[0], borderData.c1[1]]);
                            }

                            if (radius2[0] > 0 || radius2[1] > 0) {
                                borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
                                outer2[0].curveTo(borderArgs);
                                borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
                                inner2[0].curveToReversed(borderArgs);
                            } else {
                                borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
                                borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
                            }

                            if (radius1[0] > 0 || radius1[1] > 0) {
                                borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
                                inner1[1].curveToReversed(borderArgs);
                            } else {
                                borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
                            }

                            return borderArgs;
                        }

                        function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
                            if (radius1[0] > 0 || radius1[1] > 0) {
                                borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
                                corner1[0].curveTo(borderArgs);
                                corner1[1].curveTo(borderArgs);
                            } else {
                                borderArgs.push(["line", x, y]);
                            }

                            if (radius2[0] > 0 || radius2[1] > 0) {
                                borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
                            }
                        }

                        function negativeZIndex(container) {
                            return container.cssInt("zIndex") < 0;
                        }

                        function positiveZIndex(container) {
                            return container.cssInt("zIndex") > 0;
                        }

                        function zIndex0(container) {
                            return container.cssInt("zIndex") === 0;
                        }

                        function inlineLevel(container) {
                            return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
                        }

                        function isStackingContext(container) {
                            return (container instanceof StackingContext);
                        }

                        function hasText(container) {
                            return container.node.data.trim().length > 0;
                        }

                        function noLetterSpacing(container) {
                            return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing")));
                        }

                        function getBorderRadiusData(container) {
                            return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
                                var value = container.css('border' + side + 'Radius');
                                var arr = value.split(" ");
                                if (arr.length <= 1) {
                                    arr[1] = arr[0];
                                }
                                return arr.map(asInt);
                            });
                        }

                        function renderableNode(node) {
                            return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);
                        }

                        function isPositionedForStacking(container) {
                            var position = container.css("position");
                            var zIndex = (["absolute", "relative", "fixed"].indexOf(position) !== -1) ? container.css("zIndex") : "auto";
                            return zIndex !== "auto";
                        }

                        function isPositioned(container) {
                            return container.css("position") !== "static";
                        }

                        function isFloating(container) {
                            return container.css("float") !== "none";
                        }

                        function isInlineBlock(container) {
                            return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
                        }

                        function not(callback) {
                            var context = this;
                            return function() {
                                return !callback.apply(context, arguments);
                            };
                        }

                        function isElement(container) {
                            return container.node.nodeType === Node.ELEMENT_NODE;
                        }

                        function isPseudoElement(container) {
                            return container.isPseudoElement === true;
                        }

                        function isTextNode(container) {
                            return container.node.nodeType === Node.TEXT_NODE;
                        }

                        function zIndexSort(contexts) {
                            return function(a, b) {
                                return (a.cssInt("zIndex") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt("zIndex") + (contexts.indexOf(b) / contexts.length));
                            };
                        }

                        function hasOpacity(container) {
                            return container.getOpacity() < 1;
                        }

                        function asInt(value) {
                            return parseInt(value, 10);
                        }

                        function getWidth(border) {
                            return border.width;
                        }

                        function nonIgnoredElement(nodeContainer) {
                            return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1);
                        }

                        function flatten(arrays) {
                            return [].concat.apply([], arrays);
                        }

                        function stripQuotes(content) {
                            var first = content.substr(0, 1);
                            return (first === content.substr(content.length - 1) && first.match(/'|"/)) ? content.substr(1, content.length - 2) : content;
                        }

                        function getWords(characters) {
                            var words = [],
                                i = 0,
                                onWordBoundary = false,
                                word;
                            while (characters.length) {
                                if (isWordBoundary(characters[i]) === onWordBoundary) {
                                    word = characters.splice(0, i);
                                    if (word.length) {
                                        words.push(punycode.ucs2.encode(word));
                                    }
                                    onWordBoundary = !onWordBoundary;
                                    i = 0;
                                } else {
                                    i++;
                                }

                                if (i >= characters.length) {
                                    word = characters.splice(0, i);
                                    if (word.length) {
                                        words.push(punycode.ucs2.encode(word));
                                    }
                                }
                            }
                            return words;
                        }

                        function isWordBoundary(characterCode) {
                            return [
                                32, // <space>
                                13, // \r
                                10, // \n
                                9, // \t
                                45 // -
                            ].indexOf(characterCode) !== -1;
                        }

                        function hasUnicode(string) {
                            return (/[^\u0000-\u00ff]/).test(string);
                        }

                        module.exports = NodeParser;

                    }, {
                        "./color": 3,
                        "./fontmetrics": 7,
                        "./log": 13,
                        "./nodecontainer": 14,
                        "./pseudoelementcontainer": 18,
                        "./stackingcontext": 21,
                        "./textcontainer": 25,
                        "./utils": 26,
                        "punycode": 1
                    }],
                    16: [function(_dereq_, module, exports) {
                        var XHR = _dereq_('./xhr');
                        var utils = _dereq_('./utils');
                        var log = _dereq_('./log');
                        var createWindowClone = _dereq_('./clone');
                        var decode64 = utils.decode64;

                        function Proxy(src, proxyUrl, document) {
                            var supportsCORS = ('withCredentials' in new XMLHttpRequest());
                            if (!proxyUrl) {
                                return Promise.reject("No proxy configured");
                            }
                            var callback = createCallback(supportsCORS);
                            var url = createProxyUrl(proxyUrl, src, callback);

                            return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {
                                return decode64(response.content);
                            }));
                        }
                        var proxyCount = 0;

                        function ProxyURL(src, proxyUrl, document) {
                            var supportsCORSImage = ('crossOrigin' in new Image());
                            var callback = createCallback(supportsCORSImage);
                            var url = createProxyUrl(proxyUrl, src, callback);
                            return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {
                                return "data:" + response.type + ";base64," + response.content;
                            }));
                        }

                        function jsonp(document, url, callback) {
                            return new Promise(function(resolve, reject) {
                                var s = document.createElement("script");
                                var cleanup = function() {
                                    delete window.html2canvas.proxy[callback];
                                    document.body.removeChild(s);
                                };
                                window.html2canvas.proxy[callback] = function(response) {
                                    cleanup();
                                    resolve(response);
                                };
                                s.src = url;
                                s.onerror = function(e) {
                                    cleanup();
                                    reject(e);
                                };
                                document.body.appendChild(s);
                            });
                        }

                        function createCallback(useCORS) {
                            return !useCORS ? "html2canvas_" + Date.now() + "_" + (++proxyCount) + "_" + Math.round(Math.random() * 100000) : "";
                        }

                        function createProxyUrl(proxyUrl, src, callback) {
                            return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
                        }

                        function documentFromHTML(src) {
                            return function(html) {
                                var parser = new DOMParser(),
                                    doc;
                                try {
                                    doc = parser.parseFromString(html, "text/html");
                                } catch (e) {
                                    log("DOMParser not supported, falling back to createHTMLDocument");
                                    doc = document.implementation.createHTMLDocument("");
                                    try {
                                        doc.open();
                                        doc.write(html);
                                        doc.close();
                                    } catch (ee) {
                                        log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
                                        doc.body.innerHTML = html; // ie9 doesnt support writing to documentElement
                                    }
                                }

                                var b = doc.querySelector("base");
                                if (!b || !b.href.host) {
                                    var base = doc.createElement("base");
                                    base.href = src;
                                    doc.head.insertBefore(base, doc.head.firstChild);
                                }

                                return doc;
                            };
                        }

                        function loadUrlDocument(src, proxy, document, width, height, options) {
                            return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {
                                return createWindowClone(doc, document, width, height, options, 0, 0);
                            });
                        }

                        exports.Proxy = Proxy;
                        exports.ProxyURL = ProxyURL;
                        exports.loadUrlDocument = loadUrlDocument;

                    }, {
                        "./clone": 2,
                        "./log": 13,
                        "./utils": 26,
                        "./xhr": 28
                    }],
                    17: [function(_dereq_, module, exports) {
                        var ProxyURL = _dereq_('./proxy').ProxyURL;

                        function ProxyImageContainer(src, proxy) {
                            var link = document.createElement("a");
                            link.href = src;
                            src = link.href;
                            this.src = src;
                            this.image = new Image();
                            var self = this;
                            this.promise = new Promise(function(resolve, reject) {
                                self.image.crossOrigin = "Anonymous";
                                self.image.onload = resolve;
                                self.image.onerror = reject;

                                new ProxyURL(src, proxy, document).then(function(url) {
                                    self.image.src = url;
                                })['catch'](reject);
                            });
                        }

                        module.exports = ProxyImageContainer;

                    }, {
                        "./proxy": 16
                    }],
                    18: [function(_dereq_, module, exports) {
                        var NodeContainer = _dereq_('./nodecontainer');

                        function PseudoElementContainer(node, parent, type) {
                            NodeContainer.call(this, node, parent);
                            this.isPseudoElement = true;
                            this.before = type === ":before";
                        }

                        PseudoElementContainer.prototype.cloneTo = function(stack) {
                            PseudoElementContainer.prototype.cloneTo.call(this, stack);
                            stack.isPseudoElement = true;
                            stack.before = this.before;
                        };

                        PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);

                        PseudoElementContainer.prototype.appendToDOM = function() {
                            if (this.before) {
                                this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
                            } else {
                                this.parent.node.appendChild(this.node);
                            }
                            this.parent.node.className += " " + this.getHideClass();
                        };

                        PseudoElementContainer.prototype.cleanDOM = function() {
                            this.node.parentNode.removeChild(this.node);
                            this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
                        };

                        PseudoElementContainer.prototype.getHideClass = function() {
                            return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
                        };

                        PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
                        PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

                        module.exports = PseudoElementContainer;

                    }, {
                        "./nodecontainer": 14
                    }],
                    19: [function(_dereq_, module, exports) {
                        var log = _dereq_('./log');

                        function Renderer(width, height, images, options, document) {
                            this.width = width;
                            this.height = height;
                            this.images = images;
                            this.options = options;
                            this.document = document;
                        }

                        Renderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {
                            var paddingLeft = container.cssInt('paddingLeft'),
                                paddingTop = container.cssInt('paddingTop'),
                                paddingRight = container.cssInt('paddingRight'),
                                paddingBottom = container.cssInt('paddingBottom'),
                                borders = borderData.borders;

                            var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
                            var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
                            this.drawImage(
                                imageContainer,
                                0,
                                0,
                                imageContainer.image.width || width,
                                imageContainer.image.height || height,
                                bounds.left + paddingLeft + borders[3].width,
                                bounds.top + paddingTop + borders[0].width,
                                width,
                                height
                            );
                        };

                        Renderer.prototype.renderBackground = function(container, bounds, borderData) {
                            if (bounds.height > 0 && bounds.width > 0) {
                                this.renderBackgroundColor(container, bounds);
                                this.renderBackgroundImage(container, bounds, borderData);
                            }
                        };

                        Renderer.prototype.renderBackgroundColor = function(container, bounds) {
                            var color = container.color("backgroundColor");
                            if (!color.isTransparent()) {
                                this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);
                            }
                        };

                        Renderer.prototype.renderBorders = function(borders) {
                            borders.forEach(this.renderBorder, this);
                        };

                        Renderer.prototype.renderBorder = function(data) {
                            if (!data.color.isTransparent() && data.args !== null) {
                                this.drawShape(data.args, data.color);
                            }
                        };

                        Renderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {
                            var backgroundImages = container.parseBackgroundImages();
                            backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {
                                switch (backgroundImage.method) {
                                    case "url":
                                        var image = this.images.get(backgroundImage.args[0]);
                                        if (image) {
                                            this.renderBackgroundRepeating(container, bounds, image, arr.length - (index + 1), borderData);
                                        } else {
                                            log("Error loading background-image", backgroundImage.args[0]);
                                        }
                                        break;
                                    case "linear-gradient":
                                    case "gradient":
                                        var gradientImage = this.images.get(backgroundImage.value);
                                        if (gradientImage) {
                                            this.renderBackgroundGradient(gradientImage, bounds, borderData);
                                        } else {
                                            log("Error loading background-image", backgroundImage.args[0]);
                                        }
                                        break;
                                    case "none":
                                        break;
                                    default:
                                        log("Unknown background-image type", backgroundImage.args[0]);
                                }
                            }, this);
                        };

                        Renderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {
                            var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
                            var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
                            var repeat = container.parseBackgroundRepeat(index);
                            switch (repeat) {
                                case "repeat-x":
                                case "repeat no-repeat":
                                    this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
                                    break;
                                case "repeat-y":
                                case "no-repeat repeat":
                                    this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
                                    break;
                                case "no-repeat":
                                    this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
                                    break;
                                default:
                                    this.renderBackgroundRepeat(imageContainer, position, size, {
                                        top: bounds.top,
                                        left: bounds.left
                                    }, borderData[3], borderData[0]);
                                    break;
                            }
                        };

                        module.exports = Renderer;

                    }, {
                        "./log": 13
                    }],
                    20: [function(_dereq_, module, exports) {
                        var Renderer = _dereq_('../renderer');
                        var LinearGradientContainer = _dereq_('../lineargradientcontainer');
                        var log = _dereq_('../log');

                        function CanvasRenderer(width, height) {
                            Renderer.apply(this, arguments);
                            this.canvas = this.options.canvas || this.document.createElement("canvas");
                            if (!this.options.canvas) {
                                this.canvas.width = width;
                                this.canvas.height = height;
                            }
                            this.ctx = this.canvas.getContext("2d");
                            this.taintCtx = this.document.createElement("canvas").getContext("2d");
                            this.ctx.textBaseline = "bottom";
                            this.variables = {};
                            log("Initialized CanvasRenderer with size", width, "x", height);
                        }

                        CanvasRenderer.prototype = Object.create(Renderer.prototype);

                        CanvasRenderer.prototype.setFillStyle = function(fillStyle) {
                            this.ctx.fillStyle = typeof(fillStyle) === "object" && !!fillStyle.isColor ? fillStyle.toString() : fillStyle;
                            return this.ctx;
                        };

                        CanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {
                            this.setFillStyle(color).fillRect(left, top, width, height);
                        };

                        CanvasRenderer.prototype.circle = function(left, top, size, color) {
                            this.setFillStyle(color);
                            this.ctx.beginPath();
                            this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI * 2, true);
                            this.ctx.closePath();
                            this.ctx.fill();
                        };

                        CanvasRenderer.prototype.circleStroke = function(left, top, size, color, stroke, strokeColor) {
                            this.circle(left, top, size, color);
                            this.ctx.strokeStyle = strokeColor.toString();
                            this.ctx.stroke();
                        };

                        CanvasRenderer.prototype.drawShape = function(shape, color) {
                            this.shape(shape);
                            this.setFillStyle(color).fill();
                        };

                        CanvasRenderer.prototype.taints = function(imageContainer) {
                            if (imageContainer.tainted === null) {
                                this.taintCtx.drawImage(imageContainer.image, 0, 0);
                                try {
                                    this.taintCtx.getImageData(0, 0, 1, 1);
                                    imageContainer.tainted = false;
                                } catch (e) {
                                    this.taintCtx = document.createElement("canvas").getContext("2d");
                                    imageContainer.tainted = true;
                                }
                            }

                            return imageContainer.tainted;
                        };

                        CanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
                            if (!this.taints(imageContainer) || this.options.allowTaint) {
                                this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
                            }
                        };

                        CanvasRenderer.prototype.clip = function(shapes, callback, context) {
                            this.ctx.save();
                            shapes.filter(hasEntries).forEach(function(shape) {
                                this.shape(shape).clip();
                            }, this);
                            callback.call(context);
                            this.ctx.restore();
                        };

                        CanvasRenderer.prototype.shape = function(shape) {
                            this.ctx.beginPath();
                            shape.forEach(function(point, index) {
                                if (point[0] === "rect") {
                                    this.ctx.rect.apply(this.ctx, point.slice(1));
                                } else {
                                    this.ctx[(index === 0) ? "moveTo" : point[0] + "To"].apply(this.ctx, point.slice(1));
                                }
                            }, this);
                            this.ctx.closePath();
                            return this.ctx;
                        };

                        CanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {
                            this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
                        };

                        CanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {
                            this.setVariable("shadowColor", color.toString())
                                .setVariable("shadowOffsetY", offsetX)
                                .setVariable("shadowOffsetX", offsetY)
                                .setVariable("shadowBlur", blur);
                        };

                        CanvasRenderer.prototype.clearShadow = function() {
                            this.setVariable("shadowColor", "rgba(0,0,0,0)");
                        };

                        CanvasRenderer.prototype.setOpacity = function(opacity) {
                            this.ctx.globalAlpha = opacity;
                        };

                        CanvasRenderer.prototype.setTransform = function(transform) {
                            this.ctx.translate(transform.origin[0], transform.origin[1]);
                            this.ctx.transform.apply(this.ctx, transform.matrix);
                            this.ctx.translate(-transform.origin[0], -transform.origin[1]);
                        };

                        CanvasRenderer.prototype.setVariable = function(property, value) {
                            if (this.variables[property] !== value) {
                                this.variables[property] = this.ctx[property] = value;
                            }

                            return this;
                        };

                        CanvasRenderer.prototype.text = function(text, left, bottom) {
                            this.ctx.fillText(text, left, bottom);
                        };

                        CanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
                            var shape = [
                                ["line", Math.round(left), Math.round(top)],
                                ["line", Math.round(left + width), Math.round(top)],
                                ["line", Math.round(left + width), Math.round(height + top)],
                                ["line", Math.round(left), Math.round(height + top)]
                            ];
                            this.clip([shape], function() {
                                this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
                            }, this);
                        };

                        CanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
                            var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft),
                                offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
                            this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
                            this.ctx.translate(offsetX, offsetY);
                            this.ctx.fill();
                            this.ctx.translate(-offsetX, -offsetY);
                        };

                        CanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {
                            if (gradientImage instanceof LinearGradientContainer) {
                                var gradient = this.ctx.createLinearGradient(
                                    bounds.left + bounds.width * gradientImage.x0,
                                    bounds.top + bounds.height * gradientImage.y0,
                                    bounds.left + bounds.width * gradientImage.x1,
                                    bounds.top + bounds.height * gradientImage.y1);
                                gradientImage.colorStops.forEach(function(colorStop) {
                                    gradient.addColorStop(colorStop.stop, colorStop.color.toString());
                                });
                                this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
                            }
                        };

                        CanvasRenderer.prototype.resizeImage = function(imageContainer, size) {
                            var image = imageContainer.image;
                            if (image.width === size.width && image.height === size.height) {
                                return image;
                            }

                            var ctx, canvas = document.createElement('canvas');
                            canvas.width = size.width;
                            canvas.height = size.height;
                            ctx = canvas.getContext("2d");
                            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height);
                            return canvas;
                        };

                        function hasEntries(array) {
                            return array.length > 0;
                        }

                        module.exports = CanvasRenderer;

                    }, {
                        "../lineargradientcontainer": 12,
                        "../log": 13,
                        "../renderer": 19
                    }],
                    21: [function(_dereq_, module, exports) {
                        var NodeContainer = _dereq_('./nodecontainer');

                        function StackingContext(hasOwnStacking, opacity, element, parent) {
                            NodeContainer.call(this, element, parent);
                            this.ownStacking = hasOwnStacking;
                            this.contexts = [];
                            this.children = [];
                            this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
                        }

                        StackingContext.prototype = Object.create(NodeContainer.prototype);

                        StackingContext.prototype.getParentStack = function(context) {
                            var parentStack = (this.parent) ? this.parent.stack : null;
                            return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;
                        };

                        module.exports = StackingContext;

                    }, {
                        "./nodecontainer": 14
                    }],
                    22: [function(_dereq_, module, exports) {
                        function Support(document) {
                            this.rangeBounds = this.testRangeBounds(document);
                            this.cors = this.testCORS();
                            this.svg = this.testSVG();
                        }

                        Support.prototype.testRangeBounds = function(document) {
                            var range, testElement, rangeBounds, rangeHeight, support = false;

                            if (document.createRange) {
                                range = document.createRange();
                                if (range.getBoundingClientRect) {
                                    testElement = document.createElement('boundtest');
                                    testElement.style.height = "123px";
                                    testElement.style.display = "block";
                                    document.body.appendChild(testElement);

                                    range.selectNode(testElement);
                                    rangeBounds = range.getBoundingClientRect();
                                    rangeHeight = rangeBounds.height;

                                    if (rangeHeight === 123) {
                                        support = true;
                                    }
                                    document.body.removeChild(testElement);
                                }
                            }

                            return support;
                        };

                        Support.prototype.testCORS = function() {
                            return typeof((new Image()).crossOrigin) !== "undefined";
                        };

                        Support.prototype.testSVG = function() {
                            var img = new Image();
                            var canvas = document.createElement("canvas");
                            var ctx = canvas.getContext("2d");
                            img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";

                            try {
                                ctx.drawImage(img, 0, 0);
                                canvas.toDataURL();
                            } catch (e) {
                                return false;
                            }
                            return true;
                        };

                        module.exports = Support;

                    }, {}],
                    23: [function(_dereq_, module, exports) {
                        var XHR = _dereq_('./xhr');
                        var decode64 = _dereq_('./utils').decode64;

                        function SVGContainer(src) {
                            this.src = src;
                            this.image = null;
                            var self = this;

                            this.promise = this.hasFabric().then(function() {
                                return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));
                            }).then(function(svg) {
                                return new Promise(function(resolve) {
                                    window.html2canvas.svg.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
                                });
                            });
                        }

                        SVGContainer.prototype.hasFabric = function() {
                            return !window.html2canvas.svg || !window.html2canvas.svg.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
                        };

                        SVGContainer.prototype.inlineFormatting = function(src) {
                            return (/^data:image\/svg\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);
                        };

                        SVGContainer.prototype.removeContentType = function(src) {
                            return src.replace(/^data:image\/svg\+xml(;base64)?,/, '');
                        };

                        SVGContainer.prototype.isInline = function(src) {
                            return (/^data:image\/svg\+xml/i.test(src));
                        };

                        SVGContainer.prototype.createCanvas = function(resolve) {
                            var self = this;
                            return function(objects, options) {
                                var canvas = new window.html2canvas.svg.fabric.StaticCanvas('c');
                                self.image = canvas.lowerCanvasEl;
                                canvas
                                    .setWidth(options.width)
                                    .setHeight(options.height)
                                    .add(window.html2canvas.svg.fabric.util.groupSVGElements(objects, options))
                                    .renderAll();
                                resolve(canvas.lowerCanvasEl);
                            };
                        };

                        SVGContainer.prototype.decode64 = function(str) {
                            return (typeof(window.atob) === "function") ? window.atob(str) : decode64(str);
                        };

                        module.exports = SVGContainer;

                    }, {
                        "./utils": 26,
                        "./xhr": 28
                    }],
                    24: [function(_dereq_, module, exports) {
                        var SVGContainer = _dereq_('./svgcontainer');

                        function SVGNodeContainer(node, _native) {
                            this.src = node;
                            this.image = null;
                            var self = this;

                            this.promise = _native ? new Promise(function(resolve, reject) {
                                self.image = new Image();
                                self.image.onload = resolve;
                                self.image.onerror = reject;
                                self.image.src = "data:image/svg+xml," + (new XMLSerializer()).serializeToString(node);
                                if (self.image.complete === true) {
                                    resolve(self.image);
                                }
                            }) : this.hasFabric().then(function() {
                                return new Promise(function(resolve) {
                                    window.html2canvas.svg.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
                                });
                            });
                        }

                        SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

                        module.exports = SVGNodeContainer;

                    }, {
                        "./svgcontainer": 23
                    }],
                    25: [function(_dereq_, module, exports) {
                        var NodeContainer = _dereq_('./nodecontainer');

                        function TextContainer(node, parent) {
                            NodeContainer.call(this, node, parent);
                        }

                        TextContainer.prototype = Object.create(NodeContainer.prototype);

                        TextContainer.prototype.applyTextTransform = function() {
                            this.node.data = this.transform(this.parent.css("textTransform"));
                        };

                        TextContainer.prototype.transform = function(transform) {
                            var text = this.node.data;
                            switch (transform) {
                                case "lowercase":
                                    return text.toLowerCase();
                                case "capitalize":
                                    return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
                                case "uppercase":
                                    return text.toUpperCase();
                                default:
                                    return text;
                            }
                        };

                        function capitalize(m, p1, p2) {
                            if (m.length > 0) {
                                return p1 + p2.toUpperCase();
                            }
                        }

                        module.exports = TextContainer;

                    }, {
                        "./nodecontainer": 14
                    }],
                    26: [function(_dereq_, module, exports) {
                        exports.smallImage = function smallImage() {
                            return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
                        };

                        exports.bind = function(callback, context) {
                            return function() {
                                return callback.apply(context, arguments);
                            };
                        };

                        /*
                         * base64-arraybuffer
                         * https://github.com/niklasvh/base64-arraybuffer
                         *
                         * Copyright (c) 2012 Niklas von Hertzen
                         * Licensed under the MIT license.
                         */

                        exports.decode64 = function(base64) {
                            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                            var len = base64.length,
                                i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;

                            var output = "";

                            for (i = 0; i < len; i += 4) {
                                encoded1 = chars.indexOf(base64[i]);
                                encoded2 = chars.indexOf(base64[i + 1]);
                                encoded3 = chars.indexOf(base64[i + 2]);
                                encoded4 = chars.indexOf(base64[i + 3]);

                                byte1 = (encoded1 << 2) | (encoded2 >> 4);
                                byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                                byte3 = ((encoded3 & 3) << 6) | encoded4;
                                if (encoded3 === 64) {
                                    output += String.fromCharCode(byte1);
                                } else if (encoded4 === 64 || encoded4 === -1) {
                                    output += String.fromCharCode(byte1, byte2);
                                } else {
                                    output += String.fromCharCode(byte1, byte2, byte3);
                                }
                            }

                            return output;
                        };

                        exports.getBounds = function(node) {
                            if (node.getBoundingClientRect) {
                                var clientRect = node.getBoundingClientRect();
                                var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
                                return {
                                    top: clientRect.top,
                                    bottom: clientRect.bottom || (clientRect.top + clientRect.height),
                                    right: clientRect.left + width,
                                    left: clientRect.left,
                                    width: width,
                                    height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
                                };
                            }
                            return {};
                        };

                        exports.offsetBounds = function(node) {
                            var parent = node.offsetParent ? exports.offsetBounds(node.offsetParent) : {
                                top: 0,
                                left: 0
                            };

                            return {
                                top: node.offsetTop + parent.top,
                                bottom: node.offsetTop + node.offsetHeight + parent.top,
                                right: node.offsetLeft + parent.left + node.offsetWidth,
                                left: node.offsetLeft + parent.left,
                                width: node.offsetWidth,
                                height: node.offsetHeight
                            };
                        };

                        exports.parseBackgrounds = function(backgroundImage) {
                            var whitespace = ' \r\n\t',
                                method, definition, prefix, prefix_i, block, results = [],
                                mode = 0,
                                numParen = 0,
                                quote, args;
                            var appendResult = function() {
                                if (method) {
                                    if (definition.substr(0, 1) === '"') {
                                        definition = definition.substr(1, definition.length - 2);
                                    }
                                    if (definition) {
                                        args.push(definition);
                                    }
                                    if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1) + 1) > 0) {
                                        prefix = method.substr(0, prefix_i);
                                        method = method.substr(prefix_i);
                                    }
                                    results.push({
                                        prefix: prefix,
                                        method: method.toLowerCase(),
                                        value: block,
                                        args: args,
                                        image: null
                                    });
                                }
                                args = [];
                                method = prefix = definition = block = '';
                            };
                            args = [];
                            method = prefix = definition = block = '';
                            backgroundImage.split("").forEach(function(c) {
                                if (mode === 0 && whitespace.indexOf(c) > -1) {
                                    return;
                                }
                                switch (c) {
                                    case '"':
                                        if (!quote) {
                                            quote = c;
                                        } else if (quote === c) {
                                            quote = null;
                                        }
                                        break;
                                    case '(':
                                        if (quote) {
                                            break;
                                        } else if (mode === 0) {
                                            mode = 1;
                                            block += c;
                                            return;
                                        } else {
                                            numParen++;
                                        }
                                        break;
                                    case ')':
                                        if (quote) {
                                            break;
                                        } else if (mode === 1) {
                                            if (numParen === 0) {
                                                mode = 0;
                                                block += c;
                                                appendResult();
                                                return;
                                            } else {
                                                numParen--;
                                            }
                                        }
                                        break;

                                    case ',':
                                        if (quote) {
                                            break;
                                        } else if (mode === 0) {
                                            appendResult();
                                            return;
                                        } else if (mode === 1) {
                                            if (numParen === 0 && !method.match(/^url$/i)) {
                                                args.push(definition);
                                                definition = '';
                                                block += c;
                                                return;
                                            }
                                        }
                                        break;
                                }

                                block += c;
                                if (mode === 0) {
                                    method += c;
                                } else {
                                    definition += c;
                                }
                            });

                            appendResult();
                            return results;
                        };

                    }, {}],
                    27: [function(_dereq_, module, exports) {
                        var GradientContainer = _dereq_('./gradientcontainer');

                        function WebkitGradientContainer(imageData) {
                            GradientContainer.apply(this, arguments);
                            this.type = imageData.args[0] === "linear" ? GradientContainer.TYPES.LINEAR : GradientContainer.TYPES.RADIAL;
                        }

                        WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

                        module.exports = WebkitGradientContainer;

                    }, {
                        "./gradientcontainer": 9
                    }],
                    28: [function(_dereq_, module, exports) {
                        function XHR(url) {
                            return new Promise(function(resolve, reject) {
                                var xhr = new XMLHttpRequest();
                                xhr.open('GET', url);

                                xhr.onload = function() {
                                    if (xhr.status === 200) {
                                        resolve(xhr.responseText);
                                    } else {
                                        reject(new Error(xhr.statusText));
                                    }
                                };

                                xhr.onerror = function() {
                                    reject(new Error("Network Error"));
                                };

                                xhr.send();
                            });
                        }

                        module.exports = XHR;

                    }, {}]
                }, {}, [4])(4)
            });
            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(4)))

        /***/
    }),
    /* 37 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__ffs_free__ = __webpack_require__(136);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__ffs_ffs_pegjs__ = __webpack_require__(152);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__ffs_ffs_pegjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__ffs_ffs_pegjs__);
        // ffs/wizard module



        var ffs = {};
        var freeFormQuery;

        /* this converts a random boolean expression into a normalized form:
         * AB  CD  
         * for example: A(BC)  (AB)(AC)
         */
        function normalize(query) {
            var normalized_query = {
                logical: "or",
                queries: []
            };

            function normalize_recursive(rem_query) {
                if (!rem_query.logical) {
                    return [{
                        logical: "and",
                        queries: [rem_query]
                    }];
                } else if (rem_query.logical === "and") {
                    var c1 = normalize_recursive(rem_query.queries[0]);
                    var c2 = normalize_recursive(rem_query.queries[1]);
                    // return cross product of c1 and c2
                    var c = [];
                    for (var i = 0; i < c1.length; i++)
                        for (var j = 0; j < c2.length; j++) {
                            c.push({
                                logical: "and",
                                queries: c1[i].queries.concat(c2[j].queries)
                            });
                        }
                    return c;
                } else if (rem_query.logical === "or") {
                    var c1 = normalize_recursive(rem_query.queries[0]);
                    var c2 = normalize_recursive(rem_query.queries[1]);
                    return [].concat(c1, c2);
                } else {
                    alert("unsupported boolean operator: " + rem_query.logical);
                }
            }
            normalized_query.queries = normalize_recursive(query);
            return normalized_query;
        }

        function escRegexp(str) {
            return str.replace(/([()[{*+.$^\\|?])/g, "\\$1");
        }

        ffs.construct_query = function(search, comment, callback) {
            function quote_comment_str(s) {
                // quote strings that are to be used within c-style comments
                // replace any comment-ending sequences in these strings that would break the resulting query
                return s.replace(/\*\//g, "[]").replace(/\n/g, "\\n");
            }

            try {
                ffs = __WEBPACK_IMPORTED_MODULE_1__ffs_ffs_pegjs___default.a.parse(search);
            } catch (e) {
                console.log("ffs parse error");
                return callback("ffs parse error");
            }

            var query_parts = [];
            var bounds_part;

            query_parts.push("/*");
            if (comment) {
                query_parts.push(comment);
            } else {
                query_parts.push("This has been generated by the overpass-turbo wizard.");
                query_parts.push("The original search was:");
                query_parts.push("" + quote_comment_str(search) + "");
            }
            query_parts.push("*/");
            query_parts.push("[out:json][timeout:25];");

            switch (ffs.bounds) {
                case "area":
                    query_parts.push("// fetch area " + ffs.area + " to search in");
                    query_parts.push("{{geocodeArea:" + ffs.area + "}}->.searchArea;");
                    bounds_part = "(area.searchArea)";
                    break;
                case "around":
                    query_parts.push("// adjust the search radius (in meters) here");
                    query_parts.push("{{radius=1000}}");
                    bounds_part = "(around:{{radius}},{{geocodeCoords:" + ffs.area + "}})";
                    break;
                case "bbox":
                    bounds_part = "({{bbox}})";
                    break;
                case "global":
                    bounds_part = undefined;
                    break;
                default:
                    alert("unknown bounds condition: " + ffs.bounds);
                    return false;
                    break;
            }

            function get_query_clause(condition) {
                function esc(str) {
                    if (typeof str !== "string") return;
                    // see http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#Escaping
                    return str
                        .replace(/\\/g, "\\\\")
                        .replace(/"/g, '\\"') // need to escape those
                        .replace(/\t/g, "\\t")
                        .replace(/\n/g, "\\n"); // also escape newlines an tabs for better readability of the query
                }
                var key = esc(condition.key);
                var val = esc(condition.val);
                // convert substring searches into matching regexp ones
                if (condition.query === "substr") {
                    condition.query = "like";
                    condition.val = {
                        regex: escRegexp(condition.val)
                    };
                }
                // special case for empty values
                // see https://github.com/drolbr/Overpass-API/issues/53
                if (val === "") {
                    if (condition.query === "eq") {
                        condition.query = "like";
                        condition.val = {
                            regex: "^$"
                        };
                    } else if (condition.query === "neq") {
                        condition.query = "notlike";
                        condition.val = {
                            regex: "^$"
                        };
                    }
                }
                // special case for empty keys
                // see https://github.com/drolbr/Overpass-API/issues/53#issuecomment-26325122
                if (key === "") {
                    if (condition.query === "key") {
                        condition.query = "likelike";
                        key = "^$";
                        condition.val = {
                            regex: ".*"
                        };
                    } else if (condition.query === "eq") {
                        condition.query = "likelike";
                        key = "^$";
                        condition.val = {
                            regex: "^" + escRegexp(condition.val) + "$"
                        };
                    } else if (condition.query === "like") {
                        condition.query = "likelike";
                        key = "^$";
                    }
                }
                // construct the query clause
                switch (condition.query) {
                    case "key":
                        return '["' + key + '"]';
                    case "nokey":
                        return '["' + key + '"!~".*"]';
                    case "eq":
                        return '["' + key + '"="' + val + '"]';
                    case "neq":
                        return '["' + key + '"!="' + val + '"]';
                    case "like":
                        return (
                            '["' +
                            key +
                            '"~"' +
                            esc(condition.val.regex) +
                            '"' +
                            (condition.val.modifier === "i" ? ",i" : "") +
                            "]"
                        );
                    case "likelike":
                        return (
                            '[~"' +
                            key +
                            '"~"' +
                            esc(condition.val.regex) +
                            '"' +
                            (condition.val.modifier === "i" ? ",i" : "") +
                            "]"
                        );
                    case "notlike":
                        return (
                            '["' +
                            key +
                            '"!~"' +
                            esc(condition.val.regex) +
                            '"' +
                            (condition.val.modifier === "i" ? ",i" : "") +
                            "]"
                        );
                    case "meta":
                        switch (condition.meta) {
                            case "id":
                                return "(" + val + ")";
                            case "newer":
                                if (
                                    condition.val.match(
                                        /^-?\d+ ?(seconds?|minutes?|hours?|days?|weeks?|months?|years?)?$/
                                    )
                                )
                                    return '(newer:"{{date:' + val + '}}")';
                                return '(newer:"' + val + '")';
                            case "user":
                                return '(user:"' + val + '")';
                            case "uid":
                                return "(uid:" + val + ")";
                            default:
                                console.log("unknown query type: meta/" + condition.meta);
                                return false;
                        }
                    case "free form":
                        // own module, special cased below
                    default:
                        console.log("unknown query type: " + condition.query);
                        return false;
                }
            }

            function get_query_clause_str(condition) {
                function quotes(s) {
                    if (s.match(/^[a-zA-Z0-9_]+$/) === null)
                        return '"' + s.replace(/"/g, '\\"') + '"';
                    return s;
                }

                function quoteRegex(s) {
                    if (s.regex.match(/^[a-zA-Z0-9_]+$/) === null || s.modifier)
                        return "/" + s.regex.replace(/\//g, "\\/") + "/" + (s.modifier || "");
                    return s.regex;
                }
                switch (condition.query) {
                    case "key":
                        return quote_comment_str(quotes(condition.key) + "=*");
                    case "nokey":
                        return quote_comment_str(quotes(condition.key) + "!=*");
                    case "eq":
                        return quote_comment_str(
                            quotes(condition.key) + "=" + quotes(condition.val)
                        );
                    case "neq":
                        return quote_comment_str(
                            quotes(condition.key) + "!=" + quotes(condition.val)
                        );
                    case "like":
                        return quote_comment_str(
                            quotes(condition.key) + "~" + quoteRegex(condition.val)
                        );
                    case "likelike":
                        return quote_comment_str(
                            "~" + quotes(condition.key) + "~" + quoteRegex(condition.val)
                        );
                    case "notlike":
                        return quote_comment_str(
                            quotes(condition.key) + "!~" + quoteRegex(condition.val)
                        );
                    case "substr":
                        return quote_comment_str(
                            quotes(condition.key) + ":" + quotes(condition.val)
                        );
                    case "meta":
                        switch (condition.meta) {
                            case "id":
                                return quote_comment_str("id:" + quotes(condition.val));
                            case "newer":
                                return quote_comment_str("newer:" + quotes(condition.val));
                            case "user":
                                return quote_comment_str("user:" + quotes(condition.val));
                            case "uid":
                                return quote_comment_str("uid:" + quotes(condition.val));
                            default:
                                return "";
                        }
                    case "free form":
                        return quote_comment_str(quotes(condition.free));
                    default:
                        return "";
                }
            }

            ffs.query = normalize(ffs.query);

            var freeForm = false;
            for (var i = 0; i < ffs.query.queries.length; i++) {
                var and_query = ffs.query.queries[i];
                for (var j = 0; j < and_query.queries.length; j++) {
                    var cond_query = and_query.queries[j];
                    if (cond_query.query === "free form") {
                        freeForm = true;
                        break;
                    }
                }
            }

            // if we have a "free form" query part, need to load it before first use:
            (freeForm ?
                __WEBPACK_IMPORTED_MODULE_0__ffs_free__["a" /* default */ ] :
                function(x) {
                    x(null);
                })(function(freeFormQuery) {
                query_parts.push("// gather results");
                query_parts.push("(");
                for (var i = 0; i < ffs.query.queries.length; i++) {
                    var and_query = ffs.query.queries[i];

                    var types = ["node", "way", "relation"];
                    var clauses = [];
                    var clauses_str = [];
                    for (var j = 0; j < and_query.queries.length; j++) {
                        var cond_query = and_query.queries[j];
                        // todo: looks like some code duplication here could be reduced by refactoring
                        if (cond_query.query === "free form") {
                            var ffs_clause = freeFormQuery.get_query_clause(cond_query);
                            if (ffs_clause === false) return callback("unknown ffs string");
                            // restrict possible data types
                            types = types.filter(function(t) {
                                return ffs_clause.types.indexOf(t) != -1;
                            });
                            // add clauses
                            clauses_str.push(get_query_clause_str(cond_query));
                            clauses = clauses.concat(
                                ffs_clause.conditions.map(function(condition) {
                                    return get_query_clause(condition);
                                })
                            );
                        } else if (cond_query.query === "type") {
                            // restrict possible data types
                            types = types.indexOf(cond_query.type) != -1 ? [cond_query.type] : [];
                        } else {
                            // add another query clause
                            clauses_str.push(get_query_clause_str(cond_query));
                            var clause = get_query_clause(cond_query);
                            if (clause === false) return false;
                            clauses.push(clause);
                        }
                    }
                    clauses_str = clauses_str.join(" and ");

                    // construct query
                    query_parts.push("  // query part for: " + clauses_str + "");
                    for (var t = 0; t < types.length; t++) {
                        var buffer = "  " + types[t];
                        for (var c = 0; c < clauses.length; c++) buffer += clauses[c];
                        if (bounds_part) buffer += bounds_part;
                        buffer += ";";
                        query_parts.push(buffer);
                    }
                }
                query_parts.push(");");

                query_parts.push("// print results");
                query_parts.push("out body;");
                query_parts.push(">;");
                query_parts.push("out skel qt;");

                callback(null, query_parts.join("\n"));
            });
        };

        // this is a "did you mean " mechanism against typos in preset names
        ffs.repair_search = function(search, callback) {
            try {
                ffs = __WEBPACK_IMPORTED_MODULE_1__ffs_ffs_pegjs___default.a.parse(search);
            } catch (e) {
                return callback(false);
            }

            function quotes(s) {
                if (s.match(/^[a-zA-Z0-9_]+$/) === null)
                    return '"' + s.replace(/"/g, '\\"') + '"';
                return s;
            }

            var search_parts = [];
            var repaired = false;

            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__ffs_free__["a" /* default */ ])(function(freeFormQuery) {
                ffs.query = normalize(ffs.query);
                ffs.query.queries.forEach(function(q) {
                    q.queries.forEach(validateQuery);
                });

                function validateQuery(cond_query) {
                    if (cond_query.query === "free form") {
                        var ffs_clause = freeFormQuery.get_query_clause(cond_query);
                        if (ffs_clause === false) {
                            // try to find suggestions for occasional typos
                            var fuzzy = freeFormQuery.fuzzy_search(cond_query);
                            var free_regex = null;
                            try {
                                free_regex = new RegExp(
                                    "['\"]?" + escRegexp(cond_query.free) + "['\"]?"
                                );
                            } catch (e) {}
                            if (fuzzy && search.match(free_regex)) {
                                search_parts = search_parts.concat(search.split(free_regex));
                                search = search_parts.pop();
                                var replacement = quotes(fuzzy);
                                search_parts.push(replacement);
                                repaired = true;
                            }
                        }
                    }
                }
                search_parts.push(search);

                if (!repaired) callback(false);
                else callback(search_parts);
            });
        };

        ffs.invalidateCache = function() {
            freeFormQuery = undefined;
        };

        /* harmony default export */
        __webpack_exports__["a"] = (ffs);


        /***/
    }),
    /* 38 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(2);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(6);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2__promise_polyfill__ = __webpack_require__(23);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3__settings__ = __webpack_require__(8);
        // global i18n object




        var i18n = new function() {
            function browser_locale() {
                /* taken from https://github.com/maxogden/browser-locale by Max Ogden, BSD licensed */
                var lang;

                if (navigator.languages) {
                    // chrome does not currently set navigator.language correctly https://code.google.com/p/chromium/issues/detail?id=101138
                    // but it does set the first element of navigator.languages correctly
                    lang = navigator.languages[0];
                } else if (navigator.userLanguage) {
                    // IE only
                    lang = navigator.userLanguage;
                } else {
                    // as of this writing the latest version of firefox + safari set this correctly
                    lang = navigator.language;
                }

                return lang;
            }

            var default_lng = "en";
            var languages = {
                // translations found in locale/*.json
                en: "English",
                ca: "Catalan",
                da: "Danish",
                eo: "Esperanto",
                de: "German",
                el: "Greek",
                es: "Spanish",
                et: "Estonian",
                fr: "French",
                hr: "Croatian",
                hu: "Hungarian",
                it: "Italian",
                ja: "Japanese",
                nl: "Dutch",
                no: "Norwegian",
                pl: "Polish",
                pt: "Portuguese",
                "pt-BR": "Portuguese (Brazil)",
                ru: "Russian",
                sl: "Slovenian",
                uk: "Ukrainian",
                vi: "Vietnamese",
                "zh-TW": "Chinese (Taiwan)"
            };
            var supported_lngs = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.keys(languages);
            this.getSupportedLanguages = function() {
                return supported_lngs;
            };
            this.getSupportedLanguagesDescriptions = function() {
                return languages;
            };
            this.getLanguage = function(lng) {
                lng = lng || __WEBPACK_IMPORTED_MODULE_3__settings__["a" /* default */ ].ui_language;
                if (lng == "auto") {
                    // get user agent's language
                    try {
                        lng = browser_locale().toLowerCase();
                    } catch (e) {}
                    // hardcode some language fallbacks
                    if (lng === "nb") lng = "no"; // Norwegian Bokml
                    // sanitize inconsistent use of lower and upper case spelling
                    var parts;
                    if ((parts = lng.match(/(.*)-(.*)/)))
                        lng = parts[1] + "-" + parts[2].toUpperCase();
                    // fall back to generic language file if no country-specific i18n is found
                    if (__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.inArray(lng, supported_lngs) == -1) lng = lng.replace(/-.*/, "");
                }
                return lng;
            };

            /**
             * Determines the language, fetches the language pack and translates the UI
             * @return <Promise>
             */
            this.translate = function(lng) {
                lng = i18n.getLanguage(lng);

                if (__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.inArray(lng, supported_lngs) == -1) {
                    console.log(
                        "unsupported language: " + lng + " switching back to: " + default_lng
                    );
                    lng = default_lng;
                }

                // load language pack
                try {
                    return __webpack_require__(142)("./" + lng + ".json").then(
                        function(data) {
                            td = data;
                            i18n.translate_ui();
                            // todo: nicer implementation
                            return data;
                        },
                        function(e) {
                            console.log("failed to load language file " + lng, e);
                        }
                    );
                } catch (e) {
                    console.log("failed to load language file " + lng, e);
                }
            };
            this.translate_ui = function(element) {
                // if a DOM object is provided, only translate that one, otherwise
                // look for all object with the class "t"
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element || ".t").each(function(nr, element) {
                    // get translation term(s)
                    var terms = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element).attr("data-t");
                    terms = terms.split(";");
                    for (var i = 0; i < terms.length; i++) {
                        var term = terms[i];
                        var tmp = term.match(/^(\[(.*)\])?(.*)$/);
                        var what = tmp[2];
                        var key = tmp[3];
                        var val = i18n.t(key);
                        if (what === "html") {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element).html(val);
                        } else if (what !== undefined) {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element).attr(what, val);
                        } else {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element).text(val);
                        }
                    }
                });
            };
            this.t = function(key) {
                return td[key] || "/missing translation/";
            };

            // translated texts
            var td = {};
        }(); // end create i18n object

        /* harmony default export */
        __webpack_exports__["a"] = (i18n);


        /***/
    }),
    /* 39 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : afrikaans (af)
        // author : Werner Mollentze : https://github.com/wernerm

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('af', {
                months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
                weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
                weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
                weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
                meridiem: function(hours, minutes, isLower) {
                    if (hours < 12) {
                        return isLower ? 'vm' : 'VM';
                    } else {
                        return isLower ? 'nm' : 'NM';
                    }
                },
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Vandag om] LT',
                    nextDay: '[Mre om] LT',
                    nextWeek: 'dddd [om] LT',
                    lastDay: '[Gister om] LT',
                    lastWeek: '[Laas] dddd [om] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'oor %s',
                    past: '%s gelede',
                    s: '\'n paar sekondes',
                    m: '\'n minuut',
                    mm: '%d minute',
                    h: '\'n uur',
                    hh: '%d ure',
                    d: '\'n dag',
                    dd: '%d dae',
                    M: '\'n maand',
                    MM: '%d maande',
                    y: '\'n jaar',
                    yy: '%d jaar'
                },
                ordinal: function(number) {
                    return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
                },
                week: {
                    dow: 1, // Maandag is die eerste dag van die week.
                    doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
                }
            });
        }));


        /***/
    }),
    /* 40 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Moroccan Arabic (ar-ma)
        // author : ElFadili Yassine : https://github.com/ElFadiliY
        // author : Abdel Said : https://github.com/abdelsaid

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('ar-ma', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 41 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Arabic Saudi Arabia (ar-sa)
        // author : Suhail Alkowaileet : https://github.com/xsoh

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                };

            return moment.defineLocale('ar-sa', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                preparse: function(string) {
                    return string.replace(/[-]/g, function(match) {
                        return numberMap[match];
                    }).replace(//g, ',');
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    }).replace(/,/g, '');
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 42 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // Locale: Arabic (ar)
        // Author: Abdel Said: https://github.com/abdelsaid
        // Changes in months, weekdays: Ahmed Elkhatib
        // Native plural forms: forabi https://github.com/forabi

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                },
                pluralForm = function(n) {
                    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
                },
                plurals = {
                    s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                    m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                    h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                    d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                    M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                    y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
                },
                pluralize = function(u) {
                    return function(number, withoutSuffix, string, isFuture) {
                        var f = pluralForm(number),
                            str = plurals[u][pluralForm(number)];
                        if (f === 2) {
                            str = str[withoutSuffix ? 0 : 1];
                        }
                        return str.replace(/%d/i, number);
                    };
                },
                months = [
                    '  ',
                    ' ',
                    ' ',
                    ' ',
                    ' ',
                    ' ',
                    ' ',
                    ' ',
                    ' ',
                    '  ',
                    '  ',
                    '  '
                ];

            return moment.defineLocale('ar', {
                months: months,
                monthsShort: months,
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: pluralize('s'),
                    m: pluralize('m'),
                    mm: pluralize('m'),
                    h: pluralize('h'),
                    hh: pluralize('h'),
                    d: pluralize('d'),
                    dd: pluralize('d'),
                    M: pluralize('M'),
                    MM: pluralize('M'),
                    y: pluralize('y'),
                    yy: pluralize('y')
                },
                preparse: function(string) {
                    return string.replace(/[-]/g, function(match) {
                        return numberMap[match];
                    }).replace(//g, ',');
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    }).replace(/,/g, '');
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 43 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : azerbaijani (az)
        // author : topchiyev : https://github.com/topchiyev

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var suffixes = {
                1: '-inci',
                5: '-inci',
                8: '-inci',
                70: '-inci',
                80: '-inci',

                2: '-nci',
                7: '-nci',
                20: '-nci',
                50: '-nci',

                3: '-nc',
                4: '-nc',
                100: '-nc',

                6: '-nc',

                9: '-uncu',
                10: '-uncu',
                30: '-uncu',

                60: '-nc',
                90: '-nc'
            };
            return moment.defineLocale('az', {
                months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
                monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
                weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
                weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
                weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[bugn saat] LT',
                    nextDay: '[sabah saat] LT',
                    nextWeek: '[gln hft] dddd [saat] LT',
                    lastDay: '[dnn] LT',
                    lastWeek: '[ken hft] dddd [saat] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s sonra',
                    past: '%s vvl',
                    s: 'birne saniyy',
                    m: 'bir dqiq',
                    mm: '%d dqiq',
                    h: 'bir saat',
                    hh: '%d saat',
                    d: 'bir gn',
                    dd: '%d gn',
                    M: 'bir ay',
                    MM: '%d ay',
                    y: 'bir il',
                    yy: '%d il'
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return 'gec';
                    } else if (hour < 12) {
                        return 'shr';
                    } else if (hour < 17) {
                        return 'gndz';
                    } else {
                        return 'axam';
                    }
                },
                ordinal: function(number) {
                    if (number === 0) { // special case for zero
                        return number + '-nc';
                    }
                    var a = number % 10,
                        b = number % 100 - a,
                        c = number >= 100 ? 100 : null;

                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 44 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : belarusian (be)
        // author : Dmitry Demidov : https://github.com/demidov91
        // author: Praleska: http://praleska.pro/
        // Author : Menelion Elensle : https://github.com/Oire

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function plural(word, num) {
                var forms = word.split('_');
                return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
            }

            function relativeTimeWithPlural(number, withoutSuffix, key) {
                var format = {
                    'mm': withoutSuffix ? '__' : '__',
                    'hh': withoutSuffix ? '__' : '__',
                    'dd': '__',
                    'MM': '__',
                    'yy': '__'
                };
                if (key === 'm') {
                    return withoutSuffix ? '' : '';
                } else if (key === 'h') {
                    return withoutSuffix ? '' : '';
                } else {
                    return number + ' ' + plural(format[key], +number);
                }
            }

            function monthsCaseReplace(m, format) {
                var months = {
                        'nominative': '___________'.split('_'),
                        'accusative': '___________'.split('_')
                    },

                    nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
                    'accusative' :
                    'nominative';

                return months[nounCase][m.month()];
            }

            function weekdaysCaseReplace(m, format) {
                var weekdays = {
                        'nominative': '______'.split('_'),
                        'accusative': '______'.split('_')
                    },

                    nounCase = (/\[ ?[] ?(?:|)? ?\] ?dddd/).test(format) ?
                    'accusative' :
                    'nominative';

                return weekdays[nounCase][m.day()];
            }

            return moment.defineLocale('be', {
                months: monthsCaseReplace,
                monthsShort: '___________'.split('_'),
                weekdays: weekdaysCaseReplace,
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY .',
                    LLL: 'D MMMM YYYY ., LT',
                    LLLL: 'dddd, D MMMM YYYY ., LT'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    lastDay: '[ ] LT',
                    nextWeek: function() {
                        return '[] dddd [] LT';
                    },
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 5:
                            case 6:
                                return '[ ] dddd [] LT';
                            case 1:
                            case 2:
                            case 4:
                                return '[ ] dddd [] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: relativeTimeWithPlural,
                    mm: relativeTimeWithPlural,
                    h: relativeTimeWithPlural,
                    hh: relativeTimeWithPlural,
                    d: '',
                    dd: relativeTimeWithPlural,
                    M: '',
                    MM: relativeTimeWithPlural,
                    y: '',
                    yy: relativeTimeWithPlural
                },


                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else {
                        return '';
                    }
                },

                ordinal: function(number, period) {
                    switch (period) {
                        case 'M':
                        case 'd':
                        case 'DDD':
                        case 'w':
                        case 'W':
                            return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
                        case 'D':
                            return number + '-';
                        default:
                            return number;
                    }
                },

                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 45 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : bulgarian (bg)
        // author : Krasen Borisov : https://github.com/kraz

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('bg', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'D.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 6:
                                return '[ ] dddd [] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[ ] dddd [] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: ' ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                ordinal: function(number) {
                    var lastDigit = number % 10,
                        last2Digits = number % 100;
                    if (number === 0) {
                        return number + '-';
                    } else if (last2Digits === 0) {
                        return number + '-';
                    } else if (last2Digits > 10 && last2Digits < 20) {
                        return number + '-';
                    } else if (lastDigit === 1) {
                        return number + '-';
                    } else if (lastDigit === 2) {
                        return number + '-';
                    } else if (lastDigit === 7 || lastDigit === 8) {
                        return number + '-';
                    } else {
                        return number + '-';
                    }
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 46 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Bengali (bn)
        // author : Kaushik Gandhi : https://github.com/kaushikgandhi

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                };

            return moment.defineLocale('bn', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, LT',
                    LLLL: 'dddd, D MMMM YYYY, LT'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                preparse: function(string) {
                    return string.replace(/[]/g, function(match) {
                        return numberMap[match];
                    });
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    });
                },
                //Bengali is a vast language its spoken
                //in different forms in various parts of the world.
                //I have just generalized with most common one used
                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 47 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : tibetan (bo)
        // author : Thupten N. Chakrishar : https://github.com/vajradog

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                };

            return moment.defineLocale('bo', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, LT',
                    LLLL: 'dddd, D MMMM YYYY, LT'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: '[], LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                preparse: function(string) {
                    return string.replace(/[]/g, function(match) {
                        return numberMap[match];
                    });
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    });
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 48 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : breton (br)
        // author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function relativeTimeWithMutation(number, withoutSuffix, key) {
                var format = {
                    'mm': 'munutenn',
                    'MM': 'miz',
                    'dd': 'devezh'
                };
                return number + ' ' + mutation(format[key], number);
            }

            function specialMutationForYears(number) {
                switch (lastNumber(number)) {
                    case 1:
                    case 3:
                    case 4:
                    case 5:
                    case 9:
                        return number + ' bloaz';
                    default:
                        return number + ' vloaz';
                }
            }

            function lastNumber(number) {
                if (number > 9) {
                    return lastNumber(number % 10);
                }
                return number;
            }

            function mutation(text, number) {
                if (number === 2) {
                    return softMutation(text);
                }
                return text;
            }

            function softMutation(text) {
                var mutationTable = {
                    'm': 'v',
                    'b': 'v',
                    'd': 'z'
                };
                if (mutationTable[text.charAt(0)] === undefined) {
                    return text;
                }
                return mutationTable[text.charAt(0)] + text.substring(1);
            }

            return moment.defineLocale('br', {
                months: 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
                monthsShort: 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
                weekdays: 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
                weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
                weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
                longDateFormat: {
                    LT: 'h[e]mm A',
                    L: 'DD/MM/YYYY',
                    LL: 'D [a viz] MMMM YYYY',
                    LLL: 'D [a viz] MMMM YYYY LT',
                    LLLL: 'dddd, D [a viz] MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Hiziv da] LT',
                    nextDay: '[Warc\'hoazh da] LT',
                    nextWeek: 'dddd [da] LT',
                    lastDay: '[Dec\'h da] LT',
                    lastWeek: 'dddd [paset da] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'a-benn %s',
                    past: '%s \'zo',
                    s: 'un nebeud segondenno',
                    m: 'ur vunutenn',
                    mm: relativeTimeWithMutation,
                    h: 'un eur',
                    hh: '%d eur',
                    d: 'un devezh',
                    dd: relativeTimeWithMutation,
                    M: 'ur miz',
                    MM: relativeTimeWithMutation,
                    y: 'ur bloaz',
                    yy: specialMutationForYears
                },
                ordinal: function(number) {
                    var output = (number === 1) ? 'a' : 'vet';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 49 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : bosnian (bs)
        // author : Nedim Cholich : https://github.com/frontyard
        // based on (hr) translation by Bojan Markovi

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function translate(number, withoutSuffix, key) {
                var result = number + ' ';
                switch (key) {
                    case 'm':
                        return withoutSuffix ? 'jedna minuta' : 'jedne minute';
                    case 'mm':
                        if (number === 1) {
                            result += 'minuta';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'minute';
                        } else {
                            result += 'minuta';
                        }
                        return result;
                    case 'h':
                        return withoutSuffix ? 'jedan sat' : 'jednog sata';
                    case 'hh':
                        if (number === 1) {
                            result += 'sat';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'sata';
                        } else {
                            result += 'sati';
                        }
                        return result;
                    case 'dd':
                        if (number === 1) {
                            result += 'dan';
                        } else {
                            result += 'dana';
                        }
                        return result;
                    case 'MM':
                        if (number === 1) {
                            result += 'mjesec';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'mjeseca';
                        } else {
                            result += 'mjeseci';
                        }
                        return result;
                    case 'yy':
                        if (number === 1) {
                            result += 'godina';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'godine';
                        } else {
                            result += 'godina';
                        }
                        return result;
                }
            }

            return moment.defineLocale('bs', {
                months: 'januar_februar_mart_april_maj_juni_juli_avgust_septembar_oktobar_novembar_decembar'.split('_'),
                monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
                weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
                weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
                weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD. MM. YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[danas u] LT',
                    nextDay: '[sutra u] LT',

                    nextWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[u] [nedjelju] [u] LT';
                            case 3:
                                return '[u] [srijedu] [u] LT';
                            case 6:
                                return '[u] [subotu] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[u] dddd [u] LT';
                        }
                    },
                    lastDay: '[juer u] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                            case 3:
                                return '[prolu] dddd [u] LT';
                            case 6:
                                return '[prole] [subote] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[proli] dddd [u] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'prije %s',
                    s: 'par sekundi',
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: 'dan',
                    dd: translate,
                    M: 'mjesec',
                    MM: translate,
                    y: 'godinu',
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 50 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : catalan (ca)
        // author : Juan G. Hurtado : https://github.com/juanghurtado

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('ca', {
                months: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
                monthsShort: 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
                weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
                weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
                weekdaysMin: 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: function() {
                        return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    nextDay: function() {
                        return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    nextWeek: function() {
                        return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    lastDay: function() {
                        return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    lastWeek: function() {
                        return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'en %s',
                    past: 'fa %s',
                    s: 'uns segons',
                    m: 'un minut',
                    mm: '%d minuts',
                    h: 'una hora',
                    hh: '%d hores',
                    d: 'un dia',
                    dd: '%d dies',
                    M: 'un mes',
                    MM: '%d mesos',
                    y: 'un any',
                    yy: '%d anys'
                },
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 51 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : czech (cs)
        // author : petrbela : https://github.com/petrbela

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
                monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');

            function plural(n) {
                return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
            }

            function translate(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                switch (key) {
                    case 's': // a few seconds / in a few seconds / a few seconds ago
                        return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
                    case 'm': // a minute / in a minute / a minute ago
                        return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
                    case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'minuty' : 'minut');
                        } else {
                            return result + 'minutami';
                        }
                        break;
                    case 'h': // an hour / in an hour / an hour ago
                        return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
                    case 'hh': // 9 hours / in 9 hours / 9 hours ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'hodiny' : 'hodin');
                        } else {
                            return result + 'hodinami';
                        }
                        break;
                    case 'd': // a day / in a day / a day ago
                        return (withoutSuffix || isFuture) ? 'den' : 'dnem';
                    case 'dd': // 9 days / in 9 days / 9 days ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'dny' : 'dn');
                        } else {
                            return result + 'dny';
                        }
                        break;
                    case 'M': // a month / in a month / a month ago
                        return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
                    case 'MM': // 9 months / in 9 months / 9 months ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'msce' : 'msc');
                        } else {
                            return result + 'msci';
                        }
                        break;
                    case 'y': // a year / in a year / a year ago
                        return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
                    case 'yy': // 9 years / in 9 years / 9 years ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'roky' : 'let');
                        } else {
                            return result + 'lety';
                        }
                        break;
                }
            }

            return moment.defineLocale('cs', {
                months: months,
                monthsShort: monthsShort,
                monthsParse: (function(months, monthsShort) {
                    var i, _monthsParse = [];
                    for (i = 0; i < 12; i++) {
                        // use custom parser to solve problem with July (ervenec)
                        _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
                    }
                    return _monthsParse;
                }(months, monthsShort)),
                weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
                weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
                weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[dnes v] LT',
                    nextDay: '[ztra v] LT',
                    nextWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[v nedli v] LT';
                            case 1:
                            case 2:
                                return '[v] dddd [v] LT';
                            case 3:
                                return '[ve stedu v] LT';
                            case 4:
                                return '[ve tvrtek v] LT';
                            case 5:
                                return '[v ptek v] LT';
                            case 6:
                                return '[v sobotu v] LT';
                        }
                    },
                    lastDay: '[vera v] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[minulou nedli v] LT';
                            case 1:
                            case 2:
                                return '[minul] dddd [v] LT';
                            case 3:
                                return '[minulou stedu v] LT';
                            case 4:
                            case 5:
                                return '[minul] dddd [v] LT';
                            case 6:
                                return '[minulou sobotu v] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'ped %s',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 52 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : chuvash (cv)
        // author : Anatoly Mironov : https://github.com/mirontoli

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('cv', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD-MM-YYYY',
                    LL: 'YYYY [] MMMM [] D[-]',
                    LLL: 'YYYY [] MMMM [] D[-], LT',
                    LLLL: 'dddd, YYYY [] MMMM [] D[-], LT'
                },
                calendar: {
                    sameDay: '[] LT []',
                    nextDay: '[] LT []',
                    lastDay: '[] LT []',
                    nextWeek: '[] dddd LT []',
                    lastWeek: '[] dddd LT []',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: function(output) {
                        var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
                        return output + affix;
                    },
                    past: '%s ',
                    s: '- ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                ordinal: '%d-',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 53 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Welsh (cy)
        // author : Robert Allen

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('cy', {
                months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
                monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
                weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
                weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
                weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
                // time formats are the same as en-gb
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Heddiw am] LT',
                    nextDay: '[Yfory am] LT',
                    nextWeek: 'dddd [am] LT',
                    lastDay: '[Ddoe am] LT',
                    lastWeek: 'dddd [diwethaf am] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'mewn %s',
                    past: '%s yn l',
                    s: 'ychydig eiliadau',
                    m: 'munud',
                    mm: '%d munud',
                    h: 'awr',
                    hh: '%d awr',
                    d: 'diwrnod',
                    dd: '%d diwrnod',
                    M: 'mis',
                    MM: '%d mis',
                    y: 'blwyddyn',
                    yy: '%d flynedd'
                },
                // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
                ordinal: function(number) {
                    var b = number,
                        output = '',
                        lookup = [
                            '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                            'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                        ];

                    if (b > 20) {
                        if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                            output = 'fed'; // not 30ain, 70ain or 90ain
                        } else {
                            output = 'ain';
                        }
                    } else if (b > 0) {
                        output = lookup[b];
                    }

                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 54 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : danish (da)
        // author : Ulrik Nielsen : https://github.com/mrbase

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('da', {
                months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
                monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
                weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
                weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
                weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd [d.] D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[I dag kl.] LT',
                    nextDay: '[I morgen kl.] LT',
                    nextWeek: 'dddd [kl.] LT',
                    lastDay: '[I gr kl.] LT',
                    lastWeek: '[sidste] dddd [kl] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'om %s',
                    past: '%s siden',
                    s: 'f sekunder',
                    m: 'et minut',
                    mm: '%d minutter',
                    h: 'en time',
                    hh: '%d timer',
                    d: 'en dag',
                    dd: '%d dage',
                    M: 'en mned',
                    MM: '%d mneder',
                    y: 'et r',
                    yy: '%d r'
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 55 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : austrian german (de-at)
        // author : lluchs : https://github.com/lluchs
        // author: Menelion Elensle: https://github.com/Oire
        // author : Martin Groller : https://github.com/MadMG

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    'm': ['eine Minute', 'einer Minute'],
                    'h': ['eine Stunde', 'einer Stunde'],
                    'd': ['ein Tag', 'einem Tag'],
                    'dd': [number + ' Tage', number + ' Tagen'],
                    'M': ['ein Monat', 'einem Monat'],
                    'MM': [number + ' Monate', number + ' Monaten'],
                    'y': ['ein Jahr', 'einem Jahr'],
                    'yy': [number + ' Jahre', number + ' Jahren']
                };
                return withoutSuffix ? format[key][0] : format[key][1];
            }

            return moment.defineLocale('de-at', {
                months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
                monthsShort: 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
                weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
                weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
                weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm [Uhr]',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Heute um] LT',
                    sameElse: 'L',
                    nextDay: '[Morgen um] LT',
                    nextWeek: 'dddd [um] LT',
                    lastDay: '[Gestern um] LT',
                    lastWeek: '[letzten] dddd [um] LT'
                },
                relativeTime: {
                    future: 'in %s',
                    past: 'vor %s',
                    s: 'ein paar Sekunden',
                    m: processRelativeTime,
                    mm: '%d Minuten',
                    h: processRelativeTime,
                    hh: '%d Stunden',
                    d: processRelativeTime,
                    dd: processRelativeTime,
                    M: processRelativeTime,
                    MM: processRelativeTime,
                    y: processRelativeTime,
                    yy: processRelativeTime
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 56 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : german (de)
        // author : lluchs : https://github.com/lluchs
        // author: Menelion Elensle: https://github.com/Oire

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    'm': ['eine Minute', 'einer Minute'],
                    'h': ['eine Stunde', 'einer Stunde'],
                    'd': ['ein Tag', 'einem Tag'],
                    'dd': [number + ' Tage', number + ' Tagen'],
                    'M': ['ein Monat', 'einem Monat'],
                    'MM': [number + ' Monate', number + ' Monaten'],
                    'y': ['ein Jahr', 'einem Jahr'],
                    'yy': [number + ' Jahre', number + ' Jahren']
                };
                return withoutSuffix ? format[key][0] : format[key][1];
            }

            return moment.defineLocale('de', {
                months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
                monthsShort: 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
                weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
                weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
                weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm [Uhr]',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Heute um] LT',
                    sameElse: 'L',
                    nextDay: '[Morgen um] LT',
                    nextWeek: 'dddd [um] LT',
                    lastDay: '[Gestern um] LT',
                    lastWeek: '[letzten] dddd [um] LT'
                },
                relativeTime: {
                    future: 'in %s',
                    past: 'vor %s',
                    s: 'ein paar Sekunden',
                    m: processRelativeTime,
                    mm: '%d Minuten',
                    h: processRelativeTime,
                    hh: '%d Stunden',
                    d: processRelativeTime,
                    dd: processRelativeTime,
                    M: processRelativeTime,
                    MM: processRelativeTime,
                    y: processRelativeTime,
                    yy: processRelativeTime
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 57 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : modern greek (el)
        // author : Aggelos Karalias : https://github.com/mehiel

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('el', {
                monthsNominativeEl: '___________'.split('_'),
                monthsGenitiveEl: '___________'.split('_'),
                months: function(momentToFormat, format) {
                    if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                        return this._monthsGenitiveEl[momentToFormat.month()];
                    } else {
                        return this._monthsNominativeEl[momentToFormat.month()];
                    }
                },
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                meridiem: function(hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? '' : '';
                    } else {
                        return isLower ? '' : '';
                    }
                },
                isPM: function(input) {
                    return ((input + '').toLowerCase()[0] === '');
                },
                meridiemParse: /[]\.??\.?/i,
                longDateFormat: {
                    LT: 'h:mm A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendarEl: {
                    sameDay: '[ {}] LT',
                    nextDay: '[ {}] LT',
                    nextWeek: 'dddd [{}] LT',
                    lastDay: '[ {}] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 6:
                                return '[ ] dddd [{}] LT';
                            default:
                                return '[ ] dddd [{}] LT';
                        }
                    },
                    sameElse: 'L'
                },
                calendar: function(key, mom) {
                    var output = this._calendarEl[key],
                        hours = mom && mom.hours();

                    if (typeof output === 'function') {
                        output = output.apply(mom);
                    }

                    return output.replace('{}', (hours % 12 === 1 ? '' : ''));
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: '',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                ordinal: function(number) {
                    return number + '';
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 58 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : australian english (en-au)

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('en-au', {
                months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'h:mm A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                },
                ordinal: function(number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                        (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                        (b === 3) ? 'rd' : 'th';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 59 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : canadian english (en-ca)
        // author : Jonathan Abourbih : https://github.com/jonbca

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('en-ca', {
                months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'h:mm A',
                    L: 'YYYY-MM-DD',
                    LL: 'D MMMM, YYYY',
                    LLL: 'D MMMM, YYYY LT',
                    LLLL: 'dddd, D MMMM, YYYY LT'
                },
                calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                },
                ordinal: function(number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                        (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                        (b === 3) ? 'rd' : 'th';
                    return number + output;
                }
            });
        }));


        /***/
    }),
    /* 60 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : great britain english (en-gb)
        // author : Chris Gedrim : https://github.com/chrisgedrim

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('en-gb', {
                months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                },
                ordinal: function(number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                        (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                        (b === 3) ? 'rd' : 'th';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 61 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : esperanto (eo)
        // author : Colin Dean : https://github.com/colindean
        // komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
        //          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('eo', {
                months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
                monthsShort: 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
                weekdays: 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
                weekdaysShort: 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
                weekdaysMin: 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'YYYY-MM-DD',
                    LL: 'D[-an de] MMMM, YYYY',
                    LLL: 'D[-an de] MMMM, YYYY LT',
                    LLLL: 'dddd, [la] D[-an de] MMMM, YYYY LT'
                },
                meridiem: function(hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? 'p.t.m.' : 'P.T.M.';
                    } else {
                        return isLower ? 'a.t.m.' : 'A.T.M.';
                    }
                },
                calendar: {
                    sameDay: '[Hodia je] LT',
                    nextDay: '[Morga je] LT',
                    nextWeek: 'dddd [je] LT',
                    lastDay: '[Hiera je] LT',
                    lastWeek: '[pasinta] dddd [je] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'je %s',
                    past: 'anta %s',
                    s: 'sekundoj',
                    m: 'minuto',
                    mm: '%d minutoj',
                    h: 'horo',
                    hh: '%d horoj',
                    d: 'tago', //ne 'diurno', ar estas uzita por proksimumo
                    dd: '%d tagoj',
                    M: 'monato',
                    MM: '%d monatoj',
                    y: 'jaro',
                    yy: '%d jaroj'
                },
                ordinal: '%da',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 62 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : spanish (es)
        // author : Julio Napur : https://github.com/julionc

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
                monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

            return moment.defineLocale('es', {
                months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
                monthsShort: function(m, format) {
                    if (/-MMM-/.test(format)) {
                        return monthsShort[m.month()];
                    } else {
                        return monthsShortDot[m.month()];
                    }
                },
                weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
                weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
                weekdaysMin: 'Do_Lu_Ma_Mi_Ju_Vi_S'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D [de] MMMM [de] YYYY',
                    LLL: 'D [de] MMMM [de] YYYY LT',
                    LLLL: 'dddd, D [de] MMMM [de] YYYY LT'
                },
                calendar: {
                    sameDay: function() {
                        return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextDay: function() {
                        return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextWeek: function() {
                        return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    lastDay: function() {
                        return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    lastWeek: function() {
                        return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'en %s',
                    past: 'hace %s',
                    s: 'unos segundos',
                    m: 'un minuto',
                    mm: '%d minutos',
                    h: 'una hora',
                    hh: '%d horas',
                    d: 'un da',
                    dd: '%d das',
                    M: 'un mes',
                    MM: '%d meses',
                    y: 'un ao',
                    yy: '%d aos'
                },
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 63 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : estonian (et)
        // author : Henry Kehlmann : https://github.com/madhenry
        // improvements : Illimar Tambek : https://github.com/ragulka

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    's': ['mne sekundi', 'mni sekund', 'paar sekundit'],
                    'm': ['he minuti', 'ks minut'],
                    'mm': [number + ' minuti', number + ' minutit'],
                    'h': ['he tunni', 'tund aega', 'ks tund'],
                    'hh': [number + ' tunni', number + ' tundi'],
                    'd': ['he peva', 'ks pev'],
                    'M': ['kuu aja', 'kuu aega', 'ks kuu'],
                    'MM': [number + ' kuu', number + ' kuud'],
                    'y': ['he aasta', 'aasta', 'ks aasta'],
                    'yy': [number + ' aasta', number + ' aastat']
                };
                if (withoutSuffix) {
                    return format[key][2] ? format[key][2] : format[key][1];
                }
                return isFuture ? format[key][0] : format[key][1];
            }

            return moment.defineLocale('et', {
                months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
                monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
                weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
                weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
                weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Tna,] LT',
                    nextDay: '[Homme,] LT',
                    nextWeek: '[Jrgmine] dddd LT',
                    lastDay: '[Eile,] LT',
                    lastWeek: '[Eelmine] dddd LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s prast',
                    past: '%s tagasi',
                    s: processRelativeTime,
                    m: processRelativeTime,
                    mm: processRelativeTime,
                    h: processRelativeTime,
                    hh: processRelativeTime,
                    d: processRelativeTime,
                    dd: '%d peva',
                    M: processRelativeTime,
                    MM: processRelativeTime,
                    y: processRelativeTime,
                    yy: processRelativeTime
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 64 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : euskara (eu)
        // author : Eneko Illarramendi : https://github.com/eillarra

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('eu', {
                months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
                monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
                weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
                weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
                weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'YYYY-MM-DD',
                    LL: 'YYYY[ko] MMMM[ren] D[a]',
                    LLL: 'YYYY[ko] MMMM[ren] D[a] LT',
                    LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] LT',
                    l: 'YYYY-M-D',
                    ll: 'YYYY[ko] MMM D[a]',
                    lll: 'YYYY[ko] MMM D[a] LT',
                    llll: 'ddd, YYYY[ko] MMM D[a] LT'
                },
                calendar: {
                    sameDay: '[gaur] LT[etan]',
                    nextDay: '[bihar] LT[etan]',
                    nextWeek: 'dddd LT[etan]',
                    lastDay: '[atzo] LT[etan]',
                    lastWeek: '[aurreko] dddd LT[etan]',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s barru',
                    past: 'duela %s',
                    s: 'segundo batzuk',
                    m: 'minutu bat',
                    mm: '%d minutu',
                    h: 'ordu bat',
                    hh: '%d ordu',
                    d: 'egun bat',
                    dd: '%d egun',
                    M: 'hilabete bat',
                    MM: '%d hilabete',
                    y: 'urte bat',
                    yy: '%d urte'
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 65 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Persian (fa)
        // author : Ebrahim Byagowi : https://github.com/ebraminio

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                };

            return moment.defineLocale('fa', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '\u200c__\u200c__\u200c__'.split('_'),
                weekdaysShort: '\u200c__\u200c__\u200c__'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 12) {
                        return '  ';
                    } else {
                        return '  ';
                    }
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: 'dddd [] [] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                preparse: function(string) {
                    return string.replace(/[-]/g, function(match) {
                        return numberMap[match];
                    }).replace(//g, ',');
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    }).replace(/,/g, '');
                },
                ordinal: '%d',
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 66 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : finnish (fi)
        // author : Tarmo Aidantausta : https://github.com/bleadof

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
                numbersFuture = [
                    'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
                    numbersPast[7], numbersPast[8], numbersPast[9]
                ];

            function translate(number, withoutSuffix, key, isFuture) {
                var result = '';
                switch (key) {
                    case 's':
                        return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
                    case 'm':
                        return isFuture ? 'minuutin' : 'minuutti';
                    case 'mm':
                        result = isFuture ? 'minuutin' : 'minuuttia';
                        break;
                    case 'h':
                        return isFuture ? 'tunnin' : 'tunti';
                    case 'hh':
                        result = isFuture ? 'tunnin' : 'tuntia';
                        break;
                    case 'd':
                        return isFuture ? 'pivn' : 'piv';
                    case 'dd':
                        result = isFuture ? 'pivn' : 'piv';
                        break;
                    case 'M':
                        return isFuture ? 'kuukauden' : 'kuukausi';
                    case 'MM':
                        result = isFuture ? 'kuukauden' : 'kuukautta';
                        break;
                    case 'y':
                        return isFuture ? 'vuoden' : 'vuosi';
                    case 'yy':
                        result = isFuture ? 'vuoden' : 'vuotta';
                        break;
                }
                result = verbalNumber(number, isFuture) + ' ' + result;
                return result;
            }

            function verbalNumber(number, isFuture) {
                return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
            }

            return moment.defineLocale('fi', {
                months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
                monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
                weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
                weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
                weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    L: 'DD.MM.YYYY',
                    LL: 'Do MMMM[ta] YYYY',
                    LLL: 'Do MMMM[ta] YYYY, [klo] LT',
                    LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] LT',
                    l: 'D.M.YYYY',
                    ll: 'Do MMM YYYY',
                    lll: 'Do MMM YYYY, [klo] LT',
                    llll: 'ddd, Do MMM YYYY, [klo] LT'
                },
                calendar: {
                    sameDay: '[tnn] [klo] LT',
                    nextDay: '[huomenna] [klo] LT',
                    nextWeek: 'dddd [klo] LT',
                    lastDay: '[eilen] [klo] LT',
                    lastWeek: '[viime] dddd[na] [klo] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s pst',
                    past: '%s sitten',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 67 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : faroese (fo)
        // author : Ragnar Johannesen : https://github.com/ragnar123

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('fo', {
                months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
                monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
                weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
                weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
                weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D. MMMM, YYYY LT'
                },
                calendar: {
                    sameDay: '[ dag kl.] LT',
                    nextDay: '[ morgin kl.] LT',
                    nextWeek: 'dddd [kl.] LT',
                    lastDay: '[ gjr kl.] LT',
                    lastWeek: '[sstu] dddd [kl] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'um %s',
                    past: '%s sani',
                    s: 'f sekund',
                    m: 'ein minutt',
                    mm: '%d minuttir',
                    h: 'ein tmi',
                    hh: '%d tmar',
                    d: 'ein dagur',
                    dd: '%d dagar',
                    M: 'ein mnai',
                    MM: '%d mnair',
                    y: 'eitt r',
                    yy: '%d r'
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 68 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : canadian french (fr-ca)
        // author : Jonathan Abourbih : https://github.com/jonbca

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('fr-ca', {
                months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
                monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
                weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
                weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
                weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'YYYY-MM-DD',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Aujourd\'hui ] LT',
                    nextDay: '[Demain ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[Hier ] LT',
                    lastWeek: 'dddd [dernier ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dans %s',
                    past: 'il y a %s',
                    s: 'quelques secondes',
                    m: 'une minute',
                    mm: '%d minutes',
                    h: 'une heure',
                    hh: '%d heures',
                    d: 'un jour',
                    dd: '%d jours',
                    M: 'un mois',
                    MM: '%d mois',
                    y: 'un an',
                    yy: '%d ans'
                },
                ordinal: function(number) {
                    return number + (number === 1 ? 'er' : '');
                }
            });
        }));


        /***/
    }),
    /* 69 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : french (fr)
        // author : John Fischer : https://github.com/jfroffice

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('fr', {
                months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
                monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
                weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
                weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
                weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Aujourd\'hui ] LT',
                    nextDay: '[Demain ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[Hier ] LT',
                    lastWeek: 'dddd [dernier ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dans %s',
                    past: 'il y a %s',
                    s: 'quelques secondes',
                    m: 'une minute',
                    mm: '%d minutes',
                    h: 'une heure',
                    hh: '%d heures',
                    d: 'un jour',
                    dd: '%d jours',
                    M: 'un mois',
                    MM: '%d mois',
                    y: 'un an',
                    yy: '%d ans'
                },
                ordinal: function(number) {
                    return number + (number === 1 ? 'er' : '');
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 70 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : galician (gl)
        // author : Juan G. Hurtado : https://github.com/juanghurtado

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('gl', {
                months: 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuo_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
                monthsShort: 'Xan._Feb._Mar._Abr._Mai._Xu._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
                weekdays: 'Domingo_Luns_Martes_Mrcores_Xoves_Venres_Sbado'.split('_'),
                weekdaysShort: 'Dom._Lun._Mar._Mr._Xov._Ven._Sb.'.split('_'),
                weekdaysMin: 'Do_Lu_Ma_M_Xo_Ve_S'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: function() {
                        return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextDay: function() {
                        return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextWeek: function() {
                        return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
                    },
                    lastDay: function() {
                        return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
                    },
                    lastWeek: function() {
                        return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: function(str) {
                        if (str === 'uns segundos') {
                            return 'nuns segundos';
                        }
                        return 'en ' + str;
                    },
                    past: 'hai %s',
                    s: 'uns segundos',
                    m: 'un minuto',
                    mm: '%d minutos',
                    h: 'unha hora',
                    hh: '%d horas',
                    d: 'un da',
                    dd: '%d das',
                    M: 'un mes',
                    MM: '%d meses',
                    y: 'un ano',
                    yy: '%d anos'
                },
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 71 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Hebrew (he)
        // author : Tomer Cohen : https://github.com/tomer
        // author : Moshe Simantov : https://github.com/DevelopmentIL
        // author : Tal Ater : https://github.com/TalAter

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('he', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D []MMMM YYYY',
                    LLL: 'D []MMMM YYYY LT',
                    LLLL: 'dddd, D []MMMM YYYY LT',
                    l: 'D/M/YYYY',
                    ll: 'D MMM YYYY',
                    lll: 'D MMM YYYY LT',
                    llll: 'ddd, D MMM YYYY LT'
                },
                calendar: {
                    sameDay: '[ ]LT',
                    nextDay: '[ ]LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ]LT',
                    lastWeek: '[] dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: ' ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: function(number) {
                        if (number === 2) {
                            return '';
                        }
                        return number + ' ';
                    },
                    d: '',
                    dd: function(number) {
                        if (number === 2) {
                            return '';
                        }
                        return number + ' ';
                    },
                    M: '',
                    MM: function(number) {
                        if (number === 2) {
                            return '';
                        }
                        return number + ' ';
                    },
                    y: '',
                    yy: function(number) {
                        if (number === 2) {
                            return '';
                        }
                        return number + ' ';
                    }
                }
            });
        }));


        /***/
    }),
    /* 72 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : hindi (hi)
        // author : Mayank Singhal : https://github.com/mayanksinghal

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                };

            return moment.defineLocale('hi', {
                months: '___________'.split('_'),
                monthsShort: '._.__.___._._._._._.'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, LT',
                    LLLL: 'dddd, D MMMM YYYY, LT'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '  ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                preparse: function(string) {
                    return string.replace(/[]/g, function(match) {
                        return numberMap[match];
                    });
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    });
                },
                // Hindi notation for meridiems are quite fuzzy in practice. While there exists
                // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 73 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : hrvatski (hr)
        // author : Bojan Markovi : https://github.com/bmarkovic

        // based on (sl) translation by Robert Sedovek

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function translate(number, withoutSuffix, key) {
                var result = number + ' ';
                switch (key) {
                    case 'm':
                        return withoutSuffix ? 'jedna minuta' : 'jedne minute';
                    case 'mm':
                        if (number === 1) {
                            result += 'minuta';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'minute';
                        } else {
                            result += 'minuta';
                        }
                        return result;
                    case 'h':
                        return withoutSuffix ? 'jedan sat' : 'jednog sata';
                    case 'hh':
                        if (number === 1) {
                            result += 'sat';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'sata';
                        } else {
                            result += 'sati';
                        }
                        return result;
                    case 'dd':
                        if (number === 1) {
                            result += 'dan';
                        } else {
                            result += 'dana';
                        }
                        return result;
                    case 'MM':
                        if (number === 1) {
                            result += 'mjesec';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'mjeseca';
                        } else {
                            result += 'mjeseci';
                        }
                        return result;
                    case 'yy':
                        if (number === 1) {
                            result += 'godina';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'godine';
                        } else {
                            result += 'godina';
                        }
                        return result;
                }
            }

            return moment.defineLocale('hr', {
                months: 'sjeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
                monthsShort: 'sje._vel._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
                weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
                weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
                weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD. MM. YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[danas u] LT',
                    nextDay: '[sutra u] LT',

                    nextWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[u] [nedjelju] [u] LT';
                            case 3:
                                return '[u] [srijedu] [u] LT';
                            case 6:
                                return '[u] [subotu] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[u] dddd [u] LT';
                        }
                    },
                    lastDay: '[juer u] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                            case 3:
                                return '[prolu] dddd [u] LT';
                            case 6:
                                return '[prole] [subote] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[proli] dddd [u] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'prije %s',
                    s: 'par sekundi',
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: 'dan',
                    dd: translate,
                    M: 'mjesec',
                    MM: translate,
                    y: 'godinu',
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 74 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : hungarian (hu)
        // author : Adam Brunner : https://github.com/adambrunner

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');

            function translate(number, withoutSuffix, key, isFuture) {
                var num = number,
                    suffix;

                switch (key) {
                    case 's':
                        return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
                    case 'm':
                        return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
                    case 'mm':
                        return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
                    case 'h':
                        return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
                    case 'hh':
                        return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
                    case 'd':
                        return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
                    case 'dd':
                        return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
                    case 'M':
                        return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
                    case 'MM':
                        return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
                    case 'y':
                        return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
                    case 'yy':
                        return num + (isFuture || withoutSuffix ? ' v' : ' ve');
                }

                return '';
            }

            function week(isFuture) {
                return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
            }

            return moment.defineLocale('hu', {
                months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
                monthsShort: 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
                weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
                weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
                weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'YYYY.MM.DD.',
                    LL: 'YYYY. MMMM D.',
                    LLL: 'YYYY. MMMM D., LT',
                    LLLL: 'YYYY. MMMM D., dddd LT'
                },
                meridiem: function(hours, minutes, isLower) {
                    if (hours < 12) {
                        return isLower === true ? 'de' : 'DE';
                    } else {
                        return isLower === true ? 'du' : 'DU';
                    }
                },
                calendar: {
                    sameDay: '[ma] LT[-kor]',
                    nextDay: '[holnap] LT[-kor]',
                    nextWeek: function() {
                        return week.call(this, true);
                    },
                    lastDay: '[tegnap] LT[-kor]',
                    lastWeek: function() {
                        return week.call(this, false);
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s mlva',
                    past: '%s',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 75 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Armenian (hy-am)
        // author : Armendarabyan : https://github.com/armendarabyan

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function monthsCaseReplace(m, format) {
                var months = {
                        'nominative': '___________'.split('_'),
                        'accusative': '___________'.split('_')
                    },

                    nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
                    'accusative' :
                    'nominative';

                return months[nounCase][m.month()];
            }

            function monthsShortCaseReplace(m, format) {
                var monthsShort = '___________'.split('_');

                return monthsShort[m.month()];
            }

            function weekdaysCaseReplace(m, format) {
                var weekdays = '______'.split('_');

                return weekdays[m.day()];
            }

            return moment.defineLocale('hy-am', {
                months: monthsCaseReplace,
                monthsShort: monthsShortCaseReplace,
                weekdays: weekdaysCaseReplace,
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY .',
                    LLL: 'D MMMM YYYY ., LT',
                    LLLL: 'dddd, D MMMM YYYY ., LT'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    lastDay: '[] LT',
                    nextWeek: function() {
                        return 'dddd [ ] LT';
                    },
                    lastWeek: function() {
                        return '[] dddd [ ] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '  ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },

                meridiem: function(hour) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else {
                        return '';
                    }
                },

                ordinal: function(number, period) {
                    switch (period) {
                        case 'DDD':
                        case 'w':
                        case 'W':
                        case 'DDDo':
                            if (number === 1) {
                                return number + '-';
                            }
                            return number + '-';
                        default:
                            return number;
                    }
                },

                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 76 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Bahasa Indonesia (id)
        // author : Mohammad Satrio Utomo : https://github.com/tyok
        // reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('id', {
                months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
                weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
                weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
                weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY [pukul] LT',
                    LLLL: 'dddd, D MMMM YYYY [pukul] LT'
                },
                meridiem: function(hours, minutes, isLower) {
                    if (hours < 11) {
                        return 'pagi';
                    } else if (hours < 15) {
                        return 'siang';
                    } else if (hours < 19) {
                        return 'sore';
                    } else {
                        return 'malam';
                    }
                },
                calendar: {
                    sameDay: '[Hari ini pukul] LT',
                    nextDay: '[Besok pukul] LT',
                    nextWeek: 'dddd [pukul] LT',
                    lastDay: '[Kemarin pukul] LT',
                    lastWeek: 'dddd [lalu pukul] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dalam %s',
                    past: '%s yang lalu',
                    s: 'beberapa detik',
                    m: 'semenit',
                    mm: '%d menit',
                    h: 'sejam',
                    hh: '%d jam',
                    d: 'sehari',
                    dd: '%d hari',
                    M: 'sebulan',
                    MM: '%d bulan',
                    y: 'setahun',
                    yy: '%d tahun'
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 77 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : icelandic (is)
        // author : Hinrik rn Sigursson : https://github.com/hinrik

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function plural(n) {
                if (n % 100 === 11) {
                    return true;
                } else if (n % 10 === 1) {
                    return false;
                }
                return true;
            }

            function translate(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                switch (key) {
                    case 's':
                        return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
                    case 'm':
                        return withoutSuffix ? 'mnta' : 'mntu';
                    case 'mm':
                        if (plural(number)) {
                            return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
                        } else if (withoutSuffix) {
                            return result + 'mnta';
                        }
                        return result + 'mntu';
                    case 'hh':
                        if (plural(number)) {
                            return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
                        }
                        return result + 'klukkustund';
                    case 'd':
                        if (withoutSuffix) {
                            return 'dagur';
                        }
                        return isFuture ? 'dag' : 'degi';
                    case 'dd':
                        if (plural(number)) {
                            if (withoutSuffix) {
                                return result + 'dagar';
                            }
                            return result + (isFuture ? 'daga' : 'dgum');
                        } else if (withoutSuffix) {
                            return result + 'dagur';
                        }
                        return result + (isFuture ? 'dag' : 'degi');
                    case 'M':
                        if (withoutSuffix) {
                            return 'mnuur';
                        }
                        return isFuture ? 'mnu' : 'mnui';
                    case 'MM':
                        if (plural(number)) {
                            if (withoutSuffix) {
                                return result + 'mnuir';
                            }
                            return result + (isFuture ? 'mnui' : 'mnuum');
                        } else if (withoutSuffix) {
                            return result + 'mnuur';
                        }
                        return result + (isFuture ? 'mnu' : 'mnui');
                    case 'y':
                        return withoutSuffix || isFuture ? 'r' : 'ri';
                    case 'yy':
                        if (plural(number)) {
                            return result + (withoutSuffix || isFuture ? 'r' : 'rum');
                        }
                        return result + (withoutSuffix || isFuture ? 'r' : 'ri');
                }
            }

            return moment.defineLocale('is', {
                months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
                monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
                weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
                weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
                weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY [kl.] LT',
                    LLLL: 'dddd, D. MMMM YYYY [kl.] LT'
                },
                calendar: {
                    sameDay: '[ dag kl.] LT',
                    nextDay: '[ morgun kl.] LT',
                    nextWeek: 'dddd [kl.] LT',
                    lastDay: '[ gr kl.] LT',
                    lastWeek: '[sasta] dddd [kl.] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'eftir %s',
                    past: 'fyrir %s san',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: 'klukkustund',
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 78 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : italian (it)
        // author : Lorenzo : https://github.com/aliem
        // author: Mattia Larentis: https://github.com/nostalgiaz

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('it', {
                months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
                monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
                weekdays: 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
                weekdaysShort: 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
                weekdaysMin: 'D_L_Ma_Me_G_V_S'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Oggi alle] LT',
                    nextDay: '[Domani alle] LT',
                    nextWeek: 'dddd [alle] LT',
                    lastDay: '[Ieri alle] LT',
                    lastWeek: '[lo scorso] dddd [alle] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: function(s) {
                        return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
                    },
                    past: '%s fa',
                    s: 'alcuni secondi',
                    m: 'un minuto',
                    mm: '%d minuti',
                    h: 'un\'ora',
                    hh: '%d ore',
                    d: 'un giorno',
                    dd: '%d giorni',
                    M: 'un mese',
                    MM: '%d mesi',
                    y: 'un anno',
                    yy: '%d anni'
                },
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 79 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : japanese (ja)
        // author : LI Long : https://github.com/baryon

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('ja', {
                months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'Ahm',
                    L: 'YYYY/MM/DD',
                    LL: 'YYYYMD',
                    LLL: 'YYYYMDLT',
                    LLLL: 'YYYYMDLT dddd'
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: '[]dddd LT',
                    lastDay: '[] LT',
                    lastWeek: '[]dddd LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '1',
                    mm: '%d',
                    h: '1',
                    hh: '%d',
                    d: '1',
                    dd: '%d',
                    M: '1',
                    MM: '%d',
                    y: '1',
                    yy: '%d'
                }
            });
        }));


        /***/
    }),
    /* 80 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Georgian (ka)
        // author : Irakli Janiashvili : https://github.com/irakli-janiashvili

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function monthsCaseReplace(m, format) {
                var months = {
                        'nominative': '___________'.split('_'),
                        'accusative': '___________'.split('_')
                    },

                    nounCase = (/D[oD] *MMMM?/).test(format) ?
                    'accusative' :
                    'nominative';

                return months[nounCase][m.month()];
            }

            function weekdaysCaseReplace(m, format) {
                var weekdays = {
                        'nominative': '______'.split('_'),
                        'accusative': '______'.split('_')
                    },

                    nounCase = (/(|)/).test(format) ?
                    'accusative' :
                    'nominative';

                return weekdays[nounCase][m.day()];
            }

            return moment.defineLocale('ka', {
                months: monthsCaseReplace,
                monthsShort: '___________'.split('_'),
                weekdays: weekdaysCaseReplace,
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'h:mm A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[] LT[-]',
                    nextDay: '[] LT[-]',
                    lastDay: '[] LT[-]',
                    nextWeek: '[] dddd LT[-]',
                    lastWeek: '[] dddd LT-',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: function(s) {
                        return (/(|||)/).test(s) ?
                            s.replace(/$/, '') :
                            s + '';
                    },
                    past: function(s) {
                        if ((/(||||)/).test(s)) {
                            return s.replace(/(|)$/, ' ');
                        }
                        if ((//).test(s)) {
                            return s.replace(/$/, ' ');
                        }
                    },
                    s: ' ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                ordinal: function(number) {
                    if (number === 0) {
                        return number;
                    }

                    if (number === 1) {
                        return number + '-';
                    }

                    if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                        return '-' + number;
                    }

                    return number + '-';
                },
                week: {
                    dow: 1,
                    doy: 7
                }
            });
        }));


        /***/
    }),
    /* 81 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : khmer (km)
        // author : Kruy Vanna : https://github.com/kruyvanna

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('km', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: 'dddd [] [] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 82 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : korean (ko)
        //
        // authors
        //
        // - Kyungwook, Park : https://github.com/kyungw00k
        // - Jeeeyul Lee <jeeeyul@gmail.com>
        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('ko', {
                months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h m',
                    L: 'YYYY.MM.DD',
                    LL: 'YYYY MMMM D',
                    LLL: 'YYYY MMMM D LT',
                    LLLL: 'YYYY MMMM D dddd LT'
                },
                meridiem: function(hour, minute, isUpper) {
                    return hour < 12 ? '' : '';
                },
                calendar: {
                    sameDay: ' LT',
                    nextDay: ' LT',
                    nextWeek: 'dddd LT',
                    lastDay: ' LT',
                    lastWeek: ' dddd LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '',
                    ss: '%d',
                    m: '',
                    mm: '%d',
                    h: '',
                    hh: '%d',
                    d: '',
                    dd: '%d',
                    M: '',
                    MM: '%d',
                    y: '',
                    yy: '%d'
                },
                ordinal: '%d',
                meridiemParse: /(|)/,
                isPM: function(token) {
                    return token === '';
                }
            });
        }));


        /***/
    }),
    /* 83 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Luxembourgish (lb)
        // author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz

        // Note: Luxembourgish has a very particular phonological rule ('Eifeler Regel') that causes the
        // deletion of the final 'n' in certain contexts. That's what the 'eifelerRegelAppliesToWeekday'
        // and 'eifelerRegelAppliesToNumber' methods are meant for

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    'm': ['eng Minutt', 'enger Minutt'],
                    'h': ['eng Stonn', 'enger Stonn'],
                    'd': ['een Dag', 'engem Dag'],
                    'M': ['ee Mount', 'engem Mount'],
                    'y': ['ee Joer', 'engem Joer']
                };
                return withoutSuffix ? format[key][0] : format[key][1];
            }

            function processFutureTime(string) {
                var number = string.substr(0, string.indexOf(' '));
                if (eifelerRegelAppliesToNumber(number)) {
                    return 'a ' + string;
                }
                return 'an ' + string;
            }

            function processPastTime(string) {
                var number = string.substr(0, string.indexOf(' '));
                if (eifelerRegelAppliesToNumber(number)) {
                    return 'viru ' + string;
                }
                return 'virun ' + string;
            }

            /**
             * Returns true if the word before the given number loses the '-n' ending.
             * e.g. 'an 10 Deeg' but 'a 5 Deeg'
             *
             * @param number {integer}
             * @returns {boolean}
             */
            function eifelerRegelAppliesToNumber(number) {
                number = parseInt(number, 10);
                if (isNaN(number)) {
                    return false;
                }
                if (number < 0) {
                    // Negative Number --> always true
                    return true;
                } else if (number < 10) {
                    // Only 1 digit
                    if (4 <= number && number <= 7) {
                        return true;
                    }
                    return false;
                } else if (number < 100) {
                    // 2 digits
                    var lastDigit = number % 10,
                        firstDigit = number / 10;
                    if (lastDigit === 0) {
                        return eifelerRegelAppliesToNumber(firstDigit);
                    }
                    return eifelerRegelAppliesToNumber(lastDigit);
                } else if (number < 10000) {
                    // 3 or 4 digits --> recursively check first digit
                    while (number >= 10) {
                        number = number / 10;
                    }
                    return eifelerRegelAppliesToNumber(number);
                } else {
                    // Anything larger than 4 digits: recursively check first n-3 digits
                    number = number / 1000;
                    return eifelerRegelAppliesToNumber(number);
                }
            }

            return moment.defineLocale('lb', {
                months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
                monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
                weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
                weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
                weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'H:mm [Auer]',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Haut um] LT',
                    sameElse: 'L',
                    nextDay: '[Muer um] LT',
                    nextWeek: 'dddd [um] LT',
                    lastDay: '[Gschter um] LT',
                    lastWeek: function() {
                        // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                        switch (this.day()) {
                            case 2:
                            case 4:
                                return '[Leschten] dddd [um] LT';
                            default:
                                return '[Leschte] dddd [um] LT';
                        }
                    }
                },
                relativeTime: {
                    future: processFutureTime,
                    past: processPastTime,
                    s: 'e puer Sekonnen',
                    m: processRelativeTime,
                    mm: '%d Minutten',
                    h: processRelativeTime,
                    hh: '%d Stonnen',
                    d: processRelativeTime,
                    dd: '%d Deeg',
                    M: processRelativeTime,
                    MM: '%d Mint',
                    y: processRelativeTime,
                    yy: '%d Joer'
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 84 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Lithuanian (lt)
        // author : Mindaugas Mozras : https://github.com/mmozuras

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var units = {
                    'm': 'minut_minuts_minut',
                    'mm': 'minuts_minui_minutes',
                    'h': 'valanda_valandos_valand',
                    'hh': 'valandos_valand_valandas',
                    'd': 'diena_dienos_dien',
                    'dd': 'dienos_dien_dienas',
                    'M': 'mnuo_mnesio_mnes',
                    'MM': 'mnesiai_mnesi_mnesius',
                    'y': 'metai_met_metus',
                    'yy': 'metai_met_metus'
                },
                weekDays = 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_');

            function translateSeconds(number, withoutSuffix, key, isFuture) {
                if (withoutSuffix) {
                    return 'kelios sekunds';
                } else {
                    return isFuture ? 'keli sekundi' : 'kelias sekundes';
                }
            }

            function translateSingular(number, withoutSuffix, key, isFuture) {
                return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
            }

            function special(number) {
                return number % 10 === 0 || (number > 10 && number < 20);
            }

            function forms(key) {
                return units[key].split('_');
            }

            function translate(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                if (number === 1) {
                    return result + translateSingular(number, withoutSuffix, key[0], isFuture);
                } else if (withoutSuffix) {
                    return result + (special(number) ? forms(key)[1] : forms(key)[0]);
                } else {
                    if (isFuture) {
                        return result + forms(key)[1];
                    } else {
                        return result + (special(number) ? forms(key)[1] : forms(key)[2]);
                    }
                }
            }

            function relativeWeekDay(moment, format) {
                var nominative = format.indexOf('dddd HH:mm') === -1,
                    weekDay = weekDays[moment.day()];

                return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + '';
            }

            return moment.defineLocale('lt', {
                months: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
                monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
                weekdays: relativeWeekDay,
                weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
                weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'YYYY-MM-DD',
                    LL: 'YYYY [m.] MMMM D [d.]',
                    LLL: 'YYYY [m.] MMMM D [d.], LT [val.]',
                    LLLL: 'YYYY [m.] MMMM D [d.], dddd, LT [val.]',
                    l: 'YYYY-MM-DD',
                    ll: 'YYYY [m.] MMMM D [d.]',
                    lll: 'YYYY [m.] MMMM D [d.], LT [val.]',
                    llll: 'YYYY [m.] MMMM D [d.], ddd, LT [val.]'
                },
                calendar: {
                    sameDay: '[iandien] LT',
                    nextDay: '[Rytoj] LT',
                    nextWeek: 'dddd LT',
                    lastDay: '[Vakar] LT',
                    lastWeek: '[Prajus] dddd LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'po %s',
                    past: 'prie %s',
                    s: translateSeconds,
                    m: translateSingular,
                    mm: translate,
                    h: translateSingular,
                    hh: translate,
                    d: translateSingular,
                    dd: translate,
                    M: translateSingular,
                    MM: translate,
                    y: translateSingular,
                    yy: translate
                },
                ordinal: function(number) {
                    return number + '-oji';
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 85 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : latvian (lv)
        // author : Kristaps Karlsons : https://github.com/skakri

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var units = {
                'mm': 'minti_mintes_minte_mintes',
                'hh': 'stundu_stundas_stunda_stundas',
                'dd': 'dienu_dienas_diena_dienas',
                'MM': 'mnesi_mneus_mnesis_mnei',
                'yy': 'gadu_gadus_gads_gadi'
            };

            function format(word, number, withoutSuffix) {
                var forms = word.split('_');
                if (withoutSuffix) {
                    return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
                } else {
                    return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
                }
            }

            function relativeTimeWithPlural(number, withoutSuffix, key) {
                return number + ' ' + format(units[key], number, withoutSuffix);
            }

            return moment.defineLocale('lv', {
                months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
                monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
                weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
                weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
                weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'YYYY. [gada] D. MMMM',
                    LLL: 'YYYY. [gada] D. MMMM, LT',
                    LLLL: 'YYYY. [gada] D. MMMM, dddd, LT'
                },
                calendar: {
                    sameDay: '[odien pulksten] LT',
                    nextDay: '[Rt pulksten] LT',
                    nextWeek: 'dddd [pulksten] LT',
                    lastDay: '[Vakar pulksten] LT',
                    lastWeek: '[Pagju] dddd [pulksten] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s vlk',
                    past: '%s agrk',
                    s: 'daas sekundes',
                    m: 'minti',
                    mm: relativeTimeWithPlural,
                    h: 'stundu',
                    hh: relativeTimeWithPlural,
                    d: 'dienu',
                    dd: relativeTimeWithPlural,
                    M: 'mnesi',
                    MM: relativeTimeWithPlural,
                    y: 'gadu',
                    yy: relativeTimeWithPlural
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 86 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : macedonian (mk)
        // author : Borislav Mickov : https://github.com/B0k0

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('mk', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: 'e_o_____a'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'D.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 6:
                                return '[ ] dddd [] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[ ] dddd [] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: ' ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                ordinal: function(number) {
                    var lastDigit = number % 10,
                        last2Digits = number % 100;
                    if (number === 0) {
                        return number + '-';
                    } else if (last2Digits === 0) {
                        return number + '-';
                    } else if (last2Digits > 10 && last2Digits < 20) {
                        return number + '-';
                    } else if (lastDigit === 1) {
                        return number + '-';
                    } else if (lastDigit === 2) {
                        return number + '-';
                    } else if (lastDigit === 7 || lastDigit === 8) {
                        return number + '-';
                    } else {
                        return number + '-';
                    }
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 87 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : malayalam (ml)
        // author : Floyd Pink : https://github.com/floydpink

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('ml', {
                months: '___________'.split('_'),
                monthsShort: '._._._.___._._._._._.'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm -',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, LT',
                    LLLL: 'dddd, D MMMM YYYY, LT'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return ' ';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                }
            });
        }));


        /***/
    }),
    /* 88 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Marathi (mr)
        // author : Harshad Kale : https://github.com/kalehv

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                };

            return moment.defineLocale('mr', {
                months: '___________'.split('_'),
                monthsShort: '._._._._._._._._._._._.'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, LT',
                    LLLL: 'dddd, D MMMM YYYY, LT'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                preparse: function(string) {
                    return string.replace(/[]/g, function(match) {
                        return numberMap[match];
                    });
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    });
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 89 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Bahasa Malaysia (ms-MY)
        // author : Weldan Jamili : https://github.com/weldan

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('ms-my', {
                months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
                monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
                weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
                weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
                weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY [pukul] LT',
                    LLLL: 'dddd, D MMMM YYYY [pukul] LT'
                },
                meridiem: function(hours, minutes, isLower) {
                    if (hours < 11) {
                        return 'pagi';
                    } else if (hours < 15) {
                        return 'tengahari';
                    } else if (hours < 19) {
                        return 'petang';
                    } else {
                        return 'malam';
                    }
                },
                calendar: {
                    sameDay: '[Hari ini pukul] LT',
                    nextDay: '[Esok pukul] LT',
                    nextWeek: 'dddd [pukul] LT',
                    lastDay: '[Kelmarin pukul] LT',
                    lastWeek: 'dddd [lepas pukul] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dalam %s',
                    past: '%s yang lepas',
                    s: 'beberapa saat',
                    m: 'seminit',
                    mm: '%d minit',
                    h: 'sejam',
                    hh: '%d jam',
                    d: 'sehari',
                    dd: '%d hari',
                    M: 'sebulan',
                    MM: '%d bulan',
                    y: 'setahun',
                    yy: '%d tahun'
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 90 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Burmese (my)
        // author : Squar team, mysquar.com

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                };
            return moment.defineLocale('my', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[.] LT []',
                    nextDay: '[] LT []',
                    nextWeek: 'dddd LT []',
                    lastDay: '[.] LT []',
                    lastWeek: '[] dddd LT []',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s ',
                    past: ' %s ',
                    s: '.',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                preparse: function(string) {
                    return string.replace(/[]/g, function(match) {
                        return numberMap[match];
                    });
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    });
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 91 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : norwegian bokml (nb)
        // authors : Espen Hovlandsdal : https://github.com/rexxars
        //           Sigurd Gartmann : https://github.com/sigurdga

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('nb', {
                months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
                monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
                weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
                weekdaysShort: 'sn_man_tirs_ons_tors_fre_lr'.split('_'),
                weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
                longDateFormat: {
                    LT: 'H.mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY [kl.] LT',
                    LLLL: 'dddd D. MMMM YYYY [kl.] LT'
                },
                calendar: {
                    sameDay: '[i dag kl.] LT',
                    nextDay: '[i morgen kl.] LT',
                    nextWeek: 'dddd [kl.] LT',
                    lastDay: '[i gr kl.] LT',
                    lastWeek: '[forrige] dddd [kl.] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'om %s',
                    past: 'for %s siden',
                    s: 'noen sekunder',
                    m: 'ett minutt',
                    mm: '%d minutter',
                    h: 'en time',
                    hh: '%d timer',
                    d: 'en dag',
                    dd: '%d dager',
                    M: 'en mned',
                    MM: '%d mneder',
                    y: 'ett r',
                    yy: '%d r'
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 92 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : nepali/nepalese
        // author : suvash : https://github.com/suvash

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                };

            return moment.defineLocale('ne', {
                months: '___________'.split('_'),
                monthsShort: '._.__.___._._._._._.'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '._._._._._._.'.split('_'),
                weekdaysMin: '._.__._._._.'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, LT',
                    LLLL: 'dddd, D MMMM YYYY, LT'
                },
                preparse: function(string) {
                    return string.replace(/[]/g, function(match) {
                        return numberMap[match];
                    });
                },
                postformat: function(string) {
                    return string.replace(/\d/g, function(match) {
                        return symbolMap[match];
                    });
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 3) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 15) {
                        return '';
                    } else if (hour < 18) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: '[] dddd[,] LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd[,] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 93 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : dutch (nl)
        // author : Joris Rling : https://github.com/jjupiter

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
                monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

            return moment.defineLocale('nl', {
                months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
                monthsShort: function(m, format) {
                    if (/-MMM-/.test(format)) {
                        return monthsShortWithoutDots[m.month()];
                    } else {
                        return monthsShortWithDots[m.month()];
                    }
                },
                weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
                weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
                weekdaysMin: 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD-MM-YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[vandaag om] LT',
                    nextDay: '[morgen om] LT',
                    nextWeek: 'dddd [om] LT',
                    lastDay: '[gisteren om] LT',
                    lastWeek: '[afgelopen] dddd [om] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'over %s',
                    past: '%s geleden',
                    s: 'een paar seconden',
                    m: 'n minuut',
                    mm: '%d minuten',
                    h: 'n uur',
                    hh: '%d uur',
                    d: 'n dag',
                    dd: '%d dagen',
                    M: 'n maand',
                    MM: '%d maanden',
                    y: 'n jaar',
                    yy: '%d jaar'
                },
                ordinal: function(number) {
                    return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 94 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : norwegian nynorsk (nn)
        // author : https://github.com/mechuwind

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('nn', {
                months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
                monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
                weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
                weekdaysShort: 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
                weekdaysMin: 'su_m_ty_on_to_fr_l'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[I dag klokka] LT',
                    nextDay: '[I morgon klokka] LT',
                    nextWeek: 'dddd [klokka] LT',
                    lastDay: '[I gr klokka] LT',
                    lastWeek: '[Fregande] dddd [klokka] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'om %s',
                    past: 'for %s sidan',
                    s: 'nokre sekund',
                    m: 'eit minutt',
                    mm: '%d minutt',
                    h: 'ein time',
                    hh: '%d timar',
                    d: 'ein dag',
                    dd: '%d dagar',
                    M: 'ein mnad',
                    MM: '%d mnader',
                    y: 'eit r',
                    yy: '%d r'
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 95 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : polish (pl)
        // author : Rafal Hirsz : https://github.com/evoL

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
                monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');

            function plural(n) {
                return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
            }

            function translate(number, withoutSuffix, key) {
                var result = number + ' ';
                switch (key) {
                    case 'm':
                        return withoutSuffix ? 'minuta' : 'minut';
                    case 'mm':
                        return result + (plural(number) ? 'minuty' : 'minut');
                    case 'h':
                        return withoutSuffix ? 'godzina' : 'godzin';
                    case 'hh':
                        return result + (plural(number) ? 'godziny' : 'godzin');
                    case 'MM':
                        return result + (plural(number) ? 'miesice' : 'miesicy');
                    case 'yy':
                        return result + (plural(number) ? 'lata' : 'lat');
                }
            }

            return moment.defineLocale('pl', {
                months: function(momentToFormat, format) {
                    if (/D MMMM/.test(format)) {
                        return monthsSubjective[momentToFormat.month()];
                    } else {
                        return monthsNominative[momentToFormat.month()];
                    }
                },
                monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
                weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
                weekdaysShort: 'nie_pon_wt_r_czw_pt_sb'.split('_'),
                weekdaysMin: 'N_Pn_Wt_r_Cz_Pt_So'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Dzi o] LT',
                    nextDay: '[Jutro o] LT',
                    nextWeek: '[W] dddd [o] LT',
                    lastDay: '[Wczoraj o] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[W zesz niedziel o] LT';
                            case 3:
                                return '[W zesz rod o] LT';
                            case 6:
                                return '[W zesz sobot o] LT';
                            default:
                                return '[W zeszy] dddd [o] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: '%s temu',
                    s: 'kilka sekund',
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: '1 dzie',
                    dd: '%d dni',
                    M: 'miesic',
                    MM: translate,
                    y: 'rok',
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 96 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : brazilian portuguese (pt-br)
        // author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('pt-br', {
                months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
                monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
                weekdays: 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'),
                weekdaysShort: 'dom_seg_ter_qua_qui_sex_sb'.split('_'),
                weekdaysMin: 'dom_2_3_4_5_6_sb'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D [de] MMMM [de] YYYY',
                    LLL: 'D [de] MMMM [de] YYYY [s] LT',
                    LLLL: 'dddd, D [de] MMMM [de] YYYY [s] LT'
                },
                calendar: {
                    sameDay: '[Hoje s] LT',
                    nextDay: '[Amanh s] LT',
                    nextWeek: 'dddd [s] LT',
                    lastDay: '[Ontem s] LT',
                    lastWeek: function() {
                        return (this.day() === 0 || this.day() === 6) ?
                            '[ltimo] dddd [s] LT' : // Saturday + Sunday
                            '[ltima] dddd [s] LT'; // Monday - Friday
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'em %s',
                    past: '%s atrs',
                    s: 'segundos',
                    m: 'um minuto',
                    mm: '%d minutos',
                    h: 'uma hora',
                    hh: '%d horas',
                    d: 'um dia',
                    dd: '%d dias',
                    M: 'um ms',
                    MM: '%d meses',
                    y: 'um ano',
                    yy: '%d anos'
                },
                ordinal: '%d'
            });
        }));


        /***/
    }),
    /* 97 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : portuguese (pt)
        // author : Jefferson : https://github.com/jalex79

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('pt', {
                months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
                monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
                weekdays: 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'),
                weekdaysShort: 'dom_seg_ter_qua_qui_sex_sb'.split('_'),
                weekdaysMin: 'dom_2_3_4_5_6_sb'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D [de] MMMM [de] YYYY',
                    LLL: 'D [de] MMMM [de] YYYY LT',
                    LLLL: 'dddd, D [de] MMMM [de] YYYY LT'
                },
                calendar: {
                    sameDay: '[Hoje s] LT',
                    nextDay: '[Amanh s] LT',
                    nextWeek: 'dddd [s] LT',
                    lastDay: '[Ontem s] LT',
                    lastWeek: function() {
                        return (this.day() === 0 || this.day() === 6) ?
                            '[ltimo] dddd [s] LT' : // Saturday + Sunday
                            '[ltima] dddd [s] LT'; // Monday - Friday
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'em %s',
                    past: 'h %s',
                    s: 'segundos',
                    m: 'um minuto',
                    mm: '%d minutos',
                    h: 'uma hora',
                    hh: '%d horas',
                    d: 'um dia',
                    dd: '%d dias',
                    M: 'um ms',
                    MM: '%d meses',
                    y: 'um ano',
                    yy: '%d anos'
                },
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 98 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : romanian (ro)
        // author : Vlad Gurdiga : https://github.com/gurdiga
        // author : Valentin Agachi : https://github.com/avaly

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function relativeTimeWithPlural(number, withoutSuffix, key) {
                var format = {
                        'mm': 'minute',
                        'hh': 'ore',
                        'dd': 'zile',
                        'MM': 'luni',
                        'yy': 'ani'
                    },
                    separator = ' ';
                if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
                    separator = ' de ';
                }

                return number + separator + format[key];
            }

            return moment.defineLocale('ro', {
                months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
                monthsShort: 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
                weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
                weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
                weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY H:mm',
                    LLLL: 'dddd, D MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[azi la] LT',
                    nextDay: '[mine la] LT',
                    nextWeek: 'dddd [la] LT',
                    lastDay: '[ieri la] LT',
                    lastWeek: '[fosta] dddd [la] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'peste %s',
                    past: '%s n urm',
                    s: 'cteva secunde',
                    m: 'un minut',
                    mm: relativeTimeWithPlural,
                    h: 'o or',
                    hh: relativeTimeWithPlural,
                    d: 'o zi',
                    dd: relativeTimeWithPlural,
                    M: 'o lun',
                    MM: relativeTimeWithPlural,
                    y: 'un an',
                    yy: relativeTimeWithPlural
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 99 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : russian (ru)
        // author : Viktorminator : https://github.com/Viktorminator
        // Author : Menelion Elensle : https://github.com/Oire

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function plural(word, num) {
                var forms = word.split('_');
                return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
            }

            function relativeTimeWithPlural(number, withoutSuffix, key) {
                var format = {
                    'mm': withoutSuffix ? '__' : '__',
                    'hh': '__',
                    'dd': '__',
                    'MM': '__',
                    'yy': '__'
                };
                if (key === 'm') {
                    return withoutSuffix ? '' : '';
                } else {
                    return number + ' ' + plural(format[key], +number);
                }
            }

            function monthsCaseReplace(m, format) {
                var months = {
                        'nominative': '___________'.split('_'),
                        'accusative': '___________'.split('_')
                    },

                    nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
                    'accusative' :
                    'nominative';

                return months[nounCase][m.month()];
            }

            function monthsShortCaseReplace(m, format) {
                var monthsShort = {
                        'nominative': '___________'.split('_'),
                        'accusative': '___________'.split('_')
                    },

                    nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
                    'accusative' :
                    'nominative';

                return monthsShort[nounCase][m.month()];
            }

            function weekdaysCaseReplace(m, format) {
                var weekdays = {
                        'nominative': '______'.split('_'),
                        'accusative': '______'.split('_')
                    },

                    nounCase = (/\[ ?[] ?(?:|)? ?\] ?dddd/).test(format) ?
                    'accusative' :
                    'nominative';

                return weekdays[nounCase][m.day()];
            }

            return moment.defineLocale('ru', {
                months: monthsCaseReplace,
                monthsShort: monthsShortCaseReplace,
                weekdays: weekdaysCaseReplace,
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                monthsParse: [/^/i, /^/i, /^/i, /^/i, /^[|]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY .',
                    LLL: 'D MMMM YYYY ., LT',
                    LLLL: 'dddd, D MMMM YYYY ., LT'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    lastDay: '[ ] LT',
                    nextWeek: function() {
                        return this.day() === 2 ? '[] dddd [] LT' : '[] dddd [] LT';
                    },
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[ ] dddd [] LT';
                            case 1:
                            case 2:
                            case 4:
                                return '[ ] dddd [] LT';
                            case 3:
                            case 5:
                            case 6:
                                return '[ ] dddd [] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: relativeTimeWithPlural,
                    mm: relativeTimeWithPlural,
                    h: '',
                    hh: relativeTimeWithPlural,
                    d: '',
                    dd: relativeTimeWithPlural,
                    M: '',
                    MM: relativeTimeWithPlural,
                    y: '',
                    yy: relativeTimeWithPlural
                },

                meridiemParse: /|||/i,
                isPM: function(input) {
                    return /^(|)$/.test(input);
                },

                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else {
                        return '';
                    }
                },

                ordinal: function(number, period) {
                    switch (period) {
                        case 'M':
                        case 'd':
                        case 'DDD':
                            return number + '-';
                        case 'D':
                            return number + '-';
                        case 'w':
                        case 'W':
                            return number + '-';
                        default:
                            return number;
                    }
                },

                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 100 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : slovak (sk)
        // author : Martin Minka : https://github.com/k2s
        // based on work of petrbela : https://github.com/petrbela

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
                monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');

            function plural(n) {
                return (n > 1) && (n < 5);
            }

            function translate(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                switch (key) {
                    case 's': // a few seconds / in a few seconds / a few seconds ago
                        return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
                    case 'm': // a minute / in a minute / a minute ago
                        return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
                    case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'minty' : 'mint');
                        } else {
                            return result + 'mintami';
                        }
                        break;
                    case 'h': // an hour / in an hour / an hour ago
                        return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
                    case 'hh': // 9 hours / in 9 hours / 9 hours ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'hodiny' : 'hodn');
                        } else {
                            return result + 'hodinami';
                        }
                        break;
                    case 'd': // a day / in a day / a day ago
                        return (withoutSuffix || isFuture) ? 'de' : 'dom';
                    case 'dd': // 9 days / in 9 days / 9 days ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'dni' : 'dn');
                        } else {
                            return result + 'dami';
                        }
                        break;
                    case 'M': // a month / in a month / a month ago
                        return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
                    case 'MM': // 9 months / in 9 months / 9 months ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'mesiace' : 'mesiacov');
                        } else {
                            return result + 'mesiacmi';
                        }
                        break;
                    case 'y': // a year / in a year / a year ago
                        return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
                    case 'yy': // 9 years / in 9 years / 9 years ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'roky' : 'rokov');
                        } else {
                            return result + 'rokmi';
                        }
                        break;
                }
            }

            return moment.defineLocale('sk', {
                months: months,
                monthsShort: monthsShort,
                monthsParse: (function(months, monthsShort) {
                    var i, _monthsParse = [];
                    for (i = 0; i < 12; i++) {
                        // use custom parser to solve problem with July (ervenec)
                        _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
                    }
                    return _monthsParse;
                }(months, monthsShort)),
                weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
                weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
                weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[dnes o] LT',
                    nextDay: '[zajtra o] LT',
                    nextWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[v nedeu o] LT';
                            case 1:
                            case 2:
                                return '[v] dddd [o] LT';
                            case 3:
                                return '[v stredu o] LT';
                            case 4:
                                return '[vo tvrtok o] LT';
                            case 5:
                                return '[v piatok o] LT';
                            case 6:
                                return '[v sobotu o] LT';
                        }
                    },
                    lastDay: '[vera o] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[minul nedeu o] LT';
                            case 1:
                            case 2:
                                return '[minul] dddd [o] LT';
                            case 3:
                                return '[minul stredu o] LT';
                            case 4:
                            case 5:
                                return '[minul] dddd [o] LT';
                            case 6:
                                return '[minul sobotu o] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'pred %s',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 101 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : slovenian (sl)
        // author : Robert Sedovek : https://github.com/sedovsek

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function translate(number, withoutSuffix, key) {
                var result = number + ' ';
                switch (key) {
                    case 'm':
                        return withoutSuffix ? 'ena minuta' : 'eno minuto';
                    case 'mm':
                        if (number === 1) {
                            result += 'minuta';
                        } else if (number === 2) {
                            result += 'minuti';
                        } else if (number === 3 || number === 4) {
                            result += 'minute';
                        } else {
                            result += 'minut';
                        }
                        return result;
                    case 'h':
                        return withoutSuffix ? 'ena ura' : 'eno uro';
                    case 'hh':
                        if (number === 1) {
                            result += 'ura';
                        } else if (number === 2) {
                            result += 'uri';
                        } else if (number === 3 || number === 4) {
                            result += 'ure';
                        } else {
                            result += 'ur';
                        }
                        return result;
                    case 'dd':
                        if (number === 1) {
                            result += 'dan';
                        } else {
                            result += 'dni';
                        }
                        return result;
                    case 'MM':
                        if (number === 1) {
                            result += 'mesec';
                        } else if (number === 2) {
                            result += 'meseca';
                        } else if (number === 3 || number === 4) {
                            result += 'mesece';
                        } else {
                            result += 'mesecev';
                        }
                        return result;
                    case 'yy':
                        if (number === 1) {
                            result += 'leto';
                        } else if (number === 2) {
                            result += 'leti';
                        } else if (number === 3 || number === 4) {
                            result += 'leta';
                        } else {
                            result += 'let';
                        }
                        return result;
                }
            }

            return moment.defineLocale('sl', {
                months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
                monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
                weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
                weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
                weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD. MM. YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[danes ob] LT',
                    nextDay: '[jutri ob] LT',

                    nextWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[v] [nedeljo] [ob] LT';
                            case 3:
                                return '[v] [sredo] [ob] LT';
                            case 6:
                                return '[v] [soboto] [ob] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[v] dddd [ob] LT';
                        }
                    },
                    lastDay: '[veraj ob] LT',
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 6:
                                return '[prejnja] dddd [ob] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[prejnji] dddd [ob] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'ez %s',
                    past: '%s nazaj',
                    s: 'nekaj sekund',
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: 'en dan',
                    dd: translate,
                    M: 'en mesec',
                    MM: translate,
                    y: 'eno leto',
                    yy: translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 102 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Albanian (sq)
        // author : Flakrim Ismani : https://github.com/flakerimi
        // author: Menelion Elensle: https://github.com/Oire (tests)
        // author : Oerd Cukalla : https://github.com/oerd (fixes)

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('sq', {
                months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
                monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
                weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
                weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
                weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
                meridiem: function(hours, minutes, isLower) {
                    return hours < 12 ? 'PD' : 'MD';
                },
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Sot n] LT',
                    nextDay: '[Nesr n] LT',
                    nextWeek: 'dddd [n] LT',
                    lastDay: '[Dje n] LT',
                    lastWeek: 'dddd [e kaluar n] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'n %s',
                    past: '%s m par',
                    s: 'disa sekonda',
                    m: 'nj minut',
                    mm: '%d minuta',
                    h: 'nj or',
                    hh: '%d or',
                    d: 'nj dit',
                    dd: '%d dit',
                    M: 'nj muaj',
                    MM: '%d muaj',
                    y: 'nj vit',
                    yy: '%d vite'
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 103 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Serbian-cyrillic (sr-cyrl)
        // author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var translator = {
                words: { //Different grammatical cases
                    m: [' ', ' '],
                    mm: ['', '', ''],
                    h: [' ', ' '],
                    hh: ['', '', ''],
                    dd: ['', '', ''],
                    MM: ['', '', ''],
                    yy: ['', '', '']
                },
                correctGrammaticalCase: function(number, wordKey) {
                    return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
                },
                translate: function(number, withoutSuffix, key) {
                    var wordKey = translator.words[key];
                    if (key.length === 1) {
                        return withoutSuffix ? wordKey[0] : wordKey[1];
                    } else {
                        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
                    }
                }
            };

            return moment.defineLocale('sr-cyrl', {
                months: ['', '', '', '', '', '', '', '', '', '', '', ''],
                monthsShort: ['.', '.', '.', '.', '', '', '', '.', '.', '.', '.', '.'],
                weekdays: ['', '', '', '', '', '', ''],
                weekdaysShort: ['.', '.', '.', '.', '.', '.', '.'],
                weekdaysMin: ['', '', '', '', '', '', ''],
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD. MM. YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',

                    nextWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[] [] [] LT';
                            case 3:
                                return '[] [] [] LT';
                            case 6:
                                return '[] [] [] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[] dddd [] LT';
                        }
                    },
                    lastDay: '[ ] LT',
                    lastWeek: function() {
                        var lastWeekDays = [
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT'
                        ];
                        return lastWeekDays[this.day()];
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: ' ',
                    m: translator.translate,
                    mm: translator.translate,
                    h: translator.translate,
                    hh: translator.translate,
                    d: '',
                    dd: translator.translate,
                    M: '',
                    MM: translator.translate,
                    y: '',
                    yy: translator.translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 104 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Serbian-latin (sr)
        // author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var translator = {
                words: { //Different grammatical cases
                    m: ['jedan minut', 'jedne minute'],
                    mm: ['minut', 'minute', 'minuta'],
                    h: ['jedan sat', 'jednog sata'],
                    hh: ['sat', 'sata', 'sati'],
                    dd: ['dan', 'dana', 'dana'],
                    MM: ['mesec', 'meseca', 'meseci'],
                    yy: ['godina', 'godine', 'godina']
                },
                correctGrammaticalCase: function(number, wordKey) {
                    return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
                },
                translate: function(number, withoutSuffix, key) {
                    var wordKey = translator.words[key];
                    if (key.length === 1) {
                        return withoutSuffix ? wordKey[0] : wordKey[1];
                    } else {
                        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
                    }
                }
            };

            return moment.defineLocale('sr', {
                months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
                monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
                weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'etvrtak', 'petak', 'subota'],
                weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'et.', 'pet.', 'sub.'],
                weekdaysMin: ['ne', 'po', 'ut', 'sr', 'e', 'pe', 'su'],
                longDateFormat: {
                    LT: 'H:mm',
                    L: 'DD. MM. YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY LT',
                    LLLL: 'dddd, D. MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[danas u] LT',
                    nextDay: '[sutra u] LT',

                    nextWeek: function() {
                        switch (this.day()) {
                            case 0:
                                return '[u] [nedelju] [u] LT';
                            case 3:
                                return '[u] [sredu] [u] LT';
                            case 6:
                                return '[u] [subotu] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[u] dddd [u] LT';
                        }
                    },
                    lastDay: '[jue u] LT',
                    lastWeek: function() {
                        var lastWeekDays = [
                            '[prole] [nedelje] [u] LT',
                            '[prolog] [ponedeljka] [u] LT',
                            '[prolog] [utorka] [u] LT',
                            '[prole] [srede] [u] LT',
                            '[prolog] [etvrtka] [u] LT',
                            '[prolog] [petka] [u] LT',
                            '[prole] [subote] [u] LT'
                        ];
                        return lastWeekDays[this.day()];
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'pre %s',
                    s: 'nekoliko sekundi',
                    m: translator.translate,
                    mm: translator.translate,
                    h: translator.translate,
                    hh: translator.translate,
                    d: 'dan',
                    dd: translator.translate,
                    M: 'mesec',
                    MM: translator.translate,
                    y: 'godinu',
                    yy: translator.translate
                },
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 105 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : swedish (sv)
        // author : Jens Alm : https://github.com/ulmus

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('sv', {
                months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
                monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
                weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
                weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
                weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'YYYY-MM-DD',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Idag] LT',
                    nextDay: '[Imorgon] LT',
                    lastDay: '[Igr] LT',
                    nextWeek: 'dddd LT',
                    lastWeek: '[Frra] dddd[en] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'om %s',
                    past: 'fr %s sedan',
                    s: 'ngra sekunder',
                    m: 'en minut',
                    mm: '%d minuter',
                    h: 'en timme',
                    hh: '%d timmar',
                    d: 'en dag',
                    dd: '%d dagar',
                    M: 'en mnad',
                    MM: '%d mnader',
                    y: 'ett r',
                    yy: '%d r'
                },
                ordinal: function(number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'e' :
                        (b === 1) ? 'a' :
                        (b === 2) ? 'a' :
                        (b === 3) ? 'e' : 'e';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 106 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : tamil (ta)
        // author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            /*var symbolMap = {
                    '1': '',
                    '2': '',
                    '3': '',
                    '4': '',
                    '5': '',
                    '6': '',
                    '7': '',
                    '8': '',
                    '9': '',
                    '0': ''
                },
                numberMap = {
                    '': '1',
                    '': '2',
                    '': '3',
                    '': '4',
                    '': '5',
                    '': '6',
                    '': '7',
                    '': '8',
                    '': '9',
                    '': '0'
                }; */

            return moment.defineLocale('ta', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, LT',
                    LLLL: 'dddd, D MMMM YYYY, LT'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[ ] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '  ',
                    m: ' ',
                    mm: '%d ',
                    h: '  ',
                    hh: '%d  ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                /*        preparse: function (string) {
                            return string.replace(/[]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },*/
                ordinal: function(number) {
                    return number + '';
                },


                // refer http://ta.wikipedia.org/s/1er1

                meridiem: function(hour, minute, isLower) {
                    if (hour >= 6 && hour <= 10) {
                        return ' ';
                    } else if (hour >= 10 && hour <= 14) {
                        return ' ';
                    } else if (hour >= 14 && hour <= 18) {
                        return ' ';
                    } else if (hour >= 18 && hour <= 20) {
                        return ' ';
                    } else if (hour >= 20 && hour <= 24) {
                        return ' ';
                    } else if (hour >= 0 && hour <= 6) {
                        return ' ';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 107 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : thai (th)
        // author : Kridsada Thanabulpong : https://github.com/sirn

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('th', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'), // yes, three characters difference
                weekdaysMin: '._._._._._._.'.split('_'),
                longDateFormat: {
                    LT: 'H  m ',
                    L: 'YYYY/MM/DD',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY  LT',
                    LLLL: 'dddd D MMMM YYYY  LT'
                },
                meridiem: function(hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd[ ] LT',
                    lastDay: '[ ] LT',
                    lastWeek: '[]dddd[ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s',
                    s: '',
                    m: '1 ',
                    mm: '%d ',
                    h: '1 ',
                    hh: '%d ',
                    d: '1 ',
                    dd: '%d ',
                    M: '1 ',
                    MM: '%d ',
                    y: '1 ',
                    yy: '%d '
                }
            });
        }));


        /***/
    }),
    /* 108 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Tagalog/Filipino (tl-ph)
        // author : Dan Hagman

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('tl-ph', {
                months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
                monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
                weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
                weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
                weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'MM/D/YYYY',
                    LL: 'MMMM D, YYYY',
                    LLL: 'MMMM D, YYYY LT',
                    LLLL: 'dddd, MMMM DD, YYYY LT'
                },
                calendar: {
                    sameDay: '[Ngayon sa] LT',
                    nextDay: '[Bukas sa] LT',
                    nextWeek: 'dddd [sa] LT',
                    lastDay: '[Kahapon sa] LT',
                    lastWeek: 'dddd [huling linggo] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'sa loob ng %s',
                    past: '%s ang nakalipas',
                    s: 'ilang segundo',
                    m: 'isang minuto',
                    mm: '%d minuto',
                    h: 'isang oras',
                    hh: '%d oras',
                    d: 'isang araw',
                    dd: '%d araw',
                    M: 'isang buwan',
                    MM: '%d buwan',
                    y: 'isang taon',
                    yy: '%d taon'
                },
                ordinal: function(number) {
                    return number;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 109 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : turkish (tr)
        // authors : Erhan Gundogan : https://github.com/erhangundogan,
        //           Burak Yiit Kaya: https://github.com/BYK

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            var suffixes = {
                1: '\'inci',
                5: '\'inci',
                8: '\'inci',
                70: '\'inci',
                80: '\'inci',

                2: '\'nci',
                7: '\'nci',
                20: '\'nci',
                50: '\'nci',

                3: '\'nc',
                4: '\'nc',
                100: '\'nc',

                6: '\'nc',

                9: '\'uncu',
                10: '\'uncu',
                30: '\'uncu',

                60: '\'nc',
                90: '\'nc'
            };

            return moment.defineLocale('tr', {
                months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
                monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
                weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
                weekdaysShort: 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
                weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd, D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[bugn saat] LT',
                    nextDay: '[yarn saat] LT',
                    nextWeek: '[haftaya] dddd [saat] LT',
                    lastDay: '[dn] LT',
                    lastWeek: '[geen hafta] dddd [saat] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s sonra',
                    past: '%s nce',
                    s: 'birka saniye',
                    m: 'bir dakika',
                    mm: '%d dakika',
                    h: 'bir saat',
                    hh: '%d saat',
                    d: 'bir gn',
                    dd: '%d gn',
                    M: 'bir ay',
                    MM: '%d ay',
                    y: 'bir yl',
                    yy: '%d yl'
                },
                ordinal: function(number) {
                    if (number === 0) { // special case for zero
                        return number + '\'nc';
                    }
                    var a = number % 10,
                        b = number % 100 - a,
                        c = number >= 100 ? 100 : null;

                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 110 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Morocco Central Atlas Tamazit in Latin (tzm-latn)
        // author : Abdel Said : https://github.com/abdelsaid

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('tzm-latn', {
                months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
                monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
                weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
                weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
                weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[asdkh g] LT',
                    nextDay: '[aska g] LT',
                    nextWeek: 'dddd [g] LT',
                    lastDay: '[assant g] LT',
                    lastWeek: 'dddd [g] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dadkh s yan %s',
                    past: 'yan %s',
                    s: 'imik',
                    m: 'minu',
                    mm: '%d minu',
                    h: 'saa',
                    hh: '%d tassain',
                    d: 'ass',
                    dd: '%d ossan',
                    M: 'ayowr',
                    MM: '%d iyyirn',
                    y: 'asgas',
                    yy: '%d isgasn'
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 111 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : Morocco Central Atlas Tamazit (tzm)
        // author : Abdel Said : https://github.com/abdelsaid

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('tzm', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'dddd D MMMM YYYY LT'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: 'dddd [] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '   %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d o',
                    M: 'o',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 112 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : ukrainian (uk)
        // author : zemlanin : https://github.com/zemlanin
        // Author : Menelion Elensle : https://github.com/Oire

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            function plural(word, num) {
                var forms = word.split('_');
                return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
            }

            function relativeTimeWithPlural(number, withoutSuffix, key) {
                var format = {
                    'mm': '__',
                    'hh': '__',
                    'dd': '__',
                    'MM': '__',
                    'yy': '__'
                };
                if (key === 'm') {
                    return withoutSuffix ? '' : '';
                } else if (key === 'h') {
                    return withoutSuffix ? '' : '';
                } else {
                    return number + ' ' + plural(format[key], +number);
                }
            }

            function monthsCaseReplace(m, format) {
                var months = {
                        'nominative': '___________'.split('_'),
                        'accusative': '___________'.split('_')
                    },

                    nounCase = (/D[oD]? *MMMM?/).test(format) ?
                    'accusative' :
                    'nominative';

                return months[nounCase][m.month()];
            }

            function weekdaysCaseReplace(m, format) {
                var weekdays = {
                        'nominative': '______'.split('_'),
                        'accusative': '______'.split('_'),
                        'genitive': '______'.split('_')
                    },

                    nounCase = (/(\[[]\]) ?dddd/).test(format) ?
                    'accusative' :
                    ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
                        'genitive' :
                        'nominative');

                return weekdays[nounCase][m.day()];
            }

            function processHoursFunction(str) {
                return function() {
                    return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
                };
            }

            return moment.defineLocale('uk', {
                months: monthsCaseReplace,
                monthsShort: '___________'.split('_'),
                weekdays: weekdaysCaseReplace,
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY .',
                    LLL: 'D MMMM YYYY ., LT',
                    LLLL: 'dddd, D MMMM YYYY ., LT'
                },
                calendar: {
                    sameDay: processHoursFunction('[ '),
                    nextDay: processHoursFunction('[ '),
                    lastDay: processHoursFunction('[ '),
                    nextWeek: processHoursFunction('[] dddd ['),
                    lastWeek: function() {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 5:
                            case 6:
                                return processHoursFunction('[] dddd [').call(this);
                            case 1:
                            case 2:
                            case 4:
                                return processHoursFunction('[] dddd [').call(this);
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: relativeTimeWithPlural,
                    mm: relativeTimeWithPlural,
                    h: '',
                    hh: relativeTimeWithPlural,
                    d: '',
                    dd: relativeTimeWithPlural,
                    M: '',
                    MM: relativeTimeWithPlural,
                    y: '',
                    yy: relativeTimeWithPlural
                },

                // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason

                meridiem: function(hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else {
                        return '';
                    }
                },

                ordinal: function(number, period) {
                    switch (period) {
                        case 'M':
                        case 'd':
                        case 'DDD':
                        case 'w':
                        case 'W':
                            return number + '-';
                        case 'D':
                            return number + '-';
                        default:
                            return number;
                    }
                },

                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 1st is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 113 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : uzbek (uz)
        // author : Sardor Muminov : https://github.com/muminoff

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('uz', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY LT',
                    LLLL: 'D MMMM YYYY, dddd LT'
                },
                calendar: {
                    sameDay: '[ ] LT []',
                    nextDay: '[] LT []',
                    nextWeek: 'dddd [ ] LT []',
                    lastDay: '[ ] LT []',
                    lastWeek: '[] dddd [ ] LT []',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s ',
                    past: '  %s ',
                    s: '',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 114 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : vietnamese (vi)
        // author : Bang Nguyen : https://github.com/bangnk

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('vi', {
                months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
                monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
                weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
                weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
                weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM [nm] YYYY',
                    LLL: 'D MMMM [nm] YYYY LT',
                    LLLL: 'dddd, D MMMM [nm] YYYY LT',
                    l: 'DD/M/YYYY',
                    ll: 'D MMM YYYY',
                    lll: 'D MMM YYYY LT',
                    llll: 'ddd, D MMM YYYY LT'
                },
                calendar: {
                    sameDay: '[Hm nay lc] LT',
                    nextDay: '[Ngy mai lc] LT',
                    nextWeek: 'dddd [tun ti lc] LT',
                    lastDay: '[Hm qua lc] LT',
                    lastWeek: 'dddd [tun ri lc] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ti',
                    past: '%s trc',
                    s: 'vi giy',
                    m: 'mt pht',
                    mm: '%d pht',
                    h: 'mt gi',
                    hh: '%d gi',
                    d: 'mt ngy',
                    dd: '%d ngy',
                    M: 'mt thng',
                    MM: '%d thng',
                    y: 'mt nm',
                    yy: '%d nm'
                },
                ordinal: function(number) {
                    return number;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 115 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : chinese (zh-cn)
        // author : suupic : https://github.com/suupic
        // author : Zeno Zeng : https://github.com/zenozeng

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('zh-cn', {
                months: '___________'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'Ahmm',
                    L: 'YYYY-MM-DD',
                    LL: 'YYYYMMMD',
                    LLL: 'YYYYMMMDLT',
                    LLLL: 'YYYYMMMDddddLT',
                    l: 'YYYY-MM-DD',
                    ll: 'YYYYMMMD',
                    lll: 'YYYYMMMDLT',
                    llll: 'YYYYMMMDddddLT'
                },
                meridiem: function(hour, minute, isLower) {
                    var hm = hour * 100 + minute;
                    if (hm < 600) {
                        return '';
                    } else if (hm < 900) {
                        return '';
                    } else if (hm < 1130) {
                        return '';
                    } else if (hm < 1230) {
                        return '';
                    } else if (hm < 1800) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: function() {
                        return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
                    },
                    nextDay: function() {
                        return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
                    },
                    lastDay: function() {
                        return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
                    },
                    nextWeek: function() {
                        var startOfWeek, prefix;
                        startOfWeek = moment().startOf('week');
                        prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[]' : '[]';
                        return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
                    },
                    lastWeek: function() {
                        var startOfWeek, prefix;
                        startOfWeek = moment().startOf('week');
                        prefix = this.unix() < startOfWeek.unix() ? '[]' : '[]';
                        return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
                    },
                    sameElse: 'LL'
                },
                ordinal: function(number, period) {
                    switch (period) {
                        case 'd':
                        case 'D':
                        case 'DDD':
                            return number + '';
                        case 'M':
                            return number + '';
                        case 'w':
                        case 'W':
                            return number + '';
                        default:
                            return number;
                    }
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '1',
                    mm: '%d',
                    h: '1',
                    hh: '%d',
                    d: '1',
                    dd: '%d',
                    M: '1',
                    MM: '%d',
                    y: '1',
                    yy: '%d'
                },
                week: {
                    // GB/T 7408-1994ISO 8601:1988
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });
        }));


        /***/
    }),
    /* 116 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // moment.js locale configuration
        // locale : traditional chinese (zh-tw)
        // author : Ben : https://github.com/ben-lin

        (function(factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
            } else if (typeof exports === 'object') {
                module.exports = factory(require('../moment')); // Node
            } else {
                factory(window.moment); // Browser global
            }
        }(function(moment) {
            return moment.defineLocale('zh-tw', {
                months: '___________'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'Ahmm',
                    L: 'YYYYMMMD',
                    LL: 'YYYYMMMD',
                    LLL: 'YYYYMMMDLT',
                    LLLL: 'YYYYMMMDddddLT',
                    l: 'YYYYMMMD',
                    ll: 'YYYYMMMD',
                    lll: 'YYYYMMMDLT',
                    llll: 'YYYYMMMDddddLT'
                },
                meridiem: function(hour, minute, isLower) {
                    var hm = hour * 100 + minute;
                    if (hm < 900) {
                        return '';
                    } else if (hm < 1130) {
                        return '';
                    } else if (hm < 1230) {
                        return '';
                    } else if (hm < 1800) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[]LT',
                    nextDay: '[]LT',
                    nextWeek: '[]ddddLT',
                    lastDay: '[]LT',
                    lastWeek: '[]ddddLT',
                    sameElse: 'L'
                },
                ordinal: function(number, period) {
                    switch (period) {
                        case 'd':
                        case 'D':
                        case 'DDD':
                            return number + '';
                        case 'M':
                            return number + '';
                        case 'w':
                        case 'W':
                            return number + '';
                        default:
                            return number;
                    }
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '',
                    mm: '%d',
                    h: '',
                    hh: '%d',
                    d: '',
                    dd: '%d',
                    M: '',
                    MM: '%d',
                    y: '',
                    yy: '%d'
                }
            });
        }));


        /***/
    }),
    /* 117 */
    /***/
    (function(module, exports) {

        module.exports = extend

        var hasOwnProperty = Object.prototype.hasOwnProperty;

        function extend() {
            var target = {}

            for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i]

                for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                        target[key] = source[key]
                    }
                }
            }

            return target
        }


        /***/
    }),
    /* 118 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(2);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(6);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2_html2canvas__ = __webpack_require__(36);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2_html2canvas___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_html2canvas__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3_canvg_rgbcolor__ = __webpack_require__(145);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3_canvg_rgbcolor___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_canvg_rgbcolor__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_4_canvg__ = __webpack_require__(144);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_4_canvg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_canvg__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_5__promise_polyfill__ = __webpack_require__(23);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_6_leaflet__ = __webpack_require__(3);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_6_leaflet___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_leaflet__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js__ = __webpack_require__(35);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_8_moment__ = __webpack_require__(0);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_8_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_moment__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_9_tokml__ = __webpack_require__(172);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_9_tokml___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_tokml__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_10_togpx__ = __webpack_require__(171);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_10_togpx___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_togpx__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_11_file_saver__ = __webpack_require__(146);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_11_file_saver___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_file_saver__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_12_canvas_toBlob__ = __webpack_require__(143);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_12_canvas_toBlob___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_canvas_toBlob__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_13__configs__ = __webpack_require__(5);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_14__query__ = __webpack_require__(13);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_15__nominatim__ = __webpack_require__(139);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_16__ffs__ = __webpack_require__(37);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_17__i18n__ = __webpack_require__(38);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_18__settings__ = __webpack_require__(8);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_19__overpass__ = __webpack_require__(11);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_20__urlParameters__ = __webpack_require__(141);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_21__autorepair__ = __webpack_require__(135);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_22__misc__ = __webpack_require__(7);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_23__sync_with_osm__ = __webpack_require__(140);
        // global ide object




        // polyfill




        // Handler to allow copying in various MIME formats
        // @see https://developer.mozilla.org/en-US/docs/Web/Events/copy
        // @see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent/clipboardData
        var copyData = undefined;
        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document).on("copy", function(e) {
            if (copyData && e.originalEvent && e.originalEvent.clipboardData) {
                Object.keys(copyData).forEach(function(format) {
                    e.originalEvent.clipboardData.setData(format, copyData[format]);
                });
                e.originalEvent.preventDefault();
                copyData = undefined;
            } else if (copyData && copyData["text/plain"]) {
                prompt(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.copy_to_clipboard"), copyData["text/plain"]);
                copyData = null;
            }
        });

        var ide = new function() {
            // == private members ==
            var attribControl = null;
            var scaleControl = null;
            var queryParser = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__query__["a" /* default */ ])();
            var nominatim = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15__nominatim__["a" /* default */ ])();
            // == public members ==
            this.codeEditor = null;
            this.dataViewer = null;
            this.map = null;

            // == helpers ==

            var make_combobox = function(input, options) {
                if (input[0].is_combobox) {
                    input.autocomplete("option", {
                        source: options
                    });
                    return;
                }
                var wrapper = input.wrap("<span>").parent().addClass("ui-combobox");
                input
                    .autocomplete({
                        source: options,
                        minLength: 0
                    })
                    .addClass("ui-widget ui-widget-content ui-corner-left ui-state-default");
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("<a>")
                    .attr("tabIndex", -1)
                    .attr("title", "show all items")
                    .appendTo(wrapper)
                    .button({
                        icons: {
                            primary: "ui-icon-triangle-1-s"
                        },
                        text: false
                    })
                    .removeClass("ui-corner-all")
                    .addClass("ui-corner-right ui-combobox-toggle")
                    .click(function() {
                        // close if already visible
                        if (input.autocomplete("widget").is(":visible")) {
                            input.autocomplete("close");
                            return;
                        }
                        // pass empty string as value to search for, displaying all results
                        input.autocomplete("search", "");
                        input.focus();
                    });
                input[0].is_combobox = true;
            }; // make_combobox()

            // == public sub objects ==

            this.waiter = {
                opened: false,
                frames: "",
                open: function(show_info) {
                    if (show_info) {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".modal .wait-info h4").text(show_info);
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".wait-info").show();
                    } else {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".wait-info").hide();
                    }
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("body").addClass("loading");
                    document.title = ide.waiter.frames[0] + " " + ide.waiter._initialTitle;
                    var f = 0;
                    ide.waiter.interval = setInterval(function() {
                        document.title =
                            ide.waiter.frames[++f % ide.waiter.frames.length] +
                            " " +
                            ide.waiter._initialTitle;
                    }, 250);
                    ide.waiter.opened = true;
                },
                close: function() {
                    clearInterval(ide.waiter.interval);
                    document.title = ide.waiter._initialTitle;
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("body").removeClass("loading");
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".wait-info ul li").remove();
                    delete ide.waiter.onAbort;
                    ide.waiter.opened = false;
                },
                addInfo: function(txt, abortCallback) {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#aborter").remove(); // remove previously added abort button, which cannot be used anymore.
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".wait-info ul li:nth-child(n+1)").css("opacity", 0.5);
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".wait-info ul li span.ui-icon").addClass("ui-icon-check");
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".wait-info ul li:nth-child(n+4)").hide();
                    var li = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        '<li><span class="ui-icon ui-icon-arrowthick-1-e" style="display:inline-block; margin-bottom:-2px; margin-right:3px;"></span>' +
                        txt +
                        "</li>"
                    );
                    if (typeof abortCallback == "function") {
                        ide.waiter.onAbort = abortCallback;
                        var aborter = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                            '<span id="aborter">&nbsp;(<a href="#">abort</a>)</span>'
                        ).on("click", function() {
                            ide.waiter.abort();
                            return false;
                        });
                        li.append(aborter);
                    }
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".wait-info ul").prepend(li);
                },
                abort: function() {
                    if (typeof ide.waiter.onAbort == "function") {
                        ide.waiter.addInfo("aborting");
                        ide.waiter.onAbort(ide.waiter.close);
                    }
                }
            };
            this.waiter._initialTitle = document.title;

            // == public methods ==

            this.init = function() {
                ide.waiter.addInfo("ide starting up");
                // (very raw) compatibility check <- TODO: put this into its own function
                if (
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.support.cors != true ||
                    //typeof localStorage  != "object" ||
                    typeof(function() {
                        var ls = undefined;
                        try {
                            localStorage.setItem("startup_localstorage_quota_test", 123);
                            localStorage.removeItem("startup_localstorage_quota_test");
                            ls = localStorage;
                        } catch (e) {}
                        return ls;
                    })() != "object" ||
                    false
                ) {
                    // the currently used browser is not capable of running the IDE. :(
                    ide.not_supported = true;
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#warning-unsupported-browser").dialog({
                        modal: true
                    });
                }
                // load settings
                ide.waiter.addInfo("load settings");
                __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].load();
                // translate ui
                ide.waiter.addInfo("translate ui");
                var me = this;
                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate().then(function() {
                    initAfterI18n.call(me);
                });

                if (__WEBPACK_IMPORTED_MODULE_23__sync_with_osm__["a" /* default */ ].enabled) {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#load-dialog .osm").show();
                    if (__WEBPACK_IMPORTED_MODULE_23__sync_with_osm__["a" /* default */ ].authenticated()) __WEBPACK_IMPORTED_MODULE_0_jquery___default()("a#logout").show();
                }
            };

            function initAfterI18n() {
                // set up additional libraries
                __WEBPACK_IMPORTED_MODULE_8_moment___default.a.locale(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].getLanguage());
                // parse url string parameters
                ide.waiter.addInfo("parse url parameters");
                var args = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20__urlParameters__["a" /* default */ ])(location.search);
                // set appropriate settings
                if (args.has_coords) {
                    // map center coords set via url
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_lat = args.coords.lat;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_lon = args.coords.lng;
                }
                if (args.has_zoom) {
                    // map zoom set via url
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_zoom = args.zoom;
                }
                if (args.run_query) {
                    // query autorun activated via url
                    ide.run_query_on_startup = true;
                }
                __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save();
                if (typeof history.replaceState == "function")
                    history.replaceState({}, "", "."); // drop startup parameters

                ide.waiter.addInfo("initialize page");
                // init page layout
                var isInitialAspectPortrait = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).width() / __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).height() < 0.8;
                if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width != "" && !isInitialAspectPortrait) {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").css("width", __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width);
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#dataviewer").css("left", __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width);
                }
                if (isInitialAspectPortrait) {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor, #dataviewer").addClass("portrait");
                }
                // make panels resizable
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").resizable({
                    handles: isInitialAspectPortrait ? "s" : "e",
                    minWidth: isInitialAspectPortrait ? undefined : "200",
                    resize: function(ev) {
                        if (!isInitialAspectPortrait) {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).next().css("left", __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).outerWidth() + "px");
                        } else {
                            var top = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).offset().top + __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).outerHeight();
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).next().css("top", top + "px");
                        }
                        ide.map.invalidateSize(false);
                    },
                    stop: function() {
                        if (isInitialAspectPortrait) return;
                        __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").css("width");
                        __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save();
                    }
                });
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").prepend(
                    "<span class='ui-resizable-handle ui-resizable-se ui-icon ui-icon-gripsmall-diagonal-se'/>"
                );

                // init codemirror
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor textarea")[0].value = __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].code["overpass"];
                if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].use_rich_editor) {
                    var pending = 0;
                    __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.defineMIME("text/x-overpassQL", {
                        name: "clike",
                        keywords: (function(str) {
                            var r = {};
                            var a = str.split(" ");
                            for (var i = 0; i < a.length; i++) r[a[i]] = true;
                            return r;
                        })(
                            "out json xml custom popup timeout maxsize bbox" + // initial declarations
                            " date diff adiff" + //attic declarations
                            " foreach" + // block statements
                            " relation rel way node is_in area around user uid newer changed poly pivot" + // queries
                            " out meta body skel tags ids count qt asc" + // actions
                            " center bb geom" // geometry types
                            //+"r w n br bw" // recursors
                        )
                    });
                    __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.defineMIME("text/x-overpassXML", "xml");
                    __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.defineMode("xml+mustache", function(config) {
                        return __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.multiplexingMode(
                            __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.multiplexingMode(__WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.getMode(config, "xml"), {
                                open: "{{",
                                close: "}}",
                                mode: __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.getMode(config, "text/plain"),
                                delimStyle: "mustache"
                            }), {
                                open: "{{style:",
                                close: "}}",
                                mode: __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.getMode(config, "text/css"),
                                delimStyle: "mustache"
                            }
                        );
                    });
                    __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.defineMode("ql+mustache", function(config) {
                        return __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.multiplexingMode(
                            __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.multiplexingMode(
                                __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.getMode(config, "text/x-overpassQL"), {
                                    open: "{{",
                                    close: "}}",
                                    mode: __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.getMode(config, "text/plain"),
                                    delimStyle: "mustache"
                                }
                            ), {
                                open: "{{style:",
                                close: "}}",
                                mode: __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.getMode(config, "text/css"),
                                delimStyle: "mustache"
                            }
                        );
                    });
                    ide.codeEditor = __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default.a.fromTextArea(__WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor textarea")[0], {
                        //value: settings.code["overpass"],
                        lineNumbers: true,
                        lineWrapping: true,
                        mode: "text/plain",
                        onChange: function(e) {
                            clearTimeout(pending);
                            pending = setTimeout(function() {
                                // update syntax highlighting mode
                                if (ide.getQueryLang() == "xml") {
                                    if (e.getOption("mode") != "xml+mustache") {
                                        e.closeTagEnabled = true;
                                        e.setOption("matchBrackets", false);
                                        e.setOption("mode", "xml+mustache");
                                    }
                                } else {
                                    if (e.getOption("mode") != "ql+mustache") {
                                        e.closeTagEnabled = false;
                                        e.setOption("matchBrackets", true);
                                        e.setOption("mode", "ql+mustache");
                                    }
                                }
                                // check for inactive ui elements
                                var bbox_filter = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons-bboxfilter");
                                if (ide.getRawQuery().match(/\{\{bbox\}\}/)) {
                                    if (bbox_filter.hasClass("disabled")) {
                                        bbox_filter.removeClass("disabled");
                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()("span", bbox_filter).css("opacity", 1.0);
                                        bbox_filter.css("cursor", "");
                                        bbox_filter.attr("data-t", "[title]map_controlls.select_bbox");
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate_ui(bbox_filter[0]);
                                    }
                                } else {
                                    if (!bbox_filter.hasClass("disabled")) {
                                        bbox_filter.addClass("disabled");
                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()("span", bbox_filter).css("opacity", 0.5);
                                        bbox_filter.css("cursor", "default");
                                        bbox_filter.attr(
                                            "data-t",
                                            "[title]map_controlls.select_bbox_disabled"
                                        );
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate_ui(bbox_filter[0]);
                                    }
                                }
                            }, 500);
                            __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].code["overpass"] = e.getValue();
                            __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save();
                        },
                        closeTagEnabled: true,
                        closeTagIndent: [
                            "osm-script",
                            "query",
                            "union",
                            "foreach",
                            "difference"
                        ],
                        extraKeys: {
                            "'>'": function(cm) {
                                cm.closeTag(cm, ">");
                            },
                            "'/'": function(cm) {
                                cm.closeTag(cm, "/");
                            }
                        }
                    });
                    // fire onChange after initialization
                    ide.codeEditor.getOption("onChange")(ide.codeEditor);
                } else {
                    // use non-rich editor
                    ide.codeEditor = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor textarea")[0];
                    ide.codeEditor.getValue = function() {
                        return this.value;
                    };
                    ide.codeEditor.setValue = function(v) {
                        this.value = v;
                    };
                    ide.codeEditor.lineCount = function() {
                        return this.value.split(/\r\n|\r|\n/).length;
                    };
                    ide.codeEditor.setLineClass = function() {};
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor textarea").bind("input change", function(e) {
                        __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].code["overpass"] = e.target.getValue();
                        __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save();
                    });
                }
                // set query if provided as url parameter or template:
                if (args.has_query) {
                    // query set via url
                    ide.codeEditor.setValue(args.query);
                }
                // init dataviewer
                ide.dataViewer = __WEBPACK_IMPORTED_MODULE_7_codemirror_lib_codemirror_js___default()(__WEBPACK_IMPORTED_MODULE_0_jquery___default()("#data")[0], {
                    value: "no data loaded yet",
                    lineNumbers: true,
                    readOnly: true,
                    mode: "javascript"
                });

                // init leaflet
                ide.map = new __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Map("map", {
                    attributionControl: false,
                    minZoom: 0,
                    maxZoom: __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].maxMapZoom,
                    worldCopyJump: false
                });
                var tilesUrl = __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].tile_server;
                var tilesAttrib = __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].tileServerAttribution;
                var tiles = new __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.TileLayer(tilesUrl, {
                    attribution: tilesAttrib,
                    noWrap: true,
                    maxNativeZoom: 19,
                    maxZoom: ide.map.options.maxZoom
                });
                attribControl = new __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Control.Attribution({
                    prefix: ""
                });
                attribControl.addAttribution(tilesAttrib);
                var pos = new __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.LatLng(__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_lat, __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_lon);
                ide.map.setView(pos, __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_zoom).addLayer(tiles);
                ide.map.tile_layer = tiles;
                // inverse opacity layer
                ide.map.inv_opacity_layer = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.tileLayer(
                    "data:image/gif;base64,R0lGODlhAQABAIAAAP7//wAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw=="
                ).setOpacity(1 - __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].background_opacity);
                if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].background_opacity != 1)
                    ide.map.inv_opacity_layer.addTo(ide.map);
                scaleControl = new __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Control.Scale({
                    metric: true,
                    imperial: false
                });
                scaleControl.addTo(ide.map);
                ide.map.on("moveend", function() {
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_lat = ide.map.getCenter().lat;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_lon = ide.map.getCenter().lng;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_zoom = ide.map.getZoom();
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save(); // save settings
                });

                // tabs
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#dataviewer > div#data")[0].style.zIndex = -1001;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".tabs a.button").bind("click", function(e) {
                    if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target).hasClass("active")) {
                        return;
                    } else {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#dataviewer > div#data")[0].style.zIndex = -1 * __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#dataviewer > div#data")[0].style.zIndex;
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".tabs a.button").toggleClass("active");
                    }
                });

                //// wait spinner
                //$(document).on({
                //  ajaxStart: function() {
                //    if (!ide.waiter.opened) {
                //      ide.waiter.open();
                //      ide.waiter.ajaxAutoOpened = true;
                //    }
                //  },
                //  ajaxStop: function() {
                //    if (ide.waiter.ajaxAutoOpened) {
                //      ide.waiter.close();
                //      delete ide.waiter.ajaxAutoOpened;
                //    }
                //  },
                //});

                // keyboard event listener
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document).keydown(ide.onKeyPress);

                // leaflet extension: more map controls
                var MapButtons = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Control.extend({
                    options: {
                        position: "topleft"
                    },
                    onAdd: function(map) {
                        // create the control container with a particular class name
                        var container = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomUtil.create(
                            "div",
                            "leaflet-control-buttons leaflet-bar"
                        );
                        var link = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomUtil.create(
                            "a",
                            "leaflet-control-buttons-fitdata leaflet-bar-part leaflet-bar-part-top",
                            container
                        );
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<span class="ui-icon ui-icon-search"/>').appendTo(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(link));
                        link.href = "#";
                        link.className += " t";
                        link.setAttribute("data-t", "[title]map_controlls.zoom_to_data");
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate_ui(link);
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomEvent.addListener(
                            link,
                            "click",
                            function() {
                                // hardcoded maxZoom of 18, should be ok for most real-world use-cases
                                try {
                                    ide.map.fitBounds(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer.getBaseLayer().getBounds(), {
                                        maxZoom: 18
                                    });
                                } catch (e) {}
                                return false;
                            },
                            ide.map
                        );
                        link = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomUtil.create(
                            "a",
                            "leaflet-control-buttons-myloc leaflet-bar-part",
                            container
                        );
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<span class="ui-icon ui-icon-radio-off"/>').appendTo(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(link));
                        link.href = "#";
                        link.className += " t";
                        link.setAttribute("data-t", "[title]map_controlls.localize_user");
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate_ui(link);
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomEvent.addListener(
                            link,
                            "click",
                            function() {
                                // One-shot position request.
                                try {
                                    navigator.geolocation.getCurrentPosition(function(position) {
                                        var pos = new __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.LatLng(
                                            position.coords.latitude,
                                            position.coords.longitude
                                        );
                                        ide.map.setView(pos, __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].coords_zoom);
                                    });
                                } catch (e) {}
                                return false;
                            },
                            ide.map
                        );
                        link = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomUtil.create(
                            "a",
                            "leaflet-control-buttons-bboxfilter leaflet-bar-part",
                            container
                        );
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<span class="ui-icon ui-icon-image"/>').appendTo(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(link));
                        link.href = "#";
                        link.className += " t";
                        link.setAttribute("data-t", "[title]map_controlls.select_bbox");
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate_ui(link);
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomEvent.addListener(
                            link,
                            "click",
                            function(e) {
                                if (
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target).parent().hasClass("disabled") // check if this button is enabled
                                )
                                    return false;
                                if (!ide.map.bboxfilter.isEnabled()) {
                                    ide.map.bboxfilter.setBounds(ide.map.getBounds().pad(-0.2));
                                    ide.map.bboxfilter.enable();
                                } else {
                                    ide.map.bboxfilter.disable();
                                }
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target)
                                    .toggleClass("ui-icon-circlesmall-close")
                                    .toggleClass("ui-icon-image");
                                return false;
                            },
                            ide.map
                        );
                        link = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomUtil.create(
                            "a",
                            "leaflet-control-buttons-fullscreen leaflet-bar-part",
                            container
                        );
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<span class="ui-icon ui-icon-arrowthickstop-1-w"/>').appendTo(
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(link)
                        );
                        link.href = "#";
                        link.className += " t";
                        link.setAttribute("data-t", "[title]map_controlls.toggle_wide_map");
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate_ui(link);
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomEvent.addListener(
                            link,
                            "click",
                            function(e) {
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#dataviewer").toggleClass("fullscreen");
                                ide.map.invalidateSize();
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target)
                                    .toggleClass("ui-icon-arrowthickstop-1-e")
                                    .toggleClass("ui-icon-arrowthickstop-1-w");
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").toggleClass("hidden");
                                if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").resizable("option", "disabled"))
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").resizable("enable");
                                else __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").resizable("disable");
                                return false;
                            },
                            ide.map
                        );
                        link = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomUtil.create(
                            "a",
                            "leaflet-control-buttons-clearoverlay leaflet-bar-part leaflet-bar-part-bottom",
                            container
                        );
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<span class="ui-icon ui-icon-cancel"/>').appendTo(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(link));
                        link.href = "#";
                        link.className += " t";
                        link.setAttribute("data-t", "[title]map_controlls.toggle_data");
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate_ui(link);
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomEvent.addListener(
                            link,
                            "click",
                            function(e) {
                                e.preventDefault();
                                if (ide.map.hasLayer(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer))
                                    ide.map.removeLayer(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer);
                                else ide.map.addLayer(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer);
                                return false;
                            },
                            ide.map
                        );
                        return container;
                    }
                });
                ide.map.addControl(new MapButtons());
                // prevent propagation of doubleclicks on map controls
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons > a").bind("dblclick", function(e) {
                    e.stopPropagation();
                });
                // add tooltips to map controls
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons > a").tooltip({
                    items: "a[title]",
                    hide: {
                        effect: "fadeOut",
                        duration: 100
                    },
                    position: {
                        my: "left+5 center",
                        at: "right center"
                    }
                });
                // leaflet extension: search box
                var SearchBox = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Control.extend({
                    options: {
                        position: "topleft"
                    },
                    onAdd: function(map) {
                        var container = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomUtil.create(
                            "div",
                            "leaflet-control-search ui-widget"
                        );
                        container.style.position = "absolute";
                        container.style.left = "40px";
                        var inp = __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.DomUtil.create("input", "", container);
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                '<span class="ui-icon ui-icon-search" style="position:absolute; right:3px; top:3px; opacity:0.5;"/>'
                            )
                            .click(function(e) {
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).prev().autocomplete("search");
                            })
                            .insertAfter(inp);
                        inp.id = "search";
                        // hack against focus stealing leaflet :/
                        inp.onclick = function() {
                            this.focus();
                        };
                        // prevent propagation of doubleclicks to map container
                        container.ondblclick = function(e) {
                            e.stopPropagation();
                        };
                        // autocomplete functionality
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(inp).autocomplete({
                            source: function(request, response) {
                                // ajax (GET) request to nominatim
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.ajax(
                                    "https://search.osmnames.org/q/" +
                                    encodeURIComponent(request.term) +
                                    ".js?key=" +
                                    __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].osmnamesApiKey, {
                                        success: function(data) {
                                            // hacky firefox hack :( (it is not properly detecting json from the content-type header)
                                            if (typeof data == "string") {
                                                // if the data is a string, but looks more like a json object
                                                try {
                                                    data = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.parseJSON(data);
                                                } catch (e) {}
                                            }
                                            response(
                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.map(data.results.slice(0, 10), function(item) {
                                                    return {
                                                        label: item.display_name,
                                                        value: item.display_name,
                                                        lat: item.lat,
                                                        lon: item.lon,
                                                        boundingbox: item.boundingbox
                                                    };
                                                })
                                            );
                                        },
                                        error: function() {
                                            // todo: better error handling
                                            console.error(
                                                "An error occured while contacting the search server osmnames.org :("
                                            );
                                        }
                                    }
                                );
                            },
                            minLength: 2,
                            autoFocus: true,
                            select: function(event, ui) {
                                if (ui.item.boundingbox && ui.item.boundingbox instanceof Array)
                                    ide.map.fitBounds(
                                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.latLngBounds([
                                            [ui.item.boundingbox[1], ui.item.boundingbox[0]],
                                            [ui.item.boundingbox[3], ui.item.boundingbox[2]]
                                        ]), {
                                            maxZoom: 18
                                        }
                                    );
                                else ide.map.panTo(new __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.LatLng(ui.item.lat, ui.item.lon));
                                this.value = "";
                                return false;
                            },
                            open: function() {
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).removeClass("ui-corner-all").addClass("ui-corner-top");
                            },
                            close: function() {
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).addClass("ui-corner-all").removeClass("ui-corner-top");
                            }
                        });
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(inp).autocomplete("option", "delay", 20);
                        //$(inp).autocomplete().keypress(function(e) {if (e.which==13 || e.which==10) $(this).autocomplete("search");});
                        return container;
                    }
                });
                ide.map.addControl(new SearchBox());
                // add cross hairs to map
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<span class="ui-icon ui-icon-plus" />')
                    .addClass("crosshairs")
                    .hide()
                    .appendTo("#map");
                if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].enable_crosshairs) __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".crosshairs").show();

                ide.map.bboxfilter = new __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.LocationFilter({
                    enable: !true,
                    adjustButton: false,
                    enableButton: false
                }).addTo(ide.map);

                ide.map.on("popupopen popupclose", function(e) {
                    if (typeof e.popup.layer != "undefined") {
                        var layer = e.popup.layer.placeholder || e.popup.layer;
                        // re-call style handler to eventually modify the style of the clicked feature
                        var stl = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer._baseLayer.options.style(
                            layer.feature,
                            e.type == "popupopen"
                        );
                        if (typeof layer.eachLayer != "function") {
                            if (typeof layer.setStyle == "function") layer.setStyle(stl); // other objects (pois, ways)
                        } else
                            layer.eachLayer(function(layer) {
                                if (typeof layer.setStyle == "function") layer.setStyle(stl);
                            }); // for multipolygons!
                    }
                });

                // init overpass object
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].init();

                // event handlers for overpass object
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onProgress"] = function(msg, abortcallback) {
                    ide.waiter.addInfo(msg, abortcallback);
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onDone"] = function() {
                    ide.waiter.close();
                    var map_bounds = ide.map.getBounds();
                    var data_bounds = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer.getBaseLayer().getBounds();
                    if (data_bounds.isValid() && !map_bounds.intersects(data_bounds)) {
                        // show tooltip for button "zoom to data"
                        var prev_content = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons-fitdata").tooltip(
                            "option",
                            "content"
                        );
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons-fitdata").tooltip(
                            "option",
                            "content",
                            " " + __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("map_controlls.suggest_zoom_to_data")
                        );
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons-fitdata").tooltip("open");
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons-fitdata").tooltip("option", "hide", {
                            effect: "fadeOut",
                            duration: 1000
                        });
                        setTimeout(function() {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons-fitdata").tooltip(
                                "option",
                                "content",
                                prev_content
                            );
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons-fitdata").tooltip("close");
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".leaflet-control-buttons-fitdata").tooltip("option", "hide", {
                                effect: "fadeOut",
                                duration: 100
                            });
                        }, 2600);
                    }
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onEmptyMap"] = function(empty_msg, data_mode) {
                    // show warning/info if only invisible data is returned
                    if (empty_msg == "no visible data") {
                        if (!__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].no_autorepair) {
                            var dialog_buttons = {};
                            dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.repair_query")] = function() {
                                ide.repairQuery("no visible data");
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                            };
                            dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.show_data")] = function() {
                                if (
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("input[name=hide_incomplete_data_warning]", this)[0].checked
                                ) {
                                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].no_autorepair = true;
                                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save();
                                }
                                ide.switchTab("Data");
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                            };
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                '<div title="' +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.title") +
                                '"><p>' +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.expl.1") +
                                "</p><p>" +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.expl.2") +
                                '</p><p><input type="checkbox" name="hide_incomplete_data_warning"/>&nbsp;' +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.not_again") +
                                "</p></div>"
                            ).dialog({
                                modal: true,
                                buttons: dialog_buttons
                            });
                        }
                    }
                    // auto tab switching (if only areas are returned)
                    if (empty_msg == "only areas returned") ide.switchTab("Data");
                    // auto tab switching (if nodes without coordinates are returned)
                    if (empty_msg == "no coordinates returned") ide.switchTab("Data");
                    // auto tab switching (if unstructured data is returned)
                    if (data_mode == "unknown") ide.switchTab("Data");
                    // display empty map badge
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        '<div id="map_blank" style="z-index:5; display:block; position:relative; top:42px; width:100%; text-align:center; background-color:#eee; opacity: 0.8;">' +
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("map.intentionally_blank") +
                        " <small>(" +
                        empty_msg +
                        ")</small></div>"
                    ).appendTo("#map");
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onDataRecieved"] = function(
                    amount,
                    amount_txt,
                    abortCB,
                    continueCB
                ) {
                    if (amount > 1000000) {
                        // more than ~1MB of data
                        // show warning dialog
                        var dialog_buttons = {};
                        dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.abort")] = function() {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                            abortCB();
                        };
                        dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.continue_anyway")] = function() {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                            continueCB();
                        };
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                            '<div title="' +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.huge_data.title") +
                            '"><p>' +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ]
                            .t("warning.huge_data.expl.1")
                            .replace("{{amount_txt}}", amount_txt) +
                            "</p><p>" +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.huge_data.expl.2") +
                            "</p></div>"
                        ).dialog({
                            modal: true,
                            buttons: dialog_buttons,
                            dialogClass: "huge_data"
                        });
                    } else continueCB();
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onAbort"] = function() {
                    ide.waiter.close();
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onAjaxError"] = function(errmsg) {
                    // show error dialog
                    var dialog_buttons = {};
                    dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                    };
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        '<div title="' +
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.ajax.title") +
                        '"><p style="color:red;">' +
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.ajax.expl") +
                        "</p>" +
                        errmsg +
                        "</div>"
                    ).dialog({
                        modal: true,
                        buttons: dialog_buttons
                    }); // dialog
                    // print error text, if present
                    if (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].resultText) ide.dataViewer.setValue(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].resultText);
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onQueryError"] = function(errmsg) {
                    var dialog_buttons = {};
                    dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                    };
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        '<div title="' +
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.query.title") +
                        '"><p style="color:red;">' +
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.query.expl") +
                        "</p>" +
                        errmsg +
                        "</div>"
                    ).dialog({
                        modal: true,
                        maxHeight: 600,
                        buttons: dialog_buttons
                    });
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onStyleError"] = function(errmsg) {
                    var dialog_buttons = {};
                    dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                    };
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        '<div title="' +
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.mapcss.title") +
                        '"><p style="color:red;">' +
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.mapcss.expl") +
                        "</p>" +
                        errmsg +
                        "</div>"
                    ).dialog({
                        modal: true,
                        buttons: dialog_buttons
                    });
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onQueryErrorLine"] = function(linenumber) {
                    ide.highlightError(linenumber);
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onRawDataPresent"] = function() {
                    ide.dataViewer.setOption("mode", __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].resultType);
                    ide.dataViewer.setValue(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].resultText);
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onGeoJsonReady"] = function() {
                    // show layer
                    ide.map.addLayer(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer);
                    // autorun callback (e.g. zoom to data)
                    if (typeof ide.run_query_on_startup === "function") {
                        ide.run_query_on_startup();
                    }
                    // display stats
                    if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].show_data_stats) {
                        var stats = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].stats;
                        var stats_txt =
                            "<small>" +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.loaded") +
                            "</small>&nbsp;&ndash;&nbsp;" +
                            "" +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.nodes") +
                            ":&nbsp;" +
                            stats.data.nodes +
                            ", " +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.ways") +
                            ":&nbsp;" +
                            stats.data.ways +
                            ", " +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.relations") +
                            ":&nbsp;" +
                            stats.data.relations +
                            (stats.data.areas > 0 ?
                                ", " + __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.areas") + ":&nbsp;" + stats.data.areas :
                                "") +
                            "<br/>" +
                            "<small>" +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.displayed") +
                            "</small>&nbsp;&ndash;&nbsp;" +
                            "" +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.pois") +
                            ":&nbsp;" +
                            stats.geojson.pois +
                            ", " +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.lines") +
                            ":&nbsp;" +
                            stats.geojson.lines +
                            ", " +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.polygons") +
                            ":&nbsp;" +
                            stats.geojson.polys +
                            "</small>";
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                            '<div id="data_stats" class="stats">' + stats_txt + "</div>"
                        ).insertAfter("#map");
                        // show more stats as a tooltip
                        var backlogOverpass = function() {
                            return __WEBPACK_IMPORTED_MODULE_8_moment___default()(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestamp, __WEBPACK_IMPORTED_MODULE_8_moment___default.a.ISO_8601).fromNow(true);
                            //return Math.round((new Date() - new Date(overpass.timestamp))/1000/60*10)/10;
                        };
                        var backlogOverpassAreas = function() {
                            return __WEBPACK_IMPORTED_MODULE_8_moment___default()(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestampAreas, __WEBPACK_IMPORTED_MODULE_8_moment___default.a.ISO_8601).fromNow(true);
                        };
                        var backlogOverpassExceedsLimit = function() {
                            var now = __WEBPACK_IMPORTED_MODULE_8_moment___default()();
                            var ts = __WEBPACK_IMPORTED_MODULE_8_moment___default()(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestamp, __WEBPACK_IMPORTED_MODULE_8_moment___default.a.ISO_8601);
                            return now.diff(ts, "hours", true) >= 24;
                        };
                        var backlogOverpassAreasExceedsLimit = function() {
                            var now = __WEBPACK_IMPORTED_MODULE_8_moment___default()();
                            var ts = __WEBPACK_IMPORTED_MODULE_8_moment___default()(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestampAreas, __WEBPACK_IMPORTED_MODULE_8_moment___default.a.ISO_8601);
                            return now.diff(ts, "hours", true) >= 96;
                        };
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#data_stats").tooltip({
                            items: "div",
                            tooltipClass: "stats",
                            content: function() {
                                var str = "<div>";
                                if (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestamp) {
                                    str +=
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.lag") +
                                        ": " +
                                        backlogOverpass() +
                                        " <small>" +
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.lag.expl") +
                                        "</small>";
                                }
                                if (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestampAreas) {
                                    str +=
                                        "<br>" +
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.lag_areas") +
                                        ": " +
                                        backlogOverpassAreas() +
                                        " <small>" +
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("data_stats.lag.expl") +
                                        "</small>";
                                }
                                str += "</div>";
                                return str;
                            },
                            hide: {
                                effect: "fadeOut",
                                duration: 100
                            },
                            position: {
                                my: "right bottom-5",
                                at: "right top"
                            }
                        });
                        if (
                            (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestamp && backlogOverpassExceedsLimit()) ||
                            (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestampAreas && backlogOverpassAreasExceedsLimit())
                        ) {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#data_stats").css("background-color", "yellow");
                        }
                    }
                };
                __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].handlers["onPopupReady"] = function(p) {
                    p.openOn(ide.map);
                };

                // close startup waiter
                ide.waiter.close();

                // run the query immediately, if the appropriate flag was set.
                if (ide.run_query_on_startup === true) {
                    ide.update_map();
                    // automatically zoom to data.
                    if (!args.has_coords &&
                        args.has_query &&
                        args.query.match(/\{\{(bbox|center)\}\}/) === null
                    ) {
                        ide.run_query_on_startup = function() {
                            ide.run_query_on_startup = null;
                            // hardcoded maxZoom of 18, should be ok for most real-world use-cases
                            try {
                                ide.map.fitBounds(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer.getBaseLayer().getBounds(), {
                                    maxZoom: 18
                                });
                            } catch (e) {}
                            // todo: zoom only to specific zoomlevel if args.has_zoom is given
                        };
                    }
                }
            } // init()

            // returns the current visible bbox as a bbox-query
            this.map2bbox = function(lang) {
                var bbox;
                if (!ide.map.bboxfilter.isEnabled()) bbox = this.map.getBounds();
                else bbox = ide.map.bboxfilter.getBounds();
                var lat1 = Math.min(Math.max(bbox.getSouthWest().lat, -90), 90);
                var lat2 = Math.min(Math.max(bbox.getNorthEast().lat, -90), 90);
                var lng1 = Math.min(Math.max(bbox.getSouthWest().lng, -180), 180);
                var lng2 = Math.min(Math.max(bbox.getNorthEast().lng, -180), 180);
                if (lang == "OverpassQL")
                    return lat1 + "," + lng1 + "," + lat2 + "," + lng2;
                else if (lang == "xml")
                    return (
                        's="' + lat1 + '" w="' + lng1 + '" n="' + lat2 + '" e="' + lng2 + '"'
                    );
            };
            // returns the current visible map center as a coord-query
            this.map2coord = function(lang) {
                var center = this.map.getCenter();
                if (lang == "OverpassQL") return center.lat + "," + center.lng;
                else if (lang == "xml")
                    return 'lat="' + center.lat + '" lon="' + center.lng + '"';
            };
            this.relativeTime = function(instr, callback) {
                var now = Date.now();
                // very basic differential date
                instr = instr
                    .toLowerCase()
                    .match(
                        /(-?[0-9]+) ?(seconds?|minutes?|hours?|days?|weeks?|months?|years?)?/
                    );
                if (instr === null) {
                    callback(""); // todo: throw an error. do not silently fail
                    return;
                }
                var count = parseInt(instr[1]);
                var interval;
                switch (instr[2]) {
                    case "second":
                    case "seconds":
                        interval = 1;
                        break;
                    case "minute":
                    case "minutes":
                        interval = 60;
                        break;
                    case "hour":
                    case "hours":
                        interval = 3600;
                        break;
                    case "day":
                    case "days":
                    default:
                        interval = 86400;
                        break;
                    case "week":
                    case "weeks":
                        interval = 604800;
                        break;
                    case "month":
                    case "months":
                        interval = 2628000;
                        break;
                    case "year":
                    case "years":
                        interval = 31536000;
                        break;
                }
                var date = now - count * interval * 1000;
                callback(new Date(date).toISOString());
            };

            function onNominatimError(search, type) {
                // close waiter
                ide.waiter.close();
                // highlight error lines
                var query = ide.getRawQuery();
                query = query.split("\n");
                query.forEach(function(line, i) {
                    if (line.indexOf("{{geocode" + type + ":" + search + "}}") !== -1)
                        ide.highlightError(i + 1);
                });
                // show error message dialog
                var dialog_buttons = {};
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                    '<div title="' +
                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.nominatim.title") +
                    '"><p style="color:red;">' +
                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.nominatim.expl") +
                    "</p><p><i>" +
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_22__misc__["a" /* htmlentities */ ])(search) +
                    "</i></p></div>"
                ).dialog({
                    modal: true,
                    buttons: dialog_buttons
                }); // dialog
            }
            this.geocodeId = function(instr, callback) {
                var lang = ide.getQueryLang();

                function filter(n) {
                    return n.osm_type && n.osm_id;
                }
                nominatim.getBest(instr, filter, function(err, res) {
                    if (err) return onNominatimError(instr, "Id");
                    if (lang == "OverpassQL") res = res.osm_type + "(" + res.osm_id + ")";
                    else if (lang == "xml")
                        res = 'type="' + res.osm_type + '" ref="' + res.osm_id + '"';
                    callback(res);
                });
            };
            this.geocodeArea = function(instr, callback) {
                var lang = ide.getQueryLang();

                function filter(n) {
                    return n.osm_type && n.osm_id && n.osm_type !== "node";
                }
                nominatim.getBest(instr, filter, function(err, res) {
                    if (err) return onNominatimError(instr, "Area");
                    var area_ref = 1 * res.osm_id;
                    if (res.osm_type == "way") area_ref += 2400000000;
                    if (res.osm_type == "relation") area_ref += 3600000000;
                    if (lang == "OverpassQL") res = "area(" + area_ref + ")";
                    else if (lang == "xml") res = 'type="area" ref="' + area_ref + '"';
                    callback(res);
                });
            };
            this.geocodeBbox = function(instr, callback) {
                var lang = ide.getQueryLang();
                nominatim.getBest(instr, function(err, res) {
                    if (err) return onNominatimError(instr, "Bbox");
                    var lat1 = Math.min(Math.max(res.boundingbox[0], -90), 90);
                    var lat2 = Math.min(Math.max(res.boundingbox[1], -90), 90);
                    var lng1 = Math.min(Math.max(res.boundingbox[2], -180), 180);
                    var lng2 = Math.min(Math.max(res.boundingbox[3], -180), 180);
                    if (lang == "OverpassQL")
                        res = lat1 + "," + lng1 + "," + lat2 + "," + lng2;
                    else if (lang == "xml")
                        res =
                        's="' + lat1 + '" w="' + lng1 + '" n="' + lat2 + '" e="' + lng2 + '"';
                    callback(res);
                });
            };
            this.geocodeCoords = function(instr, callback) {
                var lang = ide.getQueryLang();
                nominatim.getBest(instr, function(err, res) {
                    if (err) return onNominatimError(instr, "Coords");
                    if (lang == "OverpassQL") res = res.lat + "," + res.lon;
                    else if (lang == "xml")
                        res = 'lat="' + res.lat + '" lon="' + res.lon + '"';
                    callback(res);
                });
            };
            /* this returns the current raw query in the editor.
             * shortcuts are not expanded. */
            this.getRawQuery = function() {
                return ide.codeEditor.getValue();
            };
            /* this returns the current query in the editor.
             * shortcuts are expanded. */
            this.getQuery = function(callback) {
                var query = ide.getRawQuery();
                var queryLang = ide.getQueryLang();
                // parse query and process shortcuts
                // special handling for global bbox in xml queries (which uses an OverpassQL-like notation instead of n/s/e/w parameters):
                query = query.replace(
                    /(\<osm-script[^>]+bbox[^=]*=[^"'']*["'])({{bbox}})(["'])/,
                    "$1{{__bbox__global_bbox_xml__ezs4K8__}}$3"
                );
                var shortcuts = {
                    bbox: ide.map2bbox(queryLang),
                    center: ide.map2coord(queryLang),
                    __bbox__global_bbox_xml__ezs4K8__: ide.map2bbox("OverpassQL"),
                    date: ide.relativeTime,
                    geocodeId: ide.geocodeId,
                    geocodeArea: ide.geocodeArea,
                    geocodeBbox: ide.geocodeBbox,
                    geocodeCoords: ide.geocodeCoords,
                    // legacy
                    nominatimId: queryLang == "xml" ?
                        ide.geocodeId :
                        function(instr, callback) {
                            ide.geocodeId(instr, function(result) {
                                callback(result + ";");
                            });
                        },
                    nominatimArea: queryLang == "xml" ?
                        ide.geocodeArea :
                        function(instr, callback) {
                            ide.geocodeArea(instr, function(result) {
                                callback(result + ";");
                            });
                        },
                    nominatimBbox: ide.geocodeBbox,
                    nominatimCoords: ide.geocodeCoords
                };
                queryParser.parse(query, shortcuts, function(query) {
                    // parse mapcss declarations
                    var mapcss = "";
                    if (queryParser.hasStatement("style"))
                        mapcss = queryParser.getStatement("style");
                    ide.mapcss = mapcss;
                    // parse data-source statements
                    var data_source = null;
                    if (queryParser.hasStatement("data")) {
                        data_source = queryParser.getStatement("data");
                        data_source = data_source.split(",");
                        var data_mode = data_source[0].toLowerCase();
                        data_source = data_source.slice(1);
                        var options = {};
                        for (var i = 0; i < data_source.length; i++) {
                            var tmp = data_source[i].split("=");
                            options[tmp[0]] = tmp[1];
                        }
                        data_source = {
                            mode: data_mode,
                            options: options
                        };
                    }
                    ide.data_source = data_source;
                    // call result callback
                    callback(query);
                });
            };
            this.setQuery = function(query) {
                ide.codeEditor.setValue(query);
            };
            this.getQueryLang = function() {
                if (__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.trim(ide.getRawQuery().replace(/{{.*?}}/g, "")).match(/^</))
                    return "xml";
                else return "OverpassQL";
            };
            /* this is for repairig obvious mistakes in the query, such as missing recurse statements */
            this.repairQuery = function(repair) {
                // - preparations -
                var q = ide.getRawQuery(), // get original query
                    lng = ide.getQueryLang();
                var autorepair = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_21__autorepair__["a" /* default */ ])(q, lng);
                // - repairs -
                if (repair == "no visible data") {
                    // repair missing recurse statements
                    autorepair.recurse();
                } else if (repair == "xml+metadata") {
                    // repair output for OSM editors
                    autorepair.editors();
                }
                // - set repaired query -
                ide.setQuery(autorepair.getQuery());
            };
            this.highlightError = function(line) {
                ide.codeEditor.setLineClass(line - 1, null, "errorline");
            };
            this.resetErrors = function() {
                for (var i = 0; i < ide.codeEditor.lineCount(); i++)
                    ide.codeEditor.setLineClass(i, null, null);
            };

            this.switchTab = function(tab) {
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#navs .tabs a." + tab).click();
            };

            this.loadExample = function(ex) {
                if (typeof __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].saves[ex] != "undefined")
                    ide.setQuery(__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].saves[ex].overpass);
            };
            this.removeExample = function(ex, self) {
                var dialog_buttons = {};
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.delete")] = function() {
                    delete __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].saves[ex];
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save();
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(self).parent().remove();
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.cancel")] = function() {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                    '<div title="' +
                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.delete_query.title") +
                    '"><p><span class="ui-icon ui-icon-alert" style="float:left; margin:1px 7px 20px 0;"></span>' +
                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.delete_query.expl") +
                    ": &quot;<i>" +
                    ex +
                    "</i>&quot;?</p></div>"
                ).dialog({
                    modal: true,
                    buttons: dialog_buttons
                });
            };
            this.removeExampleSync = function(query, self) {
                var dialog_buttons = {};
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.delete")] = function() {
                    __WEBPACK_IMPORTED_MODULE_23__sync_with_osm__["a" /* default */ ].delete(
                        query.name,
                        function(err) {
                            if (err) return console.error(err);

                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(self).parent().remove();
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                        }.bind(this)
                    );
                };
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.cancel")] = function() {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                    '<div title="' +
                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.delete_query.title") +
                    '"><p><span class="ui-icon ui-icon-alert" style="float:left; margin:1px 7px 20px 0;"></span>' +
                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.delete_query.expl-osm") +
                    ": &quot;<i>" +
                    query.name +
                    "</i>&quot;?</p></div>"
                ).dialog({
                    modal: true,
                    buttons: dialog_buttons
                });
            };

            // Event handlers
            this.onLoadClick = function() {
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#load-dialog ul.saved_query, #load-dialog ul.example").html(""); // reset example lists
                // load example list
                var has_saved_query = false;
                for (var example in __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].saves) {
                    var type = __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].saves[example].type;
                    if (type == "template") continue;
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("<li></li>")
                        .append(
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<a href="#">' + example + "</a>").on(
                                "click",
                                (function(example) {
                                    return function() {
                                        ide.loadExample(example);
                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).parents(".ui-dialog-content").dialog("close");
                                        return false;
                                    };
                                })(example)
                            ),
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                '<a href="#" title="' +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("load.delete_query") +
                                '" class="delete-query"><span class="ui-icon ui-icon-close" style="display:inline-block;"/></a>'
                            ).on(
                                "click",
                                (function(example) {
                                    return function() {
                                        ide.removeExample(example, this);
                                        return false;
                                    };
                                })(example)
                            )
                        )
                        .appendTo("#load-dialog ul." + type);
                    if (type == "saved_query") has_saved_query = true;
                }
                if (!has_saved_query)
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("<li>" + __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("load.no_saved_query") + "</li>").appendTo(
                        "#load-dialog ul.saved_query"
                    );
                var dialog_buttons = {};
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.cancel")] = function() {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#load-dialog").dialog({
                    modal: true,
                    buttons: dialog_buttons
                });
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#load-dialog").accordion({
                    beforeActivate: function(event, ui) {
                        if (ui.newHeader.attr("id").slice(-1) == 1) {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("ul", ui.newPanel).html(
                                "<li><i>" + __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("load.saved_queries-osm-loading") + "</i></li>"
                            );

                            __WEBPACK_IMPORTED_MODULE_23__sync_with_osm__["a" /* default */ ].load(function(err, queries) {
                                if (err) {
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("ul", ui.newPanel).html(
                                        "<li><i>" + __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("load.saved_queries-osm-error") + "</i></li>"
                                    );
                                    return console.error(err);
                                }
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("ul", ui.newPanel).html("");
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("a#logout").show();
                                queries.forEach(function(q) {
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("<li></li>")
                                        .append(
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<a href="#">' + q.name + "</a>").on(
                                                "click",
                                                (function(query) {
                                                    return function() {
                                                        ide.setQuery(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_22__misc__["b" /* lzw_decode */ ])(__WEBPACK_IMPORTED_MODULE_22__misc__["c" /* Base64 */ ].decode(query.query)));
                                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).parents(".ui-dialog-content").dialog("close");
                                                        return false;
                                                    };
                                                })(q)
                                            ),
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                                '<a href="#" title="' +
                                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("load.delete_query") +
                                                '" class="delete-query"><span class="ui-icon ui-icon-close" style="display:inline-block;"/></a>'
                                            ).on(
                                                "click",
                                                (function(example) {
                                                    return function() {
                                                        ide.removeExampleSync(example, this);
                                                        return false;
                                                    };
                                                })(q)
                                            )
                                        )
                                        .appendTo("#load-dialog ul.osm");
                                });
                            });
                        }
                    },
                    active: 0,
                    animate: false
                });
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#load-dialog").accordion(
                    "option",
                    "active",
                    __WEBPACK_IMPORTED_MODULE_23__sync_with_osm__["a" /* default */ ].authenticated() ? 1 : has_saved_query ? 0 : 2
                );
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#load-dialog").accordion("option", "animate", true);
            };
            this.onSaveClick = function() {
                // combobox for existing saves.
                var saves_names = new Array();
                for (var key in __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].saves)
                    if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].saves[key].type != "template") saves_names.push(key);
                make_combobox(__WEBPACK_IMPORTED_MODULE_0_jquery___default()("#save-dialog input[name=save]"), saves_names);
                var dialog_buttons = {};
                if (__WEBPACK_IMPORTED_MODULE_23__sync_with_osm__["a" /* default */ ].enabled) {
                    dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.save-osm")] = function() {
                        var self = this;
                        var name = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("input[name=save]", this)[0].value;
                        var query = ide.compose_share_link(ide.getRawQuery(), true).slice(3);
                        __WEBPACK_IMPORTED_MODULE_23__sync_with_osm__["a" /* default */ ].save({
                                name: name,
                                query: query
                            },
                            function(err, new_queries) {
                                if (err) return console.error(err);
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("a#logout").show();
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(self).dialog("close");
                            }
                        );
                    };
                }
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.save-local")] = function() {
                    var name = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("input[name=save]", this)[0].value;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].saves[__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_22__misc__["a" /* htmlentities */ ])(name)] = {
                        overpass: ide.getRawQuery(),
                        type: "saved_query"
                    };
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save();
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.cancel")] = function() {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#save-dialog").dialog({
                    modal: true,
                    buttons: dialog_buttons
                });
            };
            this.onLogoutClick = function() {
                __WEBPACK_IMPORTED_MODULE_23__sync_with_osm__["a" /* default */ ].logout();
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#load-dialog ul.osm").html("");
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("a#logout").hide();
            };
            this.onRunClick = function() {
                ide.update_map();
            };
            this.compose_share_link = function(query, compression, coords, run) {
                var share_link = "";
                if (!compression) {
                    // compose uncompressed share link
                    share_link += "?Q=" + encodeURIComponent(query);
                    if (coords)
                        share_link +=
                        "&C=" +
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getCenter().lat) +
                        ";" +
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getCenter().lng) +
                        ";" +
                        ide.map.getZoom();
                    if (run) share_link += "&R";
                } else {
                    // compose compressed share link
                    share_link +=
                        "?q=" + encodeURIComponent(__WEBPACK_IMPORTED_MODULE_22__misc__["c" /* Base64 */ ].encode(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_22__misc__["d" /* lzw_encode */ ])(query)));
                    if (coords) {
                        var encode_coords = function(lat, lng) {
                            var coords_cpr = __WEBPACK_IMPORTED_MODULE_22__misc__["c" /* Base64 */ ].encodeNum(
                                Math.round((lat + 90) * 100000) +
                                Math.round((lng + 180) * 100000) * 180 * 100000
                            );
                            return "AAAAAAAA".substring(0, 9 - coords_cpr.length) + coords_cpr;
                        };
                        share_link +=
                            "&c=" +
                            encode_coords(ide.map.getCenter().lat, ide.map.getCenter().lng) +
                            __WEBPACK_IMPORTED_MODULE_22__misc__["c" /* Base64 */ ].encodeNum(ide.map.getZoom());
                    }
                    if (run) share_link += "&R";
                }
                return share_link;
            };
            this.updateShareLink = function() {
                var baseurl = location.protocol + "//" + location.host + location.pathname;
                var query = ide.getRawQuery();
                var compress =
                    (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].share_compression == "auto" && query.length > 300) ||
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].share_compression == "on";
                var inc_coords = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog input[name=include_coords]")[0]
                    .checked;
                var run_immediately = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog input[name=run_immediately]")[0]
                    .checked;

                var shared_query = ide.compose_share_link(
                    query,
                    compress,
                    inc_coords,
                    run_immediately
                );
                var share_link = baseurl + shared_query;

                var warning = "";
                if (share_link.length >= 2000)
                    warning = '<p class="warning">' + __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.share.long") + "</p>";
                if (share_link.length >= 4000)
                    warning =
                    '<p class="warning severe">' +
                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.share.very_long") +
                    "</p>";

                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog #share_link_warning").html(warning);

                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog #share_link_a")[0].href = share_link;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog #share_link_textarea")[0].value = share_link;

                // automatically minify urls if enabled
                if (__WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].short_url_service != "") {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.get(
                        __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].short_url_service + encodeURIComponent(share_link),
                        function(data) {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog #share_link_a")[0].href = data;
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog #share_link_textarea")[0].value = data;
                        }
                    );
                }
            };
            this.onShareClick = function() {
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog input[name=include_coords]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].share_include_pos;
                ide.updateShareLink();
                var dialog_buttons = {};
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.done")] = function() {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("div#share-dialog").dialog({
                    modal: true,
                    buttons: dialog_buttons
                });
            };
            this.onExportClick = function() {
                // prepare export dialog
                ide.getQuery(function(query) {
                    var baseurl =
                        location.protocol +
                        "//" +
                        location.host +
                        location.pathname.match(/.*\//)[0];
                    var server = ide.data_source &&
                        ide.data_source.mode == "overpass" &&
                        ide.data_source.options.server ?
                        ide.data_source.options.server :
                        __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].server;
                    var queryWithMapCSS = query;
                    if (queryParser.hasStatement("style"))
                        queryWithMapCSS +=
                        "{{style: " + queryParser.getStatement("style") + " }}";
                    if (queryParser.hasStatement("data"))
                        queryWithMapCSS += "{{data:" + queryParser.getStatement("data") + "}}";
                    else if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].server !== __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].defaultServer)
                        queryWithMapCSS += "{{data:overpass,server=" + __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].server + "}}";
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-interactive-map")[0].href =
                        baseurl + "map.html?Q=" + encodeURIComponent(queryWithMapCSS);
                    // encoding exclamation marks for better command line usability (bash)
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-overpass-api")[0].href =
                        server +
                        "interpreter?data=" +
                        encodeURIComponent(query)
                        .replace(/!/g, "%21")
                        .replace(/\(/g, "%28")
                        .replace(/\)/g, "%29");

                    function toDataURL(text) {
                        return (
                            "data:text/plain;charset=" +
                            (document.characterSet || document.charset) +
                            ";base64," +
                            __WEBPACK_IMPORTED_MODULE_22__misc__["c" /* Base64 */ ].encode(text, true)
                        );
                    }

                    function copyHandler(text) {
                        return function() {
                            copyData = {
                                "text/plain": text
                            };
                            document.execCommand("copy");
                            return false;
                        };
                    }
                    // export query
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text .format").html(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.format_text"));
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text .export").attr({
                        download: "query.txt",
                        target: "_blank",
                        href: toDataURL(query)
                    });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text .copy").attr("href", "").click(copyHandler(query));
                    // export raw query
                    var query_raw = ide.getRawQuery();
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text_raw .format").html(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.format_text_raw"));
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text_raw .export").attr({
                        download: "query-raw.txt",
                        target: "_blank",
                        href: toDataURL(query_raw)
                    });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text_raw .copy")
                        .attr("href", "")
                        .click(copyHandler(query_raw));
                    // export wiki query
                    var query_wiki =
                        "{{OverpassTurboExample|loc=" +
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getCenter().lat) +
                        ";" +
                        __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getCenter().lng) +
                        ";" +
                        ide.map.getZoom() +
                        "|query=\n";
                    query_wiki += query_raw
                        .replace(/{{/g, "mSAvmrw81O8NgWlX")
                        .replace(/{/g, "Z9P563g6zQYzjiLE")
                        .replace(/}}/g, "AtUhvGGxAlM1mP5i")
                        .replace(/}/g, "Yfxw6RTW5lewTqtg")
                        .replace(/mSAvmrw81O8NgWlX/g, "{{((}}")
                        .replace(/Z9P563g6zQYzjiLE/g, "{{(}}")
                        .replace(/AtUhvGGxAlM1mP5i/g, "{{))}}")
                        .replace(/Yfxw6RTW5lewTqtg/g, "{{)}}")
                        .replace(/\|/g, "{{!}}")
                        .replace(/{{!}}{{!}}/g, "{{!!}}");
                    query_wiki += "\n}}";
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text_wiki .format").html(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.format_text_wiki"));
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text_wiki .export").attr({
                        download: "query-wiki.txt",
                        target: "_blank",
                        href: toDataURL(query_wiki)
                    });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-text_wiki .copy")
                        .attr("href", "")
                        .click(copyHandler(query_wiki));

                    var dialog_buttons = {};
                    dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.done")] = function() {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                    };
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-map-state")
                        .unbind("click")
                        .bind("click", function() {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                '<div title="' +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.title") +
                                '">' +
                                "<h4>" +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.permalink") +
                                "</h4>" +
                                '<p><a href="//www.openstreetmap.org/#map=' +
                                ide.map.getZoom() +
                                "/" +
                                __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getCenter().lat) +
                                "/" +
                                __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getCenter().lng) +
                                '" target="_blank">' +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.permalink_osm") +
                                "</a></p>" +
                                "<h4>" +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.center") +
                                "</h4><p>" +
                                __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getCenter().lat) +
                                ", " +
                                __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getCenter().lng) +
                                " <small>(" +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.center_expl") +
                                ")</small></p>" +
                                "<h4>" +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.bounds") +
                                "</h4><p>" +
                                __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getBounds().getSouthWest().lat) +
                                ", " +
                                __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getBounds().getSouthWest().lng) +
                                ", " +
                                __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getBounds().getNorthEast().lat) +
                                ", " +
                                __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(ide.map.getBounds().getNorthEast().lng) +
                                "<br /><small>(" +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.bounds_expl") +
                                ")</small></p>" +
                                (ide.map.bboxfilter.isEnabled() ?
                                    "<h4>" +
                                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.bounds_selection") +
                                    "</h4><p>" +
                                    __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(
                                        ide.map.bboxfilter.getBounds().getSouthWest().lat
                                    ) +
                                    ", " +
                                    __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(
                                        ide.map.bboxfilter.getBounds().getSouthWest().lng
                                    ) +
                                    ", " +
                                    __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(
                                        ide.map.bboxfilter.getBounds().getNorthEast().lat
                                    ) +
                                    ", " +
                                    __WEBPACK_IMPORTED_MODULE_6_leaflet___default.a.Util.formatNum(
                                        ide.map.bboxfilter.getBounds().getNorthEast().lng
                                    ) +
                                    "<br /><small>(" +
                                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.bounds_expl") +
                                    ")</small></p>" :
                                    "") +
                                "<h4>" +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.map_view.zoom") +
                                "</h4><p>" +
                                ide.map.getZoom() +
                                "</p>" +
                                "</div>"
                            ).dialog({
                                modal: true,
                                buttons: dialog_buttons
                            });
                            return false;
                        });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-image")
                        .unbind("click")
                        .on("click", function() {
                            ide.onExportImageClick();
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).parents(".ui-dialog-content").dialog("close");
                            return false;
                        });
                    // GeoJSON format
                    function constructGeojsonString(geojson) {
                        var geoJSON_str;
                        if (!geojson) geoJSON_str = __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.geoJSON.no_data");
                        else {
                            console.log(new Date());
                            var gJ = {
                                type: "FeatureCollection",
                                generator: __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].appname,
                                copyright: __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].copyright,
                                timestamp: __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestamp,
                                features: geojson.features.map(function(feature) {
                                    return {
                                        type: "Feature",
                                        properties: feature.properties,
                                        geometry: feature.geometry
                                    };
                                }) // makes deep copy
                            };
                            gJ.features.forEach(function(f) {
                                var p = f.properties;
                                f.id = p.type + "/" + p.id;
                                f.properties = {
                                    "@id": f.id
                                };
                                // escapes tags beginning with an @ with another @
                                for (var m in p.tags || {})
                                    f.properties[m.replace(/^@/, "@@")] = p.tags[m];
                                for (var m in p.meta || {}) f.properties["@" + m] = p.meta[m];
                                // expose internal properties:
                                // * tainted: indicates that the feature's geometry is incomplete
                                if (p.tainted) f.properties["@tainted"] = p.tainted;
                                // * geometry: indicates that the feature's geometry is approximated via the Overpass geometry types "center" or "bounds"
                                if (p.geometry) f.properties["@geometry"] = p.geometry;
                                // expose relation membership (complex data type)
                                if (p.relations && p.relations.length > 0)
                                    f.properties["@relations"] = p.relations;
                                // todo: expose way membership for nodes?
                            });
                            geoJSON_str = JSON.stringify(gJ, undefined, 2);
                        }
                        return geoJSON_str;
                    }
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-geoJSON .format").text("GeoJSON");
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-geoJSON .export")
                        .attr("href", "")
                        .unbind("click")
                        .on("click", function() {
                            var geoJSON_str = constructGeojsonString(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson);
                            var d = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-geojson-dialog");

                            // make content downloadable as file
                            if (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson) {
                                var blob = new Blob([geoJSON_str], {
                                    type: "application/json;charset=utf-8"
                                });
                                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_file_saver__["saveAs"])(blob, "export.geojson");
                            } else {
                                var dialog_buttons = {};
                                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                };
                                d.dialog({
                                    modal: true,
                                    width: 500,
                                    buttons: dialog_buttons
                                });
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".message", d).text(geoJSON_str);
                            }
                            return false;
                        });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-geoJSON .copy").attr("href", "").click(function() {
                        if (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson) {
                            var geojson = constructGeojsonString(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson);
                            copyData = {
                                "text/plain": geojson,
                                "application/geo+json": geojson
                            };
                            document.execCommand("copy");
                        }
                        return false;
                    });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-geoJSON-gist")
                        .unbind("click")
                        .on("click", function() {
                            var geoJSON_str = constructGeojsonString(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson);
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.ajax("https://api.github.com/gists", {
                                    method: "POST",
                                    data: JSON.stringify({
                                        description: "data exported by overpass turbo", // todo:descr
                                        public: true,
                                        files: {
                                            "overpass.geojson": {
                                                // todo:name
                                                content: geoJSON_str
                                            }
                                        }
                                    })
                                })
                                .success(function(data, textStatus, jqXHR) {
                                    var dialog_buttons = {};
                                    dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.done")] = function() {
                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                    };
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                        '<div title="' +
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.geoJSON_gist.title") +
                                        '">' +
                                        "<p>" +
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.geoJSON_gist.gist") +
                                        '&nbsp;<a href="' +
                                        data.html_url +
                                        '" target="_blank" class="external">' +
                                        data.id +
                                        "</a></p>" +
                                        "<p>" +
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.geoJSON_gist.geojsonio") +
                                        '&nbsp;<a href="http://geojson.io/#id=gist:anonymous/' +
                                        data.id +
                                        '" target="_blank" class="external">' +
                                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.geoJSON_gist.geojsonio_link") +
                                        "</a></p>" +
                                        "</div>"
                                    ).dialog({
                                        modal: true,
                                        buttons: dialog_buttons
                                    });
                                    // data.html_url;
                                })
                                .error(function(jqXHR, textStatus, errorStr) {
                                    alert(
                                        "an error occured during the creation of the overpass gist:\n" +
                                        JSON.stringify(jqXHR)
                                    );
                                });
                            return false;
                        });
                    // GPX format
                    function constructGpxString(geojson) {
                        var gpx_str;
                        if (!geojson) gpx_str = __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.GPX.no_data");
                        else {
                            gpx_str = __WEBPACK_IMPORTED_MODULE_10_togpx___default()(geojson, {
                                creator: __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].appname,
                                metadata: {
                                    copyright: __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].copyright,
                                    desc: "Filtered OSM data converted to GPX by overpass turbo",
                                    time: __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestamp
                                },
                                featureTitle: function(props) {
                                    if (props.tags) {
                                        if (props.tags.name) return props.tags.name;
                                        if (props.tags.ref) return props.tags.ref;
                                        if (props.tags["addr:housenumber"] && props.tags["addr:street"])
                                            return (
                                                props.tags["addr:street"] +
                                                " " +
                                                props.tags["addr:housenumber"]
                                            );
                                    }
                                    return props.type + "/" + props.id;
                                },
                                //featureDescription: function(props) {},
                                featureLink: function(props) {
                                    return "http://osm.org/browse/" + props.type + "/" + props.id;
                                }
                            });
                            if (gpx_str[1] !== "?")
                                gpx_str = '<?xml version="1.0" encoding="UTF-8"?>\n' + gpx_str;
                        }
                        return gpx_str;
                    }
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-GPX .format").text("GPX");
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-GPX .export")
                        .attr("href", "")
                        .unbind("click")
                        .on("click", function() {
                            var geojson = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson;
                            var gpx_str = constructGpxString(geojson);
                            // make content downloadable as file
                            if (geojson) {
                                var blob = new Blob([gpx_str], {
                                    type: "application/xml;charset=utf-8"
                                });
                                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_file_saver__["saveAs"])(blob, "export.gpx");
                            } else {
                                var d = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-gpx-dialog");
                                var dialog_buttons = {};
                                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                };
                                d.dialog({
                                    modal: true,
                                    width: 500,
                                    buttons: dialog_buttons
                                });
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".message", d).text(gpx_str);
                            }
                            return false;
                        });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-GPX .copy").attr("href", "").click(function() {
                        if (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson) {
                            var gpx = constructGpxString(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson);
                            copyData = {
                                "text/plain": gpx,
                                "application/gpx+xml": gpx
                            };
                            document.execCommand("copy");
                        }
                        return false;
                    });
                    // KML format
                    function constructKmlString(geojson) {
                        geojson = geojson && JSON.parse(constructGeojsonString(geojson));
                        if (!geojson) return __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.KML.no_data");
                        else {
                            return __WEBPACK_IMPORTED_MODULE_9_tokml___default()(geojson, {
                                documentName: "overpass-turbo.eu export",
                                documentDescription: "Filtered OSM data converted to KML by overpass turbo.\n" +
                                    "Copyright: " +
                                    __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].copyright +
                                    "\n" +
                                    "Timestamp: " +
                                    __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].timestamp,
                                name: "name",
                                description: "description"
                            });
                        }
                    }
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-KML .format").text("KML");
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-KML .export")
                        .attr("href", "")
                        .unbind("click")
                        .on("click", function() {
                            var geojson = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson;
                            var kml_str = constructKmlString(geojson);
                            // make content downloadable as file
                            if (geojson) {
                                var blob = new Blob([kml_str], {
                                    type: "application/xml;charset=utf-8"
                                });
                                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_file_saver__["saveAs"])(blob, "export.kml");
                            } else {
                                var d = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-kml-dialog");
                                var dialog_buttons = {};
                                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                };
                                d.dialog({
                                    modal: true,
                                    width: 500,
                                    buttons: dialog_buttons
                                });
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".message", d).text(kml_str);
                            }
                            return false;
                        });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-KML .copy").attr("href", "").click(function() {
                        if (__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson) {
                            var kml = constructKmlString(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson);
                            copyData = {
                                "text/plain": kml,
                                "application/vnd.google-earth.kml+xml": kml
                            };
                            document.execCommand("copy");
                        }
                        return false;
                    });
                    // RAW format
                    function constructRawData(geojson) {
                        var raw_str, raw_type;
                        var geojson = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson;
                        if (!geojson) raw_str = __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.raw.no_data");
                        else {
                            var data = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].data;
                            if (data instanceof XMLDocument) {
                                raw_str = new XMLSerializer().serializeToString(data);
                                raw_type = raw_str.match(/<osm/) ? "osm" : "xml";
                            } else if (data instanceof Object) {
                                raw_str = JSON.stringify(data, undefined, 2);
                                raw_type = "json";
                            } else {
                                try {
                                    raw_str = data.toString();
                                } catch (e) {
                                    raw_str = "Error while exporting the data";
                                }
                            }
                        }
                        return {
                            raw_str: raw_str,
                            raw_type: raw_type
                        };
                    }
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-raw .format").text(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.raw_data"));
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-raw .export")
                        .attr("href", "")
                        .unbind("click")
                        .on("click", function() {
                            var geojson = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson;
                            var raw = constructRawData(geojson);
                            var raw_str = raw.raw_str;
                            var raw_type = raw.raw_type;
                            // make content downloadable as file
                            if (geojson) {
                                if (raw_type == "osm" || raw_type == "xml") {
                                    var blob = new Blob([raw_str], {
                                        type: "application/xml;charset=utf-8"
                                    });
                                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_file_saver__["saveAs"])(blob, "export." + raw_type);
                                } else if (raw_type == "json") {
                                    var blob = new Blob([raw_str], {
                                        type: "application/json;charset=utf-8"
                                    });
                                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_file_saver__["saveAs"])(blob, "export.json");
                                } else {
                                    var blob = new Blob([raw_str], {
                                        type: "application/octet-stream;charset=utf-8"
                                    });
                                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_file_saver__["saveAs"])(blob, "export.dat");
                                }
                            } else {
                                var d = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-raw-dialog");
                                var dialog_buttons = {};
                                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                };
                                d.dialog({
                                    modal: true,
                                    width: 500,
                                    buttons: dialog_buttons
                                });
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".message", d).text(raw_str);
                            }
                            return false;
                        });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-raw .copy").attr("href", "").click(function() {
                        var geojson = __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].geojson;
                        if (geojson) {
                            var raw = constructRawData(geojson);
                            var raw_str = raw.raw_str;
                            var raw_type = raw.raw_type;
                            copyData = {
                                "text/plain": raw_str
                            };
                            if (raw_type == "osm" || raw_type == "xml") {
                                copyData["application/xml"] = raw_str;
                            } else if (raw_type == "json") {
                                copyData["application/json"] = raw_str;
                            } else {
                                copyData["application/octet-stream"] = raw_str;
                            }
                            document.execCommand("copy");
                        }
                        return false;
                    });

                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-convert-xml")[0].href =
                        server + "convert?data=" + encodeURIComponent(query) + "&target=xml";
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-convert-ql")[0].href =
                        server + "convert?data=" + encodeURIComponent(query) + "&target=mapql";
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-convert-compact")[0].href =
                        server +
                        "convert?data=" +
                        encodeURIComponent(query) +
                        "&target=compact";

                    // OSM editors
                    // first check for possible mistakes in query.
                    var validEditorQuery = __WEBPACK_IMPORTED_MODULE_21__autorepair__["a" /* default */ ].detect.editors(
                        ide.getRawQuery(),
                        ide.getQueryLang()
                    );
                    // * Level0
                    var exportToLevel0 = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-editors-level0");
                    exportToLevel0.unbind("click");

                    function constructLevel0Link(query) {
                        return (
                            "http://level0.osmz.ru/?url=" +
                            encodeURIComponent(
                                server + "interpreter?data=" + encodeURIComponent(query)
                            )
                        );
                    }
                    if (validEditorQuery) {
                        exportToLevel0[0].href = constructLevel0Link(query);
                    } else {
                        exportToLevel0[0].href = "";
                        exportToLevel0.bind("click", function() {
                            var dialog_buttons = {};
                            dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.repair_query")] = function() {
                                ide.repairQuery("xml+metadata");
                                var message_dialog = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this);
                                ide.getQuery(function(query) {
                                    exportToLevel0.unbind("click");
                                    exportToLevel0[0].href = constructLevel0Link(query);
                                    message_dialog.dialog("close");
                                });
                            };
                            dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.continue_anyway")] = function() {
                                exportToLevel0.unbind("click");
                                exportToLevel0[0].href = constructLevel0Link(query);
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                            };
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                '<div title="' +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.title") +
                                '"><p>' +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.remote.expl.1") +
                                "</p><p>" +
                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.remote.expl.2") +
                                "</p></div>"
                            ).dialog({
                                modal: true,
                                buttons: dialog_buttons
                            });
                            return false;
                        });
                    }
                    // * JOSM
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog a#export-editors-josm")
                        .unbind("click")
                        .on("click", function() {
                            var export_dialog = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).parents("div.ui-dialog-content").first();
                            var send_to_josm = function(query) {
                                var JRC_url = "http://127.0.0.1:8111/";
                                if (location.protocol === "https:")
                                    JRC_url = "https://127.0.0.1:8112/";
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.getJSON(JRC_url + "version")
                                    .success(function(d, s, xhr) {
                                        if (d.protocolversion.major == 1) {
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.get(JRC_url + "import", {
                                                    // JOSM doesn't handle protocol-less links very well
                                                    url: server.replace(/^\/\//, location.protocol + "//") +
                                                        "interpreter?data=" +
                                                        encodeURIComponent(query)
                                                })
                                                .error(function(xhr, s, e) {
                                                    alert("Error: Unexpected JOSM remote control error.");
                                                })
                                                .success(function(d, s, xhr) {
                                                    console.log("successfully invoked JOSM remote constrol");
                                                });
                                        } else {
                                            var dialog_buttons = {};
                                            dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                            };
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                                '<div title="' +
                                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.remote.title") +
                                                '"><p>' +
                                                __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.remote.incompat") +
                                                ": " +
                                                d.protocolversion.major +
                                                "." +
                                                d.protocolversion.minor +
                                                " :(</p></div>"
                                            ).dialog({
                                                modal: true,
                                                width: 350,
                                                buttons: dialog_buttons
                                            });
                                        }
                                    })
                                    .error(function(xhr, s, e) {
                                        var dialog_buttons = {};
                                        dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.dismiss")] = function() {
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                        };
                                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                            '<div title="' +
                                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.remote.title") +
                                            '"><p>' +
                                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("error.remote.not_found") +
                                            "</p></div>"
                                        ).dialog({
                                            modal: true,
                                            width: 350,
                                            buttons: dialog_buttons
                                        });
                                    });
                            };
                            // first check for possible mistakes in query.
                            var valid = __WEBPACK_IMPORTED_MODULE_21__autorepair__["a" /* default */ ].detect.editors(
                                ide.getRawQuery(),
                                ide.getQueryLang()
                            );
                            if (valid) {
                                // now send the query to JOSM via remote control
                                send_to_josm(query);
                                return false;
                            } else {
                                var dialog_buttons = {};
                                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.repair_query")] = function() {
                                    ide.repairQuery("xml+metadata");
                                    var message_dialog = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this);
                                    ide.getQuery(function(query) {
                                        send_to_josm(query);
                                        message_dialog.dialog("close");
                                        export_dialog.dialog("close");
                                    });
                                };
                                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.continue_anyway")] = function() {
                                    send_to_josm(query);
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                    export_dialog.dialog("close");
                                };
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                                    '<div title="' +
                                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.title") +
                                    '"><p>' +
                                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.remote.expl.1") +
                                    "</p><p>" +
                                    __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("warning.incomplete.remote.expl.2") +
                                    "</p></div>"
                                ).dialog({
                                    modal: true,
                                    buttons: dialog_buttons
                                });
                                return false;
                            }
                        });
                    // open the export dialog
                    var dialog_buttons = {};
                    dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.done")] = function() {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                    };
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog").dialog({
                        modal: true,
                        width: 350,
                        buttons: dialog_buttons
                    });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export-dialog").accordion();
                });
            };
            this.onExportImageClick = function() {
                ide.waiter.open(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("waiter.export_as_image"));
                // 1. render canvas from map tiles
                // hide map controlls in this step :/
                // todo: also hide popups?
                ide.waiter.addInfo("prepare map");
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#map .leaflet-control-container .leaflet-top").hide();
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#data_stats").hide();
                if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_attribution) attribControl.addTo(ide.map);
                if (!__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_scale) scaleControl.removeFrom(ide.map);
                // try to use crossOrigin image loading. osm tiles should be served with the appropriate headers -> no need of bothering the proxy
                ide.waiter.addInfo("rendering map tiles");
                __WEBPACK_IMPORTED_MODULE_2_html2canvas___default()(document.getElementById("map"), {
                    useCORS: true,
                    allowTaint: false,
                    proxy: __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].html2canvas_use_proxy ? "/html2canvas_proxy/" : undefined, // use own proxy if necessary and available
                    onrendered: function(canvas) {
                        if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_attribution)
                            attribControl.removeFrom(ide.map);
                        if (!__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_scale) scaleControl.addTo(ide.map);
                        if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].show_data_stats) __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#data_stats").show();
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#map .leaflet-control-container .leaflet-top").show();
                        ide.waiter.addInfo("rendering map data");
                        // 2. render overlay data onto canvas
                        canvas.id = "render_canvas";
                        var ctx = canvas.getContext("2d");
                        // get geometry for svg rendering
                        var height = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#map .leaflet-overlay-pane svg").height();
                        var width = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#map .leaflet-overlay-pane svg").width();
                        var tmp = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#map .leaflet-map-pane")[0].style.cssText.match(
                            /.*?(-?\d+)px.*?(-?\d+)px.*/
                        );
                        var offx = +tmp[1];
                        var offy = +tmp[2];
                        if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()("#map .leaflet-overlay-pane").html().length > 0)
                            ctx.drawSvg(
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#map .leaflet-overlay-pane").html(),
                                offx,
                                offy,
                                width,
                                height
                            );
                        ide.waiter.addInfo("converting to png image");
                        // 3. export canvas as html image
                        var imgstr = canvas.toDataURL("image/png");
                        var attrib_message = "";
                        if (!__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_attribution)
                            attrib_message =
                            '<p style="font-size:smaller; color:orange;">Make sure to include proper attributions when distributing this image!</p>';
                        var dialog_buttons = {};
                        dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.done")] = function() {
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                            // free dialog from DOM
                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#export_image_dialog").remove();
                        };
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                            '<div title="' +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.image.title") +
                            '" id="export_image_dialog"><p><img src="' +
                            imgstr +
                            '" alt="' +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.image.alt") +
                            '" width="480px"/><br><!--<a href="' +
                            imgstr +
                            '" download="export.png" target="_blank">' +
                            __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("export.image.download") +
                            "</a>--></p>" +
                            attrib_message +
                            "</div>"
                        ).dialog({
                            modal: true,
                            width: 500,
                            position: ["center", 60],
                            open: function() {
                                // close progress indicator
                                ide.waiter.close();
                            },
                            buttons: dialog_buttons
                        });
                        canvas.toBlob(function(blob) {
                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_file_saver__["saveAs"])(blob, "export.png");
                        });
                    }
                });
            };
            this.onFfsClick = function() {
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-parse-error").hide();
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-typo").hide();
                var build_query = function(autorun) {
                    // build query and run it immediately
                    ide.update_ffs_query(
                        undefined,
                        function(err, ffs_result) {
                            if (!err) {
                                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                                if (autorun !== false) ide.onRunClick();
                            } else {
                                if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(ffs_result)) {
                                    // show parse error message
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-parse-error").hide();
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-typo").show();
                                    var correction = ffs_result.join("");
                                    var correction_html = ffs_result
                                        .map(function(ffs_result_part, i) {
                                            if (i % 2 === 1) return "<b>" + ffs_result_part + "</b>";
                                            else return ffs_result_part;
                                        })
                                        .join("");
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-typo-correction").html(
                                        correction_html
                                    );
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-typo-correction")
                                        .unbind("click")
                                        .bind("click", function(e) {
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog input[type=text]").val(correction);
                                            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).parent().hide();
                                            e.preventDefault();
                                        });
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-typo").effect(
                                        "shake", {
                                            direction: "right",
                                            distance: 10,
                                            times: 2
                                        },
                                        300
                                    );
                                } else {
                                    // show parse error message
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-typo").hide();
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-parse-error").show();
                                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog #ffs-dialog-parse-error").effect(
                                        "shake", {
                                            direction: "right",
                                            distance: 10,
                                            times: 2
                                        },
                                        300
                                    );
                                }
                            }
                        }.bind(this)
                    );
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog input[type=text]")
                    .unbind("keypress")
                    .bind("keypress", function(e) {
                        if (e.which == 13 || e.which == 10) {
                            build_query.bind(this.parentElement.parentElement)();
                            e.preventDefault();
                        }
                    });
                var dialog_buttons = {};
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.wizard_build")] = function() {
                    build_query.bind(this, false)();
                };
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.wizard_run")] = build_query;
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.cancel")] = function() {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog").dialog({
                    modal: true,
                    minWidth: 350,
                    buttons: dialog_buttons
                });
            };
            this.onSettingsClick = function() {
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=ui_language]")[0].value =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].ui_language;
                var lngDescs = __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].getSupportedLanguagesDescriptions();
                make_combobox(
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=ui_language]"), ["auto"].concat(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].getSupportedLanguages()).map(function(lng) {
                        return {
                            value: lng,
                            label: lng == "auto" ? "auto" : lng + " - " + lngDescs[lng]
                        };
                    })
                );
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=server]")[0].value = __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].server;
                make_combobox(
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=server]"),
                    __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].suggestedServers
                );
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=force_simple_cors_request]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].force_simple_cors_request;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=no_autorepair]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].no_autorepair;
                // editor options
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=use_rich_editor]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].use_rich_editor;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=editor_width]")[0].value =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width;
                // sharing options
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=share_include_pos]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].share_include_pos;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=share_compression]")[0].value =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].share_compression;
                make_combobox(__WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=share_compression]"), [
                    "auto",
                    "on",
                    "off"
                ]);
                // map settings
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=tile_server]")[0].value =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].tile_server;
                make_combobox(
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=tile_server]"),
                    __WEBPACK_IMPORTED_MODULE_13__configs__["a" /* default */ ].suggestedTiles
                );
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=background_opacity]")[0].value =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].background_opacity;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=enable_crosshairs]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].enable_crosshairs;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=disable_poiomatic]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].disable_poiomatic;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=show_data_stats]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].show_data_stats;
                // export settings
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=export_image_scale]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_scale;
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=export_image_attribution]")[0].checked =
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_attribution;
                // open dialog
                var dialog_buttons = {};
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.save")] = function() {
                    // save settings
                    var new_ui_language = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=ui_language]")[0]
                        .value;
                    // reload ui if language has been changed
                    if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].ui_language != new_ui_language) {
                        __WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].translate(new_ui_language);
                        __WEBPACK_IMPORTED_MODULE_8_moment___default.a.locale(new_ui_language);
                        __WEBPACK_IMPORTED_MODULE_16__ffs__["a" /* default */ ].invalidateCache();
                    }
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].ui_language = new_ui_language;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].server = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog input[name=server]")[0].value;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].force_simple_cors_request = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=force_simple_cors_request]"
                    )[0].checked;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].no_autorepair = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=no_autorepair]"
                    )[0].checked;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].use_rich_editor = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=use_rich_editor]"
                    )[0].checked;
                    var prev_editor_width = __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=editor_width]"
                    )[0].value;
                    // update editor width (if changed)
                    if (prev_editor_width != __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width) {
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#editor").css("width", __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width);
                        __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#dataviewer").css("left", __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].editor_width);
                    }
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].share_include_pos = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=share_include_pos]"
                    )[0].checked;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].share_compression = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=share_compression]"
                    )[0].value;
                    var prev_tile_server = __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].tile_server;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].tile_server = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=tile_server]"
                    )[0].value;
                    // update tile layer (if changed)
                    if (prev_tile_server != __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].tile_server)
                        ide.map.tile_layer.setUrl(__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].tile_server);
                    var prev_background_opacity = __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].background_opacity;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].background_opacity = +__WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=background_opacity]"
                    )[0].value;
                    // update background opacity layer
                    if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].background_opacity != prev_background_opacity)
                        if (__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].background_opacity == 1)
                            ide.map.removeLayer(ide.map.inv_opacity_layer);
                        else
                            ide.map.inv_opacity_layer
                            .setOpacity(1 - __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].background_opacity)
                            .addTo(ide.map);
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].enable_crosshairs = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=enable_crosshairs]"
                    )[0].checked;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].disable_poiomatic = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=disable_poiomatic]"
                    )[0].checked;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].show_data_stats = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=show_data_stats]"
                    )[0].checked;
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".crosshairs").toggle(__WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].enable_crosshairs); // show/hide crosshairs
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_scale = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=export_image_scale]"
                    )[0].checked;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].export_image_attribution = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(
                        "#settings-dialog input[name=export_image_attribution]"
                    )[0].checked;
                    __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].save();
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog").dialog({
                    modal: true,
                    width: 400,
                    buttons: dialog_buttons
                });
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#settings-dialog").accordion();
            };
            this.onHelpClick = function() {
                var dialog_buttons = {};
                dialog_buttons[__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("dialog.close")] = function() {
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).dialog("close");
                };
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#help-dialog").dialog({
                    modal: false,
                    width: 450,
                    buttons: dialog_buttons
                });
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#help-dialog").accordion({
                    heightStyle: "content"
                });
            };
            this.onKeyPress = function(event) {
                if (
                    (event.which == 120 && event.charCode == 0) || // F9
                    ((event.which == 13 || event.which == 10) &&
                        (event.ctrlKey || event.metaKey))
                ) {
                    // Ctrl+Enter
                    ide.onRunClick(); // run query
                    event.preventDefault();
                }
                if (
                    String.fromCharCode(event.which).toLowerCase() == "s" &&
                    (event.ctrlKey || event.metaKey) &&
                    !event.shiftKey &&
                    !event.altKey
                ) {
                    // Ctrl+S
                    ide.onSaveClick();
                    event.preventDefault();
                }
                if (
                    String.fromCharCode(event.which).toLowerCase() == "o" &&
                    (event.ctrlKey || event.metaKey) &&
                    !event.shiftKey &&
                    !event.altKey
                ) {
                    // Ctrl+O
                    ide.onLoadClick();
                    event.preventDefault();
                }
                if (
                    String.fromCharCode(event.which).toLowerCase() == "h" &&
                    (event.ctrlKey || event.metaKey) &&
                    !event.shiftKey &&
                    !event.altKey
                ) {
                    // Ctrl+H
                    ide.onHelpClick();
                    event.preventDefault();
                }
                if (
                    (String.fromCharCode(event.which).toLowerCase() == "i" &&
                        (event.ctrlKey || event.metaKey) &&
                        !event.shiftKey &&
                        !event.altKey) || // Ctrl+I
                    (String.fromCharCode(event.which).toLowerCase() == "f" &&
                        (event.ctrlKey || event.metaKey) &&
                        event.shiftKey &&
                        !event.altKey)
                ) {
                    // Ctrl+Shift+F
                    ide.onFfsClick();
                    event.preventDefault();
                }
                // todo: more shortcuts
            };
            this.update_map = function() {
                ide.waiter.open(__WEBPACK_IMPORTED_MODULE_17__i18n__["a" /* default */ ].t("waiter.processing_query"));
                ide.waiter.addInfo("resetting map");
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#data_stats").remove();
                // resets previously highlighted error lines
                this.resetErrors();
                // reset previously loaded data and overlay
                ide.dataViewer.setValue("");
                if (typeof __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer != "undefined")
                    ide.map.removeLayer(__WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].osmLayer);
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#map_blank").remove();

                ide.waiter.addInfo("building query");
                // run the query via the overpass object
                ide.getQuery(function(query) {
                    var query_lang = ide.getQueryLang();
                    var server = ide.data_source &&
                        ide.data_source.mode == "overpass" &&
                        ide.data_source.options.server ?
                        ide.data_source.options.server :
                        __WEBPACK_IMPORTED_MODULE_18__settings__["a" /* default */ ].server;
                    __WEBPACK_IMPORTED_MODULE_19__overpass__["a" /* default */ ].run_query(
                        query,
                        query_lang,
                        undefined,
                        undefined,
                        server,
                        ide.mapcss
                    );
                });
            };
            this.update_ffs_query = function(s, callback) {
                var search = s || __WEBPACK_IMPORTED_MODULE_0_jquery___default()("#ffs-dialog input[type=text]").val();
                __WEBPACK_IMPORTED_MODULE_16__ffs__["a" /* default */ ].construct_query(
                    search,
                    undefined,
                    function(err, query) {
                        if (err) {
                            __WEBPACK_IMPORTED_MODULE_16__ffs__["a" /* default */ ].repair_search(
                                search,
                                function(repaired) {
                                    if (repaired) {
                                        callback("repairable query", repaired);
                                    } else {
                                        if (s) return callback(true);
                                        // try to parse as generic ffs search
                                        this.update_ffs_query('"' + search + '"', callback);
                                    }
                                }.bind(this)
                            );
                        } else {
                            ide.setQuery(query);
                            callback(null);
                        }
                    }.bind(this)
                );
            };
        }(); // end create ide object

        /* harmony default export */
        __webpack_exports__["a"] = (ide);


        /***/
    }),
    /* 119 */
    /***/
    (function(module, exports) {

        /**
         * Tag-closer extension for CodeMirror.
         *
         * This extension adds a "closeTag" utility function that can be used with key bindings to 
         * insert a matching end tag after the ">" character of a start tag has been typed.  It can
         * also complete "</" if a matching start tag is found.  It will correctly ignore signal
         * characters for empty tags, comments, CDATA, etc.
         *
         * The function depends on internal parser state to identify tags.  It is compatible with the
         * following CodeMirror modes and will ignore all others:
         * - htmlmixed
         * - xml
         *
         * See demos/closetag.html for a usage example.
         * 
         * @author Nathan Williams <nathan@nlwillia.net>
         * Contributed under the same license terms as CodeMirror.
         */
        (function() {
            /** Option that allows tag closing behavior to be toggled.  Default is true. */
            CodeMirror.defaults['closeTagEnabled'] = true;

            /** Array of tag names to add indentation after the start tag for.  Default is the list of block-level html tags. */
            CodeMirror.defaults['closeTagIndent'] = ['applet', 'blockquote', 'body', 'button', 'div', 'dl', 'fieldset', 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'html', 'iframe', 'layer', 'legend', 'object', 'ol', 'p', 'select', 'table', 'ul'];

            /** Array of tag names where an end tag is forbidden. */
            CodeMirror.defaults['closeTagVoid'] = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

            function innerXMLState(cm, state) {
                var inner = CodeMirror.innerMode(cm.getMode(), state);
                if (inner.mode.name == "xml") return inner.state;
            }


            /**
             * Call during key processing to close tags.  Handles the key event if the tag is closed, otherwise throws CodeMirror.Pass.
             * - cm: The editor instance.
             * - ch: The character being processed.
             * - indent: Optional.  An array of tag names to indent when closing.  Omit or pass true to use the default indentation tag list defined in the 'closeTagIndent' option.
             *   Pass false to disable indentation.  Pass an array to override the default list of tag names.
             * - vd: Optional.  An array of tag names that should not be closed.  Omit to use the default void (end tag forbidden) tag list defined in the 'closeTagVoid' option.  Ignored in xml mode.
             */
            CodeMirror.defineExtension("closeTag", function(cm, ch, indent, vd) {
                if (!cm.getOption('closeTagEnabled')) {
                    throw CodeMirror.Pass;
                }

                /*
                 * Relevant structure of token:
                 *
                 * htmlmixed
                 *      className
                 *      state
                 *          htmlState
                 *              type
                 *              tagName
                 *              context
                 *                  tagName
                 *          mode
                 * 
                 * xml
                 *      className
                 *      state
                 *          tagName
                 *          type
                 */

                var pos = cm.getCursor();
                var tok = cm.getTokenAt(pos);
                var state = innerXMLState(cm, tok.state);

                if (state) {

                    if (ch == '>') {
                        var type = state.type;

                        if (tok.className == 'tag' && type == 'closeTag') {
                            throw CodeMirror.Pass; // Don't process the '>' at the end of an end-tag.
                        }

                        cm.replaceSelection('>'); // Mode state won't update until we finish the tag.
                        pos = {
                            line: pos.line,
                            ch: pos.ch + 1
                        };
                        cm.setCursor(pos);

                        tok = cm.getTokenAt(cm.getCursor());
                        state = innerXMLState(cm, tok.state);
                        if (!state) throw CodeMirror.Pass;
                        var type = state.type;

                        if (tok.className == 'tag' && type != 'selfcloseTag') {
                            var tagName = state.tagName;
                            if (tagName.length > 0 && shouldClose(cm, vd, tagName)) {
                                insertEndTag(cm, indent, pos, tagName);
                            }
                            return;
                        }

                        // Undo the '>' insert and allow cm to handle the key instead.
                        cm.setSelection({
                            line: pos.line,
                            ch: pos.ch - 1
                        }, pos);
                        cm.replaceSelection("");

                    } else if (ch == '/') {
                        if (tok.className == 'tag' && tok.string == '<') {
                            var ctx = state.context,
                                tagName = ctx ? ctx.tagName : '';
                            if (tagName.length > 0) {
                                completeEndTag(cm, pos, tagName);
                                return;
                            }
                        }
                    }

                }

                throw CodeMirror.Pass; // Bubble if not handled
            });

            function insertEndTag(cm, indent, pos, tagName) {
                if (shouldIndent(cm, indent, tagName)) {
                    cm.replaceSelection('\n\n</' + tagName + '>', 'end');
                    cm.indentLine(pos.line + 1);
                    cm.indentLine(pos.line + 2);
                    cm.setCursor({
                        line: pos.line + 1,
                        ch: cm.getLine(pos.line + 1).length
                    });
                } else {
                    cm.replaceSelection('</' + tagName + '>');
                    cm.setCursor(pos);
                }
            }

            function shouldIndent(cm, indent, tagName) {
                if (typeof indent == 'undefined' || indent == null || indent == true) {
                    indent = cm.getOption('closeTagIndent');
                }
                if (!indent) {
                    indent = [];
                }
                return indexOf(indent, tagName.toLowerCase()) != -1;
            }

            function shouldClose(cm, vd, tagName) {
                if (cm.getOption('mode') == 'xml') {
                    return true; // always close xml tags
                }
                if (typeof vd == 'undefined' || vd == null) {
                    vd = cm.getOption('closeTagVoid');
                }
                if (!vd) {
                    vd = [];
                }
                return indexOf(vd, tagName.toLowerCase()) == -1;
            }

            // C&P from codemirror.js...would be nice if this were visible to utilities.
            function indexOf(collection, elt) {
                if (collection.indexOf) return collection.indexOf(elt);
                for (var i = 0, e = collection.length; i < e; ++i)
                    if (collection[i] == elt) return i;
                return -1;
            }

            function completeEndTag(cm, pos, tagName) {
                cm.replaceSelection('/' + tagName + '>');
                cm.setCursor({
                    line: pos.line,
                    ch: pos.ch + tagName.length + 2
                });
            }

        })();


        /***/
    }),
    /* 120 */
    /***/
    (function(module, exports) {

        CodeMirror.multiplexingMode = function(outer /*, others */ ) {
            // Others should be {open, close, mode [, delimStyle]} objects
            var others = Array.prototype.slice.call(arguments, 1);
            var n_others = others.length;

            function indexOf(string, pattern, from) {
                if (typeof pattern == "string") return string.indexOf(pattern, from);
                var m = pattern.exec(from ? string.slice(from) : string);
                return m ? m.index + from : -1;
            }

            return {
                startState: function() {
                    return {
                        outer: CodeMirror.startState(outer),
                        innerActive: null,
                        inner: null
                    };
                },

                copyState: function(state) {
                    return {
                        outer: CodeMirror.copyState(outer, state.outer),
                        innerActive: state.innerActive,
                        inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)
                    };
                },

                token: function(stream, state) {
                    if (!state.innerActive) {
                        var cutOff = Infinity,
                            oldContent = stream.string;
                        for (var i = 0; i < n_others; ++i) {
                            var other = others[i];
                            var found = indexOf(oldContent, other.open, stream.pos);
                            if (found == stream.pos) {
                                stream.match(other.open);
                                state.innerActive = other;
                                state.inner = CodeMirror.startState(other.mode, outer.indent ? outer.indent(state.outer, "") : 0);
                                return other.delimStyle;
                            } else if (found != -1 && found < cutOff) {
                                cutOff = found;
                            }
                        }
                        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);
                        var outerToken = outer.token(stream, state.outer);
                        if (cutOff != Infinity) stream.string = oldContent;
                        return outerToken;
                    } else {
                        var curInner = state.innerActive,
                            oldContent = stream.string;
                        var found = indexOf(oldContent, curInner.close, stream.pos);
                        if (found == stream.pos) {
                            stream.match(curInner.close);
                            state.innerActive = state.inner = null;
                            return curInner.delimStyle;
                        }
                        if (found > -1) stream.string = oldContent.slice(0, found);
                        var innerToken = curInner.mode.token(stream, state.inner);
                        if (found > -1) stream.string = oldContent;
                        var cur = stream.current(),
                            found = cur.indexOf(curInner.close);
                        if (found > -1) stream.backUp(cur.length - found);
                        return innerToken;
                    }
                },

                indent: function(state, textAfter) {
                    var mode = state.innerActive ? state.innerActive.mode : outer;
                    if (!mode.indent) return CodeMirror.Pass;
                    return mode.indent(state.innerActive ? state.inner : state.outer, textAfter);
                },

                blankLine: function(state) {
                    var mode = state.innerActive ? state.innerActive.mode : outer;
                    if (mode.blankLine) {
                        mode.blankLine(state.innerActive ? state.inner : state.outer);
                    }
                    if (!state.innerActive) {
                        for (var i = 0; i < n_others; ++i) {
                            var other = others[i];
                            if (other.open === "\n") {
                                state.innerActive = other;
                                state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, "") : 0);
                            }
                        }
                    } else if (mode.close === "\n") {
                        state.innerActive = state.inner = null;
                    }
                },

                electricChars: outer.electricChars,

                innerMode: function(state) {
                    return state.inner ? {
                        state: state.inner,
                        mode: state.innerActive.mode
                    } : {
                        state: state.outer,
                        mode: outer
                    };
                }
            };
        };


        /***/
    }),
    /* 121 */
    /***/
    (function(module, exports) {

        CodeMirror.defineMode("clike", function(config, parserConfig) {
            var indentUnit = config.indentUnit,
                statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
                dontAlignCalls = parserConfig.dontAlignCalls,
                keywords = parserConfig.keywords || {},
                builtin = parserConfig.builtin || {},
                blockKeywords = parserConfig.blockKeywords || {},
                atoms = parserConfig.atoms || {},
                hooks = parserConfig.hooks || {},
                multiLineStrings = parserConfig.multiLineStrings;
            var isOperatorChar = /[+\-*&%=<>!?|\/]/;

            var curPunc;

            function tokenBase(stream, state) {
                var ch = stream.next();
                if (hooks[ch]) {
                    var result = hooks[ch](stream, state);
                    if (result !== false) return result;
                }
                if (ch == '"' || ch == "'") {
                    state.tokenize = tokenString(ch);
                    return state.tokenize(stream, state);
                }
                if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
                    curPunc = ch;
                    return null;
                }
                if (/\d/.test(ch)) {
                    stream.eatWhile(/[\w\.]/);
                    return "number";
                }
                if (ch == "/") {
                    if (stream.eat("*")) {
                        state.tokenize = tokenComment;
                        return tokenComment(stream, state);
                    }
                    if (stream.eat("/")) {
                        stream.skipToEnd();
                        return "comment";
                    }
                }
                if (isOperatorChar.test(ch)) {
                    stream.eatWhile(isOperatorChar);
                    return "operator";
                }
                stream.eatWhile(/[\w\$_]/);
                var cur = stream.current();
                if (keywords.propertyIsEnumerable(cur)) {
                    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
                    return "keyword";
                }
                if (builtin.propertyIsEnumerable(cur)) {
                    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
                    return "builtin";
                }
                if (atoms.propertyIsEnumerable(cur)) return "atom";
                return "variable";
            }

            function tokenString(quote) {
                return function(stream, state) {
                    var escaped = false,
                        next, end = false;
                    while ((next = stream.next()) != null) {
                        if (next == quote && !escaped) {
                            end = true;
                            break;
                        }
                        escaped = !escaped && next == "\\";
                    }
                    if (end || !(escaped || multiLineStrings))
                        state.tokenize = null;
                    return "string";
                };
            }

            function tokenComment(stream, state) {
                var maybeEnd = false,
                    ch;
                while (ch = stream.next()) {
                    if (ch == "/" && maybeEnd) {
                        state.tokenize = null;
                        break;
                    }
                    maybeEnd = (ch == "*");
                }
                return "comment";
            }

            function Context(indented, column, type, align, prev) {
                this.indented = indented;
                this.column = column;
                this.type = type;
                this.align = align;
                this.prev = prev;
            }

            function pushContext(state, col, type) {
                var indent = state.indented;
                if (state.context && state.context.type == "statement")
                    indent = state.context.indented;
                return state.context = new Context(indent, col, type, null, state.context);
            }

            function popContext(state) {
                var t = state.context.type;
                if (t == ")" || t == "]" || t == "}")
                    state.indented = state.context.indented;
                return state.context = state.context.prev;
            }

            // Interface

            return {
                startState: function(basecolumn) {
                    return {
                        tokenize: null,
                        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
                        indented: 0,
                        startOfLine: true
                    };
                },

                token: function(stream, state) {
                    var ctx = state.context;
                    if (stream.sol()) {
                        if (ctx.align == null) ctx.align = false;
                        state.indented = stream.indentation();
                        state.startOfLine = true;
                    }
                    if (stream.eatSpace()) return null;
                    curPunc = null;
                    var style = (state.tokenize || tokenBase)(stream, state);
                    if (style == "comment" || style == "meta") return style;
                    if (ctx.align == null) ctx.align = true;

                    if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);
                    else if (curPunc == "{") pushContext(state, stream.column(), "}");
                    else if (curPunc == "[") pushContext(state, stream.column(), "]");
                    else if (curPunc == "(") pushContext(state, stream.column(), ")");
                    else if (curPunc == "}") {
                        while (ctx.type == "statement") ctx = popContext(state);
                        if (ctx.type == "}") ctx = popContext(state);
                        while (ctx.type == "statement") ctx = popContext(state);
                    } else if (curPunc == ctx.type) popContext(state);
                    else if (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') || (ctx.type == "statement" && curPunc == "newstatement"))
                        pushContext(state, stream.column(), "statement");
                    state.startOfLine = false;
                    return style;
                },

                indent: function(state, textAfter) {
                    if (state.tokenize == tokenComment) return CodeMirror.Pass;
                    if (state.tokenize != tokenBase && state.tokenize != null) return 0;
                    var ctx = state.context,
                        firstChar = textAfter && textAfter.charAt(0);
                    if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
                    var closing = firstChar == ctx.type;
                    if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
                    else if (dontAlignCalls && ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;
                    else if (ctx.align) return ctx.column + (closing ? 0 : 1);
                    else return ctx.indented + (closing ? 0 : indentUnit);
                },

                electricChars: "{}"
            };
        });

        (function() {
            function words(str) {
                var obj = {},
                    words = str.split(" ");
                for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
                return obj;
            }
            var cKeywords = "auto if break int case long char register continue return default short do sizeof " +
                "double static else struct entry switch extern typedef float union for unsigned " +
                "goto while enum void const signed volatile";

            function cppHook(stream, state) {
                if (!state.startOfLine) return false;
                for (;;) {
                    if (stream.skipTo("\\")) {
                        stream.next();
                        if (stream.eol()) {
                            state.tokenize = cppHook;
                            break;
                        }
                    } else {
                        stream.skipToEnd();
                        state.tokenize = null;
                        break;
                    }
                }
                return "meta";
            }

            // C#-style strings where "" escapes a quote.
            function tokenAtString(stream, state) {
                var next;
                while ((next = stream.next()) != null) {
                    if (next == '"' && !stream.eat('"')) {
                        state.tokenize = null;
                        break;
                    }
                }
                return "string";
            }

            function mimes(ms, mode) {
                for (var i = 0; i < ms.length; ++i) CodeMirror.defineMIME(ms[i], mode);
            }

            mimes(["text/x-csrc", "text/x-c", "text/x-chdr"], {
                name: "clike",
                keywords: words(cKeywords),
                blockKeywords: words("case do else for if switch while struct"),
                atoms: words("null"),
                hooks: {
                    "#": cppHook
                }
            });
            mimes(["text/x-c++src", "text/x-c++hdr"], {
                name: "clike",
                keywords: words(cKeywords + " asm dynamic_cast namespace reinterpret_cast try bool explicit new " +
                    "static_cast typeid catch operator template typename class friend private " +
                    "this using const_cast inline public throw virtual delete mutable protected " +
                    "wchar_t"),
                blockKeywords: words("catch class do else finally for if struct switch try while"),
                atoms: words("true false null"),
                hooks: {
                    "#": cppHook
                }
            });
            CodeMirror.defineMIME("text/x-java", {
                name: "clike",
                keywords: words("abstract assert boolean break byte case catch char class const continue default " +
                    "do double else enum extends final finally float for goto if implements import " +
                    "instanceof int interface long native new package private protected public " +
                    "return short static strictfp super switch synchronized this throw throws transient " +
                    "try void volatile while"),
                blockKeywords: words("catch class do else finally for if switch try while"),
                atoms: words("true false null"),
                hooks: {
                    "@": function(stream, state) {
                        stream.eatWhile(/[\w\$_]/);
                        return "meta";
                    }
                }
            });
            CodeMirror.defineMIME("text/x-csharp", {
                name: "clike",
                keywords: words("abstract as base break case catch checked class const continue" +
                    " default delegate do else enum event explicit extern finally fixed for" +
                    " foreach goto if implicit in interface internal is lock namespace new" +
                    " operator out override params private protected public readonly ref return sealed" +
                    " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                    " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                    " global group into join let orderby partial remove select set value var yield"),
                blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
                builtin: words("Boolean Byte Char DateTime DateTimeOffset Decimal Double" +
                    " Guid Int16 Int32 Int64 Object SByte Single String TimeSpan UInt16 UInt32" +
                    " UInt64 bool byte char decimal double short int long object" +
                    " sbyte float string ushort uint ulong"),
                atoms: words("true false null"),
                hooks: {
                    "@": function(stream, state) {
                        if (stream.eat('"')) {
                            state.tokenize = tokenAtString;
                            return tokenAtString(stream, state);
                        }
                        stream.eatWhile(/[\w\$_]/);
                        return "meta";
                    }
                }
            });
            CodeMirror.defineMIME("text/x-scala", {
                name: "clike",
                keywords: words(

                    /* scala */
                    "abstract case catch class def do else extends false final finally for forSome if " +
                    "implicit import lazy match new null object override package private protected return " +
                    "sealed super this throw trait try trye type val var while with yield _ : = => <- <: " +
                    "<% >: # @ " +

                    /* package scala */
                    "assert assume require print println printf readLine readBoolean readByte readShort " +
                    "readChar readInt readLong readFloat readDouble " +

                    "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
                    "Enumeration Equiv Error Exception Fractional Function IndexedSeq Integral Iterable " +
                    "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
                    "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
                    "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector :: #:: " +

                    /* package java.lang */
                    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
                    "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
                    "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
                    "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"


                ),
                blockKeywords: words("catch class do else finally for forSome if match switch try while"),
                atoms: words("true false null"),
                hooks: {
                    "@": function(stream, state) {
                        stream.eatWhile(/[\w\$_]/);
                        return "meta";
                    }
                }
            });
        }());


        /***/
    }),
    /* 122 */
    /***/
    (function(module, exports) {

        CodeMirror.defineMode("css", function(config) {
            var indentUnit = config.indentUnit,
                type;

            var atMediaTypes = keySet([
                "all", "aural", "braille", "handheld", "print", "projection", "screen",
                "tty", "tv", "embossed"
            ]);

            var atMediaFeatures = keySet([
                "width", "min-width", "max-width", "height", "min-height", "max-height",
                "device-width", "min-device-width", "max-device-width", "device-height",
                "min-device-height", "max-device-height", "aspect-ratio",
                "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
                "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
                "max-color", "color-index", "min-color-index", "max-color-index",
                "monochrome", "min-monochrome", "max-monochrome", "resolution",
                "min-resolution", "max-resolution", "scan", "grid"
            ]);

            var propertyKeywords = keySet([
                "align-content", "align-items", "align-self", "alignment-adjust",
                "alignment-baseline", "anchor-point", "animation", "animation-delay",
                "animation-direction", "animation-duration", "animation-iteration-count",
                "animation-name", "animation-play-state", "animation-timing-function",
                "appearance", "azimuth", "backface-visibility", "background",
                "background-attachment", "background-clip", "background-color",
                "background-image", "background-origin", "background-position",
                "background-repeat", "background-size", "baseline-shift", "binding",
                "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
                "bookmark-target", "border", "border-bottom", "border-bottom-color",
                "border-bottom-left-radius", "border-bottom-right-radius",
                "border-bottom-style", "border-bottom-width", "border-collapse",
                "border-color", "border-image", "border-image-outset",
                "border-image-repeat", "border-image-slice", "border-image-source",
                "border-image-width", "border-left", "border-left-color",
                "border-left-style", "border-left-width", "border-radius", "border-right",
                "border-right-color", "border-right-style", "border-right-width",
                "border-spacing", "border-style", "border-top", "border-top-color",
                "border-top-left-radius", "border-top-right-radius", "border-top-style",
                "border-top-width", "border-width", "bottom", "box-decoration-break",
                "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
                "caption-side", "clear", "clip", "color", "color-profile", "column-count",
                "column-fill", "column-gap", "column-rule", "column-rule-color",
                "column-rule-style", "column-rule-width", "column-span", "column-width",
                "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
                "cue-after", "cue-before", "cursor", "direction", "display",
                "dominant-baseline", "drop-initial-after-adjust",
                "drop-initial-after-align", "drop-initial-before-adjust",
                "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
                "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
                "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
                "float", "float-offset", "font", "font-feature-settings", "font-family",
                "font-kerning", "font-language-override", "font-size", "font-size-adjust",
                "font-stretch", "font-style", "font-synthesis", "font-variant",
                "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
                "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
                "font-weight", "grid-cell", "grid-column", "grid-column-align",
                "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",
                "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",
                "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",
                "icon", "image-orientation", "image-rendering", "image-resolution",
                "inline-box-align", "justify-content", "left", "letter-spacing",
                "line-break", "line-height", "line-stacking", "line-stacking-ruby",
                "line-stacking-shift", "line-stacking-strategy", "list-style",
                "list-style-image", "list-style-position", "list-style-type", "margin",
                "margin-bottom", "margin-left", "margin-right", "margin-top",
                "marker-offset", "marks", "marquee-direction", "marquee-loop",
                "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
                "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
                "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",
                "outline-color", "outline-offset", "outline-style", "outline-width",
                "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
                "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
                "page", "page-break-after", "page-break-before", "page-break-inside",
                "page-policy", "pause", "pause-after", "pause-before", "perspective",
                "perspective-origin", "pitch", "pitch-range", "play-during", "position",
                "presentation-level", "punctuation-trim", "quotes", "rendering-intent",
                "resize", "rest", "rest-after", "rest-before", "richness", "right",
                "rotation", "rotation-point", "ruby-align", "ruby-overhang",
                "ruby-position", "ruby-span", "size", "speak", "speak-as", "speak-header",
                "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
                "tab-size", "table-layout", "target", "target-name", "target-new",
                "target-position", "text-align", "text-align-last", "text-decoration",
                "text-decoration-color", "text-decoration-line", "text-decoration-skip",
                "text-decoration-style", "text-emphasis", "text-emphasis-color",
                "text-emphasis-position", "text-emphasis-style", "text-height",
                "text-indent", "text-justify", "text-outline", "text-shadow",
                "text-space-collapse", "text-transform", "text-underline-position",
                "text-wrap", "top", "transform", "transform-origin", "transform-style",
                "transition", "transition-delay", "transition-duration",
                "transition-property", "transition-timing-function", "unicode-bidi",
                "vertical-align", "visibility", "voice-balance", "voice-duration",
                "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
                "voice-volume", "volume", "white-space", "widows", "width", "word-break",
                "word-spacing", "word-wrap", "z-index"
            ]);

            var colorKeywords = keySet([
                "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia",
                "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua"
            ]);

            var valueKeywords = keySet([
                "above", "absolute", "activeborder", "activecaption", "afar",
                "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",
                "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
                "arabic-indic", "armenian", "asterisks", "auto", "avoid", "background",
                "backwards", "baseline", "below", "bidi-override", "binary", "bengali",
                "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
                "both", "bottom", "break-all", "break-word", "button", "button-bevel",
                "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",
                "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
                "cell", "center", "checkbox", "circle", "cjk-earthly-branch",
                "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
                "col-resize", "collapse", "compact", "condensed", "contain", "content",
                "content-box", "context-menu", "continuous", "copy", "cover", "crop",
                "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",
                "decimal-leading-zero", "default", "default-button", "destination-atop",
                "destination-in", "destination-out", "destination-over", "devanagari",
                "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",
                "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
                "element", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
                "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
                "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
                "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
                "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
                "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
                "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",
                "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",
                "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",
                "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",
                "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",
                "help", "hidden", "hide", "higher", "highlight", "highlighttext",
                "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",
                "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
                "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
                "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",
                "italic", "justify", "kannada", "katakana", "katakana-iroha", "khmer",
                "landscape", "lao", "large", "larger", "left", "level", "lighter",
                "line-through", "linear", "lines", "list-item", "listbox", "listitem",
                "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
                "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
                "lower-roman", "lowercase", "ltr", "malayalam", "match",
                "media-controls-background", "media-current-time-display",
                "media-fullscreen-button", "media-mute-button", "media-play-button",
                "media-return-to-realtime-button", "media-rewind-button",
                "media-seek-back-button", "media-seek-forward-button", "media-slider",
                "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
                "media-volume-slider-container", "media-volume-sliderthumb", "medium",
                "menu", "menulist", "menulist-button", "menulist-text",
                "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
                "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",
                "narrower", "navy", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
                "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
                "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",
                "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
                "outside", "overlay", "overline", "padding", "padding-box", "painted",
                "paused", "persian", "plus-darker", "plus-lighter", "pointer", "portrait",
                "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",
                "radio", "read-only", "read-write", "read-write-plaintext-only", "relative",
                "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",
                "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",
                "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",
                "searchfield-cancel-button", "searchfield-decoration",
                "searchfield-results-button", "searchfield-results-decoration",
                "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
                "single", "skip-white-space", "slide", "slider-horizontal",
                "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
                "small", "small-caps", "small-caption", "smaller", "solid", "somali",
                "source-atop", "source-in", "source-out", "source-over", "space", "square",
                "square-button", "start", "static", "status-bar", "stretch", "stroke",
                "sub", "subpixel-antialiased", "super", "sw-resize", "table",
                "table-caption", "table-cell", "table-column", "table-column-group",
                "table-footer-group", "table-header-group", "table-row", "table-row-group",
                "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
                "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
                "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
                "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
                "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",
                "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
                "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
                "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
                "visibleStroke", "visual", "w-resize", "wait", "wave", "white", "wider",
                "window", "windowframe", "windowtext", "x-large", "x-small", "xor",
                "xx-large", "xx-small", "yellow"
            ]);

            function keySet(array) {
                var keys = {};
                for (var i = 0; i < array.length; ++i) keys[array[i]] = true;
                return keys;
            }

            function ret(style, tp) {
                type = tp;
                return style;
            }

            function tokenBase(stream, state) {
                var ch = stream.next();
                if (ch == "@") {
                    stream.eatWhile(/[\w\\\-]/);
                    return ret("def", stream.current());
                } else if (ch == "/" && stream.eat("*")) {
                    state.tokenize = tokenCComment;
                    return tokenCComment(stream, state);
                } else if (ch == "<" && stream.eat("!")) {
                    state.tokenize = tokenSGMLComment;
                    return tokenSGMLComment(stream, state);
                } else if (ch == "=") ret(null, "compare");
                else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
                else if (ch == "\"" || ch == "'") {
                    state.tokenize = tokenString(ch);
                    return state.tokenize(stream, state);
                } else if (ch == "#") {
                    stream.eatWhile(/[\w\\\-]/);
                    return ret("atom", "hash");
                } else if (ch == "!") {
                    stream.match(/^\s*\w*/);
                    return ret("keyword", "important");
                } else if (/\d/.test(ch)) {
                    stream.eatWhile(/[\w.%]/);
                    return ret("number", "unit");
                } else if (ch === "-") {
                    if (/\d/.test(stream.peek())) {
                        stream.eatWhile(/[\w.%]/);
                        return ret("number", "unit");
                    } else if (stream.match(/^[^-]+-/)) {
                        return ret("meta", type);
                    }
                } else if (/[,+>*\/]/.test(ch)) {
                    return ret(null, "select-op");
                } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
                    return ret("qualifier", type);
                } else if (ch == ":") {
                    return ret("operator", ch);
                } else if (/[;{}\[\]\(\)]/.test(ch)) {
                    return ret(null, ch);
                } else if (ch == "u" && stream.match("rl(")) {
                    stream.backUp(1);
                    state.tokenize = tokenParenthesized;
                    return ret("property", "variable");
                } else {
                    stream.eatWhile(/[\w\\\-]/);
                    return ret("property", "variable");
                }
            }

            function tokenCComment(stream, state) {
                var maybeEnd = false,
                    ch;
                while ((ch = stream.next()) != null) {
                    if (maybeEnd && ch == "/") {
                        state.tokenize = tokenBase;
                        break;
                    }
                    maybeEnd = (ch == "*");
                }
                return ret("comment", "comment");
            }

            function tokenSGMLComment(stream, state) {
                var dashes = 0,
                    ch;
                while ((ch = stream.next()) != null) {
                    if (dashes >= 2 && ch == ">") {
                        state.tokenize = tokenBase;
                        break;
                    }
                    dashes = (ch == "-") ? dashes + 1 : 0;
                }
                return ret("comment", "comment");
            }

            function tokenString(quote, nonInclusive) {
                return function(stream, state) {
                    var escaped = false,
                        ch;
                    while ((ch = stream.next()) != null) {
                        if (ch == quote && !escaped)
                            break;
                        escaped = !escaped && ch == "\\";
                    }
                    if (!escaped) {
                        if (nonInclusive) stream.backUp(1);
                        state.tokenize = tokenBase;
                    }
                    return ret("string", "string");
                };
            }

            function tokenParenthesized(stream, state) {
                stream.next(); // Must be '('
                if (!stream.match(/\s*[\"\']/, false))
                    state.tokenize = tokenString(")", true);
                else
                    state.tokenize = tokenBase;
                return ret(null, "(");
            }

            return {
                startState: function(base) {
                    return {
                        tokenize: tokenBase,
                        baseIndent: base || 0,
                        stack: []
                    };
                },

                token: function(stream, state) {

                    // Use these terms when applicable (see http://www.xanthir.com/blog/b4E50)
                    // 
                    // rule** or **ruleset:
                    // A selector + braces combo, or an at-rule.
                    // 
                    // declaration block:
                    // A sequence of declarations.
                    // 
                    // declaration:
                    // A property + colon + value combo.
                    // 
                    // property value:
                    // The entire value of a property.
                    // 
                    // component value:
                    // A single piece of a property value. Like the 5px in
                    // text-shadow: 0 0 5px blue;. Can also refer to things that are
                    // multiple terms, like the 1-4 terms that make up the background-size
                    // portion of the background shorthand.
                    // 
                    // term:
                    // The basic unit of author-facing CSS, like a single number (5),
                    // dimension (5px), string ("foo"), or function. Officially defined
                    //  by the CSS 2.1 grammar (look for the 'term' production)
                    // 
                    // 
                    // simple selector:
                    // A single atomic selector, like a type selector, an attr selector, a
                    // class selector, etc.
                    // 
                    // compound selector:
                    // One or more simple selectors without a combinator. div.example is
                    // compound, div > .example is not.
                    // 
                    // complex selector:
                    // One or more compound selectors chained with combinators.
                    // 
                    // combinator:
                    // The parts of selectors that express relationships. There are four
                    // currently - the space (descendant combinator), the greater-than
                    // bracket (child combinator), the plus sign (next sibling combinator),
                    // and the tilda (following sibling combinator).
                    // 
                    // sequence of selectors:
                    // One or more of the named type of selector chained with commas.

                    if (state.tokenize == tokenBase && stream.eatSpace()) return null;
                    var style = state.tokenize(stream, state);

                    // Changing style returned based on context
                    var context = state.stack[state.stack.length - 1];
                    if (style == "property") {
                        if (context == "propertyValue") {
                            if (valueKeywords[stream.current()]) {
                                style = "string-2";
                            } else if (colorKeywords[stream.current()]) {
                                style = "keyword";
                            } else {
                                style = "variable-2";
                            }
                        } else if (context == "rule") {
                            if (!propertyKeywords[stream.current()]) {
                                style += " error";
                            }
                        } else if (!context || context == "@media{") {
                            style = "tag";
                        } else if (context == "@media") {
                            if (atMediaTypes[stream.current()]) {
                                style = "attribute"; // Known attribute
                            } else if (/^(only|not)$/i.test(stream.current())) {
                                style = "keyword";
                            } else if (stream.current().toLowerCase() == "and") {
                                style = "error"; // "and" is only allowed in @mediaType
                            } else if (atMediaFeatures[stream.current()]) {
                                style = "error"; // Known property, should be in @mediaType(
                            } else {
                                // Unknown, expecting keyword or attribute, assuming attribute
                                style = "attribute error";
                            }
                        } else if (context == "@mediaType") {
                            if (atMediaTypes[stream.current()]) {
                                style = "attribute";
                            } else if (stream.current().toLowerCase() == "and") {
                                style = "operator";
                            } else if (/^(only|not)$/i.test(stream.current())) {
                                style = "error"; // Only allowed in @media
                            } else if (atMediaFeatures[stream.current()]) {
                                style = "error"; // Known property, should be in parentheses
                            } else {
                                // Unknown attribute or property, but expecting property (preceded
                                // by "and"). Should be in parentheses
                                style = "error";
                            }
                        } else if (context == "@mediaType(") {
                            if (propertyKeywords[stream.current()]) {
                                // do nothing, remains "property"
                            } else if (atMediaTypes[stream.current()]) {
                                style = "error"; // Known property, should be in parentheses
                            } else if (stream.current().toLowerCase() == "and") {
                                style = "operator";
                            } else if (/^(only|not)$/i.test(stream.current())) {
                                style = "error"; // Only allowed in @media
                            } else {
                                style += " error";
                            }
                        } else {
                            style = "error";
                        }
                    } else if (style == "atom") {
                        if (!context || context == "@media{") {
                            style = "builtin";
                        } else if (context == "propertyValue") {
                            if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
                                style += " error";
                            }
                        } else {
                            style = "error";
                        }
                    } else if (context == "@media" && type == "{") {
                        style = "error";
                    }

                    // Push/pop context stack
                    if (type == "{") {
                        if (context == "@media" || context == "@mediaType") {
                            state.stack.pop();
                            state.stack[state.stack.length - 1] = "@media{";
                        } else state.stack.push("rule");
                    } else if (type == "}") {
                        state.stack.pop();
                        if (context == "propertyValue") state.stack.pop();
                    } else if (type == "@media") state.stack.push("@media");
                    else if (context == "@media" && /\b(keyword|attribute)\b/.test(style))
                        state.stack.push("@mediaType");
                    else if (context == "@mediaType" && stream.current() == ",") state.stack.pop();
                    else if (context == "@mediaType" && type == "(") state.stack.push("@mediaType(");
                    else if (context == "@mediaType(" && type == ")") state.stack.pop();
                    else if (context == "rule" && type == ":") state.stack.push("propertyValue");
                    else if (context == "propertyValue" && type == ";") state.stack.pop();
                    return style;
                },

                indent: function(state, textAfter) {
                    var n = state.stack.length;
                    if (/^\}/.test(textAfter))
                        n -= state.stack[state.stack.length - 1] == "propertyValue" ? 2 : 1;
                    return state.baseIndent + n * indentUnit;
                },

                electricChars: "}"
            };
        });

        CodeMirror.defineMIME("text/css", "css");


        /***/
    }),
    /* 123 */
    /***/
    (function(module, exports) {

        // TODO actually recognize syntax of TypeScript constructs

        CodeMirror.defineMode("javascript", function(config, parserConfig) {
            var indentUnit = config.indentUnit;
            var jsonMode = parserConfig.json;
            var isTS = parserConfig.typescript;

            // Tokenizer

            var keywords = function() {
                function kw(type) {
                    return {
                        type: type,
                        style: "keyword"
                    };
                }
                var A = kw("keyword a"),
                    B = kw("keyword b"),
                    C = kw("keyword c");
                var operator = kw("operator"),
                    atom = {
                        type: "atom",
                        style: "atom"
                    };

                var jsKeywords = {
                    "if": A,
                    "while": A,
                    "with": A,
                    "else": B,
                    "do": B,
                    "try": B,
                    "finally": B,
                    "return": C,
                    "break": C,
                    "continue": C,
                    "new": C,
                    "delete": C,
                    "throw": C,
                    "var": kw("var"),
                    "const": kw("var"),
                    "let": kw("var"),
                    "function": kw("function"),
                    "catch": kw("catch"),
                    "for": kw("for"),
                    "switch": kw("switch"),
                    "case": kw("case"),
                    "default": kw("default"),
                    "in": operator,
                    "typeof": operator,
                    "instanceof": operator,
                    "true": atom,
                    "false": atom,
                    "null": atom,
                    "undefined": atom,
                    "NaN": atom,
                    "Infinity": atom
                };

                // Extend the 'normal' keywords with the TypeScript language extensions
                if (isTS) {
                    var type = {
                        type: "variable",
                        style: "variable-3"
                    };
                    var tsKeywords = {
                        // object-like things
                        "interface": kw("interface"),
                        "class": kw("class"),
                        "extends": kw("extends"),
                        "constructor": kw("constructor"),

                        // scope modifiers
                        "public": kw("public"),
                        "private": kw("private"),
                        "protected": kw("protected"),
                        "static": kw("static"),

                        "super": kw("super"),

                        // types
                        "string": type,
                        "number": type,
                        "bool": type,
                        "any": type
                    };

                    for (var attr in tsKeywords) {
                        jsKeywords[attr] = tsKeywords[attr];
                    }
                }

                return jsKeywords;
            }();

            var isOperatorChar = /[+\-*&%=<>!?|]/;

            function chain(stream, state, f) {
                state.tokenize = f;
                return f(stream, state);
            }

            function nextUntilUnescaped(stream, end) {
                var escaped = false,
                    next;
                while ((next = stream.next()) != null) {
                    if (next == end && !escaped)
                        return false;
                    escaped = !escaped && next == "\\";
                }
                return escaped;
            }

            // Used as scratch variables to communicate multiple values without
            // consing up tons of objects.
            var type, content;

            function ret(tp, style, cont) {
                type = tp;
                content = cont;
                return style;
            }

            function jsTokenBase(stream, state) {
                var ch = stream.next();
                if (ch == '"' || ch == "'")
                    return chain(stream, state, jsTokenString(ch));
                else if (/[\[\]{}\(\),;\:\.]/.test(ch))
                    return ret(ch);
                else if (ch == "0" && stream.eat(/x/i)) {
                    stream.eatWhile(/[\da-f]/i);
                    return ret("number", "number");
                } else if (/\d/.test(ch) || ch == "-" && stream.eat(/\d/)) {
                    stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
                    return ret("number", "number");
                } else if (ch == "/") {
                    if (stream.eat("*")) {
                        return chain(stream, state, jsTokenComment);
                    } else if (stream.eat("/")) {
                        stream.skipToEnd();
                        return ret("comment", "comment");
                    } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
                        /^[\[{}\(,;:]$/.test(state.lastType)) {
                        nextUntilUnescaped(stream, "/");
                        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
                        return ret("regexp", "string-2");
                    } else {
                        stream.eatWhile(isOperatorChar);
                        return ret("operator", null, stream.current());
                    }
                } else if (ch == "#") {
                    stream.skipToEnd();
                    return ret("error", "error");
                } else if (isOperatorChar.test(ch)) {
                    stream.eatWhile(isOperatorChar);
                    return ret("operator", null, stream.current());
                } else {
                    stream.eatWhile(/[\w\$_]/);
                    var word = stream.current(),
                        known = keywords.propertyIsEnumerable(word) && keywords[word];
                    return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                        ret("variable", "variable", word);
                }
            }

            function jsTokenString(quote) {
                return function(stream, state) {
                    if (!nextUntilUnescaped(stream, quote))
                        state.tokenize = jsTokenBase;
                    return ret("string", "string");
                };
            }

            function jsTokenComment(stream, state) {
                var maybeEnd = false,
                    ch;
                while (ch = stream.next()) {
                    if (ch == "/" && maybeEnd) {
                        state.tokenize = jsTokenBase;
                        break;
                    }
                    maybeEnd = (ch == "*");
                }
                return ret("comment", "comment");
            }

            // Parser

            var atomicTypes = {
                "atom": true,
                "number": true,
                "variable": true,
                "string": true,
                "regexp": true
            };

            function JSLexical(indented, column, type, align, prev, info) {
                this.indented = indented;
                this.column = column;
                this.type = type;
                this.prev = prev;
                this.info = info;
                if (align != null) this.align = align;
            }

            function inScope(state, varname) {
                for (var v = state.localVars; v; v = v.next)
                    if (v.name == varname) return true;
            }

            function parseJS(state, style, type, content, stream) {
                var cc = state.cc;
                // Communicate our context to the combinators.
                // (Less wasteful than consing up a hundred closures on every call.)
                cx.state = state;
                cx.stream = stream;
                cx.marked = null, cx.cc = cc;

                if (!state.lexical.hasOwnProperty("align"))
                    state.lexical.align = true;

                while (true) {
                    var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
                    if (combinator(type, content)) {
                        while (cc.length && cc[cc.length - 1].lex)
                            cc.pop()();
                        if (cx.marked) return cx.marked;
                        if (type == "variable" && inScope(state, content)) return "variable-2";
                        return style;
                    }
                }
            }

            // Combinator utils

            var cx = {
                state: null,
                column: null,
                marked: null,
                cc: null
            };

            function pass() {
                for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
            }

            function cont() {
                pass.apply(null, arguments);
                return true;
            }

            function register(varname) {
                function inList(list) {
                    for (var v = list; v; v = v.next)
                        if (v.name == varname) return true;
                    return false;
                }
                var state = cx.state;
                if (state.context) {
                    cx.marked = "def";
                    if (inList(state.localVars)) return;
                    state.localVars = {
                        name: varname,
                        next: state.localVars
                    };
                } else {
                    if (inList(state.globalVars)) return;
                    state.globalVars = {
                        name: varname,
                        next: state.globalVars
                    };
                }
            }

            // Combinators

            var defaultVars = {
                name: "this",
                next: {
                    name: "arguments"
                }
            };

            function pushcontext() {
                cx.state.context = {
                    prev: cx.state.context,
                    vars: cx.state.localVars
                };
                cx.state.localVars = defaultVars;
            }

            function popcontext() {
                cx.state.localVars = cx.state.context.vars;
                cx.state.context = cx.state.context.prev;
            }

            function pushlex(type, info) {
                var result = function() {
                    var state = cx.state;
                    state.lexical = new JSLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);
                };
                result.lex = true;
                return result;
            }

            function poplex() {
                var state = cx.state;
                if (state.lexical.prev) {
                    if (state.lexical.type == ")")
                        state.indented = state.lexical.indented;
                    state.lexical = state.lexical.prev;
                }
            }
            poplex.lex = true;

            function expect(wanted) {
                return function expecting(type) {
                    if (type == wanted) return cont();
                    else if (wanted == ";") return pass();
                    else return cont(arguments.callee);
                };
            }

            function statement(type) {
                if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
                if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
                if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
                if (type == "{") return cont(pushlex("}"), block, poplex);
                if (type == ";") return cont();
                if (type == "function") return cont(functiondef);
                if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                    poplex, statement, poplex);
                if (type == "variable") return cont(pushlex("stat"), maybelabel);
                if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                    block, poplex, poplex);
                if (type == "case") return cont(expression, expect(":"));
                if (type == "default") return cont(expect(":"));
                if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                    statement, poplex, popcontext);
                return pass(pushlex("stat"), expression, expect(";"), poplex);
            }

            function expression(type) {
                if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);
                if (type == "function") return cont(functiondef);
                if (type == "keyword c") return cont(maybeexpression);
                if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeoperator);
                if (type == "operator") return cont(expression);
                if (type == "[") return cont(pushlex("]"), commasep(expression, "]"), poplex, maybeoperator);
                if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeoperator);
                return cont();
            }

            function maybeexpression(type) {
                if (type.match(/[;\}\)\],]/)) return pass();
                return pass(expression);
            }

            function maybeoperator(type, value) {
                if (type == "operator" && /\+\+|--/.test(value)) return cont(maybeoperator);
                if (type == "operator" && value == "?") return cont(expression, expect(":"), expression);
                if (type == ";") return;
                if (type == "(") return cont(pushlex(")"), commasep(expression, ")"), poplex, maybeoperator);
                if (type == ".") return cont(property, maybeoperator);
                if (type == "[") return cont(pushlex("]"), expression, expect("]"), poplex, maybeoperator);
            }

            function maybelabel(type) {
                if (type == ":") return cont(poplex, statement);
                return pass(maybeoperator, expect(";"), poplex);
            }

            function property(type) {
                if (type == "variable") {
                    cx.marked = "property";
                    return cont();
                }
            }

            function objprop(type) {
                if (type == "variable") cx.marked = "property";
                if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expression);
            }

            function commasep(what, end) {
                function proceed(type) {
                    if (type == ",") return cont(what, proceed);
                    if (type == end) return cont();
                    return cont(expect(end));
                }
                return function commaSeparated(type) {
                    if (type == end) return cont();
                    else return pass(what, proceed);
                };
            }

            function block(type) {
                if (type == "}") return cont();
                return pass(statement, block);
            }

            function maybetype(type) {
                if (type == ":") return cont(typedef);
                return pass();
            }

            function typedef(type) {
                if (type == "variable") {
                    cx.marked = "variable-3";
                    return cont();
                }
                return pass();
            }

            function vardef1(type, value) {
                if (type == "variable") {
                    register(value);
                    return isTS ? cont(maybetype, vardef2) : cont(vardef2);
                }
                return pass();
            }

            function vardef2(type, value) {
                if (value == "=") return cont(expression, vardef2);
                if (type == ",") return cont(vardef1);
            }

            function forspec1(type) {
                if (type == "var") return cont(vardef1, expect(";"), forspec2);
                if (type == ";") return cont(forspec2);
                if (type == "variable") return cont(formaybein);
                return cont(forspec2);
            }

            function formaybein(type, value) {
                if (value == "in") return cont(expression);
                return cont(maybeoperator, forspec2);
            }

            function forspec2(type, value) {
                if (type == ";") return cont(forspec3);
                if (value == "in") return cont(expression);
                return cont(expression, expect(";"), forspec3);
            }

            function forspec3(type) {
                if (type != ")") cont(expression);
            }

            function functiondef(type, value) {
                if (type == "variable") {
                    register(value);
                    return cont(functiondef);
                }
                if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, statement, popcontext);
            }

            function funarg(type, value) {
                if (type == "variable") {
                    register(value);
                    return isTS ? cont(maybetype) : cont();
                }
            }

            // Interface

            return {
                startState: function(basecolumn) {
                    return {
                        tokenize: jsTokenBase,
                        lastType: null,
                        cc: [],
                        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
                        localVars: parserConfig.localVars,
                        globalVars: parserConfig.globalVars,
                        context: parserConfig.localVars && {
                            vars: parserConfig.localVars
                        },
                        indented: 0
                    };
                },

                token: function(stream, state) {
                    if (stream.sol()) {
                        if (!state.lexical.hasOwnProperty("align"))
                            state.lexical.align = false;
                        state.indented = stream.indentation();
                    }
                    if (stream.eatSpace()) return null;
                    var style = state.tokenize(stream, state);
                    if (type == "comment") return style;
                    state.lastType = type;
                    return parseJS(state, style, type, content, stream);
                },

                indent: function(state, textAfter) {
                    if (state.tokenize == jsTokenComment) return CodeMirror.Pass;
                    if (state.tokenize != jsTokenBase) return 0;
                    var firstChar = textAfter && textAfter.charAt(0),
                        lexical = state.lexical;
                    if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
                    var type = lexical.type,
                        closing = firstChar == type;
                    if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? 4 : 0);
                    else if (type == "form" && firstChar == "{") return lexical.indented;
                    else if (type == "form") return lexical.indented + indentUnit;
                    else if (type == "stat")
                        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? indentUnit : 0);
                    else if (lexical.info == "switch" && !closing)
                        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
                    else if (lexical.align) return lexical.column + (closing ? 0 : 1);
                    else return lexical.indented + (closing ? 0 : indentUnit);
                },

                electricChars: ":{}",

                jsonMode: jsonMode
            };
        });

        CodeMirror.defineMIME("text/javascript", "javascript");
        CodeMirror.defineMIME("text/ecmascript", "javascript");
        CodeMirror.defineMIME("application/javascript", "javascript");
        CodeMirror.defineMIME("application/ecmascript", "javascript");
        CodeMirror.defineMIME("application/json", {
            name: "javascript",
            json: true
        });
        CodeMirror.defineMIME("text/typescript", {
            name: "javascript",
            typescript: true
        });
        CodeMirror.defineMIME("application/typescript", {
            name: "javascript",
            typescript: true
        });


        /***/
    }),
    /* 124 */
    /***/
    (function(module, exports) {

        CodeMirror.defineMode("xml", function(config, parserConfig) {
            var indentUnit = config.indentUnit;
            var Kludges = parserConfig.htmlMode ? {
                autoSelfClosers: {
                    'area': true,
                    'base': true,
                    'br': true,
                    'col': true,
                    'command': true,
                    'embed': true,
                    'frame': true,
                    'hr': true,
                    'img': true,
                    'input': true,
                    'keygen': true,
                    'link': true,
                    'meta': true,
                    'param': true,
                    'source': true,
                    'track': true,
                    'wbr': true
                },
                implicitlyClosed: {
                    'dd': true,
                    'li': true,
                    'optgroup': true,
                    'option': true,
                    'p': true,
                    'rp': true,
                    'rt': true,
                    'tbody': true,
                    'td': true,
                    'tfoot': true,
                    'th': true,
                    'tr': true
                },
                contextGrabbers: {
                    'dd': {
                        'dd': true,
                        'dt': true
                    },
                    'dt': {
                        'dd': true,
                        'dt': true
                    },
                    'li': {
                        'li': true
                    },
                    'option': {
                        'option': true,
                        'optgroup': true
                    },
                    'optgroup': {
                        'optgroup': true
                    },
                    'p': {
                        'address': true,
                        'article': true,
                        'aside': true,
                        'blockquote': true,
                        'dir': true,
                        'div': true,
                        'dl': true,
                        'fieldset': true,
                        'footer': true,
                        'form': true,
                        'h1': true,
                        'h2': true,
                        'h3': true,
                        'h4': true,
                        'h5': true,
                        'h6': true,
                        'header': true,
                        'hgroup': true,
                        'hr': true,
                        'menu': true,
                        'nav': true,
                        'ol': true,
                        'p': true,
                        'pre': true,
                        'section': true,
                        'table': true,
                        'ul': true
                    },
                    'rp': {
                        'rp': true,
                        'rt': true
                    },
                    'rt': {
                        'rp': true,
                        'rt': true
                    },
                    'tbody': {
                        'tbody': true,
                        'tfoot': true
                    },
                    'td': {
                        'td': true,
                        'th': true
                    },
                    'tfoot': {
                        'tbody': true
                    },
                    'th': {
                        'td': true,
                        'th': true
                    },
                    'thead': {
                        'tbody': true,
                        'tfoot': true
                    },
                    'tr': {
                        'tr': true
                    }
                },
                doNotIndent: {
                    "pre": true
                },
                allowUnquoted: true,
                allowMissing: true
            } : {
                autoSelfClosers: {},
                implicitlyClosed: {},
                contextGrabbers: {},
                doNotIndent: {},
                allowUnquoted: false,
                allowMissing: false
            };
            var alignCDATA = parserConfig.alignCDATA;

            // Return variables for tokenizers
            var tagName, type;

            function inText(stream, state) {
                function chain(parser) {
                    state.tokenize = parser;
                    return parser(stream, state);
                }

                var ch = stream.next();
                if (ch == "<") {
                    if (stream.eat("!")) {
                        if (stream.eat("[")) {
                            if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
                            else return null;
                        } else if (stream.match("--")) return chain(inBlock("comment", "-->"));
                        else if (stream.match("DOCTYPE", true, true)) {
                            stream.eatWhile(/[\w\._\-]/);
                            return chain(doctype(1));
                        } else return null;
                    } else if (stream.eat("?")) {
                        stream.eatWhile(/[\w\._\-]/);
                        state.tokenize = inBlock("meta", "?>");
                        return "meta";
                    } else {
                        var isClose = stream.eat("/");
                        tagName = "";
                        var c;
                        while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;
                        if (!tagName) return "error";
                        type = isClose ? "closeTag" : "openTag";
                        state.tokenize = inTag;
                        return "tag";
                    }
                } else if (ch == "&") {
                    var ok;
                    if (stream.eat("#")) {
                        if (stream.eat("x")) {
                            ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
                        } else {
                            ok = stream.eatWhile(/[\d]/) && stream.eat(";");
                        }
                    } else {
                        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
                    }
                    return ok ? "atom" : "error";
                } else {
                    stream.eatWhile(/[^&<]/);
                    return null;
                }
            }

            function inTag(stream, state) {
                var ch = stream.next();
                if (ch == ">" || (ch == "/" && stream.eat(">"))) {
                    state.tokenize = inText;
                    type = ch == ">" ? "endTag" : "selfcloseTag";
                    return "tag";
                } else if (ch == "=") {
                    type = "equals";
                    return null;
                } else if (/[\'\"]/.test(ch)) {
                    state.tokenize = inAttribute(ch);
                    return state.tokenize(stream, state);
                } else {
                    stream.eatWhile(/[^\s\u00a0=<>\"\']/);
                    return "word";
                }
            }

            function inAttribute(quote) {
                return function(stream, state) {
                    while (!stream.eol()) {
                        if (stream.next() == quote) {
                            state.tokenize = inTag;
                            break;
                        }
                    }
                    return "string";
                };
            }

            function inBlock(style, terminator) {
                return function(stream, state) {
                    while (!stream.eol()) {
                        if (stream.match(terminator)) {
                            state.tokenize = inText;
                            break;
                        }
                        stream.next();
                    }
                    return style;
                };
            }

            function doctype(depth) {
                return function(stream, state) {
                    var ch;
                    while ((ch = stream.next()) != null) {
                        if (ch == "<") {
                            state.tokenize = doctype(depth + 1);
                            return state.tokenize(stream, state);
                        } else if (ch == ">") {
                            if (depth == 1) {
                                state.tokenize = inText;
                                break;
                            } else {
                                state.tokenize = doctype(depth - 1);
                                return state.tokenize(stream, state);
                            }
                        }
                    }
                    return "meta";
                };
            }

            var curState, setStyle;

            function pass() {
                for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
            }

            function cont() {
                pass.apply(null, arguments);
                return true;
            }

            function pushContext(tagName, startOfLine) {
                var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || (curState.context && curState.context.noIndent);
                curState.context = {
                    prev: curState.context,
                    tagName: tagName,
                    indent: curState.indented,
                    startOfLine: startOfLine,
                    noIndent: noIndent
                };
            }

            function popContext() {
                if (curState.context) curState.context = curState.context.prev;
            }

            function element(type) {
                if (type == "openTag") {
                    curState.tagName = tagName;
                    return cont(attributes, endtag(curState.startOfLine));
                } else if (type == "closeTag") {
                    var err = false;
                    if (curState.context) {
                        if (curState.context.tagName != tagName) {
                            if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
                                popContext();
                            }
                            err = !curState.context || curState.context.tagName != tagName;
                        }
                    } else {
                        err = true;
                    }
                    if (err) setStyle = "error";
                    return cont(endclosetag(err));
                }
                return cont();
            }

            function endtag(startOfLine) {
                return function(type) {
                    if (type == "selfcloseTag" ||
                        (type == "endTag" && Kludges.autoSelfClosers.hasOwnProperty(curState.tagName.toLowerCase()))) {
                        maybePopContext(curState.tagName.toLowerCase());
                        return cont();
                    }
                    if (type == "endTag") {
                        maybePopContext(curState.tagName.toLowerCase());
                        pushContext(curState.tagName, startOfLine);
                        return cont();
                    }
                    return cont();
                };
            }

            function endclosetag(err) {
                return function(type) {
                    if (err) setStyle = "error";
                    if (type == "endTag") {
                        popContext();
                        return cont();
                    }
                    setStyle = "error";
                    return cont(arguments.callee);
                };
            }

            function maybePopContext(nextTagName) {
                var parentTagName;
                while (true) {
                    if (!curState.context) {
                        return;
                    }
                    parentTagName = curState.context.tagName.toLowerCase();
                    if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||
                        !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
                        return;
                    }
                    popContext();
                }
            }

            function attributes(type) {
                if (type == "word") {
                    setStyle = "attribute";
                    return cont(attribute, attributes);
                }
                if (type == "endTag" || type == "selfcloseTag") return pass();
                setStyle = "error";
                return cont(attributes);
            }

            function attribute(type) {
                if (type == "equals") return cont(attvalue, attributes);
                if (!Kludges.allowMissing) setStyle = "error";
                else if (type == "word") setStyle = "attribute";
                return (type == "endTag" || type == "selfcloseTag") ? pass() : cont();
            }

            function attvalue(type) {
                if (type == "string") return cont(attvaluemaybe);
                if (type == "word" && Kludges.allowUnquoted) {
                    setStyle = "string";
                    return cont();
                }
                setStyle = "error";
                return (type == "endTag" || type == "selfCloseTag") ? pass() : cont();
            }

            function attvaluemaybe(type) {
                if (type == "string") return cont(attvaluemaybe);
                else return pass();
            }

            return {
                startState: function() {
                    return {
                        tokenize: inText,
                        cc: [],
                        indented: 0,
                        startOfLine: true,
                        tagName: null,
                        context: null
                    };
                },

                token: function(stream, state) {
                    if (stream.sol()) {
                        state.startOfLine = true;
                        state.indented = stream.indentation();
                    }
                    if (stream.eatSpace()) return null;

                    setStyle = type = tagName = null;
                    var style = state.tokenize(stream, state);
                    state.type = type;
                    if ((style || type) && style != "comment") {
                        curState = state;
                        while (true) {
                            var comb = state.cc.pop() || element;
                            if (comb(type || style)) break;
                        }
                    }
                    state.startOfLine = false;
                    return setStyle || style;
                },

                indent: function(state, textAfter, fullLine) {
                    var context = state.context;
                    if ((state.tokenize != inTag && state.tokenize != inText) ||
                        context && context.noIndent)
                        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
                    if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
                    if (context && /^<\//.test(textAfter))
                        context = context.prev;
                    while (context && !context.startOfLine)
                        context = context.prev;
                    if (context) return context.indent + indentUnit;
                    else return 0;
                },

                electricChars: "/",

                configuration: parserConfig.htmlMode ? "html" : "xml"
            };
        });

        CodeMirror.defineMIME("text/xml", "xml");
        CodeMirror.defineMIME("application/xml", "xml");
        if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
            CodeMirror.defineMIME("text/html", {
                name: "xml",
                htmlMode: true
            });


        /***/
    }),
    /* 125 */
    /***/
    (function(module, exports) {

        // removed by extract-text-webpack-plugin

        /***/
    }),
    /* 126 */
    /***/
    (function(module, exports) {

        // removed by extract-text-webpack-plugin

        /***/
    }),
    /* 127 */
    ,
    /* 128 */
    /***/
    (function(module, exports) {

        // removed by extract-text-webpack-plugin

        /***/
    }),
    /* 129 */
    /***/
    (function(module, exports) {

        // removed by extract-text-webpack-plugin

        /***/
    }),
    /* 130 */
    /***/
    (function(module, exports) {

        // removed by extract-text-webpack-plugin

        /***/
    }),
    /* 131 */
    /***/
    (function(module, exports, __webpack_require__) {

        var jQuery = __webpack_require__(2);

        /*! jQuery UI - v1.10.3 - 2013-05-03
         * http://jqueryui.com
         * Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
         * Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
        (function($, undefined) {

            var uuid = 0,
                runiqueId = /^ui-id-\d+$/;

            // $.ui might exist from components with no dependencies, e.g., $.ui.position
            $.ui = $.ui || {};

            $.extend($.ui, {
                version: "1.10.3",

                keyCode: {
                    BACKSPACE: 8,
                    COMMA: 188,
                    DELETE: 46,
                    DOWN: 40,
                    END: 35,
                    ENTER: 13,
                    ESCAPE: 27,
                    HOME: 36,
                    LEFT: 37,
                    NUMPAD_ADD: 107,
                    NUMPAD_DECIMAL: 110,
                    NUMPAD_DIVIDE: 111,
                    NUMPAD_ENTER: 108,
                    NUMPAD_MULTIPLY: 106,
                    NUMPAD_SUBTRACT: 109,
                    PAGE_DOWN: 34,
                    PAGE_UP: 33,
                    PERIOD: 190,
                    RIGHT: 39,
                    SPACE: 32,
                    TAB: 9,
                    UP: 38
                }
            });

            // plugins
            $.fn.extend({
                focus: (function(orig) {
                    return function(delay, fn) {
                        return typeof delay === "number" ?
                            this.each(function() {
                                var elem = this;
                                setTimeout(function() {
                                    $(elem).focus();
                                    if (fn) {
                                        fn.call(elem);
                                    }
                                }, delay);
                            }) :
                            orig.apply(this, arguments);
                    };
                })($.fn.focus),

                scrollParent: function() {
                    var scrollParent;
                    if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
                        scrollParent = this.parents().filter(function() {
                            return (/(relative|absolute|fixed)/).test($.css(this, "position")) && (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                        }).eq(0);
                    } else {
                        scrollParent = this.parents().filter(function() {
                            return (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                        }).eq(0);
                    }

                    return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
                },

                zIndex: function(zIndex) {
                    if (zIndex !== undefined) {
                        return this.css("zIndex", zIndex);
                    }

                    if (this.length) {
                        var elem = $(this[0]),
                            position, value;
                        while (elem.length && elem[0] !== document) {
                            // Ignore z-index if position is set to a value where z-index is ignored by the browser
                            // This makes behavior of this function consistent across browsers
                            // WebKit always returns auto if the element is positioned
                            position = elem.css("position");
                            if (position === "absolute" || position === "relative" || position === "fixed") {
                                // IE returns 0 when zIndex is not specified
                                // other browsers return a string
                                // we ignore the case of nested elements with an explicit value of 0
                                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                                value = parseInt(elem.css("zIndex"), 10);
                                if (!isNaN(value) && value !== 0) {
                                    return value;
                                }
                            }
                            elem = elem.parent();
                        }
                    }

                    return 0;
                },

                uniqueId: function() {
                    return this.each(function() {
                        if (!this.id) {
                            this.id = "ui-id-" + (++uuid);
                        }
                    });
                },

                removeUniqueId: function() {
                    return this.each(function() {
                        if (runiqueId.test(this.id)) {
                            $(this).removeAttr("id");
                        }
                    });
                }
            });

            // selectors
            function focusable(element, isTabIndexNotNaN) {
                var map, mapName, img,
                    nodeName = element.nodeName.toLowerCase();
                if ("area" === nodeName) {
                    map = element.parentNode;
                    mapName = map.name;
                    if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                        return false;
                    }
                    img = $("img[usemap=#" + mapName + "]")[0];
                    return !!img && visible(img);
                }
                return (/input|select|textarea|button|object/.test(nodeName) ?
                        !element.disabled :
                        "a" === nodeName ?
                        element.href || isTabIndexNotNaN :
                        isTabIndexNotNaN) &&
                    // the element and all of its ancestors must be visible
                    visible(element);
            }

            function visible(element) {
                return $.expr.filters.visible(element) &&
                    !$(element).parents().addBack().filter(function() {
                        return $.css(this, "visibility") === "hidden";
                    }).length;
            }

            $.extend($.expr[":"], {
                data: $.expr.createPseudo ?
                    $.expr.createPseudo(function(dataName) {
                        return function(elem) {
                            return !!$.data(elem, dataName);
                        };
                    }) :
                    // support: jQuery <1.8
                    function(elem, i, match) {
                        return !!$.data(elem, match[3]);
                    },

                focusable: function(element) {
                    return focusable(element, !isNaN($.attr(element, "tabindex")));
                },

                tabbable: function(element) {
                    var tabIndex = $.attr(element, "tabindex"),
                        isTabIndexNaN = isNaN(tabIndex);
                    return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
                }
            });

            // support: jQuery <1.8
            if (!$("<a>").outerWidth(1).jquery) {
                $.each(["Width", "Height"], function(i, name) {
                    var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                        type = name.toLowerCase(),
                        orig = {
                            innerWidth: $.fn.innerWidth,
                            innerHeight: $.fn.innerHeight,
                            outerWidth: $.fn.outerWidth,
                            outerHeight: $.fn.outerHeight
                        };

                    function reduce(elem, size, border, margin) {
                        $.each(side, function() {
                            size -= parseFloat($.css(elem, "padding" + this)) || 0;
                            if (border) {
                                size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                            }
                            if (margin) {
                                size -= parseFloat($.css(elem, "margin" + this)) || 0;
                            }
                        });
                        return size;
                    }

                    $.fn["inner" + name] = function(size) {
                        if (size === undefined) {
                            return orig["inner" + name].call(this);
                        }

                        return this.each(function() {
                            $(this).css(type, reduce(this, size) + "px");
                        });
                    };

                    $.fn["outer" + name] = function(size, margin) {
                        if (typeof size !== "number") {
                            return orig["outer" + name].call(this, size);
                        }

                        return this.each(function() {
                            $(this).css(type, reduce(this, size, true, margin) + "px");
                        });
                    };
                });
            }

            // support: jQuery <1.8
            if (!$.fn.addBack) {
                $.fn.addBack = function(selector) {
                    return this.add(selector == null ?
                        this.prevObject : this.prevObject.filter(selector)
                    );
                };
            }

            // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
            if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
                $.fn.removeData = (function(removeData) {
                    return function(key) {
                        if (arguments.length) {
                            return removeData.call(this, $.camelCase(key));
                        } else {
                            return removeData.call(this);
                        }
                    };
                })($.fn.removeData);
            }




            // deprecated
            $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

            $.support.selectstart = "onselectstart" in document.createElement("div");
            $.fn.extend({
                disableSelection: function() {
                    return this.bind(($.support.selectstart ? "selectstart" : "mousedown") +
                        ".ui-disableSelection",
                        function(event) {
                            event.preventDefault();
                        });
                },

                enableSelection: function() {
                    return this.unbind(".ui-disableSelection");
                }
            });

            $.extend($.ui, {
                // $.ui.plugin is deprecated. Use $.widget() extensions instead.
                plugin: {
                    add: function(module, option, set) {
                        var i,
                            proto = $.ui[module].prototype;
                        for (i in set) {
                            proto.plugins[i] = proto.plugins[i] || [];
                            proto.plugins[i].push([option, set[i]]);
                        }
                    },
                    call: function(instance, name, args) {
                        var i,
                            set = instance.plugins[name];
                        if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
                            return;
                        }

                        for (i = 0; i < set.length; i++) {
                            if (instance.options[set[i][0]]) {
                                set[i][1].apply(instance.element, args);
                            }
                        }
                    }
                },

                // only used by resizable
                hasScroll: function(el, a) {

                    //If overflow is hidden, the element might have extra content, but the user wants to hide it
                    if ($(el).css("overflow") === "hidden") {
                        return false;
                    }

                    var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
                        has = false;

                    if (el[scroll] > 0) {
                        return true;
                    }

                    // TODO: determine which cases actually cause this to happen
                    // if the element doesn't have the scroll set, see if it's possible to
                    // set the scroll
                    el[scroll] = 1;
                    has = (el[scroll] > 0);
                    el[scroll] = 0;
                    return has;
                }
            });

        })(jQuery);

        (function($, undefined) {

            var uuid = 0,
                slice = Array.prototype.slice,
                _cleanData = $.cleanData;
            $.cleanData = function(elems) {
                for (var i = 0, elem;
                    (elem = elems[i]) != null; i++) {
                    try {
                        $(elem).triggerHandler("remove");
                        // http://bugs.jquery.com/ticket/8235
                    } catch (e) {}
                }
                _cleanData(elems);
            };

            $.widget = function(name, base, prototype) {
                var fullName, existingConstructor, constructor, basePrototype,
                    // proxiedPrototype allows the provided prototype to remain unmodified
                    // so that it can be used as a mixin for multiple widgets (#8876)
                    proxiedPrototype = {},
                    namespace = name.split(".")[0];

                name = name.split(".")[1];
                fullName = namespace + "-" + name;

                if (!prototype) {
                    prototype = base;
                    base = $.Widget;
                }

                // create selector for plugin
                $.expr[":"][fullName.toLowerCase()] = function(elem) {
                    return !!$.data(elem, fullName);
                };

                $[namespace] = $[namespace] || {};
                existingConstructor = $[namespace][name];
                constructor = $[namespace][name] = function(options, element) {
                    // allow instantiation without "new" keyword
                    if (!this._createWidget) {
                        return new constructor(options, element);
                    }

                    // allow instantiation without initializing for simple inheritance
                    // must use "new" keyword (the code above always passes args)
                    if (arguments.length) {
                        this._createWidget(options, element);
                    }
                };
                // extend with the existing constructor to carry over any static properties
                $.extend(constructor, existingConstructor, {
                    version: prototype.version,
                    // copy the object used to create the prototype in case we need to
                    // redefine the widget later
                    _proto: $.extend({}, prototype),
                    // track widgets that inherit from this widget in case this widget is
                    // redefined after a widget inherits from it
                    _childConstructors: []
                });

                basePrototype = new base();
                // we need to make the options hash a property directly on the new instance
                // otherwise we'll modify the options hash on the prototype that we're
                // inheriting from
                basePrototype.options = $.widget.extend({}, basePrototype.options);
                $.each(prototype, function(prop, value) {
                    if (!$.isFunction(value)) {
                        proxiedPrototype[prop] = value;
                        return;
                    }
                    proxiedPrototype[prop] = (function() {
                        var _super = function() {
                                return base.prototype[prop].apply(this, arguments);
                            },
                            _superApply = function(args) {
                                return base.prototype[prop].apply(this, args);
                            };
                        return function() {
                            var __super = this._super,
                                __superApply = this._superApply,
                                returnValue;

                            this._super = _super;
                            this._superApply = _superApply;

                            returnValue = value.apply(this, arguments);

                            this._super = __super;
                            this._superApply = __superApply;

                            return returnValue;
                        };
                    })();
                });
                constructor.prototype = $.widget.extend(basePrototype, {
                    // TODO: remove support for widgetEventPrefix
                    // always use the name + a colon as the prefix, e.g., draggable:start
                    // don't prefix for widgets that aren't DOM-based
                    widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
                }, proxiedPrototype, {
                    constructor: constructor,
                    namespace: namespace,
                    widgetName: name,
                    widgetFullName: fullName
                });

                // If this widget is being redefined then we need to find all widgets that
                // are inheriting from it and redefine all of them so that they inherit from
                // the new version of this widget. We're essentially trying to replace one
                // level in the prototype chain.
                if (existingConstructor) {
                    $.each(existingConstructor._childConstructors, function(i, child) {
                        var childPrototype = child.prototype;

                        // redefine the child widget using the same prototype that was
                        // originally used, but inherit from the new version of the base
                        $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
                    });
                    // remove the list of existing child constructors from the old constructor
                    // so the old child constructors can be garbage collected
                    delete existingConstructor._childConstructors;
                } else {
                    base._childConstructors.push(constructor);
                }

                $.widget.bridge(name, constructor);
            };

            $.widget.extend = function(target) {
                var input = slice.call(arguments, 1),
                    inputIndex = 0,
                    inputLength = input.length,
                    key,
                    value;
                for (; inputIndex < inputLength; inputIndex++) {
                    for (key in input[inputIndex]) {
                        value = input[inputIndex][key];
                        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                            // Clone objects
                            if ($.isPlainObject(value)) {
                                target[key] = $.isPlainObject(target[key]) ?
                                    $.widget.extend({}, target[key], value) :
                                    // Don't extend strings, arrays, etc. with objects
                                    $.widget.extend({}, value);
                                // Copy everything else by reference
                            } else {
                                target[key] = value;
                            }
                        }
                    }
                }
                return target;
            };

            $.widget.bridge = function(name, object) {
                var fullName = object.prototype.widgetFullName || name;
                $.fn[name] = function(options) {
                    var isMethodCall = typeof options === "string",
                        args = slice.call(arguments, 1),
                        returnValue = this;

                    // allow multiple hashes to be passed on init
                    options = !isMethodCall && args.length ?
                        $.widget.extend.apply(null, [options].concat(args)) :
                        options;

                    if (isMethodCall) {
                        this.each(function() {
                            var methodValue,
                                instance = $.data(this, fullName);
                            if (!instance) {
                                return $.error("cannot call methods on " + name + " prior to initialization; " +
                                    "attempted to call method '" + options + "'");
                            }
                            if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                                return $.error("no such method '" + options + "' for " + name + " widget instance");
                            }
                            methodValue = instance[options].apply(instance, args);
                            if (methodValue !== instance && methodValue !== undefined) {
                                returnValue = methodValue && methodValue.jquery ?
                                    returnValue.pushStack(methodValue.get()) :
                                    methodValue;
                                return false;
                            }
                        });
                    } else {
                        this.each(function() {
                            var instance = $.data(this, fullName);
                            if (instance) {
                                instance.option(options || {})._init();
                            } else {
                                $.data(this, fullName, new object(options, this));
                            }
                        });
                    }

                    return returnValue;
                };
            };

            $.Widget = function( /* options, element */ ) {};
            $.Widget._childConstructors = [];

            $.Widget.prototype = {
                widgetName: "widget",
                widgetEventPrefix: "",
                defaultElement: "<div>",
                options: {
                    disabled: false,

                    // callbacks
                    create: null
                },
                _createWidget: function(options, element) {
                    element = $(element || this.defaultElement || this)[0];
                    this.element = $(element);
                    this.uuid = uuid++;
                    this.eventNamespace = "." + this.widgetName + this.uuid;
                    this.options = $.widget.extend({},
                        this.options,
                        this._getCreateOptions(),
                        options);

                    this.bindings = $();
                    this.hoverable = $();
                    this.focusable = $();

                    if (element !== this) {
                        $.data(element, this.widgetFullName, this);
                        this._on(true, this.element, {
                            remove: function(event) {
                                if (event.target === element) {
                                    this.destroy();
                                }
                            }
                        });
                        this.document = $(element.style ?
                            // element within the document
                            element.ownerDocument :
                            // element is window or document
                            element.document || element);
                        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
                    }

                    this._create();
                    this._trigger("create", null, this._getCreateEventData());
                    this._init();
                },
                _getCreateOptions: $.noop,
                _getCreateEventData: $.noop,
                _create: $.noop,
                _init: $.noop,

                destroy: function() {
                    this._destroy();
                    // we can probably remove the unbind calls in 2.0
                    // all event bindings should go through this._on()
                    this.element
                        .unbind(this.eventNamespace)
                        // 1.9 BC for #7810
                        // TODO remove dual storage
                        .removeData(this.widgetName)
                        .removeData(this.widgetFullName)
                        // support: jquery <1.6.3
                        // http://bugs.jquery.com/ticket/9413
                        .removeData($.camelCase(this.widgetFullName));
                    this.widget()
                        .unbind(this.eventNamespace)
                        .removeAttr("aria-disabled")
                        .removeClass(
                            this.widgetFullName + "-disabled " +
                            "ui-state-disabled");

                    // clean up events and states
                    this.bindings.unbind(this.eventNamespace);
                    this.hoverable.removeClass("ui-state-hover");
                    this.focusable.removeClass("ui-state-focus");
                },
                _destroy: $.noop,

                widget: function() {
                    return this.element;
                },

                option: function(key, value) {
                    var options = key,
                        parts,
                        curOption,
                        i;

                    if (arguments.length === 0) {
                        // don't return a reference to the internal hash
                        return $.widget.extend({}, this.options);
                    }

                    if (typeof key === "string") {
                        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                        options = {};
                        parts = key.split(".");
                        key = parts.shift();
                        if (parts.length) {
                            curOption = options[key] = $.widget.extend({}, this.options[key]);
                            for (i = 0; i < parts.length - 1; i++) {
                                curOption[parts[i]] = curOption[parts[i]] || {};
                                curOption = curOption[parts[i]];
                            }
                            key = parts.pop();
                            if (value === undefined) {
                                return curOption[key] === undefined ? null : curOption[key];
                            }
                            curOption[key] = value;
                        } else {
                            if (value === undefined) {
                                return this.options[key] === undefined ? null : this.options[key];
                            }
                            options[key] = value;
                        }
                    }

                    this._setOptions(options);

                    return this;
                },
                _setOptions: function(options) {
                    var key;

                    for (key in options) {
                        this._setOption(key, options[key]);
                    }

                    return this;
                },
                _setOption: function(key, value) {
                    this.options[key] = value;

                    if (key === "disabled") {
                        this.widget()
                            .toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value)
                            .attr("aria-disabled", value);
                        this.hoverable.removeClass("ui-state-hover");
                        this.focusable.removeClass("ui-state-focus");
                    }

                    return this;
                },

                enable: function() {
                    return this._setOption("disabled", false);
                },
                disable: function() {
                    return this._setOption("disabled", true);
                },

                _on: function(suppressDisabledCheck, element, handlers) {
                    var delegateElement,
                        instance = this;

                    // no suppressDisabledCheck flag, shuffle arguments
                    if (typeof suppressDisabledCheck !== "boolean") {
                        handlers = element;
                        element = suppressDisabledCheck;
                        suppressDisabledCheck = false;
                    }

                    // no element argument, shuffle and use this.element
                    if (!handlers) {
                        handlers = element;
                        element = this.element;
                        delegateElement = this.widget();
                    } else {
                        // accept selectors, DOM elements
                        element = delegateElement = $(element);
                        this.bindings = this.bindings.add(element);
                    }

                    $.each(handlers, function(event, handler) {
                        function handlerProxy() {
                            // allow widgets to customize the disabled handling
                            // - disabled as an array instead of boolean
                            // - disabled class as method for disabling individual parts
                            if (!suppressDisabledCheck &&
                                (instance.options.disabled === true ||
                                    $(this).hasClass("ui-state-disabled"))) {
                                return;
                            }
                            return (typeof handler === "string" ? instance[handler] : handler)
                                .apply(instance, arguments);
                        }

                        // copy the guid so direct unbinding works
                        if (typeof handler !== "string") {
                            handlerProxy.guid = handler.guid =
                                handler.guid || handlerProxy.guid || $.guid++;
                        }

                        var match = event.match(/^(\w+)\s*(.*)$/),
                            eventName = match[1] + instance.eventNamespace,
                            selector = match[2];
                        if (selector) {
                            delegateElement.delegate(selector, eventName, handlerProxy);
                        } else {
                            element.bind(eventName, handlerProxy);
                        }
                    });
                },

                _off: function(element, eventName) {
                    eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
                    element.unbind(eventName).undelegate(eventName);
                },

                _delay: function(handler, delay) {
                    function handlerProxy() {
                        return (typeof handler === "string" ? instance[handler] : handler)
                            .apply(instance, arguments);
                    }
                    var instance = this;
                    return setTimeout(handlerProxy, delay || 0);
                },

                _hoverable: function(element) {
                    this.hoverable = this.hoverable.add(element);
                    this._on(element, {
                        mouseenter: function(event) {
                            $(event.currentTarget).addClass("ui-state-hover");
                        },
                        mouseleave: function(event) {
                            $(event.currentTarget).removeClass("ui-state-hover");
                        }
                    });
                },

                _focusable: function(element) {
                    this.focusable = this.focusable.add(element);
                    this._on(element, {
                        focusin: function(event) {
                            $(event.currentTarget).addClass("ui-state-focus");
                        },
                        focusout: function(event) {
                            $(event.currentTarget).removeClass("ui-state-focus");
                        }
                    });
                },

                _trigger: function(type, event, data) {
                    var prop, orig,
                        callback = this.options[type];

                    data = data || {};
                    event = $.Event(event);
                    event.type = (type === this.widgetEventPrefix ?
                        type :
                        this.widgetEventPrefix + type).toLowerCase();
                    // the original event may come from any element
                    // so we need to reset the target on the new event
                    event.target = this.element[0];

                    // copy original event properties over to the new event
                    orig = event.originalEvent;
                    if (orig) {
                        for (prop in orig) {
                            if (!(prop in event)) {
                                event[prop] = orig[prop];
                            }
                        }
                    }

                    this.element.trigger(event, data);
                    return !($.isFunction(callback) &&
                        callback.apply(this.element[0], [event].concat(data)) === false ||
                        event.isDefaultPrevented());
                }
            };

            $.each({
                show: "fadeIn",
                hide: "fadeOut"
            }, function(method, defaultEffect) {
                $.Widget.prototype["_" + method] = function(element, options, callback) {
                    if (typeof options === "string") {
                        options = {
                            effect: options
                        };
                    }
                    var hasOptions,
                        effectName = !options ?
                        method :
                        options === true || typeof options === "number" ?
                        defaultEffect :
                        options.effect || defaultEffect;
                    options = options || {};
                    if (typeof options === "number") {
                        options = {
                            duration: options
                        };
                    }
                    hasOptions = !$.isEmptyObject(options);
                    options.complete = callback;
                    if (options.delay) {
                        element.delay(options.delay);
                    }
                    if (hasOptions && $.effects && $.effects.effect[effectName]) {
                        element[method](options);
                    } else if (effectName !== method && element[effectName]) {
                        element[effectName](options.duration, options.easing, callback);
                    } else {
                        element.queue(function(next) {
                            $(this)[method]();
                            if (callback) {
                                callback.call(element[0]);
                            }
                            next();
                        });
                    }
                };
            });

        })(jQuery);

        (function($, undefined) {

            var mouseHandled = false;
            $(document).mouseup(function() {
                mouseHandled = false;
            });

            $.widget("ui.mouse", {
                version: "1.10.3",
                options: {
                    cancel: "input,textarea,button,select,option",
                    distance: 1,
                    delay: 0
                },
                _mouseInit: function() {
                    var that = this;

                    this.element
                        .bind("mousedown." + this.widgetName, function(event) {
                            return that._mouseDown(event);
                        })
                        .bind("click." + this.widgetName, function(event) {
                            if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                                $.removeData(event.target, that.widgetName + ".preventClickEvent");
                                event.stopImmediatePropagation();
                                return false;
                            }
                        });

                    this.started = false;
                },

                // TODO: make sure destroying one instance of mouse doesn't mess with
                // other instances of mouse
                _mouseDestroy: function() {
                    this.element.unbind("." + this.widgetName);
                    if (this._mouseMoveDelegate) {
                        $(document)
                            .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                            .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
                    }
                },

                _mouseDown: function(event) {
                    // don't let more than one widget handle mouseStart
                    if (mouseHandled) {
                        return;
                    }

                    // we may have missed mouseup (out of window)
                    (this._mouseStarted && this._mouseUp(event));

                    this._mouseDownEvent = event;

                    var that = this,
                        btnIsLeft = (event.which === 1),
                        // event.target.nodeName works around a bug in IE 8 with
                        // disabled inputs (#7620)
                        elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
                    if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                        return true;
                    }

                    this.mouseDelayMet = !this.options.delay;
                    if (!this.mouseDelayMet) {
                        this._mouseDelayTimer = setTimeout(function() {
                            that.mouseDelayMet = true;
                        }, this.options.delay);
                    }

                    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                        this._mouseStarted = (this._mouseStart(event) !== false);
                        if (!this._mouseStarted) {
                            event.preventDefault();
                            return true;
                        }
                    }

                    // Click event may never have fired (Gecko & Opera)
                    if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, this.widgetName + ".preventClickEvent");
                    }

                    // these delegates are required to keep context
                    this._mouseMoveDelegate = function(event) {
                        return that._mouseMove(event);
                    };
                    this._mouseUpDelegate = function(event) {
                        return that._mouseUp(event);
                    };
                    $(document)
                        .bind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                        .bind("mouseup." + this.widgetName, this._mouseUpDelegate);

                    event.preventDefault();

                    mouseHandled = true;
                    return true;
                },

                _mouseMove: function(event) {
                    // IE mouseup check - mouseup happened when mouse was out of window
                    if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                        return this._mouseUp(event);
                    }

                    if (this._mouseStarted) {
                        this._mouseDrag(event);
                        return event.preventDefault();
                    }

                    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                        this._mouseStarted =
                            (this._mouseStart(this._mouseDownEvent, event) !== false);
                        (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
                    }

                    return !this._mouseStarted;
                },

                _mouseUp: function(event) {
                    $(document)
                        .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                        .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);

                    if (this._mouseStarted) {
                        this._mouseStarted = false;

                        if (event.target === this._mouseDownEvent.target) {
                            $.data(event.target, this.widgetName + ".preventClickEvent", true);
                        }

                        this._mouseStop(event);
                    }

                    return false;
                },

                _mouseDistanceMet: function(event) {
                    return (Math.max(
                        Math.abs(this._mouseDownEvent.pageX - event.pageX),
                        Math.abs(this._mouseDownEvent.pageY - event.pageY)
                    ) >= this.options.distance);
                },

                _mouseDelayMet: function( /* event */ ) {
                    return this.mouseDelayMet;
                },

                // These are placeholder methods, to be overriden by extending plugin
                _mouseStart: function( /* event */ ) {},
                _mouseDrag: function( /* event */ ) {},
                _mouseStop: function( /* event */ ) {},
                _mouseCapture: function( /* event */ ) {
                    return true;
                }
            });

        })(jQuery);

        (function($, undefined) {

            $.widget("ui.draggable", $.ui.mouse, {
                version: "1.10.3",
                widgetEventPrefix: "drag",
                options: {
                    addClasses: true,
                    appendTo: "parent",
                    axis: false,
                    connectToSortable: false,
                    containment: false,
                    cursor: "auto",
                    cursorAt: false,
                    grid: false,
                    handle: false,
                    helper: "original",
                    iframeFix: false,
                    opacity: false,
                    refreshPositions: false,
                    revert: false,
                    revertDuration: 500,
                    scope: "default",
                    scroll: true,
                    scrollSensitivity: 20,
                    scrollSpeed: 20,
                    snap: false,
                    snapMode: "both",
                    snapTolerance: 20,
                    stack: false,
                    zIndex: false,

                    // callbacks
                    drag: null,
                    start: null,
                    stop: null
                },
                _create: function() {

                    if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
                        this.element[0].style.position = "relative";
                    }
                    if (this.options.addClasses) {
                        this.element.addClass("ui-draggable");
                    }
                    if (this.options.disabled) {
                        this.element.addClass("ui-draggable-disabled");
                    }

                    this._mouseInit();

                },

                _destroy: function() {
                    this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
                    this._mouseDestroy();
                },

                _mouseCapture: function(event) {

                    var o = this.options;

                    // among others, prevent a drag on a resizable-handle
                    if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                        return false;
                    }

                    //Quit if we're not on a valid handle
                    this.handle = this._getHandle(event);
                    if (!this.handle) {
                        return false;
                    }

                    $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
                        $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
                            .css({
                                width: this.offsetWidth + "px",
                                height: this.offsetHeight + "px",
                                position: "absolute",
                                opacity: "0.001",
                                zIndex: 1000
                            })
                            .css($(this).offset())
                            .appendTo("body");
                    });

                    return true;

                },

                _mouseStart: function(event) {

                    var o = this.options;

                    //Create and append the visible helper
                    this.helper = this._createHelper(event);

                    this.helper.addClass("ui-draggable-dragging");

                    //Cache the helper size
                    this._cacheHelperProportions();

                    //If ddmanager is used for droppables, set the global draggable
                    if ($.ui.ddmanager) {
                        $.ui.ddmanager.current = this;
                    }

                    /*
                     * - Position generation -
                     * This block generates everything position related - it's the core of draggables.
                     */

                    //Cache the margins of the original element
                    this._cacheMargins();

                    //Store the helper's css position
                    this.cssPosition = this.helper.css("position");
                    this.scrollParent = this.helper.scrollParent();
                    this.offsetParent = this.helper.offsetParent();
                    this.offsetParentCssPosition = this.offsetParent.css("position");

                    //The element's absolute position on the page minus margins
                    this.offset = this.positionAbs = this.element.offset();
                    this.offset = {
                        top: this.offset.top - this.margins.top,
                        left: this.offset.left - this.margins.left
                    };

                    //Reset scroll cache
                    this.offset.scroll = false;

                    $.extend(this.offset, {
                        click: { //Where the click happened, relative to the element
                            left: event.pageX - this.offset.left,
                            top: event.pageY - this.offset.top
                        },
                        parent: this._getParentOffset(),
                        relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
                    });

                    //Generate the original position
                    this.originalPosition = this.position = this._generatePosition(event);
                    this.originalPageX = event.pageX;
                    this.originalPageY = event.pageY;

                    //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

                    //Set a containment if given in the options
                    this._setContainment();

                    //Trigger event + callbacks
                    if (this._trigger("start", event) === false) {
                        this._clear();
                        return false;
                    }

                    //Recache the helper size
                    this._cacheHelperProportions();

                    //Prepare the droppable offsets
                    if ($.ui.ddmanager && !o.dropBehaviour) {
                        $.ui.ddmanager.prepareOffsets(this, event);
                    }


                    this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

                    //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
                    if ($.ui.ddmanager) {
                        $.ui.ddmanager.dragStart(this, event);
                    }

                    return true;
                },

                _mouseDrag: function(event, noPropagation) {
                    // reset any necessary cached properties (see #5009)
                    if (this.offsetParentCssPosition === "fixed") {
                        this.offset.parent = this._getParentOffset();
                    }

                    //Compute the helpers position
                    this.position = this._generatePosition(event);
                    this.positionAbs = this._convertPositionTo("absolute");

                    //Call plugins and callbacks and use the resulting position if something is returned
                    if (!noPropagation) {
                        var ui = this._uiHash();
                        if (this._trigger("drag", event, ui) === false) {
                            this._mouseUp({});
                            return false;
                        }
                        this.position = ui.position;
                    }

                    if (!this.options.axis || this.options.axis !== "y") {
                        this.helper[0].style.left = this.position.left + "px";
                    }
                    if (!this.options.axis || this.options.axis !== "x") {
                        this.helper[0].style.top = this.position.top + "px";
                    }
                    if ($.ui.ddmanager) {
                        $.ui.ddmanager.drag(this, event);
                    }

                    return false;
                },

                _mouseStop: function(event) {

                    //If we are using droppables, inform the manager about the drop
                    var that = this,
                        dropped = false;
                    if ($.ui.ddmanager && !this.options.dropBehaviour) {
                        dropped = $.ui.ddmanager.drop(this, event);
                    }

                    //if a drop comes from outside (a sortable)
                    if (this.dropped) {
                        dropped = this.dropped;
                        this.dropped = false;
                    }

                    //if the original element is no longer in the DOM don't bother to continue (see #8269)
                    if (this.options.helper === "original" && !$.contains(this.element[0].ownerDocument, this.element[0])) {
                        return false;
                    }

                    if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
                        $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                            if (that._trigger("stop", event) !== false) {
                                that._clear();
                            }
                        });
                    } else {
                        if (this._trigger("stop", event) !== false) {
                            this._clear();
                        }
                    }

                    return false;
                },

                _mouseUp: function(event) {
                    //Remove frame helpers
                    $("div.ui-draggable-iframeFix").each(function() {
                        this.parentNode.removeChild(this);
                    });

                    //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
                    if ($.ui.ddmanager) {
                        $.ui.ddmanager.dragStop(this, event);
                    }

                    return $.ui.mouse.prototype._mouseUp.call(this, event);
                },

                cancel: function() {

                    if (this.helper.is(".ui-draggable-dragging")) {
                        this._mouseUp({});
                    } else {
                        this._clear();
                    }

                    return this;

                },

                _getHandle: function(event) {
                    return this.options.handle ?
                        !!$(event.target).closest(this.element.find(this.options.handle)).length :
                        true;
                },

                _createHelper: function(event) {

                    var o = this.options,
                        helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

                    if (!helper.parents("body").length) {
                        helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
                    }

                    if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
                        helper.css("position", "absolute");
                    }

                    return helper;

                },

                _adjustOffsetFromHelper: function(obj) {
                    if (typeof obj === "string") {
                        obj = obj.split(" ");
                    }
                    if ($.isArray(obj)) {
                        obj = {
                            left: +obj[0],
                            top: +obj[1] || 0
                        };
                    }
                    if ("left" in obj) {
                        this.offset.click.left = obj.left + this.margins.left;
                    }
                    if ("right" in obj) {
                        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                    }
                    if ("top" in obj) {
                        this.offset.click.top = obj.top + this.margins.top;
                    }
                    if ("bottom" in obj) {
                        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                    }
                },

                _getParentOffset: function() {

                    //Get the offsetParent and cache its position
                    var po = this.offsetParent.offset();

                    // This is a special case where we need to modify a offset calculated on start, since the following happened:
                    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                    if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                        po.left += this.scrollParent.scrollLeft();
                        po.top += this.scrollParent.scrollTop();
                    }

                    //This needs to be actually done for all browsers, since pageX/pageY includes this information
                    //Ugly IE fix
                    if ((this.offsetParent[0] === document.body) ||
                        (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                        po = {
                            top: 0,
                            left: 0
                        };
                    }

                    return {
                        top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                        left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                    };

                },

                _getRelativeOffset: function() {

                    if (this.cssPosition === "relative") {
                        var p = this.element.position();
                        return {
                            top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                            left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                        };
                    } else {
                        return {
                            top: 0,
                            left: 0
                        };
                    }

                },

                _cacheMargins: function() {
                    this.margins = {
                        left: (parseInt(this.element.css("marginLeft"), 10) || 0),
                        top: (parseInt(this.element.css("marginTop"), 10) || 0),
                        right: (parseInt(this.element.css("marginRight"), 10) || 0),
                        bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
                    };
                },

                _cacheHelperProportions: function() {
                    this.helperProportions = {
                        width: this.helper.outerWidth(),
                        height: this.helper.outerHeight()
                    };
                },

                _setContainment: function() {

                    var over, c, ce,
                        o = this.options;

                    if (!o.containment) {
                        this.containment = null;
                        return;
                    }

                    if (o.containment === "window") {
                        this.containment = [
                            $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                            $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                            $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left,
                            $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                        ];
                        return;
                    }

                    if (o.containment === "document") {
                        this.containment = [
                            0,
                            0,
                            $(document).width() - this.helperProportions.width - this.margins.left,
                            ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                        ];
                        return;
                    }

                    if (o.containment.constructor === Array) {
                        this.containment = o.containment;
                        return;
                    }

                    if (o.containment === "parent") {
                        o.containment = this.helper[0].parentNode;
                    }

                    c = $(o.containment);
                    ce = c[0];

                    if (!ce) {
                        return;
                    }

                    over = c.css("overflow") !== "hidden";

                    this.containment = [
                        (parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0),
                        (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0),
                        (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
                        (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom
                    ];
                    this.relative_container = c;
                },

                _convertPositionTo: function(d, pos) {

                    if (!pos) {
                        pos = this.position;
                    }

                    var mod = d === "absolute" ? 1 : -1,
                        scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent;

                    //Cache the scroll
                    if (!this.offset.scroll) {
                        this.offset.scroll = {
                            top: scroll.scrollTop(),
                            left: scroll.scrollLeft()
                        };
                    }

                    return {
                        top: (
                            pos.top + // The absolute mouse position
                            this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
                            ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top) * mod)
                        ),
                        left: (
                            pos.left + // The absolute mouse position
                            this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
                            ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left) * mod)
                        )
                    };

                },

                _generatePosition: function(event) {

                    var containment, co, top, left,
                        o = this.options,
                        scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                        pageX = event.pageX,
                        pageY = event.pageY;

                    //Cache the scroll
                    if (!this.offset.scroll) {
                        this.offset.scroll = {
                            top: scroll.scrollTop(),
                            left: scroll.scrollLeft()
                        };
                    }

                    /*
                     * - Position constraining -
                     * Constrain the position to a mix of grid, containment.
                     */

                    // If we are not dragging yet, we won't check for options
                    if (this.originalPosition) {
                        if (this.containment) {
                            if (this.relative_container) {
                                co = this.relative_container.offset();
                                containment = [
                                    this.containment[0] + co.left,
                                    this.containment[1] + co.top,
                                    this.containment[2] + co.left,
                                    this.containment[3] + co.top
                                ];
                            } else {
                                containment = this.containment;
                            }

                            if (event.pageX - this.offset.click.left < containment[0]) {
                                pageX = containment[0] + this.offset.click.left;
                            }
                            if (event.pageY - this.offset.click.top < containment[1]) {
                                pageY = containment[1] + this.offset.click.top;
                            }
                            if (event.pageX - this.offset.click.left > containment[2]) {
                                pageX = containment[2] + this.offset.click.left;
                            }
                            if (event.pageY - this.offset.click.top > containment[3]) {
                                pageY = containment[3] + this.offset.click.top;
                            }
                        }

                        if (o.grid) {
                            //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                            top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                            pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                            left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                            pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                        }

                    }

                    return {
                        top: (
                            pageY - // The absolute mouse position
                            this.offset.click.top - // Click offset (relative to the element)
                            this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.top + // The offsetParent's offset without borders (offset + border)
                            (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top)
                        ),
                        left: (
                            pageX - // The absolute mouse position
                            this.offset.click.left - // Click offset (relative to the element)
                            this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.left + // The offsetParent's offset without borders (offset + border)
                            (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left)
                        )
                    };

                },

                _clear: function() {
                    this.helper.removeClass("ui-draggable-dragging");
                    if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                        this.helper.remove();
                    }
                    this.helper = null;
                    this.cancelHelperRemoval = false;
                },

                // From now on bulk stuff - mainly helpers

                _trigger: function(type, event, ui) {
                    ui = ui || this._uiHash();
                    $.ui.plugin.call(this, type, [event, ui]);
                    //The absolute position has to be recalculated after plugins
                    if (type === "drag") {
                        this.positionAbs = this._convertPositionTo("absolute");
                    }
                    return $.Widget.prototype._trigger.call(this, type, event, ui);
                },

                plugins: {},

                _uiHash: function() {
                    return {
                        helper: this.helper,
                        position: this.position,
                        originalPosition: this.originalPosition,
                        offset: this.positionAbs
                    };
                }

            });

            $.ui.plugin.add("draggable", "connectToSortable", {
                start: function(event, ui) {

                    var inst = $(this).data("ui-draggable"),
                        o = inst.options,
                        uiSortable = $.extend({}, ui, {
                            item: inst.element
                        });
                    inst.sortables = [];
                    $(o.connectToSortable).each(function() {
                        var sortable = $.data(this, "ui-sortable");
                        if (sortable && !sortable.options.disabled) {
                            inst.sortables.push({
                                instance: sortable,
                                shouldRevert: sortable.options.revert
                            });
                            sortable.refreshPositions(); // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
                            sortable._trigger("activate", event, uiSortable);
                        }
                    });

                },
                stop: function(event, ui) {

                    //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
                    var inst = $(this).data("ui-draggable"),
                        uiSortable = $.extend({}, ui, {
                            item: inst.element
                        });

                    $.each(inst.sortables, function() {
                        if (this.instance.isOver) {

                            this.instance.isOver = 0;

                            inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
                            this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

                            //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
                            if (this.shouldRevert) {
                                this.instance.options.revert = this.shouldRevert;
                            }

                            //Trigger the stop of the sortable
                            this.instance._mouseStop(event);

                            this.instance.options.helper = this.instance.options._helper;

                            //If the helper has been the original item, restore properties in the sortable
                            if (inst.options.helper === "original") {
                                this.instance.currentItem.css({
                                    top: "auto",
                                    left: "auto"
                                });
                            }

                        } else {
                            this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
                            this.instance._trigger("deactivate", event, uiSortable);
                        }

                    });

                },
                drag: function(event, ui) {

                    var inst = $(this).data("ui-draggable"),
                        that = this;

                    $.each(inst.sortables, function() {

                        var innermostIntersecting = false,
                            thisSortable = this;

                        //Copy over some variables to allow calling the sortable's native _intersectsWith
                        this.instance.positionAbs = inst.positionAbs;
                        this.instance.helperProportions = inst.helperProportions;
                        this.instance.offset.click = inst.offset.click;

                        if (this.instance._intersectsWith(this.instance.containerCache)) {
                            innermostIntersecting = true;
                            $.each(inst.sortables, function() {
                                this.instance.positionAbs = inst.positionAbs;
                                this.instance.helperProportions = inst.helperProportions;
                                this.instance.offset.click = inst.offset.click;
                                if (this !== thisSortable &&
                                    this.instance._intersectsWith(this.instance.containerCache) &&
                                    $.contains(thisSortable.instance.element[0], this.instance.element[0])
                                ) {
                                    innermostIntersecting = false;
                                }
                                return innermostIntersecting;
                            });
                        }


                        if (innermostIntersecting) {
                            //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
                            if (!this.instance.isOver) {

                                this.instance.isOver = 1;
                                //Now we fake the start of dragging for the sortable instance,
                                //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
                                //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
                                this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
                                this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
                                this.instance.options.helper = function() {
                                    return ui.helper[0];
                                };

                                event.target = this.instance.currentItem[0];
                                this.instance._mouseCapture(event, true);
                                this.instance._mouseStart(event, true, true);

                                //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
                                this.instance.offset.click.top = inst.offset.click.top;
                                this.instance.offset.click.left = inst.offset.click.left;
                                this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
                                this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

                                inst._trigger("toSortable", event);
                                inst.dropped = this.instance.element; //draggable revert needs that
                                //hack so receive/update callbacks work (mostly)
                                inst.currentItem = inst.element;
                                this.instance.fromOutside = inst;

                            }

                            //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
                            if (this.instance.currentItem) {
                                this.instance._mouseDrag(event);
                            }

                        } else {

                            //If it doesn't intersect with the sortable, and it intersected before,
                            //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
                            if (this.instance.isOver) {

                                this.instance.isOver = 0;
                                this.instance.cancelHelperRemoval = true;

                                //Prevent reverting on this forced stop
                                this.instance.options.revert = false;

                                // The out event needs to be triggered independently
                                this.instance._trigger("out", event, this.instance._uiHash(this.instance));

                                this.instance._mouseStop(event, true);
                                this.instance.options.helper = this.instance.options._helper;

                                //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
                                this.instance.currentItem.remove();
                                if (this.instance.placeholder) {
                                    this.instance.placeholder.remove();
                                }

                                inst._trigger("fromSortable", event);
                                inst.dropped = false; //draggable revert needs that
                            }

                        }

                    });

                }
            });

            $.ui.plugin.add("draggable", "cursor", {
                start: function() {
                    var t = $("body"),
                        o = $(this).data("ui-draggable").options;
                    if (t.css("cursor")) {
                        o._cursor = t.css("cursor");
                    }
                    t.css("cursor", o.cursor);
                },
                stop: function() {
                    var o = $(this).data("ui-draggable").options;
                    if (o._cursor) {
                        $("body").css("cursor", o._cursor);
                    }
                }
            });

            $.ui.plugin.add("draggable", "opacity", {
                start: function(event, ui) {
                    var t = $(ui.helper),
                        o = $(this).data("ui-draggable").options;
                    if (t.css("opacity")) {
                        o._opacity = t.css("opacity");
                    }
                    t.css("opacity", o.opacity);
                },
                stop: function(event, ui) {
                    var o = $(this).data("ui-draggable").options;
                    if (o._opacity) {
                        $(ui.helper).css("opacity", o._opacity);
                    }
                }
            });

            $.ui.plugin.add("draggable", "scroll", {
                start: function() {
                    var i = $(this).data("ui-draggable");
                    if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                        i.overflowOffset = i.scrollParent.offset();
                    }
                },
                drag: function(event) {

                    var i = $(this).data("ui-draggable"),
                        o = i.options,
                        scrolled = false;

                    if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

                        if (!o.axis || o.axis !== "x") {
                            if ((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                                i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
                            } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                                i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
                            }
                        }

                        if (!o.axis || o.axis !== "y") {
                            if ((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                                i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
                            } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                                i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
                            }
                        }

                    } else {

                        if (!o.axis || o.axis !== "x") {
                            if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                                scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                            } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                                scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                            }
                        }

                        if (!o.axis || o.axis !== "y") {
                            if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                                scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                            } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                                scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                            }
                        }

                    }

                    if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                        $.ui.ddmanager.prepareOffsets(i, event);
                    }

                }
            });

            $.ui.plugin.add("draggable", "snap", {
                start: function() {

                    var i = $(this).data("ui-draggable"),
                        o = i.options;

                    i.snapElements = [];

                    $(o.snap.constructor !== String ? (o.snap.items || ":data(ui-draggable)") : o.snap).each(function() {
                        var $t = $(this),
                            $o = $t.offset();
                        if (this !== i.element[0]) {
                            i.snapElements.push({
                                item: this,
                                width: $t.outerWidth(),
                                height: $t.outerHeight(),
                                top: $o.top,
                                left: $o.left
                            });
                        }
                    });

                },
                drag: function(event, ui) {

                    var ts, bs, ls, rs, l, r, t, b, i, first,
                        inst = $(this).data("ui-draggable"),
                        o = inst.options,
                        d = o.snapTolerance,
                        x1 = ui.offset.left,
                        x2 = x1 + inst.helperProportions.width,
                        y1 = ui.offset.top,
                        y2 = y1 + inst.helperProportions.height;

                    for (i = inst.snapElements.length - 1; i >= 0; i--) {

                        l = inst.snapElements[i].left;
                        r = l + inst.snapElements[i].width;
                        t = inst.snapElements[i].top;
                        b = t + inst.snapElements[i].height;

                        if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
                            if (inst.snapElements[i].snapping) {
                                (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                                    snapItem: inst.snapElements[i].item
                                })));
                            }
                            inst.snapElements[i].snapping = false;
                            continue;
                        }

                        if (o.snapMode !== "inner") {
                            ts = Math.abs(t - y2) <= d;
                            bs = Math.abs(b - y1) <= d;
                            ls = Math.abs(l - x2) <= d;
                            rs = Math.abs(r - x1) <= d;
                            if (ts) {
                                ui.position.top = inst._convertPositionTo("relative", {
                                    top: t - inst.helperProportions.height,
                                    left: 0
                                }).top - inst.margins.top;
                            }
                            if (bs) {
                                ui.position.top = inst._convertPositionTo("relative", {
                                    top: b,
                                    left: 0
                                }).top - inst.margins.top;
                            }
                            if (ls) {
                                ui.position.left = inst._convertPositionTo("relative", {
                                    top: 0,
                                    left: l - inst.helperProportions.width
                                }).left - inst.margins.left;
                            }
                            if (rs) {
                                ui.position.left = inst._convertPositionTo("relative", {
                                    top: 0,
                                    left: r
                                }).left - inst.margins.left;
                            }
                        }

                        first = (ts || bs || ls || rs);

                        if (o.snapMode !== "outer") {
                            ts = Math.abs(t - y1) <= d;
                            bs = Math.abs(b - y2) <= d;
                            ls = Math.abs(l - x1) <= d;
                            rs = Math.abs(r - x2) <= d;
                            if (ts) {
                                ui.position.top = inst._convertPositionTo("relative", {
                                    top: t,
                                    left: 0
                                }).top - inst.margins.top;
                            }
                            if (bs) {
                                ui.position.top = inst._convertPositionTo("relative", {
                                    top: b - inst.helperProportions.height,
                                    left: 0
                                }).top - inst.margins.top;
                            }
                            if (ls) {
                                ui.position.left = inst._convertPositionTo("relative", {
                                    top: 0,
                                    left: l
                                }).left - inst.margins.left;
                            }
                            if (rs) {
                                ui.position.left = inst._convertPositionTo("relative", {
                                    top: 0,
                                    left: r - inst.helperProportions.width
                                }).left - inst.margins.left;
                            }
                        }

                        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                            (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                                snapItem: inst.snapElements[i].item
                            })));
                        }
                        inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

                    }

                }
            });

            $.ui.plugin.add("draggable", "stack", {
                start: function() {
                    var min,
                        o = this.data("ui-draggable").options,
                        group = $.makeArray($(o.stack)).sort(function(a, b) {
                            return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
                        });

                    if (!group.length) {
                        return;
                    }

                    min = parseInt($(group[0]).css("zIndex"), 10) || 0;
                    $(group).each(function(i) {
                        $(this).css("zIndex", min + i);
                    });
                    this.css("zIndex", (min + group.length));
                }
            });

            $.ui.plugin.add("draggable", "zIndex", {
                start: function(event, ui) {
                    var t = $(ui.helper),
                        o = $(this).data("ui-draggable").options;
                    if (t.css("zIndex")) {
                        o._zIndex = t.css("zIndex");
                    }
                    t.css("zIndex", o.zIndex);
                },
                stop: function(event, ui) {
                    var o = $(this).data("ui-draggable").options;
                    if (o._zIndex) {
                        $(ui.helper).css("zIndex", o._zIndex);
                    }
                }
            });

        })(jQuery);

        (function($, undefined) {

            function isOverAxis(x, reference, size) {
                return (x > reference) && (x < (reference + size));
            }

            $.widget("ui.droppable", {
                version: "1.10.3",
                widgetEventPrefix: "drop",
                options: {
                    accept: "*",
                    activeClass: false,
                    addClasses: true,
                    greedy: false,
                    hoverClass: false,
                    scope: "default",
                    tolerance: "intersect",

                    // callbacks
                    activate: null,
                    deactivate: null,
                    drop: null,
                    out: null,
                    over: null
                },
                _create: function() {

                    var o = this.options,
                        accept = o.accept;

                    this.isover = false;
                    this.isout = true;

                    this.accept = $.isFunction(accept) ? accept : function(d) {
                        return d.is(accept);
                    };

                    //Store the droppable's proportions
                    this.proportions = {
                        width: this.element[0].offsetWidth,
                        height: this.element[0].offsetHeight
                    };

                    // Add the reference and positions to the manager
                    $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
                    $.ui.ddmanager.droppables[o.scope].push(this);

                    (o.addClasses && this.element.addClass("ui-droppable"));

                },

                _destroy: function() {
                    var i = 0,
                        drop = $.ui.ddmanager.droppables[this.options.scope];

                    for (; i < drop.length; i++) {
                        if (drop[i] === this) {
                            drop.splice(i, 1);
                        }
                    }

                    this.element.removeClass("ui-droppable ui-droppable-disabled");
                },

                _setOption: function(key, value) {

                    if (key === "accept") {
                        this.accept = $.isFunction(value) ? value : function(d) {
                            return d.is(value);
                        };
                    }
                    $.Widget.prototype._setOption.apply(this, arguments);
                },

                _activate: function(event) {
                    var draggable = $.ui.ddmanager.current;
                    if (this.options.activeClass) {
                        this.element.addClass(this.options.activeClass);
                    }
                    if (draggable) {
                        this._trigger("activate", event, this.ui(draggable));
                    }
                },

                _deactivate: function(event) {
                    var draggable = $.ui.ddmanager.current;
                    if (this.options.activeClass) {
                        this.element.removeClass(this.options.activeClass);
                    }
                    if (draggable) {
                        this._trigger("deactivate", event, this.ui(draggable));
                    }
                },

                _over: function(event) {

                    var draggable = $.ui.ddmanager.current;

                    // Bail if draggable and droppable are same element
                    if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                        return;
                    }

                    if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                        if (this.options.hoverClass) {
                            this.element.addClass(this.options.hoverClass);
                        }
                        this._trigger("over", event, this.ui(draggable));
                    }

                },

                _out: function(event) {

                    var draggable = $.ui.ddmanager.current;

                    // Bail if draggable and droppable are same element
                    if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                        return;
                    }

                    if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                        if (this.options.hoverClass) {
                            this.element.removeClass(this.options.hoverClass);
                        }
                        this._trigger("out", event, this.ui(draggable));
                    }

                },

                _drop: function(event, custom) {

                    var draggable = custom || $.ui.ddmanager.current,
                        childrenIntersection = false;

                    // Bail if draggable and droppable are same element
                    if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                        return false;
                    }

                    this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                        var inst = $.data(this, "ui-droppable");
                        if (
                            inst.options.greedy &&
                            !inst.options.disabled &&
                            inst.options.scope === draggable.options.scope &&
                            inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
                            $.ui.intersect(draggable, $.extend(inst, {
                                offset: inst.element.offset()
                            }), inst.options.tolerance)
                        ) {
                            childrenIntersection = true;
                            return false;
                        }
                    });
                    if (childrenIntersection) {
                        return false;
                    }

                    if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                        if (this.options.activeClass) {
                            this.element.removeClass(this.options.activeClass);
                        }
                        if (this.options.hoverClass) {
                            this.element.removeClass(this.options.hoverClass);
                        }
                        this._trigger("drop", event, this.ui(draggable));
                        return this.element;
                    }

                    return false;

                },

                ui: function(c) {
                    return {
                        draggable: (c.currentItem || c.element),
                        helper: c.helper,
                        position: c.position,
                        offset: c.positionAbs
                    };
                }

            });

            $.ui.intersect = function(draggable, droppable, toleranceMode) {

                if (!droppable.offset) {
                    return false;
                }

                var draggableLeft, draggableTop,
                    x1 = (draggable.positionAbs || draggable.position.absolute).left,
                    x2 = x1 + draggable.helperProportions.width,
                    y1 = (draggable.positionAbs || draggable.position.absolute).top,
                    y2 = y1 + draggable.helperProportions.height,
                    l = droppable.offset.left,
                    r = l + droppable.proportions.width,
                    t = droppable.offset.top,
                    b = t + droppable.proportions.height;

                switch (toleranceMode) {
                    case "fit":
                        return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
                    case "intersect":
                        return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
                            x2 - (draggable.helperProportions.width / 2) < r && // Left Half
                            t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
                            y2 - (draggable.helperProportions.height / 2) < b); // Top Half
                    case "pointer":
                        draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
                        draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
                        return isOverAxis(draggableTop, t, droppable.proportions.height) && isOverAxis(draggableLeft, l, droppable.proportions.width);
                    case "touch":
                        return (
                            (y1 >= t && y1 <= b) || // Top edge touching
                            (y2 >= t && y2 <= b) || // Bottom edge touching
                            (y1 < t && y2 > b) // Surrounded vertically
                        ) && (
                            (x1 >= l && x1 <= r) || // Left edge touching
                            (x2 >= l && x2 <= r) || // Right edge touching
                            (x1 < l && x2 > r) // Surrounded horizontally
                        );
                    default:
                        return false;
                }

            };

            /*
                This manager tracks offsets of draggables and droppables
            */
            $.ui.ddmanager = {
                current: null,
                droppables: {
                    "default": []
                },
                prepareOffsets: function(t, event) {

                    var i, j,
                        m = $.ui.ddmanager.droppables[t.options.scope] || [],
                        type = event ? event.type : null, // workaround for #2317
                        list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();

                    droppablesLoop: for (i = 0; i < m.length; i++) {

                        //No disabled and non-accepted
                        if (m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0], (t.currentItem || t.element)))) {
                            continue;
                        }

                        // Filter out elements in the current dragged item
                        for (j = 0; j < list.length; j++) {
                            if (list[j] === m[i].element[0]) {
                                m[i].proportions.height = 0;
                                continue droppablesLoop;
                            }
                        }

                        m[i].visible = m[i].element.css("display") !== "none";
                        if (!m[i].visible) {
                            continue;
                        }

                        //Activate the droppable if used directly from draggables
                        if (type === "mousedown") {
                            m[i]._activate.call(m[i], event);
                        }

                        m[i].offset = m[i].element.offset();
                        m[i].proportions = {
                            width: m[i].element[0].offsetWidth,
                            height: m[i].element[0].offsetHeight
                        };

                    }

                },
                drop: function(draggable, event) {

                    var dropped = false;
                    // Create a copy of the droppables in case the list changes during the drop (#9116)
                    $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {

                        if (!this.options) {
                            return;
                        }
                        if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
                            dropped = this._drop.call(this, event) || dropped;
                        }

                        if (!this.options.disabled && this.visible && this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                            this.isout = true;
                            this.isover = false;
                            this._deactivate.call(this, event);
                        }

                    });
                    return dropped;

                },
                dragStart: function(draggable, event) {
                    //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
                    draggable.element.parentsUntil("body").bind("scroll.droppable", function() {
                        if (!draggable.options.refreshPositions) {
                            $.ui.ddmanager.prepareOffsets(draggable, event);
                        }
                    });
                },
                drag: function(draggable, event) {

                    //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
                    if (draggable.options.refreshPositions) {
                        $.ui.ddmanager.prepareOffsets(draggable, event);
                    }

                    //Run through all droppables and check their positions based on specific tolerance options
                    $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

                        if (this.options.disabled || this.greedyChild || !this.visible) {
                            return;
                        }

                        var parentInstance, scope, parent,
                            intersects = $.ui.intersect(draggable, this, this.options.tolerance),
                            c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
                        if (!c) {
                            return;
                        }

                        if (this.options.greedy) {
                            // find droppable parents with same scope
                            scope = this.options.scope;
                            parent = this.element.parents(":data(ui-droppable)").filter(function() {
                                return $.data(this, "ui-droppable").options.scope === scope;
                            });

                            if (parent.length) {
                                parentInstance = $.data(parent[0], "ui-droppable");
                                parentInstance.greedyChild = (c === "isover");
                            }
                        }

                        // we just moved into a greedy child
                        if (parentInstance && c === "isover") {
                            parentInstance.isover = false;
                            parentInstance.isout = true;
                            parentInstance._out.call(parentInstance, event);
                        }

                        this[c] = true;
                        this[c === "isout" ? "isover" : "isout"] = false;
                        this[c === "isover" ? "_over" : "_out"].call(this, event);

                        // we just moved out of a greedy child
                        if (parentInstance && c === "isout") {
                            parentInstance.isout = false;
                            parentInstance.isover = true;
                            parentInstance._over.call(parentInstance, event);
                        }
                    });

                },
                dragStop: function(draggable, event) {
                    draggable.element.parentsUntil("body").unbind("scroll.droppable");
                    //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
                    if (!draggable.options.refreshPositions) {
                        $.ui.ddmanager.prepareOffsets(draggable, event);
                    }
                }
            };

        })(jQuery);

        (function($, undefined) {

            function num(v) {
                return parseInt(v, 10) || 0;
            }

            function isNumber(value) {
                return !isNaN(parseInt(value, 10));
            }

            $.widget("ui.resizable", $.ui.mouse, {
                version: "1.10.3",
                widgetEventPrefix: "resize",
                options: {
                    alsoResize: false,
                    animate: false,
                    animateDuration: "slow",
                    animateEasing: "swing",
                    aspectRatio: false,
                    autoHide: false,
                    containment: false,
                    ghost: false,
                    grid: false,
                    handles: "e,s,se",
                    helper: false,
                    maxHeight: null,
                    maxWidth: null,
                    minHeight: 10,
                    minWidth: 10,
                    // See #7960
                    zIndex: 90,

                    // callbacks
                    resize: null,
                    start: null,
                    stop: null
                },
                _create: function() {

                    var n, i, handle, axis, hname,
                        that = this,
                        o = this.options;
                    this.element.addClass("ui-resizable");

                    $.extend(this, {
                        _aspectRatio: !!(o.aspectRatio),
                        aspectRatio: o.aspectRatio,
                        originalElement: this.element,
                        _proportionallyResizeElements: [],
                        _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
                    });

                    //Wrap the element if it cannot hold child nodes
                    if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

                        //Create a wrapper element and set the wrapper to the new current internal element
                        this.element.wrap(
                            $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                                position: this.element.css("position"),
                                width: this.element.outerWidth(),
                                height: this.element.outerHeight(),
                                top: this.element.css("top"),
                                left: this.element.css("left")
                            })
                        );

                        //Overwrite the original this.element
                        this.element = this.element.parent().data(
                            "ui-resizable", this.element.data("ui-resizable")
                        );

                        this.elementIsWrapper = true;

                        //Move margins to the wrapper
                        this.element.css({
                            marginLeft: this.originalElement.css("marginLeft"),
                            marginTop: this.originalElement.css("marginTop"),
                            marginRight: this.originalElement.css("marginRight"),
                            marginBottom: this.originalElement.css("marginBottom")
                        });
                        this.originalElement.css({
                            marginLeft: 0,
                            marginTop: 0,
                            marginRight: 0,
                            marginBottom: 0
                        });

                        //Prevent Safari textarea resize
                        this.originalResizeStyle = this.originalElement.css("resize");
                        this.originalElement.css("resize", "none");

                        //Push the actual element to our proportionallyResize internal array
                        this._proportionallyResizeElements.push(this.originalElement.css({
                            position: "static",
                            zoom: 1,
                            display: "block"
                        }));

                        // avoid IE jump (hard set the margin)
                        this.originalElement.css({
                            margin: this.originalElement.css("margin")
                        });

                        // fix handlers offset
                        this._proportionallyResize();

                    }

                    this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
                        n: ".ui-resizable-n",
                        e: ".ui-resizable-e",
                        s: ".ui-resizable-s",
                        w: ".ui-resizable-w",
                        se: ".ui-resizable-se",
                        sw: ".ui-resizable-sw",
                        ne: ".ui-resizable-ne",
                        nw: ".ui-resizable-nw"
                    });
                    if (this.handles.constructor === String) {

                        if (this.handles === "all") {
                            this.handles = "n,e,s,w,se,sw,ne,nw";
                        }

                        n = this.handles.split(",");
                        this.handles = {};

                        for (i = 0; i < n.length; i++) {

                            handle = $.trim(n[i]);
                            hname = "ui-resizable-" + handle;
                            axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

                            // Apply zIndex to all handles - see #7960
                            axis.css({
                                zIndex: o.zIndex
                            });

                            //TODO : What's going on here?
                            if ("se" === handle) {
                                axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                            }

                            //Insert into internal handles object and append to element
                            this.handles[handle] = ".ui-resizable-" + handle;
                            this.element.append(axis);
                        }

                    }

                    this._renderAxis = function(target) {

                        var i, axis, padPos, padWrapper;

                        target = target || this.element;

                        for (i in this.handles) {

                            if (this.handles[i].constructor === String) {
                                this.handles[i] = $(this.handles[i], this.element).show();
                            }

                            //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
                            if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

                                axis = $(this.handles[i], this.element);

                                //Checking the correct pad and border
                                padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

                                //The padding type i have to apply...
                                padPos = ["padding",
                                    /ne|nw|n/.test(i) ? "Top" :
                                    /se|sw|s/.test(i) ? "Bottom" :
                                    /^e$/.test(i) ? "Right" : "Left"
                                ].join("");

                                target.css(padPos, padWrapper);

                                this._proportionallyResize();

                            }

                            //TODO: What's that good for? There's not anything to be executed left
                            if (!$(this.handles[i]).length) {
                                continue;
                            }
                        }
                    };

                    //TODO: make renderAxis a prototype function
                    this._renderAxis(this.element);

                    this._handles = $(".ui-resizable-handle", this.element)
                        .disableSelection();

                    //Matching axis name
                    this._handles.mouseover(function() {
                        if (!that.resizing) {
                            if (this.className) {
                                axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                            }
                            //Axis, default = se
                            that.axis = axis && axis[1] ? axis[1] : "se";
                        }
                    });

                    //If we want to auto hide the elements
                    if (o.autoHide) {
                        this._handles.hide();
                        $(this.element)
                            .addClass("ui-resizable-autohide")
                            .mouseenter(function() {
                                if (o.disabled) {
                                    return;
                                }
                                $(this).removeClass("ui-resizable-autohide");
                                that._handles.show();
                            })
                            .mouseleave(function() {
                                if (o.disabled) {
                                    return;
                                }
                                if (!that.resizing) {
                                    $(this).addClass("ui-resizable-autohide");
                                    that._handles.hide();
                                }
                            });
                    }

                    //Initialize the mouse interaction
                    this._mouseInit();

                },

                _destroy: function() {

                    this._mouseDestroy();

                    var wrapper,
                        _destroy = function(exp) {
                            $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
                                .removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
                        };

                    //TODO: Unwrap at same DOM position
                    if (this.elementIsWrapper) {
                        _destroy(this.element);
                        wrapper = this.element;
                        this.originalElement.css({
                            position: wrapper.css("position"),
                            width: wrapper.outerWidth(),
                            height: wrapper.outerHeight(),
                            top: wrapper.css("top"),
                            left: wrapper.css("left")
                        }).insertAfter(wrapper);
                        wrapper.remove();
                    }

                    this.originalElement.css("resize", this.originalResizeStyle);
                    _destroy(this.originalElement);

                    return this;
                },

                _mouseCapture: function(event) {
                    var i, handle,
                        capture = false;

                    for (i in this.handles) {
                        handle = $(this.handles[i])[0];
                        if (handle === event.target || $.contains(handle, event.target)) {
                            capture = true;
                        }
                    }

                    return !this.options.disabled && capture;
                },

                _mouseStart: function(event) {

                    var curleft, curtop, cursor,
                        o = this.options,
                        iniPos = this.element.position(),
                        el = this.element;

                    this.resizing = true;

                    // bugfix for http://dev.jquery.com/ticket/1749
                    if ((/absolute/).test(el.css("position"))) {
                        el.css({
                            position: "absolute",
                            top: el.css("top"),
                            left: el.css("left")
                        });
                    } else if (el.is(".ui-draggable")) {
                        el.css({
                            position: "absolute",
                            top: iniPos.top,
                            left: iniPos.left
                        });
                    }

                    this._renderProxy();

                    curleft = num(this.helper.css("left"));
                    curtop = num(this.helper.css("top"));

                    if (o.containment) {
                        curleft += $(o.containment).scrollLeft() || 0;
                        curtop += $(o.containment).scrollTop() || 0;
                    }

                    //Store needed variables
                    this.offset = this.helper.offset();
                    this.position = {
                        left: curleft,
                        top: curtop
                    };
                    this.size = this._helper ? {
                        width: el.outerWidth(),
                        height: el.outerHeight()
                    } : {
                        width: el.width(),
                        height: el.height()
                    };
                    this.originalSize = this._helper ? {
                        width: el.outerWidth(),
                        height: el.outerHeight()
                    } : {
                        width: el.width(),
                        height: el.height()
                    };
                    this.originalPosition = {
                        left: curleft,
                        top: curtop
                    };
                    this.sizeDiff = {
                        width: el.outerWidth() - el.width(),
                        height: el.outerHeight() - el.height()
                    };
                    this.originalMousePosition = {
                        left: event.pageX,
                        top: event.pageY
                    };

                    //Aspect Ratio
                    this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

                    cursor = $(".ui-resizable-" + this.axis).css("cursor");
                    $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

                    el.addClass("ui-resizable-resizing");
                    this._propagate("start", event);
                    return true;
                },

                _mouseDrag: function(event) {

                    //Increase performance, avoid regex
                    var data,
                        el = this.helper,
                        props = {},
                        smp = this.originalMousePosition,
                        a = this.axis,
                        prevTop = this.position.top,
                        prevLeft = this.position.left,
                        prevWidth = this.size.width,
                        prevHeight = this.size.height,
                        dx = (event.pageX - smp.left) || 0,
                        dy = (event.pageY - smp.top) || 0,
                        trigger = this._change[a];

                    if (!trigger) {
                        return false;
                    }

                    // Calculate the attrs that will be change
                    data = trigger.apply(this, [event, dx, dy]);

                    // Put this in the mouseDrag handler since the user can start pressing shift while resizing
                    this._updateVirtualBoundaries(event.shiftKey);
                    if (this._aspectRatio || event.shiftKey) {
                        data = this._updateRatio(data, event);
                    }

                    data = this._respectSize(data, event);

                    this._updateCache(data);

                    // plugins callbacks need to be called first
                    this._propagate("resize", event);

                    if (this.position.top !== prevTop) {
                        props.top = this.position.top + "px";
                    }
                    if (this.position.left !== prevLeft) {
                        props.left = this.position.left + "px";
                    }
                    if (this.size.width !== prevWidth) {
                        props.width = this.size.width + "px";
                    }
                    if (this.size.height !== prevHeight) {
                        props.height = this.size.height + "px";
                    }
                    el.css(props);

                    if (!this._helper && this._proportionallyResizeElements.length) {
                        this._proportionallyResize();
                    }

                    // Call the user callback if the element was resized
                    if (!$.isEmptyObject(props)) {
                        this._trigger("resize", event, this.ui());
                    }

                    return false;
                },

                _mouseStop: function(event) {

                    this.resizing = false;
                    var pr, ista, soffseth, soffsetw, s, left, top,
                        o = this.options,
                        that = this;

                    if (this._helper) {

                        pr = this._proportionallyResizeElements;
                        ista = pr.length && (/textarea/i).test(pr[0].nodeName);
                        soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
                        soffsetw = ista ? 0 : that.sizeDiff.width;

                        s = {
                            width: (that.helper.width() - soffsetw),
                            height: (that.helper.height() - soffseth)
                        };
                        left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
                        top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

                        if (!o.animate) {
                            this.element.css($.extend(s, {
                                top: top,
                                left: left
                            }));
                        }

                        that.helper.height(that.size.height);
                        that.helper.width(that.size.width);

                        if (this._helper && !o.animate) {
                            this._proportionallyResize();
                        }
                    }

                    $("body").css("cursor", "auto");

                    this.element.removeClass("ui-resizable-resizing");

                    this._propagate("stop", event);

                    if (this._helper) {
                        this.helper.remove();
                    }

                    return false;

                },

                _updateVirtualBoundaries: function(forceAspectRatio) {
                    var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
                        o = this.options;

                    b = {
                        minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
                        maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                        minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
                        maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
                    };

                    if (this._aspectRatio || forceAspectRatio) {
                        // We want to create an enclosing box whose aspect ration is the requested one
                        // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
                        pMinWidth = b.minHeight * this.aspectRatio;
                        pMinHeight = b.minWidth / this.aspectRatio;
                        pMaxWidth = b.maxHeight * this.aspectRatio;
                        pMaxHeight = b.maxWidth / this.aspectRatio;

                        if (pMinWidth > b.minWidth) {
                            b.minWidth = pMinWidth;
                        }
                        if (pMinHeight > b.minHeight) {
                            b.minHeight = pMinHeight;
                        }
                        if (pMaxWidth < b.maxWidth) {
                            b.maxWidth = pMaxWidth;
                        }
                        if (pMaxHeight < b.maxHeight) {
                            b.maxHeight = pMaxHeight;
                        }
                    }
                    this._vBoundaries = b;
                },

                _updateCache: function(data) {
                    this.offset = this.helper.offset();
                    if (isNumber(data.left)) {
                        this.position.left = data.left;
                    }
                    if (isNumber(data.top)) {
                        this.position.top = data.top;
                    }
                    if (isNumber(data.height)) {
                        this.size.height = data.height;
                    }
                    if (isNumber(data.width)) {
                        this.size.width = data.width;
                    }
                },

                _updateRatio: function(data) {

                    var cpos = this.position,
                        csize = this.size,
                        a = this.axis;

                    if (isNumber(data.height)) {
                        data.width = (data.height * this.aspectRatio);
                    } else if (isNumber(data.width)) {
                        data.height = (data.width / this.aspectRatio);
                    }

                    if (a === "sw") {
                        data.left = cpos.left + (csize.width - data.width);
                        data.top = null;
                    }
                    if (a === "nw") {
                        data.top = cpos.top + (csize.height - data.height);
                        data.left = cpos.left + (csize.width - data.width);
                    }

                    return data;
                },

                _respectSize: function(data) {

                    var o = this._vBoundaries,
                        a = this.axis,
                        ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
                        ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
                        isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
                        isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
                        dw = this.originalPosition.left + this.originalSize.width,
                        dh = this.position.top + this.size.height,
                        cw = /sw|nw|w/.test(a),
                        ch = /nw|ne|n/.test(a);
                    if (isminw) {
                        data.width = o.minWidth;
                    }
                    if (isminh) {
                        data.height = o.minHeight;
                    }
                    if (ismaxw) {
                        data.width = o.maxWidth;
                    }
                    if (ismaxh) {
                        data.height = o.maxHeight;
                    }

                    if (isminw && cw) {
                        data.left = dw - o.minWidth;
                    }
                    if (ismaxw && cw) {
                        data.left = dw - o.maxWidth;
                    }
                    if (isminh && ch) {
                        data.top = dh - o.minHeight;
                    }
                    if (ismaxh && ch) {
                        data.top = dh - o.maxHeight;
                    }

                    // fixing jump error on top/left - bug #2330
                    if (!data.width && !data.height && !data.left && data.top) {
                        data.top = null;
                    } else if (!data.width && !data.height && !data.top && data.left) {
                        data.left = null;
                    }

                    return data;
                },

                _proportionallyResize: function() {

                    if (!this._proportionallyResizeElements.length) {
                        return;
                    }

                    var i, j, borders, paddings, prel,
                        element = this.helper || this.element;

                    for (i = 0; i < this._proportionallyResizeElements.length; i++) {

                        prel = this._proportionallyResizeElements[i];

                        if (!this.borderDif) {
                            this.borderDif = [];
                            borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
                            paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

                            for (j = 0; j < borders.length; j++) {
                                this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
                            }
                        }

                        prel.css({
                            height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
                            width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
                        });

                    }

                },

                _renderProxy: function() {

                    var el = this.element,
                        o = this.options;
                    this.elementOffset = el.offset();

                    if (this._helper) {

                        this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

                        this.helper.addClass(this._helper).css({
                            width: this.element.outerWidth() - 1,
                            height: this.element.outerHeight() - 1,
                            position: "absolute",
                            left: this.elementOffset.left + "px",
                            top: this.elementOffset.top + "px",
                            zIndex: ++o.zIndex //TODO: Don't modify option
                        });

                        this.helper
                            .appendTo("body")
                            .disableSelection();

                    } else {
                        this.helper = this.element;
                    }

                },

                _change: {
                    e: function(event, dx) {
                        return {
                            width: this.originalSize.width + dx
                        };
                    },
                    w: function(event, dx) {
                        var cs = this.originalSize,
                            sp = this.originalPosition;
                        return {
                            left: sp.left + dx,
                            width: cs.width - dx
                        };
                    },
                    n: function(event, dx, dy) {
                        var cs = this.originalSize,
                            sp = this.originalPosition;
                        return {
                            top: sp.top + dy,
                            height: cs.height - dy
                        };
                    },
                    s: function(event, dx, dy) {
                        return {
                            height: this.originalSize.height + dy
                        };
                    },
                    se: function(event, dx, dy) {
                        return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
                    },
                    sw: function(event, dx, dy) {
                        return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
                    },
                    ne: function(event, dx, dy) {
                        return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
                    },
                    nw: function(event, dx, dy) {
                        return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
                    }
                },

                _propagate: function(n, event) {
                    $.ui.plugin.call(this, n, [event, this.ui()]);
                    (n !== "resize" && this._trigger(n, event, this.ui()));
                },

                plugins: {},

                ui: function() {
                    return {
                        originalElement: this.originalElement,
                        element: this.element,
                        helper: this.helper,
                        position: this.position,
                        size: this.size,
                        originalSize: this.originalSize,
                        originalPosition: this.originalPosition
                    };
                }

            });

            /*
             * Resizable Extensions
             */

            $.ui.plugin.add("resizable", "animate", {

                stop: function(event) {
                    var that = $(this).data("ui-resizable"),
                        o = that.options,
                        pr = that._proportionallyResizeElements,
                        ista = pr.length && (/textarea/i).test(pr[0].nodeName),
                        soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
                        soffsetw = ista ? 0 : that.sizeDiff.width,
                        style = {
                            width: (that.size.width - soffsetw),
                            height: (that.size.height - soffseth)
                        },
                        left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
                        top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

                    that.element.animate(
                        $.extend(style, top && left ? {
                            top: top,
                            left: left
                        } : {}), {
                            duration: o.animateDuration,
                            easing: o.animateEasing,
                            step: function() {

                                var data = {
                                    width: parseInt(that.element.css("width"), 10),
                                    height: parseInt(that.element.css("height"), 10),
                                    top: parseInt(that.element.css("top"), 10),
                                    left: parseInt(that.element.css("left"), 10)
                                };

                                if (pr && pr.length) {
                                    $(pr[0]).css({
                                        width: data.width,
                                        height: data.height
                                    });
                                }

                                // propagating resize, and updating values for each animation step
                                that._updateCache(data);
                                that._propagate("resize", event);

                            }
                        }
                    );
                }

            });

            $.ui.plugin.add("resizable", "containment", {

                start: function() {
                    var element, p, co, ch, cw, width, height,
                        that = $(this).data("ui-resizable"),
                        o = that.options,
                        el = that.element,
                        oc = o.containment,
                        ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

                    if (!ce) {
                        return;
                    }

                    that.containerElement = $(ce);

                    if (/document/.test(oc) || oc === document) {
                        that.containerOffset = {
                            left: 0,
                            top: 0
                        };
                        that.containerPosition = {
                            left: 0,
                            top: 0
                        };

                        that.parentData = {
                            element: $(document),
                            left: 0,
                            top: 0,
                            width: $(document).width(),
                            height: $(document).height() || document.body.parentNode.scrollHeight
                        };
                    }

                    // i'm a node, so compute top, left, right, bottom
                    else {
                        element = $(ce);
                        p = [];
                        $(["Top", "Right", "Left", "Bottom"]).each(function(i, name) {
                            p[i] = num(element.css("padding" + name));
                        });

                        that.containerOffset = element.offset();
                        that.containerPosition = element.position();
                        that.containerSize = {
                            height: (element.innerHeight() - p[3]),
                            width: (element.innerWidth() - p[1])
                        };

                        co = that.containerOffset;
                        ch = that.containerSize.height;
                        cw = that.containerSize.width;
                        width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw);
                        height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

                        that.parentData = {
                            element: ce,
                            left: co.left,
                            top: co.top,
                            width: width,
                            height: height
                        };
                    }
                },

                resize: function(event) {
                    var woset, hoset, isParent, isOffsetRelative,
                        that = $(this).data("ui-resizable"),
                        o = that.options,
                        co = that.containerOffset,
                        cp = that.position,
                        pRatio = that._aspectRatio || event.shiftKey,
                        cop = {
                            top: 0,
                            left: 0
                        },
                        ce = that.containerElement;

                    if (ce[0] !== document && (/static/).test(ce.css("position"))) {
                        cop = co;
                    }

                    if (cp.left < (that._helper ? co.left : 0)) {
                        that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
                        if (pRatio) {
                            that.size.height = that.size.width / that.aspectRatio;
                        }
                        that.position.left = o.helper ? co.left : 0;
                    }

                    if (cp.top < (that._helper ? co.top : 0)) {
                        that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
                        if (pRatio) {
                            that.size.width = that.size.height * that.aspectRatio;
                        }
                        that.position.top = that._helper ? co.top : 0;
                    }

                    that.offset.left = that.parentData.left + that.position.left;
                    that.offset.top = that.parentData.top + that.position.top;

                    woset = Math.abs((that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width);
                    hoset = Math.abs((that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height);

                    isParent = that.containerElement.get(0) === that.element.parent().get(0);
                    isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

                    if (isParent && isOffsetRelative) {
                        woset -= that.parentData.left;
                    }

                    if (woset + that.size.width >= that.parentData.width) {
                        that.size.width = that.parentData.width - woset;
                        if (pRatio) {
                            that.size.height = that.size.width / that.aspectRatio;
                        }
                    }

                    if (hoset + that.size.height >= that.parentData.height) {
                        that.size.height = that.parentData.height - hoset;
                        if (pRatio) {
                            that.size.width = that.size.height * that.aspectRatio;
                        }
                    }
                },

                stop: function() {
                    var that = $(this).data("ui-resizable"),
                        o = that.options,
                        co = that.containerOffset,
                        cop = that.containerPosition,
                        ce = that.containerElement,
                        helper = $(that.helper),
                        ho = helper.offset(),
                        w = helper.outerWidth() - that.sizeDiff.width,
                        h = helper.outerHeight() - that.sizeDiff.height;

                    if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
                        $(this).css({
                            left: ho.left - cop.left - co.left,
                            width: w,
                            height: h
                        });
                    }

                    if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
                        $(this).css({
                            left: ho.left - cop.left - co.left,
                            width: w,
                            height: h
                        });
                    }

                }
            });

            $.ui.plugin.add("resizable", "alsoResize", {

                start: function() {
                    var that = $(this).data("ui-resizable"),
                        o = that.options,
                        _store = function(exp) {
                            $(exp).each(function() {
                                var el = $(this);
                                el.data("ui-resizable-alsoresize", {
                                    width: parseInt(el.width(), 10),
                                    height: parseInt(el.height(), 10),
                                    left: parseInt(el.css("left"), 10),
                                    top: parseInt(el.css("top"), 10)
                                });
                            });
                        };

                    if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
                        if (o.alsoResize.length) {
                            o.alsoResize = o.alsoResize[0];
                            _store(o.alsoResize);
                        } else {
                            $.each(o.alsoResize, function(exp) {
                                _store(exp);
                            });
                        }
                    } else {
                        _store(o.alsoResize);
                    }
                },

                resize: function(event, ui) {
                    var that = $(this).data("ui-resizable"),
                        o = that.options,
                        os = that.originalSize,
                        op = that.originalPosition,
                        delta = {
                            height: (that.size.height - os.height) || 0,
                            width: (that.size.width - os.width) || 0,
                            top: (that.position.top - op.top) || 0,
                            left: (that.position.left - op.left) || 0
                        },

                        _alsoResize = function(exp, c) {
                            $(exp).each(function() {
                                var el = $(this),
                                    start = $(this).data("ui-resizable-alsoresize"),
                                    style = {},
                                    css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

                                $.each(css, function(i, prop) {
                                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                                    if (sum && sum >= 0) {
                                        style[prop] = sum || null;
                                    }
                                });

                                el.css(style);
                            });
                        };

                    if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
                        $.each(o.alsoResize, function(exp, c) {
                            _alsoResize(exp, c);
                        });
                    } else {
                        _alsoResize(o.alsoResize);
                    }
                },

                stop: function() {
                    $(this).removeData("resizable-alsoresize");
                }
            });

            $.ui.plugin.add("resizable", "ghost", {

                start: function() {

                    var that = $(this).data("ui-resizable"),
                        o = that.options,
                        cs = that.size;

                    that.ghost = that.originalElement.clone();
                    that.ghost
                        .css({
                            opacity: 0.25,
                            display: "block",
                            position: "relative",
                            height: cs.height,
                            width: cs.width,
                            margin: 0,
                            left: 0,
                            top: 0
                        })
                        .addClass("ui-resizable-ghost")
                        .addClass(typeof o.ghost === "string" ? o.ghost : "");

                    that.ghost.appendTo(that.helper);

                },

                resize: function() {
                    var that = $(this).data("ui-resizable");
                    if (that.ghost) {
                        that.ghost.css({
                            position: "relative",
                            height: that.size.height,
                            width: that.size.width
                        });
                    }
                },

                stop: function() {
                    var that = $(this).data("ui-resizable");
                    if (that.ghost && that.helper) {
                        that.helper.get(0).removeChild(that.ghost.get(0));
                    }
                }

            });

            $.ui.plugin.add("resizable", "grid", {

                resize: function() {
                    var that = $(this).data("ui-resizable"),
                        o = that.options,
                        cs = that.size,
                        os = that.originalSize,
                        op = that.originalPosition,
                        a = that.axis,
                        grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
                        gridX = (grid[0] || 1),
                        gridY = (grid[1] || 1),
                        ox = Math.round((cs.width - os.width) / gridX) * gridX,
                        oy = Math.round((cs.height - os.height) / gridY) * gridY,
                        newWidth = os.width + ox,
                        newHeight = os.height + oy,
                        isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
                        isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
                        isMinWidth = o.minWidth && (o.minWidth > newWidth),
                        isMinHeight = o.minHeight && (o.minHeight > newHeight);

                    o.grid = grid;

                    if (isMinWidth) {
                        newWidth = newWidth + gridX;
                    }
                    if (isMinHeight) {
                        newHeight = newHeight + gridY;
                    }
                    if (isMaxWidth) {
                        newWidth = newWidth - gridX;
                    }
                    if (isMaxHeight) {
                        newHeight = newHeight - gridY;
                    }

                    if (/^(se|s|e)$/.test(a)) {
                        that.size.width = newWidth;
                        that.size.height = newHeight;
                    } else if (/^(ne)$/.test(a)) {
                        that.size.width = newWidth;
                        that.size.height = newHeight;
                        that.position.top = op.top - oy;
                    } else if (/^(sw)$/.test(a)) {
                        that.size.width = newWidth;
                        that.size.height = newHeight;
                        that.position.left = op.left - ox;
                    } else {
                        that.size.width = newWidth;
                        that.size.height = newHeight;
                        that.position.top = op.top - oy;
                        that.position.left = op.left - ox;
                    }
                }

            });

        })(jQuery);

        (function($, undefined) {

            $.widget("ui.selectable", $.ui.mouse, {
                version: "1.10.3",
                options: {
                    appendTo: "body",
                    autoRefresh: true,
                    distance: 0,
                    filter: "*",
                    tolerance: "touch",

                    // callbacks
                    selected: null,
                    selecting: null,
                    start: null,
                    stop: null,
                    unselected: null,
                    unselecting: null
                },
                _create: function() {
                    var selectees,
                        that = this;

                    this.element.addClass("ui-selectable");

                    this.dragged = false;

                    // cache selectee children based on filter
                    this.refresh = function() {
                        selectees = $(that.options.filter, that.element[0]);
                        selectees.addClass("ui-selectee");
                        selectees.each(function() {
                            var $this = $(this),
                                pos = $this.offset();
                            $.data(this, "selectable-item", {
                                element: this,
                                $element: $this,
                                left: pos.left,
                                top: pos.top,
                                right: pos.left + $this.outerWidth(),
                                bottom: pos.top + $this.outerHeight(),
                                startselected: false,
                                selected: $this.hasClass("ui-selected"),
                                selecting: $this.hasClass("ui-selecting"),
                                unselecting: $this.hasClass("ui-unselecting")
                            });
                        });
                    };
                    this.refresh();

                    this.selectees = selectees.addClass("ui-selectee");

                    this._mouseInit();

                    this.helper = $("<div class='ui-selectable-helper'></div>");
                },

                _destroy: function() {
                    this.selectees
                        .removeClass("ui-selectee")
                        .removeData("selectable-item");
                    this.element
                        .removeClass("ui-selectable ui-selectable-disabled");
                    this._mouseDestroy();
                },

                _mouseStart: function(event) {
                    var that = this,
                        options = this.options;

                    this.opos = [event.pageX, event.pageY];

                    if (this.options.disabled) {
                        return;
                    }

                    this.selectees = $(options.filter, this.element[0]);

                    this._trigger("start", event);

                    $(options.appendTo).append(this.helper);
                    // position helper (lasso)
                    this.helper.css({
                        "left": event.pageX,
                        "top": event.pageY,
                        "width": 0,
                        "height": 0
                    });

                    if (options.autoRefresh) {
                        this.refresh();
                    }

                    this.selectees.filter(".ui-selected").each(function() {
                        var selectee = $.data(this, "selectable-item");
                        selectee.startselected = true;
                        if (!event.metaKey && !event.ctrlKey) {
                            selectee.$element.removeClass("ui-selected");
                            selectee.selected = false;
                            selectee.$element.addClass("ui-unselecting");
                            selectee.unselecting = true;
                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    });

                    $(event.target).parents().addBack().each(function() {
                        var doSelect,
                            selectee = $.data(this, "selectable-item");
                        if (selectee) {
                            doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
                            selectee.$element
                                .removeClass(doSelect ? "ui-unselecting" : "ui-selected")
                                .addClass(doSelect ? "ui-selecting" : "ui-unselecting");
                            selectee.unselecting = !doSelect;
                            selectee.selecting = doSelect;
                            selectee.selected = doSelect;
                            // selectable (UN)SELECTING callback
                            if (doSelect) {
                                that._trigger("selecting", event, {
                                    selecting: selectee.element
                                });
                            } else {
                                that._trigger("unselecting", event, {
                                    unselecting: selectee.element
                                });
                            }
                            return false;
                        }
                    });

                },

                _mouseDrag: function(event) {

                    this.dragged = true;

                    if (this.options.disabled) {
                        return;
                    }

                    var tmp,
                        that = this,
                        options = this.options,
                        x1 = this.opos[0],
                        y1 = this.opos[1],
                        x2 = event.pageX,
                        y2 = event.pageY;

                    if (x1 > x2) {
                        tmp = x2;
                        x2 = x1;
                        x1 = tmp;
                    }
                    if (y1 > y2) {
                        tmp = y2;
                        y2 = y1;
                        y1 = tmp;
                    }
                    this.helper.css({
                        left: x1,
                        top: y1,
                        width: x2 - x1,
                        height: y2 - y1
                    });

                    this.selectees.each(function() {
                        var selectee = $.data(this, "selectable-item"),
                            hit = false;

                        //prevent helper from being selected if appendTo: selectable
                        if (!selectee || selectee.element === that.element[0]) {
                            return;
                        }

                        if (options.tolerance === "touch") {
                            hit = (!(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1));
                        } else if (options.tolerance === "fit") {
                            hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
                        }

                        if (hit) {
                            // SELECT
                            if (selectee.selected) {
                                selectee.$element.removeClass("ui-selected");
                                selectee.selected = false;
                            }
                            if (selectee.unselecting) {
                                selectee.$element.removeClass("ui-unselecting");
                                selectee.unselecting = false;
                            }
                            if (!selectee.selecting) {
                                selectee.$element.addClass("ui-selecting");
                                selectee.selecting = true;
                                // selectable SELECTING callback
                                that._trigger("selecting", event, {
                                    selecting: selectee.element
                                });
                            }
                        } else {
                            // UNSELECT
                            if (selectee.selecting) {
                                if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                                    selectee.$element.removeClass("ui-selecting");
                                    selectee.selecting = false;
                                    selectee.$element.addClass("ui-selected");
                                    selectee.selected = true;
                                } else {
                                    selectee.$element.removeClass("ui-selecting");
                                    selectee.selecting = false;
                                    if (selectee.startselected) {
                                        selectee.$element.addClass("ui-unselecting");
                                        selectee.unselecting = true;
                                    }
                                    // selectable UNSELECTING callback
                                    that._trigger("unselecting", event, {
                                        unselecting: selectee.element
                                    });
                                }
                            }
                            if (selectee.selected) {
                                if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                                    selectee.$element.removeClass("ui-selected");
                                    selectee.selected = false;

                                    selectee.$element.addClass("ui-unselecting");
                                    selectee.unselecting = true;
                                    // selectable UNSELECTING callback
                                    that._trigger("unselecting", event, {
                                        unselecting: selectee.element
                                    });
                                }
                            }
                        }
                    });

                    return false;
                },

                _mouseStop: function(event) {
                    var that = this;

                    this.dragged = false;

                    $(".ui-unselecting", this.element[0]).each(function() {
                        var selectee = $.data(this, "selectable-item");
                        selectee.$element.removeClass("ui-unselecting");
                        selectee.unselecting = false;
                        selectee.startselected = false;
                        that._trigger("unselected", event, {
                            unselected: selectee.element
                        });
                    });
                    $(".ui-selecting", this.element[0]).each(function() {
                        var selectee = $.data(this, "selectable-item");
                        selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
                        selectee.selecting = false;
                        selectee.selected = true;
                        selectee.startselected = true;
                        that._trigger("selected", event, {
                            selected: selectee.element
                        });
                    });
                    this._trigger("stop", event);

                    this.helper.remove();

                    return false;
                }

            });

        })(jQuery);

        (function($, undefined) {

            /*jshint loopfunc: true */

            function isOverAxis(x, reference, size) {
                return (x > reference) && (x < (reference + size));
            }

            function isFloating(item) {
                return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
            }

            $.widget("ui.sortable", $.ui.mouse, {
                version: "1.10.3",
                widgetEventPrefix: "sort",
                ready: false,
                options: {
                    appendTo: "parent",
                    axis: false,
                    connectWith: false,
                    containment: false,
                    cursor: "auto",
                    cursorAt: false,
                    dropOnEmpty: true,
                    forcePlaceholderSize: false,
                    forceHelperSize: false,
                    grid: false,
                    handle: false,
                    helper: "original",
                    items: "> *",
                    opacity: false,
                    placeholder: false,
                    revert: false,
                    scroll: true,
                    scrollSensitivity: 20,
                    scrollSpeed: 20,
                    scope: "default",
                    tolerance: "intersect",
                    zIndex: 1000,

                    // callbacks
                    activate: null,
                    beforeStop: null,
                    change: null,
                    deactivate: null,
                    out: null,
                    over: null,
                    receive: null,
                    remove: null,
                    sort: null,
                    start: null,
                    stop: null,
                    update: null
                },
                _create: function() {

                    var o = this.options;
                    this.containerCache = {};
                    this.element.addClass("ui-sortable");

                    //Get the items
                    this.refresh();

                    //Let's determine if the items are being displayed horizontally
                    this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;

                    //Let's determine the parent's offset
                    this.offset = this.element.offset();

                    //Initialize mouse events for interaction
                    this._mouseInit();

                    //We're ready to go
                    this.ready = true;

                },

                _destroy: function() {
                    this.element
                        .removeClass("ui-sortable ui-sortable-disabled");
                    this._mouseDestroy();

                    for (var i = this.items.length - 1; i >= 0; i--) {
                        this.items[i].item.removeData(this.widgetName + "-item");
                    }

                    return this;
                },

                _setOption: function(key, value) {
                    if (key === "disabled") {
                        this.options[key] = value;

                        this.widget().toggleClass("ui-sortable-disabled", !!value);
                    } else {
                        // Don't call widget base _setOption for disable as it adds ui-state-disabled class
                        $.Widget.prototype._setOption.apply(this, arguments);
                    }
                },

                _mouseCapture: function(event, overrideHandle) {
                    var currentItem = null,
                        validHandle = false,
                        that = this;

                    if (this.reverting) {
                        return false;
                    }

                    if (this.options.disabled || this.options.type === "static") {
                        return false;
                    }

                    //We have to refresh the items data once first
                    this._refreshItems(event);

                    //Find out if the clicked node (or one of its parents) is a actual item in this.items
                    $(event.target).parents().each(function() {
                        if ($.data(this, that.widgetName + "-item") === that) {
                            currentItem = $(this);
                            return false;
                        }
                    });
                    if ($.data(event.target, that.widgetName + "-item") === that) {
                        currentItem = $(event.target);
                    }

                    if (!currentItem) {
                        return false;
                    }
                    if (this.options.handle && !overrideHandle) {
                        $(this.options.handle, currentItem).find("*").addBack().each(function() {
                            if (this === event.target) {
                                validHandle = true;
                            }
                        });
                        if (!validHandle) {
                            return false;
                        }
                    }

                    this.currentItem = currentItem;
                    this._removeCurrentsFromItems();
                    return true;

                },

                _mouseStart: function(event, overrideHandle, noActivation) {

                    var i, body,
                        o = this.options;

                    this.currentContainer = this;

                    //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
                    this.refreshPositions();

                    //Create and append the visible helper
                    this.helper = this._createHelper(event);

                    //Cache the helper size
                    this._cacheHelperProportions();

                    /*
                     * - Position generation -
                     * This block generates everything position related - it's the core of draggables.
                     */

                    //Cache the margins of the original element
                    this._cacheMargins();

                    //Get the next scrolling parent
                    this.scrollParent = this.helper.scrollParent();

                    //The element's absolute position on the page minus margins
                    this.offset = this.currentItem.offset();
                    this.offset = {
                        top: this.offset.top - this.margins.top,
                        left: this.offset.left - this.margins.left
                    };

                    $.extend(this.offset, {
                        click: { //Where the click happened, relative to the element
                            left: event.pageX - this.offset.left,
                            top: event.pageY - this.offset.top
                        },
                        parent: this._getParentOffset(),
                        relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
                    });

                    // Only after we got the offset, we can change the helper's position to absolute
                    // TODO: Still need to figure out a way to make relative sorting possible
                    this.helper.css("position", "absolute");
                    this.cssPosition = this.helper.css("position");

                    //Generate the original position
                    this.originalPosition = this._generatePosition(event);
                    this.originalPageX = event.pageX;
                    this.originalPageY = event.pageY;

                    //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

                    //Cache the former DOM position
                    this.domPosition = {
                        prev: this.currentItem.prev()[0],
                        parent: this.currentItem.parent()[0]
                    };

                    //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
                    if (this.helper[0] !== this.currentItem[0]) {
                        this.currentItem.hide();
                    }

                    //Create the placeholder
                    this._createPlaceholder();

                    //Set a containment if given in the options
                    if (o.containment) {
                        this._setContainment();
                    }

                    if (o.cursor && o.cursor !== "auto") { // cursor option
                        body = this.document.find("body");

                        // support: IE
                        this.storedCursor = body.css("cursor");
                        body.css("cursor", o.cursor);

                        this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
                    }

                    if (o.opacity) { // opacity option
                        if (this.helper.css("opacity")) {
                            this._storedOpacity = this.helper.css("opacity");
                        }
                        this.helper.css("opacity", o.opacity);
                    }

                    if (o.zIndex) { // zIndex option
                        if (this.helper.css("zIndex")) {
                            this._storedZIndex = this.helper.css("zIndex");
                        }
                        this.helper.css("zIndex", o.zIndex);
                    }

                    //Prepare scrolling
                    if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                        this.overflowOffset = this.scrollParent.offset();
                    }

                    //Call callbacks
                    this._trigger("start", event, this._uiHash());

                    //Recache the helper size
                    if (!this._preserveHelperProportions) {
                        this._cacheHelperProportions();
                    }


                    //Post "activate" events to possible containers
                    if (!noActivation) {
                        for (i = this.containers.length - 1; i >= 0; i--) {
                            this.containers[i]._trigger("activate", event, this._uiHash(this));
                        }
                    }

                    //Prepare possible droppables
                    if ($.ui.ddmanager) {
                        $.ui.ddmanager.current = this;
                    }

                    if ($.ui.ddmanager && !o.dropBehaviour) {
                        $.ui.ddmanager.prepareOffsets(this, event);
                    }

                    this.dragging = true;

                    this.helper.addClass("ui-sortable-helper");
                    this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
                    return true;

                },

                _mouseDrag: function(event) {
                    var i, item, itemElement, intersection,
                        o = this.options,
                        scrolled = false;

                    //Compute the helpers position
                    this.position = this._generatePosition(event);
                    this.positionAbs = this._convertPositionTo("absolute");

                    if (!this.lastPositionAbs) {
                        this.lastPositionAbs = this.positionAbs;
                    }

                    //Do scrolling
                    if (this.options.scroll) {
                        if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {

                            if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                                this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                            } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                                this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                            }

                            if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                                this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                            } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                                this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                            }

                        } else {

                            if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                                scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                            } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                                scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                            }

                            if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                                scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                            } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                                scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                            }

                        }

                        if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                            $.ui.ddmanager.prepareOffsets(this, event);
                        }
                    }

                    //Regenerate the absolute position used for position checks
                    this.positionAbs = this._convertPositionTo("absolute");

                    //Set the helper position
                    if (!this.options.axis || this.options.axis !== "y") {
                        this.helper[0].style.left = this.position.left + "px";
                    }
                    if (!this.options.axis || this.options.axis !== "x") {
                        this.helper[0].style.top = this.position.top + "px";
                    }

                    //Rearrange
                    for (i = this.items.length - 1; i >= 0; i--) {

                        //Cache variables and intersection, continue if no intersection
                        item = this.items[i];
                        itemElement = item.item[0];
                        intersection = this._intersectsWithPointer(item);
                        if (!intersection) {
                            continue;
                        }

                        // Only put the placeholder inside the current Container, skip all
                        // items form other containers. This works because when moving
                        // an item from one container to another the
                        // currentContainer is switched before the placeholder is moved.
                        //
                        // Without this moving items in "sub-sortables" can cause the placeholder to jitter
                        // beetween the outer and inner container.
                        if (item.instance !== this.currentContainer) {
                            continue;
                        }

                        // cannot intersect with itself
                        // no useless actions that have been done before
                        // no action if the item moved is the parent of the item checked
                        if (itemElement !== this.currentItem[0] &&
                            this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
                            !$.contains(this.placeholder[0], itemElement) &&
                            (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
                        ) {

                            this.direction = intersection === 1 ? "down" : "up";

                            if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                                this._rearrange(event, item);
                            } else {
                                break;
                            }

                            this._trigger("change", event, this._uiHash());
                            break;
                        }
                    }

                    //Post events to containers
                    this._contactContainers(event);

                    //Interconnect with droppables
                    if ($.ui.ddmanager) {
                        $.ui.ddmanager.drag(this, event);
                    }

                    //Call callbacks
                    this._trigger("sort", event, this._uiHash());

                    this.lastPositionAbs = this.positionAbs;
                    return false;

                },

                _mouseStop: function(event, noPropagation) {

                    if (!event) {
                        return;
                    }

                    //If we are using droppables, inform the manager about the drop
                    if ($.ui.ddmanager && !this.options.dropBehaviour) {
                        $.ui.ddmanager.drop(this, event);
                    }

                    if (this.options.revert) {
                        var that = this,
                            cur = this.placeholder.offset(),
                            axis = this.options.axis,
                            animation = {};

                        if (!axis || axis === "x") {
                            animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
                        }
                        if (!axis || axis === "y") {
                            animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
                        }
                        this.reverting = true;
                        $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
                            that._clear(event);
                        });
                    } else {
                        this._clear(event, noPropagation);
                    }

                    return false;

                },

                cancel: function() {

                    if (this.dragging) {

                        this._mouseUp({
                            target: null
                        });

                        if (this.options.helper === "original") {
                            this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                        } else {
                            this.currentItem.show();
                        }

                        //Post deactivating events to containers
                        for (var i = this.containers.length - 1; i >= 0; i--) {
                            this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                            if (this.containers[i].containerCache.over) {
                                this.containers[i]._trigger("out", null, this._uiHash(this));
                                this.containers[i].containerCache.over = 0;
                            }
                        }

                    }

                    if (this.placeholder) {
                        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                        if (this.placeholder[0].parentNode) {
                            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                        }
                        if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                            this.helper.remove();
                        }

                        $.extend(this, {
                            helper: null,
                            dragging: false,
                            reverting: false,
                            _noFinalSort: null
                        });

                        if (this.domPosition.prev) {
                            $(this.domPosition.prev).after(this.currentItem);
                        } else {
                            $(this.domPosition.parent).prepend(this.currentItem);
                        }
                    }

                    return this;

                },

                serialize: function(o) {

                    var items = this._getItemsAsjQuery(o && o.connected),
                        str = [];
                    o = o || {};

                    $(items).each(function() {
                        var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
                        if (res) {
                            str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                        }
                    });

                    if (!str.length && o.key) {
                        str.push(o.key + "=");
                    }

                    return str.join("&");

                },

                toArray: function(o) {

                    var items = this._getItemsAsjQuery(o && o.connected),
                        ret = [];

                    o = o || {};

                    items.each(function() {
                        ret.push($(o.item || this).attr(o.attribute || "id") || "");
                    });
                    return ret;

                },

                /* Be careful with the following core functions */
                _intersectsWith: function(item) {

                    var x1 = this.positionAbs.left,
                        x2 = x1 + this.helperProportions.width,
                        y1 = this.positionAbs.top,
                        y2 = y1 + this.helperProportions.height,
                        l = item.left,
                        r = l + item.width,
                        t = item.top,
                        b = t + item.height,
                        dyClick = this.offset.click.top,
                        dxClick = this.offset.click.left,
                        isOverElementHeight = (this.options.axis === "x") || ((y1 + dyClick) > t && (y1 + dyClick) < b),
                        isOverElementWidth = (this.options.axis === "y") || ((x1 + dxClick) > l && (x1 + dxClick) < r),
                        isOverElement = isOverElementHeight && isOverElementWidth;

                    if (this.options.tolerance === "pointer" ||
                        this.options.forcePointerForContainers ||
                        (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
                    ) {
                        return isOverElement;
                    } else {

                        return (l < x1 + (this.helperProportions.width / 2) && // Right Half
                            x2 - (this.helperProportions.width / 2) < r && // Left Half
                            t < y1 + (this.helperProportions.height / 2) && // Bottom Half
                            y2 - (this.helperProportions.height / 2) < b); // Top Half

                    }
                },

                _intersectsWithPointer: function(item) {

                    var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                        isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                        isOverElement = isOverElementHeight && isOverElementWidth,
                        verticalDirection = this._getDragVerticalDirection(),
                        horizontalDirection = this._getDragHorizontalDirection();

                    if (!isOverElement) {
                        return false;
                    }

                    return this.floating ?
                        (((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1) :
                        (verticalDirection && (verticalDirection === "down" ? 2 : 1));

                },

                _intersectsWithSides: function(item) {

                    var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height / 2), item.height),
                        isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width / 2), item.width),
                        verticalDirection = this._getDragVerticalDirection(),
                        horizontalDirection = this._getDragHorizontalDirection();

                    if (this.floating && horizontalDirection) {
                        return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
                    } else {
                        return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
                    }

                },

                _getDragVerticalDirection: function() {
                    var delta = this.positionAbs.top - this.lastPositionAbs.top;
                    return delta !== 0 && (delta > 0 ? "down" : "up");
                },

                _getDragHorizontalDirection: function() {
                    var delta = this.positionAbs.left - this.lastPositionAbs.left;
                    return delta !== 0 && (delta > 0 ? "right" : "left");
                },

                refresh: function(event) {
                    this._refreshItems(event);
                    this.refreshPositions();
                    return this;
                },

                _connectWith: function() {
                    var options = this.options;
                    return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
                },

                _getItemsAsjQuery: function(connected) {

                    var i, j, cur, inst,
                        items = [],
                        queries = [],
                        connectWith = this._connectWith();

                    if (connectWith && connected) {
                        for (i = connectWith.length - 1; i >= 0; i--) {
                            cur = $(connectWith[i]);
                            for (j = cur.length - 1; j >= 0; j--) {
                                inst = $.data(cur[j], this.widgetFullName);
                                if (inst && inst !== this && !inst.options.disabled) {
                                    queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                                }
                            }
                        }
                    }

                    queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                        options: this.options,
                        item: this.currentItem
                    }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

                    for (i = queries.length - 1; i >= 0; i--) {
                        queries[i][0].each(function() {
                            items.push(this);
                        });
                    }

                    return $(items);

                },

                _removeCurrentsFromItems: function() {

                    var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

                    this.items = $.grep(this.items, function(item) {
                        for (var j = 0; j < list.length; j++) {
                            if (list[j] === item.item[0]) {
                                return false;
                            }
                        }
                        return true;
                    });

                },

                _refreshItems: function(event) {

                    this.items = [];
                    this.containers = [this];

                    var i, j, cur, inst, targetData, _queries, item, queriesLength,
                        items = this.items,
                        queries = [
                            [$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                                item: this.currentItem
                            }) : $(this.options.items, this.element), this]
                        ],
                        connectWith = this._connectWith();

                    if (connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
                        for (i = connectWith.length - 1; i >= 0; i--) {
                            cur = $(connectWith[i]);
                            for (j = cur.length - 1; j >= 0; j--) {
                                inst = $.data(cur[j], this.widgetFullName);
                                if (inst && inst !== this && !inst.options.disabled) {
                                    queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                                        item: this.currentItem
                                    }) : $(inst.options.items, inst.element), inst]);
                                    this.containers.push(inst);
                                }
                            }
                        }
                    }

                    for (i = queries.length - 1; i >= 0; i--) {
                        targetData = queries[i][1];
                        _queries = queries[i][0];

                        for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                            item = $(_queries[j]);

                            item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

                            items.push({
                                item: item,
                                instance: targetData,
                                width: 0,
                                height: 0,
                                left: 0,
                                top: 0
                            });
                        }
                    }

                },

                refreshPositions: function(fast) {

                    //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
                    if (this.offsetParent && this.helper) {
                        this.offset.parent = this._getParentOffset();
                    }

                    var i, item, t, p;

                    for (i = this.items.length - 1; i >= 0; i--) {
                        item = this.items[i];

                        //We ignore calculating positions of all connected containers when we're not over them
                        if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                            continue;
                        }

                        t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

                        if (!fast) {
                            item.width = t.outerWidth();
                            item.height = t.outerHeight();
                        }

                        p = t.offset();
                        item.left = p.left;
                        item.top = p.top;
                    }

                    if (this.options.custom && this.options.custom.refreshContainers) {
                        this.options.custom.refreshContainers.call(this);
                    } else {
                        for (i = this.containers.length - 1; i >= 0; i--) {
                            p = this.containers[i].element.offset();
                            this.containers[i].containerCache.left = p.left;
                            this.containers[i].containerCache.top = p.top;
                            this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                            this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                        }
                    }

                    return this;
                },

                _createPlaceholder: function(that) {
                    that = that || this;
                    var className,
                        o = that.options;

                    if (!o.placeholder || o.placeholder.constructor === String) {
                        className = o.placeholder;
                        o.placeholder = {
                            element: function() {

                                var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                                    element = $("<" + nodeName + ">", that.document[0])
                                    .addClass(className || that.currentItem[0].className + " ui-sortable-placeholder")
                                    .removeClass("ui-sortable-helper");

                                if (nodeName === "tr") {
                                    that.currentItem.children().each(function() {
                                        $("<td>&#160;</td>", that.document[0])
                                            .attr("colspan", $(this).attr("colspan") || 1)
                                            .appendTo(element);
                                    });
                                } else if (nodeName === "img") {
                                    element.attr("src", that.currentItem.attr("src"));
                                }

                                if (!className) {
                                    element.css("visibility", "hidden");
                                }

                                return element;
                            },
                            update: function(container, p) {

                                // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
                                // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
                                if (className && !o.forcePlaceholderSize) {
                                    return;
                                }

                                //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
                                if (!p.height()) {
                                    p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                                }
                                if (!p.width()) {
                                    p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
                                }
                            }
                        };
                    }

                    //Create the placeholder
                    that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

                    //Append it after the actual current item
                    that.currentItem.after(that.placeholder);

                    //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
                    o.placeholder.update(that, that.placeholder);

                },

                _contactContainers: function(event) {
                    var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
                        innermostContainer = null,
                        innermostIndex = null;

                    // get innermost container that intersects with item
                    for (i = this.containers.length - 1; i >= 0; i--) {

                        // never consider a container that's located within the item itself
                        if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                            continue;
                        }

                        if (this._intersectsWith(this.containers[i].containerCache)) {

                            // if we've already found a container and it's more "inner" than this, then continue
                            if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                                continue;
                            }

                            innermostContainer = this.containers[i];
                            innermostIndex = i;

                        } else {
                            // container doesn't intersect. trigger "out" event if necessary
                            if (this.containers[i].containerCache.over) {
                                this.containers[i]._trigger("out", event, this._uiHash(this));
                                this.containers[i].containerCache.over = 0;
                            }
                        }

                    }

                    // if no intersecting containers found, return
                    if (!innermostContainer) {
                        return;
                    }

                    // move the item into the container if it's not there already
                    if (this.containers.length === 1) {
                        if (!this.containers[innermostIndex].containerCache.over) {
                            this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                            this.containers[innermostIndex].containerCache.over = 1;
                        }
                    } else {

                        //When entering a new container, we will find the item with the least distance and append our item near it
                        dist = 10000;
                        itemWithLeastDistance = null;
                        floating = innermostContainer.floating || isFloating(this.currentItem);
                        posProperty = floating ? "left" : "top";
                        sizeProperty = floating ? "width" : "height";
                        base = this.positionAbs[posProperty] + this.offset.click[posProperty];
                        for (j = this.items.length - 1; j >= 0; j--) {
                            if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                                continue;
                            }
                            if (this.items[j].item[0] === this.currentItem[0]) {
                                continue;
                            }
                            if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
                                continue;
                            }
                            cur = this.items[j].item.offset()[posProperty];
                            nearBottom = false;
                            if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
                                nearBottom = true;
                                cur += this.items[j][sizeProperty];
                            }

                            if (Math.abs(cur - base) < dist) {
                                dist = Math.abs(cur - base);
                                itemWithLeastDistance = this.items[j];
                                this.direction = nearBottom ? "up" : "down";
                            }
                        }

                        //Check if dropOnEmpty is enabled
                        if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                            return;
                        }

                        if (this.currentContainer === this.containers[innermostIndex]) {
                            return;
                        }

                        itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                        this._trigger("change", event, this._uiHash());
                        this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                        this.currentContainer = this.containers[innermostIndex];

                        //Update the placeholder
                        this.options.placeholder.update(this.currentContainer, this.placeholder);

                        this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                        this.containers[innermostIndex].containerCache.over = 1;
                    }


                },

                _createHelper: function(event) {

                    var o = this.options,
                        helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

                    //Add the helper to the DOM if that didn't happen already
                    if (!helper.parents("body").length) {
                        $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
                    }

                    if (helper[0] === this.currentItem[0]) {
                        this._storedCSS = {
                            width: this.currentItem[0].style.width,
                            height: this.currentItem[0].style.height,
                            position: this.currentItem.css("position"),
                            top: this.currentItem.css("top"),
                            left: this.currentItem.css("left")
                        };
                    }

                    if (!helper[0].style.width || o.forceHelperSize) {
                        helper.width(this.currentItem.width());
                    }
                    if (!helper[0].style.height || o.forceHelperSize) {
                        helper.height(this.currentItem.height());
                    }

                    return helper;

                },

                _adjustOffsetFromHelper: function(obj) {
                    if (typeof obj === "string") {
                        obj = obj.split(" ");
                    }
                    if ($.isArray(obj)) {
                        obj = {
                            left: +obj[0],
                            top: +obj[1] || 0
                        };
                    }
                    if ("left" in obj) {
                        this.offset.click.left = obj.left + this.margins.left;
                    }
                    if ("right" in obj) {
                        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                    }
                    if ("top" in obj) {
                        this.offset.click.top = obj.top + this.margins.top;
                    }
                    if ("bottom" in obj) {
                        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                    }
                },

                _getParentOffset: function() {


                    //Get the offsetParent and cache its position
                    this.offsetParent = this.helper.offsetParent();
                    var po = this.offsetParent.offset();

                    // This is a special case where we need to modify a offset calculated on start, since the following happened:
                    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                    if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                        po.left += this.scrollParent.scrollLeft();
                        po.top += this.scrollParent.scrollTop();
                    }

                    // This needs to be actually done for all browsers, since pageX/pageY includes this information
                    // with an ugly IE fix
                    if (this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                        po = {
                            top: 0,
                            left: 0
                        };
                    }

                    return {
                        top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                        left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                    };

                },

                _getRelativeOffset: function() {

                    if (this.cssPosition === "relative") {
                        var p = this.currentItem.position();
                        return {
                            top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                            left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                        };
                    } else {
                        return {
                            top: 0,
                            left: 0
                        };
                    }

                },

                _cacheMargins: function() {
                    this.margins = {
                        left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0),
                        top: (parseInt(this.currentItem.css("marginTop"), 10) || 0)
                    };
                },

                _cacheHelperProportions: function() {
                    this.helperProportions = {
                        width: this.helper.outerWidth(),
                        height: this.helper.outerHeight()
                    };
                },

                _setContainment: function() {

                    var ce, co, over,
                        o = this.options;
                    if (o.containment === "parent") {
                        o.containment = this.helper[0].parentNode;
                    }
                    if (o.containment === "document" || o.containment === "window") {
                        this.containment = [
                            0 - this.offset.relative.left - this.offset.parent.left,
                            0 - this.offset.relative.top - this.offset.parent.top,
                            $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
                            ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                        ];
                    }

                    if (!(/^(document|window|parent)$/).test(o.containment)) {
                        ce = $(o.containment)[0];
                        co = $(o.containment).offset();
                        over = ($(ce).css("overflow") !== "hidden");

                        this.containment = [
                            co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left,
                            co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top,
                            co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left,
                            co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top
                        ];
                    }

                },

                _convertPositionTo: function(d, pos) {

                    if (!pos) {
                        pos = this.position;
                    }
                    var mod = d === "absolute" ? 1 : -1,
                        scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                        scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

                    return {
                        top: (
                            pos.top + // The absolute mouse position
                            this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
                            ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)
                        ),
                        left: (
                            pos.left + // The absolute mouse position
                            this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
                            ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod)
                        )
                    };

                },

                _generatePosition: function(event) {

                    var top, left,
                        o = this.options,
                        pageX = event.pageX,
                        pageY = event.pageY,
                        scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                        scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

                    // This is another very weird special case that only happens for relative elements:
                    // 1. If the css position is relative
                    // 2. and the scroll parent is the document or similar to the offset parent
                    // we have to refresh the relative offset during the scroll so there are no jumps
                    if (this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
                        this.offset.relative = this._getRelativeOffset();
                    }

                    /*
                     * - Position constraining -
                     * Constrain the position to a mix of grid, containment.
                     */

                    if (this.originalPosition) { //If we are not dragging yet, we won't check for options

                        if (this.containment) {
                            if (event.pageX - this.offset.click.left < this.containment[0]) {
                                pageX = this.containment[0] + this.offset.click.left;
                            }
                            if (event.pageY - this.offset.click.top < this.containment[1]) {
                                pageY = this.containment[1] + this.offset.click.top;
                            }
                            if (event.pageX - this.offset.click.left > this.containment[2]) {
                                pageX = this.containment[2] + this.offset.click.left;
                            }
                            if (event.pageY - this.offset.click.top > this.containment[3]) {
                                pageY = this.containment[3] + this.offset.click.top;
                            }
                        }

                        if (o.grid) {
                            top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                            pageY = this.containment ? ((top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                            left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                            pageX = this.containment ? ((left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                        }

                    }

                    return {
                        top: (
                            pageY - // The absolute mouse position
                            this.offset.click.top - // Click offset (relative to the element)
                            this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.top + // The offsetParent's offset without borders (offset + border)
                            ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))
                        ),
                        left: (
                            pageX - // The absolute mouse position
                            this.offset.click.left - // Click offset (relative to the element)
                            this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.left + // The offsetParent's offset without borders (offset + border)
                            ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()))
                        )
                    };

                },

                _rearrange: function(event, i, a, hardRefresh) {

                    a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

                    //Various things done here to improve the performance:
                    // 1. we create a setTimeout, that calls refreshPositions
                    // 2. on the instance, we have a counter variable, that get's higher after every append
                    // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
                    // 4. this lets only the last addition to the timeout stack through
                    this.counter = this.counter ? ++this.counter : 1;
                    var counter = this.counter;

                    this._delay(function() {
                        if (counter === this.counter) {
                            this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
                        }
                    });

                },

                _clear: function(event, noPropagation) {

                    this.reverting = false;
                    // We delay all events that have to be triggered to after the point where the placeholder has been removed and
                    // everything else normalized again
                    var i,
                        delayedTriggers = [];

                    // We first have to update the dom position of the actual currentItem
                    // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
                    if (!this._noFinalSort && this.currentItem.parent().length) {
                        this.placeholder.before(this.currentItem);
                    }
                    this._noFinalSort = null;

                    if (this.helper[0] === this.currentItem[0]) {
                        for (i in this._storedCSS) {
                            if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                                this._storedCSS[i] = "";
                            }
                        }
                        this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                    } else {
                        this.currentItem.show();
                    }

                    if (this.fromOutside && !noPropagation) {
                        delayedTriggers.push(function(event) {
                            this._trigger("receive", event, this._uiHash(this.fromOutside));
                        });
                    }
                    if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                        delayedTriggers.push(function(event) {
                            this._trigger("update", event, this._uiHash());
                        }); //Trigger update callback if the DOM position has changed
                    }

                    // Check if the items Container has Changed and trigger appropriate
                    // events.
                    if (this !== this.currentContainer) {
                        if (!noPropagation) {
                            delayedTriggers.push(function(event) {
                                this._trigger("remove", event, this._uiHash());
                            });
                            delayedTriggers.push((function(c) {
                                return function(event) {
                                    c._trigger("receive", event, this._uiHash(this));
                                };
                            }).call(this, this.currentContainer));
                            delayedTriggers.push((function(c) {
                                return function(event) {
                                    c._trigger("update", event, this._uiHash(this));
                                };
                            }).call(this, this.currentContainer));
                        }
                    }


                    //Post events to containers
                    for (i = this.containers.length - 1; i >= 0; i--) {
                        if (!noPropagation) {
                            delayedTriggers.push((function(c) {
                                return function(event) {
                                    c._trigger("deactivate", event, this._uiHash(this));
                                };
                            }).call(this, this.containers[i]));
                        }
                        if (this.containers[i].containerCache.over) {
                            delayedTriggers.push((function(c) {
                                return function(event) {
                                    c._trigger("out", event, this._uiHash(this));
                                };
                            }).call(this, this.containers[i]));
                            this.containers[i].containerCache.over = 0;
                        }
                    }

                    //Do what was originally in plugins
                    if (this.storedCursor) {
                        this.document.find("body").css("cursor", this.storedCursor);
                        this.storedStylesheet.remove();
                    }
                    if (this._storedOpacity) {
                        this.helper.css("opacity", this._storedOpacity);
                    }
                    if (this._storedZIndex) {
                        this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
                    }

                    this.dragging = false;
                    if (this.cancelHelperRemoval) {
                        if (!noPropagation) {
                            this._trigger("beforeStop", event, this._uiHash());
                            for (i = 0; i < delayedTriggers.length; i++) {
                                delayedTriggers[i].call(this, event);
                            } //Trigger all delayed events
                            this._trigger("stop", event, this._uiHash());
                        }

                        this.fromOutside = false;
                        return false;
                    }

                    if (!noPropagation) {
                        this._trigger("beforeStop", event, this._uiHash());
                    }

                    //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

                    if (this.helper[0] !== this.currentItem[0]) {
                        this.helper.remove();
                    }
                    this.helper = null;

                    if (!noPropagation) {
                        for (i = 0; i < delayedTriggers.length; i++) {
                            delayedTriggers[i].call(this, event);
                        } //Trigger all delayed events
                        this._trigger("stop", event, this._uiHash());
                    }

                    this.fromOutside = false;
                    return true;

                },

                _trigger: function() {
                    if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                        this.cancel();
                    }
                },

                _uiHash: function(_inst) {
                    var inst = _inst || this;
                    return {
                        helper: inst.helper,
                        placeholder: inst.placeholder || $([]),
                        position: inst.position,
                        originalPosition: inst.originalPosition,
                        offset: inst.positionAbs,
                        item: inst.currentItem,
                        sender: _inst ? _inst.element : null
                    };
                }

            });

        })(jQuery);

        (function($, undefined) {

            var dataSpace = "ui-effects-";

            $.effects = {
                effect: {}
            };

            /*!
             * jQuery Color Animations v2.1.2
             * https://github.com/jquery/jquery-color
             *
             * Copyright 2013 jQuery Foundation and other contributors
             * Released under the MIT license.
             * http://jquery.org/license
             *
             * Date: Wed Jan 16 08:47:09 2013 -0600
             */
            (function(jQuery, undefined) {

                var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

                    // plusequals test for += 100 -= 100
                    rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
                    // a set of RE's that can match strings and generate color tuples.
                    stringParsers = [{
                        re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                        parse: function(execResult) {
                            return [
                                execResult[1],
                                execResult[2],
                                execResult[3],
                                execResult[4]
                            ];
                        }
                    }, {
                        re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                        parse: function(execResult) {
                            return [
                                execResult[1] * 2.55,
                                execResult[2] * 2.55,
                                execResult[3] * 2.55,
                                execResult[4]
                            ];
                        }
                    }, {
                        // this regex ignores A-F because it's compared against an already lowercased string
                        re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                        parse: function(execResult) {
                            return [
                                parseInt(execResult[1], 16),
                                parseInt(execResult[2], 16),
                                parseInt(execResult[3], 16)
                            ];
                        }
                    }, {
                        // this regex ignores A-F because it's compared against an already lowercased string
                        re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                        parse: function(execResult) {
                            return [
                                parseInt(execResult[1] + execResult[1], 16),
                                parseInt(execResult[2] + execResult[2], 16),
                                parseInt(execResult[3] + execResult[3], 16)
                            ];
                        }
                    }, {
                        re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                        space: "hsla",
                        parse: function(execResult) {
                            return [
                                execResult[1],
                                execResult[2] / 100,
                                execResult[3] / 100,
                                execResult[4]
                            ];
                        }
                    }],

                    // jQuery.Color( )
                    color = jQuery.Color = function(color, green, blue, alpha) {
                        return new jQuery.Color.fn.parse(color, green, blue, alpha);
                    },
                    spaces = {
                        rgba: {
                            props: {
                                red: {
                                    idx: 0,
                                    type: "byte"
                                },
                                green: {
                                    idx: 1,
                                    type: "byte"
                                },
                                blue: {
                                    idx: 2,
                                    type: "byte"
                                }
                            }
                        },

                        hsla: {
                            props: {
                                hue: {
                                    idx: 0,
                                    type: "degrees"
                                },
                                saturation: {
                                    idx: 1,
                                    type: "percent"
                                },
                                lightness: {
                                    idx: 2,
                                    type: "percent"
                                }
                            }
                        }
                    },
                    propTypes = {
                        "byte": {
                            floor: true,
                            max: 255
                        },
                        "percent": {
                            max: 1
                        },
                        "degrees": {
                            mod: 360,
                            floor: true
                        }
                    },
                    support = color.support = {},

                    // element for support tests
                    supportElem = jQuery("<p>")[0],

                    // colors = jQuery.Color.names
                    colors,

                    // local aliases of functions called often
                    each = jQuery.each;

                // determine rgba support immediately
                supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
                support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;

                // define cache name and alpha properties
                // for rgba and hsla spaces
                each(spaces, function(spaceName, space) {
                    space.cache = "_" + spaceName;
                    space.props.alpha = {
                        idx: 3,
                        type: "percent",
                        def: 1
                    };
                });

                function clamp(value, prop, allowEmpty) {
                    var type = propTypes[prop.type] || {};

                    if (value == null) {
                        return (allowEmpty || !prop.def) ? null : prop.def;
                    }

                    // ~~ is an short way of doing floor for positive numbers
                    value = type.floor ? ~~value : parseFloat(value);

                    // IE will pass in empty strings as value for alpha,
                    // which will hit this case
                    if (isNaN(value)) {
                        return prop.def;
                    }

                    if (type.mod) {
                        // we add mod before modding to make sure that negatives values
                        // get converted properly: -10 -> 350
                        return (value + type.mod) % type.mod;
                    }

                    // for now all property types without mod have min and max
                    return 0 > value ? 0 : type.max < value ? type.max : value;
                }

                function stringParse(string) {
                    var inst = color(),
                        rgba = inst._rgba = [];

                    string = string.toLowerCase();

                    each(stringParsers, function(i, parser) {
                        var parsed,
                            match = parser.re.exec(string),
                            values = match && parser.parse(match),
                            spaceName = parser.space || "rgba";

                        if (values) {
                            parsed = inst[spaceName](values);

                            // if this was an rgba parse the assignment might happen twice
                            // oh well....
                            inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                            rgba = inst._rgba = parsed._rgba;

                            // exit each( stringParsers ) here because we matched
                            return false;
                        }
                    });

                    // Found a stringParser that handled it
                    if (rgba.length) {

                        // if this came from a parsed string, force "transparent" when alpha is 0
                        // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
                        if (rgba.join() === "0,0,0,0") {
                            jQuery.extend(rgba, colors.transparent);
                        }
                        return inst;
                    }

                    // named colors
                    return colors[string];
                }

                color.fn = jQuery.extend(color.prototype, {
                    parse: function(red, green, blue, alpha) {
                        if (red === undefined) {
                            this._rgba = [null, null, null, null];
                            return this;
                        }
                        if (red.jquery || red.nodeType) {
                            red = jQuery(red).css(green);
                            green = undefined;
                        }

                        var inst = this,
                            type = jQuery.type(red),
                            rgba = this._rgba = [];

                        // more than 1 argument specified - assume ( red, green, blue, alpha )
                        if (green !== undefined) {
                            red = [red, green, blue, alpha];
                            type = "array";
                        }

                        if (type === "string") {
                            return this.parse(stringParse(red) || colors._default);
                        }

                        if (type === "array") {
                            each(spaces.rgba.props, function(key, prop) {
                                rgba[prop.idx] = clamp(red[prop.idx], prop);
                            });
                            return this;
                        }

                        if (type === "object") {
                            if (red instanceof color) {
                                each(spaces, function(spaceName, space) {
                                    if (red[space.cache]) {
                                        inst[space.cache] = red[space.cache].slice();
                                    }
                                });
                            } else {
                                each(spaces, function(spaceName, space) {
                                    var cache = space.cache;
                                    each(space.props, function(key, prop) {

                                        // if the cache doesn't exist, and we know how to convert
                                        if (!inst[cache] && space.to) {

                                            // if the value was null, we don't need to copy it
                                            // if the key was alpha, we don't need to copy it either
                                            if (key === "alpha" || red[key] == null) {
                                                return;
                                            }
                                            inst[cache] = space.to(inst._rgba);
                                        }

                                        // this is the only case where we allow nulls for ALL properties.
                                        // call clamp with alwaysAllowEmpty
                                        inst[cache][prop.idx] = clamp(red[key], prop, true);
                                    });

                                    // everything defined but alpha?
                                    if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                                        // use the default of 1
                                        inst[cache][3] = 1;
                                        if (space.from) {
                                            inst._rgba = space.from(inst[cache]);
                                        }
                                    }
                                });
                            }
                            return this;
                        }
                    },
                    is: function(compare) {
                        var is = color(compare),
                            same = true,
                            inst = this;

                        each(spaces, function(_, space) {
                            var localCache,
                                isCache = is[space.cache];
                            if (isCache) {
                                localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                                each(space.props, function(_, prop) {
                                    if (isCache[prop.idx] != null) {
                                        same = (isCache[prop.idx] === localCache[prop.idx]);
                                        return same;
                                    }
                                });
                            }
                            return same;
                        });
                        return same;
                    },
                    _space: function() {
                        var used = [],
                            inst = this;
                        each(spaces, function(spaceName, space) {
                            if (inst[space.cache]) {
                                used.push(spaceName);
                            }
                        });
                        return used.pop();
                    },
                    transition: function(other, distance) {
                        var end = color(other),
                            spaceName = end._space(),
                            space = spaces[spaceName],
                            startColor = this.alpha() === 0 ? color("transparent") : this,
                            start = startColor[space.cache] || space.to(startColor._rgba),
                            result = start.slice();

                        end = end[space.cache];
                        each(space.props, function(key, prop) {
                            var index = prop.idx,
                                startValue = start[index],
                                endValue = end[index],
                                type = propTypes[prop.type] || {};

                            // if null, don't override start value
                            if (endValue === null) {
                                return;
                            }
                            // if null - use end
                            if (startValue === null) {
                                result[index] = endValue;
                            } else {
                                if (type.mod) {
                                    if (endValue - startValue > type.mod / 2) {
                                        startValue += type.mod;
                                    } else if (startValue - endValue > type.mod / 2) {
                                        startValue -= type.mod;
                                    }
                                }
                                result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                            }
                        });
                        return this[spaceName](result);
                    },
                    blend: function(opaque) {
                        // if we are already opaque - return ourself
                        if (this._rgba[3] === 1) {
                            return this;
                        }

                        var rgb = this._rgba.slice(),
                            a = rgb.pop(),
                            blend = color(opaque)._rgba;

                        return color(jQuery.map(rgb, function(v, i) {
                            return (1 - a) * blend[i] + a * v;
                        }));
                    },
                    toRgbaString: function() {
                        var prefix = "rgba(",
                            rgba = jQuery.map(this._rgba, function(v, i) {
                                return v == null ? (i > 2 ? 1 : 0) : v;
                            });

                        if (rgba[3] === 1) {
                            rgba.pop();
                            prefix = "rgb(";
                        }

                        return prefix + rgba.join() + ")";
                    },
                    toHslaString: function() {
                        var prefix = "hsla(",
                            hsla = jQuery.map(this.hsla(), function(v, i) {
                                if (v == null) {
                                    v = i > 2 ? 1 : 0;
                                }

                                // catch 1 and 2
                                if (i && i < 3) {
                                    v = Math.round(v * 100) + "%";
                                }
                                return v;
                            });

                        if (hsla[3] === 1) {
                            hsla.pop();
                            prefix = "hsl(";
                        }
                        return prefix + hsla.join() + ")";
                    },
                    toHexString: function(includeAlpha) {
                        var rgba = this._rgba.slice(),
                            alpha = rgba.pop();

                        if (includeAlpha) {
                            rgba.push(~~(alpha * 255));
                        }

                        return "#" + jQuery.map(rgba, function(v) {

                            // default to 0 when nulls exist
                            v = (v || 0).toString(16);
                            return v.length === 1 ? "0" + v : v;
                        }).join("");
                    },
                    toString: function() {
                        return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
                    }
                });
                color.fn.parse.prototype = color.fn;

                // hsla conversions adapted from:
                // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

                function hue2rgb(p, q, h) {
                    h = (h + 1) % 1;
                    if (h * 6 < 1) {
                        return p + (q - p) * h * 6;
                    }
                    if (h * 2 < 1) {
                        return q;
                    }
                    if (h * 3 < 2) {
                        return p + (q - p) * ((2 / 3) - h) * 6;
                    }
                    return p;
                }

                spaces.hsla.to = function(rgba) {
                    if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                        return [null, null, null, rgba[3]];
                    }
                    var r = rgba[0] / 255,
                        g = rgba[1] / 255,
                        b = rgba[2] / 255,
                        a = rgba[3],
                        max = Math.max(r, g, b),
                        min = Math.min(r, g, b),
                        diff = max - min,
                        add = max + min,
                        l = add * 0.5,
                        h, s;

                    if (min === max) {
                        h = 0;
                    } else if (r === max) {
                        h = (60 * (g - b) / diff) + 360;
                    } else if (g === max) {
                        h = (60 * (b - r) / diff) + 120;
                    } else {
                        h = (60 * (r - g) / diff) + 240;
                    }

                    // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
                    // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
                    if (diff === 0) {
                        s = 0;
                    } else if (l <= 0.5) {
                        s = diff / add;
                    } else {
                        s = diff / (2 - add);
                    }
                    return [Math.round(h) % 360, s, l, a == null ? 1 : a];
                };

                spaces.hsla.from = function(hsla) {
                    if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                        return [null, null, null, hsla[3]];
                    }
                    var h = hsla[0] / 360,
                        s = hsla[1],
                        l = hsla[2],
                        a = hsla[3],
                        q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
                        p = 2 * l - q;

                    return [
                        Math.round(hue2rgb(p, q, h + (1 / 3)) * 255),
                        Math.round(hue2rgb(p, q, h) * 255),
                        Math.round(hue2rgb(p, q, h - (1 / 3)) * 255),
                        a
                    ];
                };


                each(spaces, function(spaceName, space) {
                    var props = space.props,
                        cache = space.cache,
                        to = space.to,
                        from = space.from;

                    // makes rgba() and hsla()
                    color.fn[spaceName] = function(value) {

                        // generate a cache for this space if it doesn't exist
                        if (to && !this[cache]) {
                            this[cache] = to(this._rgba);
                        }
                        if (value === undefined) {
                            return this[cache].slice();
                        }

                        var ret,
                            type = jQuery.type(value),
                            arr = (type === "array" || type === "object") ? value : arguments,
                            local = this[cache].slice();

                        each(props, function(key, prop) {
                            var val = arr[type === "object" ? key : prop.idx];
                            if (val == null) {
                                val = local[prop.idx];
                            }
                            local[prop.idx] = clamp(val, prop);
                        });

                        if (from) {
                            ret = color(from(local));
                            ret[cache] = local;
                            return ret;
                        } else {
                            return color(local);
                        }
                    };

                    // makes red() green() blue() alpha() hue() saturation() lightness()
                    each(props, function(key, prop) {
                        // alpha is included in more than one space
                        if (color.fn[key]) {
                            return;
                        }
                        color.fn[key] = function(value) {
                            var vtype = jQuery.type(value),
                                fn = (key === "alpha" ? (this._hsla ? "hsla" : "rgba") : spaceName),
                                local = this[fn](),
                                cur = local[prop.idx],
                                match;

                            if (vtype === "undefined") {
                                return cur;
                            }

                            if (vtype === "function") {
                                value = value.call(this, cur);
                                vtype = jQuery.type(value);
                            }
                            if (value == null && prop.empty) {
                                return this;
                            }
                            if (vtype === "string") {
                                match = rplusequals.exec(value);
                                if (match) {
                                    value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                                }
                            }
                            local[prop.idx] = value;
                            return this[fn](local);
                        };
                    });
                });

                // add cssHook and .fx.step function for each named hook.
                // accept a space separated string of properties
                color.hook = function(hook) {
                    var hooks = hook.split(" ");
                    each(hooks, function(i, hook) {
                        jQuery.cssHooks[hook] = {
                            set: function(elem, value) {
                                var parsed, curElem,
                                    backgroundColor = "";

                                if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                                    value = color(parsed || value);
                                    if (!support.rgba && value._rgba[3] !== 1) {
                                        curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                        while (
                                            (backgroundColor === "" || backgroundColor === "transparent") &&
                                            curElem && curElem.style
                                        ) {
                                            try {
                                                backgroundColor = jQuery.css(curElem, "backgroundColor");
                                                curElem = curElem.parentNode;
                                            } catch (e) {}
                                        }

                                        value = value.blend(backgroundColor && backgroundColor !== "transparent" ?
                                            backgroundColor :
                                            "_default");
                                    }

                                    value = value.toRgbaString();
                                }
                                try {
                                    elem.style[hook] = value;
                                } catch (e) {
                                    // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
                                }
                            }
                        };
                        jQuery.fx.step[hook] = function(fx) {
                            if (!fx.colorInit) {
                                fx.start = color(fx.elem, hook);
                                fx.end = color(fx.end);
                                fx.colorInit = true;
                            }
                            jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                        };
                    });

                };

                color.hook(stepHooks);

                jQuery.cssHooks.borderColor = {
                    expand: function(value) {
                        var expanded = {};

                        each(["Top", "Right", "Bottom", "Left"], function(i, part) {
                            expanded["border" + part + "Color"] = value;
                        });
                        return expanded;
                    }
                };

                // Basic color names only.
                // Usage of any of the other color names requires adding yourself or including
                // jquery.color.svg-names.js.
                colors = jQuery.Color.names = {
                    // 4.1. Basic color keywords
                    aqua: "#00ffff",
                    black: "#000000",
                    blue: "#0000ff",
                    fuchsia: "#ff00ff",
                    gray: "#808080",
                    green: "#008000",
                    lime: "#00ff00",
                    maroon: "#800000",
                    navy: "#000080",
                    olive: "#808000",
                    purple: "#800080",
                    red: "#ff0000",
                    silver: "#c0c0c0",
                    teal: "#008080",
                    white: "#ffffff",
                    yellow: "#ffff00",

                    // 4.2.3. "transparent" color keyword
                    transparent: [null, null, null, 0],

                    _default: "#ffffff"
                };

            })(jQuery);


            /******************************************************************************/
            /****************************** CLASS ANIMATIONS ******************************/
            /******************************************************************************/
            (function() {

                var classAnimationActions = ["add", "remove", "toggle"],
                    shorthandStyles = {
                        border: 1,
                        borderBottom: 1,
                        borderColor: 1,
                        borderLeft: 1,
                        borderRight: 1,
                        borderTop: 1,
                        borderWidth: 1,
                        margin: 1,
                        padding: 1
                    };

                $.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function(_, prop) {
                    $.fx.step[prop] = function(fx) {
                        if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                            jQuery.style(fx.elem, prop, fx.end);
                            fx.setAttr = true;
                        }
                    };
                });

                function getElementStyles(elem) {
                    var key, len,
                        style = elem.ownerDocument.defaultView ?
                        elem.ownerDocument.defaultView.getComputedStyle(elem, null) :
                        elem.currentStyle,
                        styles = {};

                    if (style && style.length && style[0] && style[style[0]]) {
                        len = style.length;
                        while (len--) {
                            key = style[len];
                            if (typeof style[key] === "string") {
                                styles[$.camelCase(key)] = style[key];
                            }
                        }
                        // support: Opera, IE <9
                    } else {
                        for (key in style) {
                            if (typeof style[key] === "string") {
                                styles[key] = style[key];
                            }
                        }
                    }

                    return styles;
                }


                function styleDifference(oldStyle, newStyle) {
                    var diff = {},
                        name, value;

                    for (name in newStyle) {
                        value = newStyle[name];
                        if (oldStyle[name] !== value) {
                            if (!shorthandStyles[name]) {
                                if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                                    diff[name] = value;
                                }
                            }
                        }
                    }

                    return diff;
                }

                // support: jQuery <1.8
                if (!$.fn.addBack) {
                    $.fn.addBack = function(selector) {
                        return this.add(selector == null ?
                            this.prevObject : this.prevObject.filter(selector)
                        );
                    };
                }

                $.effects.animateClass = function(value, duration, easing, callback) {
                    var o = $.speed(duration, easing, callback);

                    return this.queue(function() {
                        var animated = $(this),
                            baseClass = animated.attr("class") || "",
                            applyClassChange,
                            allAnimations = o.children ? animated.find("*").addBack() : animated;

                        // map the animated objects to store the original styles.
                        allAnimations = allAnimations.map(function() {
                            var el = $(this);
                            return {
                                el: el,
                                start: getElementStyles(this)
                            };
                        });

                        // apply class change
                        applyClassChange = function() {
                            $.each(classAnimationActions, function(i, action) {
                                if (value[action]) {
                                    animated[action + "Class"](value[action]);
                                }
                            });
                        };
                        applyClassChange();

                        // map all animated objects again - calculate new styles and diff
                        allAnimations = allAnimations.map(function() {
                            this.end = getElementStyles(this.el[0]);
                            this.diff = styleDifference(this.start, this.end);
                            return this;
                        });

                        // apply original class
                        animated.attr("class", baseClass);

                        // map all animated objects again - this time collecting a promise
                        allAnimations = allAnimations.map(function() {
                            var styleInfo = this,
                                dfd = $.Deferred(),
                                opts = $.extend({}, o, {
                                    queue: false,
                                    complete: function() {
                                        dfd.resolve(styleInfo);
                                    }
                                });

                            this.el.animate(this.diff, opts);
                            return dfd.promise();
                        });

                        // once all animations have completed:
                        $.when.apply($, allAnimations.get()).done(function() {

                            // set the final class
                            applyClassChange();

                            // for each animated element,
                            // clear all css properties that were animated
                            $.each(arguments, function() {
                                var el = this.el;
                                $.each(this.diff, function(key) {
                                    el.css(key, "");
                                });
                            });

                            // this is guarnteed to be there if you use jQuery.speed()
                            // it also handles dequeuing the next anim...
                            o.complete.call(animated[0]);
                        });
                    });
                };

                $.fn.extend({
                    addClass: (function(orig) {
                        return function(classNames, speed, easing, callback) {
                            return speed ?
                                $.effects.animateClass.call(this, {
                                    add: classNames
                                }, speed, easing, callback) :
                                orig.apply(this, arguments);
                        };
                    })($.fn.addClass),

                    removeClass: (function(orig) {
                        return function(classNames, speed, easing, callback) {
                            return arguments.length > 1 ?
                                $.effects.animateClass.call(this, {
                                    remove: classNames
                                }, speed, easing, callback) :
                                orig.apply(this, arguments);
                        };
                    })($.fn.removeClass),

                    toggleClass: (function(orig) {
                        return function(classNames, force, speed, easing, callback) {
                            if (typeof force === "boolean" || force === undefined) {
                                if (!speed) {
                                    // without speed parameter
                                    return orig.apply(this, arguments);
                                } else {
                                    return $.effects.animateClass.call(this,
                                        (force ? {
                                            add: classNames
                                        } : {
                                            remove: classNames
                                        }),
                                        speed, easing, callback);
                                }
                            } else {
                                // without force parameter
                                return $.effects.animateClass.call(this, {
                                    toggle: classNames
                                }, force, speed, easing);
                            }
                        };
                    })($.fn.toggleClass),

                    switchClass: function(remove, add, speed, easing, callback) {
                        return $.effects.animateClass.call(this, {
                            add: add,
                            remove: remove
                        }, speed, easing, callback);
                    }
                });

            })();

            /******************************************************************************/
            /*********************************** EFFECTS **********************************/
            /******************************************************************************/

            (function() {

                $.extend($.effects, {
                    version: "1.10.3",

                    // Saves a set of properties in a data storage
                    save: function(element, set) {
                        for (var i = 0; i < set.length; i++) {
                            if (set[i] !== null) {
                                element.data(dataSpace + set[i], element[0].style[set[i]]);
                            }
                        }
                    },

                    // Restores a set of previously saved properties from a data storage
                    restore: function(element, set) {
                        var val, i;
                        for (i = 0; i < set.length; i++) {
                            if (set[i] !== null) {
                                val = element.data(dataSpace + set[i]);
                                // support: jQuery 1.6.2
                                // http://bugs.jquery.com/ticket/9917
                                // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
                                // We can't differentiate between "" and 0 here, so we just assume
                                // empty string since it's likely to be a more common value...
                                if (val === undefined) {
                                    val = "";
                                }
                                element.css(set[i], val);
                            }
                        }
                    },

                    setMode: function(el, mode) {
                        if (mode === "toggle") {
                            mode = el.is(":hidden") ? "show" : "hide";
                        }
                        return mode;
                    },

                    // Translates a [top,left] array into a baseline value
                    // this should be a little more flexible in the future to handle a string & hash
                    getBaseline: function(origin, original) {
                        var y, x;
                        switch (origin[0]) {
                            case "top":
                                y = 0;
                                break;
                            case "middle":
                                y = 0.5;
                                break;
                            case "bottom":
                                y = 1;
                                break;
                            default:
                                y = origin[0] / original.height;
                        }
                        switch (origin[1]) {
                            case "left":
                                x = 0;
                                break;
                            case "center":
                                x = 0.5;
                                break;
                            case "right":
                                x = 1;
                                break;
                            default:
                                x = origin[1] / original.width;
                        }
                        return {
                            x: x,
                            y: y
                        };
                    },

                    // Wraps the element around a wrapper that copies position properties
                    createWrapper: function(element) {

                        // if the element is already wrapped, return it
                        if (element.parent().is(".ui-effects-wrapper")) {
                            return element.parent();
                        }

                        // wrap the element
                        var props = {
                                width: element.outerWidth(true),
                                height: element.outerHeight(true),
                                "float": element.css("float")
                            },
                            wrapper = $("<div></div>")
                            .addClass("ui-effects-wrapper")
                            .css({
                                fontSize: "100%",
                                background: "transparent",
                                border: "none",
                                margin: 0,
                                padding: 0
                            }),
                            // Store the size in case width/height are defined in % - Fixes #5245
                            size = {
                                width: element.width(),
                                height: element.height()
                            },
                            active = document.activeElement;

                        // support: Firefox
                        // Firefox incorrectly exposes anonymous content
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                        try {
                            active.id;
                        } catch (e) {
                            active = document.body;
                        }

                        element.wrap(wrapper);

                        // Fixes #7595 - Elements lose focus when wrapped.
                        if (element[0] === active || $.contains(element[0], active)) {
                            $(active).focus();
                        }

                        wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

                        // transfer positioning properties to the wrapper
                        if (element.css("position") === "static") {
                            wrapper.css({
                                position: "relative"
                            });
                            element.css({
                                position: "relative"
                            });
                        } else {
                            $.extend(props, {
                                position: element.css("position"),
                                zIndex: element.css("z-index")
                            });
                            $.each(["top", "left", "bottom", "right"], function(i, pos) {
                                props[pos] = element.css(pos);
                                if (isNaN(parseInt(props[pos], 10))) {
                                    props[pos] = "auto";
                                }
                            });
                            element.css({
                                position: "relative",
                                top: 0,
                                left: 0,
                                right: "auto",
                                bottom: "auto"
                            });
                        }
                        element.css(size);

                        return wrapper.css(props).show();
                    },

                    removeWrapper: function(element) {
                        var active = document.activeElement;

                        if (element.parent().is(".ui-effects-wrapper")) {
                            element.parent().replaceWith(element);

                            // Fixes #7595 - Elements lose focus when wrapped.
                            if (element[0] === active || $.contains(element[0], active)) {
                                $(active).focus();
                            }
                        }


                        return element;
                    },

                    setTransition: function(element, list, factor, value) {
                        value = value || {};
                        $.each(list, function(i, x) {
                            var unit = element.cssUnit(x);
                            if (unit[0] > 0) {
                                value[x] = unit[0] * factor + unit[1];
                            }
                        });
                        return value;
                    }
                });

                // return an effect options object for the given parameters:
                function _normalizeArguments(effect, options, speed, callback) {

                    // allow passing all options as the first parameter
                    if ($.isPlainObject(effect)) {
                        options = effect;
                        effect = effect.effect;
                    }

                    // convert to an object
                    effect = {
                        effect: effect
                    };

                    // catch (effect, null, ...)
                    if (options == null) {
                        options = {};
                    }

                    // catch (effect, callback)
                    if ($.isFunction(options)) {
                        callback = options;
                        speed = null;
                        options = {};
                    }

                    // catch (effect, speed, ?)
                    if (typeof options === "number" || $.fx.speeds[options]) {
                        callback = speed;
                        speed = options;
                        options = {};
                    }

                    // catch (effect, options, callback)
                    if ($.isFunction(speed)) {
                        callback = speed;
                        speed = null;
                    }

                    // add options to effect
                    if (options) {
                        $.extend(effect, options);
                    }

                    speed = speed || options.duration;
                    effect.duration = $.fx.off ? 0 :
                        typeof speed === "number" ? speed :
                        speed in $.fx.speeds ? $.fx.speeds[speed] :
                        $.fx.speeds._default;

                    effect.complete = callback || options.complete;

                    return effect;
                }

                function standardAnimationOption(option) {
                    // Valid standard speeds (nothing, number, named speed)
                    if (!option || typeof option === "number" || $.fx.speeds[option]) {
                        return true;
                    }

                    // Invalid strings - treat as "normal" speed
                    if (typeof option === "string" && !$.effects.effect[option]) {
                        return true;
                    }

                    // Complete callback
                    if ($.isFunction(option)) {
                        return true;
                    }

                    // Options hash (but not naming an effect)
                    if (typeof option === "object" && !option.effect) {
                        return true;
                    }

                    // Didn't match any standard API
                    return false;
                }

                $.fn.extend({
                    effect: function( /* effect, options, speed, callback */ ) {
                        var args = _normalizeArguments.apply(this, arguments),
                            mode = args.mode,
                            queue = args.queue,
                            effectMethod = $.effects.effect[args.effect];

                        if ($.fx.off || !effectMethod) {
                            // delegate to the original method (e.g., .show()) if possible
                            if (mode) {
                                return this[mode](args.duration, args.complete);
                            } else {
                                return this.each(function() {
                                    if (args.complete) {
                                        args.complete.call(this);
                                    }
                                });
                            }
                        }

                        function run(next) {
                            var elem = $(this),
                                complete = args.complete,
                                mode = args.mode;

                            function done() {
                                if ($.isFunction(complete)) {
                                    complete.call(elem[0]);
                                }
                                if ($.isFunction(next)) {
                                    next();
                                }
                            }

                            // If the element already has the correct final state, delegate to
                            // the core methods so the internal tracking of "olddisplay" works.
                            if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                                elem[mode]();
                                done();
                            } else {
                                effectMethod.call(elem[0], args, done);
                            }
                        }

                        return queue === false ? this.each(run) : this.queue(queue || "fx", run);
                    },

                    show: (function(orig) {
                        return function(option) {
                            if (standardAnimationOption(option)) {
                                return orig.apply(this, arguments);
                            } else {
                                var args = _normalizeArguments.apply(this, arguments);
                                args.mode = "show";
                                return this.effect.call(this, args);
                            }
                        };
                    })($.fn.show),

                    hide: (function(orig) {
                        return function(option) {
                            if (standardAnimationOption(option)) {
                                return orig.apply(this, arguments);
                            } else {
                                var args = _normalizeArguments.apply(this, arguments);
                                args.mode = "hide";
                                return this.effect.call(this, args);
                            }
                        };
                    })($.fn.hide),

                    toggle: (function(orig) {
                        return function(option) {
                            if (standardAnimationOption(option) || typeof option === "boolean") {
                                return orig.apply(this, arguments);
                            } else {
                                var args = _normalizeArguments.apply(this, arguments);
                                args.mode = "toggle";
                                return this.effect.call(this, args);
                            }
                        };
                    })($.fn.toggle),

                    // helper functions
                    cssUnit: function(key) {
                        var style = this.css(key),
                            val = [];

                        $.each(["em", "px", "%", "pt"], function(i, unit) {
                            if (style.indexOf(unit) > 0) {
                                val = [parseFloat(style), unit];
                            }
                        });
                        return val;
                    }
                });

            })();

            /******************************************************************************/
            /*********************************** EASING ***********************************/
            /******************************************************************************/

            (function() {

                // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

                var baseEasings = {};

                $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function(i, name) {
                    baseEasings[name] = function(p) {
                        return Math.pow(p, i + 2);
                    };
                });

                $.extend(baseEasings, {
                    Sine: function(p) {
                        return 1 - Math.cos(p * Math.PI / 2);
                    },
                    Circ: function(p) {
                        return 1 - Math.sqrt(1 - p * p);
                    },
                    Elastic: function(p) {
                        return p === 0 || p === 1 ? p :
                            -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
                    },
                    Back: function(p) {
                        return p * p * (3 * p - 2);
                    },
                    Bounce: function(p) {
                        var pow2,
                            bounce = 4;

                        while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
                        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
                    }
                });

                $.each(baseEasings, function(name, easeIn) {
                    $.easing["easeIn" + name] = easeIn;
                    $.easing["easeOut" + name] = function(p) {
                        return 1 - easeIn(1 - p);
                    };
                    $.easing["easeInOut" + name] = function(p) {
                        return p < 0.5 ?
                            easeIn(p * 2) / 2 :
                            1 - easeIn(p * -2 + 2) / 2;
                    };
                });

            })();

        })(jQuery);

        (function($, undefined) {

            var uid = 0,
                hideProps = {},
                showProps = {};

            hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
                hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
            showProps.height = showProps.paddingTop = showProps.paddingBottom =
                showProps.borderTopWidth = showProps.borderBottomWidth = "show";

            $.widget("ui.accordion", {
                version: "1.10.3",
                options: {
                    active: 0,
                    animate: {},
                    collapsible: false,
                    event: "click",
                    header: "> li > :first-child,> :not(li):even",
                    heightStyle: "auto",
                    icons: {
                        activeHeader: "ui-icon-triangle-1-s",
                        header: "ui-icon-triangle-1-e"
                    },

                    // callbacks
                    activate: null,
                    beforeActivate: null
                },

                _create: function() {
                    var options = this.options;
                    this.prevShow = this.prevHide = $();
                    this.element.addClass("ui-accordion ui-widget ui-helper-reset")
                        // ARIA
                        .attr("role", "tablist");

                    // don't allow collapsible: false and active: false / null
                    if (!options.collapsible && (options.active === false || options.active == null)) {
                        options.active = 0;
                    }

                    this._processPanels();
                    // handle negative values
                    if (options.active < 0) {
                        options.active += this.headers.length;
                    }
                    this._refresh();
                },

                _getCreateEventData: function() {
                    return {
                        header: this.active,
                        panel: !this.active.length ? $() : this.active.next(),
                        content: !this.active.length ? $() : this.active.next()
                    };
                },

                _createIcons: function() {
                    var icons = this.options.icons;
                    if (icons) {
                        $("<span>")
                            .addClass("ui-accordion-header-icon ui-icon " + icons.header)
                            .prependTo(this.headers);
                        this.active.children(".ui-accordion-header-icon")
                            .removeClass(icons.header)
                            .addClass(icons.activeHeader);
                        this.headers.addClass("ui-accordion-icons");
                    }
                },

                _destroyIcons: function() {
                    this.headers
                        .removeClass("ui-accordion-icons")
                        .children(".ui-accordion-header-icon")
                        .remove();
                },

                _destroy: function() {
                    var contents;

                    // clean up main element
                    this.element
                        .removeClass("ui-accordion ui-widget ui-helper-reset")
                        .removeAttr("role");

                    // clean up headers
                    this.headers
                        .removeClass("ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top")
                        .removeAttr("role")
                        .removeAttr("aria-selected")
                        .removeAttr("aria-controls")
                        .removeAttr("tabIndex")
                        .each(function() {
                            if (/^ui-accordion/.test(this.id)) {
                                this.removeAttribute("id");
                            }
                        });
                    this._destroyIcons();

                    // clean up content panels
                    contents = this.headers.next()
                        .css("display", "")
                        .removeAttr("role")
                        .removeAttr("aria-expanded")
                        .removeAttr("aria-hidden")
                        .removeAttr("aria-labelledby")
                        .removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled")
                        .each(function() {
                            if (/^ui-accordion/.test(this.id)) {
                                this.removeAttribute("id");
                            }
                        });
                    if (this.options.heightStyle !== "content") {
                        contents.css("height", "");
                    }
                },

                _setOption: function(key, value) {
                    if (key === "active") {
                        // _activate() will handle invalid values and update this.options
                        this._activate(value);
                        return;
                    }

                    if (key === "event") {
                        if (this.options.event) {
                            this._off(this.headers, this.options.event);
                        }
                        this._setupEvents(value);
                    }

                    this._super(key, value);

                    // setting collapsible: false while collapsed; open first panel
                    if (key === "collapsible" && !value && this.options.active === false) {
                        this._activate(0);
                    }

                    if (key === "icons") {
                        this._destroyIcons();
                        if (value) {
                            this._createIcons();
                        }
                    }

                    // #5332 - opacity doesn't cascade to positioned elements in IE
                    // so we need to add the disabled class to the headers and panels
                    if (key === "disabled") {
                        this.headers.add(this.headers.next())
                            .toggleClass("ui-state-disabled", !!value);
                    }
                },

                _keydown: function(event) {
                    /*jshint maxcomplexity:15*/
                    if (event.altKey || event.ctrlKey) {
                        return;
                    }

                    var keyCode = $.ui.keyCode,
                        length = this.headers.length,
                        currentIndex = this.headers.index(event.target),
                        toFocus = false;

                    switch (event.keyCode) {
                        case keyCode.RIGHT:
                        case keyCode.DOWN:
                            toFocus = this.headers[(currentIndex + 1) % length];
                            break;
                        case keyCode.LEFT:
                        case keyCode.UP:
                            toFocus = this.headers[(currentIndex - 1 + length) % length];
                            break;
                        case keyCode.SPACE:
                        case keyCode.ENTER:
                            this._eventHandler(event);
                            break;
                        case keyCode.HOME:
                            toFocus = this.headers[0];
                            break;
                        case keyCode.END:
                            toFocus = this.headers[length - 1];
                            break;
                    }

                    if (toFocus) {
                        $(event.target).attr("tabIndex", -1);
                        $(toFocus).attr("tabIndex", 0);
                        toFocus.focus();
                        event.preventDefault();
                    }
                },

                _panelKeyDown: function(event) {
                    if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                        $(event.currentTarget).prev().focus();
                    }
                },

                refresh: function() {
                    var options = this.options;
                    this._processPanels();

                    // was collapsed or no panel
                    if ((options.active === false && options.collapsible === true) || !this.headers.length) {
                        options.active = false;
                        this.active = $();
                        // active false only when collapsible is true
                    } else if (options.active === false) {
                        this._activate(0);
                        // was active, but active panel is gone
                    } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
                        // all remaining panel are disabled
                        if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                            options.active = false;
                            this.active = $();
                            // activate previous panel
                        } else {
                            this._activate(Math.max(0, options.active - 1));
                        }
                        // was active, active panel still exists
                    } else {
                        // make sure active index is correct
                        options.active = this.headers.index(this.active);
                    }

                    this._destroyIcons();

                    this._refresh();
                },

                _processPanels: function() {
                    this.headers = this.element.find(this.options.header)
                        .addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all");

                    this.headers.next()
                        .addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom")
                        .filter(":not(.ui-accordion-content-active)")
                        .hide();
                },

                _refresh: function() {
                    var maxHeight,
                        options = this.options,
                        heightStyle = options.heightStyle,
                        parent = this.element.parent(),
                        accordionId = this.accordionId = "ui-accordion-" +
                        (this.element.attr("id") || ++uid);

                    this.active = this._findActive(options.active)
                        .addClass("ui-accordion-header-active ui-state-active ui-corner-top")
                        .removeClass("ui-corner-all");
                    this.active.next()
                        .addClass("ui-accordion-content-active")
                        .show();

                    this.headers
                        .attr("role", "tab")
                        .each(function(i) {
                            var header = $(this),
                                headerId = header.attr("id"),
                                panel = header.next(),
                                panelId = panel.attr("id");
                            if (!headerId) {
                                headerId = accordionId + "-header-" + i;
                                header.attr("id", headerId);
                            }
                            if (!panelId) {
                                panelId = accordionId + "-panel-" + i;
                                panel.attr("id", panelId);
                            }
                            header.attr("aria-controls", panelId);
                            panel.attr("aria-labelledby", headerId);
                        })
                        .next()
                        .attr("role", "tabpanel");

                    this.headers
                        .not(this.active)
                        .attr({
                            "aria-selected": "false",
                            tabIndex: -1
                        })
                        .next()
                        .attr({
                            "aria-expanded": "false",
                            "aria-hidden": "true"
                        })
                        .hide();

                    // make sure at least one header is in the tab order
                    if (!this.active.length) {
                        this.headers.eq(0).attr("tabIndex", 0);
                    } else {
                        this.active.attr({
                                "aria-selected": "true",
                                tabIndex: 0
                            })
                            .next()
                            .attr({
                                "aria-expanded": "true",
                                "aria-hidden": "false"
                            });
                    }

                    this._createIcons();

                    this._setupEvents(options.event);

                    if (heightStyle === "fill") {
                        maxHeight = parent.height();
                        this.element.siblings(":visible").each(function() {
                            var elem = $(this),
                                position = elem.css("position");

                            if (position === "absolute" || position === "fixed") {
                                return;
                            }
                            maxHeight -= elem.outerHeight(true);
                        });

                        this.headers.each(function() {
                            maxHeight -= $(this).outerHeight(true);
                        });

                        this.headers.next()
                            .each(function() {
                                $(this).height(Math.max(0, maxHeight -
                                    $(this).innerHeight() + $(this).height()));
                            })
                            .css("overflow", "auto");
                    } else if (heightStyle === "auto") {
                        maxHeight = 0;
                        this.headers.next()
                            .each(function() {
                                maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                            })
                            .height(maxHeight);
                    }
                },

                _activate: function(index) {
                    var active = this._findActive(index)[0];

                    // trying to activate the already active panel
                    if (active === this.active[0]) {
                        return;
                    }

                    // trying to collapse, simulate a click on the currently active header
                    active = active || this.active[0];

                    this._eventHandler({
                        target: active,
                        currentTarget: active,
                        preventDefault: $.noop
                    });
                },

                _findActive: function(selector) {
                    return typeof selector === "number" ? this.headers.eq(selector) : $();
                },

                _setupEvents: function(event) {
                    var events = {
                        keydown: "_keydown"
                    };
                    if (event) {
                        $.each(event.split(" "), function(index, eventName) {
                            events[eventName] = "_eventHandler";
                        });
                    }

                    this._off(this.headers.add(this.headers.next()));
                    this._on(this.headers, events);
                    this._on(this.headers.next(), {
                        keydown: "_panelKeyDown"
                    });
                    this._hoverable(this.headers);
                    this._focusable(this.headers);
                },

                _eventHandler: function(event) {
                    var options = this.options,
                        active = this.active,
                        clicked = $(event.currentTarget),
                        clickedIsActive = clicked[0] === active[0],
                        collapsing = clickedIsActive && options.collapsible,
                        toShow = collapsing ? $() : clicked.next(),
                        toHide = active.next(),
                        eventData = {
                            oldHeader: active,
                            oldPanel: toHide,
                            newHeader: collapsing ? $() : clicked,
                            newPanel: toShow
                        };

                    event.preventDefault();

                    if (
                        // click on active header, but not collapsible
                        (clickedIsActive && !options.collapsible) ||
                        // allow canceling activation
                        (this._trigger("beforeActivate", event, eventData) === false)) {
                        return;
                    }

                    options.active = collapsing ? false : this.headers.index(clicked);

                    // when the call to ._toggle() comes after the class changes
                    // it causes a very odd bug in IE 8 (see #6720)
                    this.active = clickedIsActive ? $() : clicked;
                    this._toggle(eventData);

                    // switch classes
                    // corner classes on the previously active header stay after the animation
                    active.removeClass("ui-accordion-header-active ui-state-active");
                    if (options.icons) {
                        active.children(".ui-accordion-header-icon")
                            .removeClass(options.icons.activeHeader)
                            .addClass(options.icons.header);
                    }

                    if (!clickedIsActive) {
                        clicked
                            .removeClass("ui-corner-all")
                            .addClass("ui-accordion-header-active ui-state-active ui-corner-top");
                        if (options.icons) {
                            clicked.children(".ui-accordion-header-icon")
                                .removeClass(options.icons.header)
                                .addClass(options.icons.activeHeader);
                        }

                        clicked
                            .next()
                            .addClass("ui-accordion-content-active");
                    }
                },

                _toggle: function(data) {
                    var toShow = data.newPanel,
                        toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

                    // handle activating a panel during the animation for another activation
                    this.prevShow.add(this.prevHide).stop(true, true);
                    this.prevShow = toShow;
                    this.prevHide = toHide;

                    if (this.options.animate) {
                        this._animate(toShow, toHide, data);
                    } else {
                        toHide.hide();
                        toShow.show();
                        this._toggleComplete(data);
                    }

                    toHide.attr({
                        "aria-expanded": "false",
                        "aria-hidden": "true"
                    });
                    toHide.prev().attr("aria-selected", "false");
                    // if we're switching panels, remove the old header from the tab order
                    // if we're opening from collapsed state, remove the previous header from the tab order
                    // if we're collapsing, then keep the collapsing header in the tab order
                    if (toShow.length && toHide.length) {
                        toHide.prev().attr("tabIndex", -1);
                    } else if (toShow.length) {
                        this.headers.filter(function() {
                                return $(this).attr("tabIndex") === 0;
                            })
                            .attr("tabIndex", -1);
                    }

                    toShow
                        .attr({
                            "aria-expanded": "true",
                            "aria-hidden": "false"
                        })
                        .prev()
                        .attr({
                            "aria-selected": "true",
                            tabIndex: 0
                        });
                },

                _animate: function(toShow, toHide, data) {
                    var total, easing, duration,
                        that = this,
                        adjust = 0,
                        down = toShow.length &&
                        (!toHide.length || (toShow.index() < toHide.index())),
                        animate = this.options.animate || {},
                        options = down && animate.down || animate,
                        complete = function() {
                            that._toggleComplete(data);
                        };

                    if (typeof options === "number") {
                        duration = options;
                    }
                    if (typeof options === "string") {
                        easing = options;
                    }
                    // fall back from options to animation in case of partial down settings
                    easing = easing || options.easing || animate.easing;
                    duration = duration || options.duration || animate.duration;

                    if (!toHide.length) {
                        return toShow.animate(showProps, duration, easing, complete);
                    }
                    if (!toShow.length) {
                        return toHide.animate(hideProps, duration, easing, complete);
                    }

                    total = toShow.show().outerHeight();
                    toHide.animate(hideProps, {
                        duration: duration,
                        easing: easing,
                        step: function(now, fx) {
                            fx.now = Math.round(now);
                        }
                    });
                    toShow
                        .hide()
                        .animate(showProps, {
                            duration: duration,
                            easing: easing,
                            complete: complete,
                            step: function(now, fx) {
                                fx.now = Math.round(now);
                                if (fx.prop !== "height") {
                                    adjust += fx.now;
                                } else if (that.options.heightStyle !== "content") {
                                    fx.now = Math.round(total - toHide.outerHeight() - adjust);
                                    adjust = 0;
                                }
                            }
                        });
                },

                _toggleComplete: function(data) {
                    var toHide = data.oldPanel;

                    toHide
                        .removeClass("ui-accordion-content-active")
                        .prev()
                        .removeClass("ui-corner-top")
                        .addClass("ui-corner-all");

                    // Work around for rendering bug in IE (#5421)
                    if (toHide.length) {
                        toHide.parent()[0].className = toHide.parent()[0].className;
                    }

                    this._trigger("activate", null, data);
                }
            });

        })(jQuery);

        (function($, undefined) {

            // used to prevent race conditions with remote data sources
            var requestIndex = 0;

            $.widget("ui.autocomplete", {
                version: "1.10.3",
                defaultElement: "<input>",
                options: {
                    appendTo: null,
                    autoFocus: false,
                    delay: 300,
                    minLength: 1,
                    position: {
                        my: "left top",
                        at: "left bottom",
                        collision: "none"
                    },
                    source: null,

                    // callbacks
                    change: null,
                    close: null,
                    focus: null,
                    open: null,
                    response: null,
                    search: null,
                    select: null
                },

                pending: 0,

                _create: function() {
                    // Some browsers only repeat keydown events, not keypress events,
                    // so we use the suppressKeyPress flag to determine if we've already
                    // handled the keydown event. #7269
                    // Unfortunately the code for & in keypress is the same as the up arrow,
                    // so we use the suppressKeyPressRepeat flag to avoid handling keypress
                    // events when we know the keydown event was used to modify the
                    // search term. #7799
                    var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
                        nodeName = this.element[0].nodeName.toLowerCase(),
                        isTextarea = nodeName === "textarea",
                        isInput = nodeName === "input";

                    this.isMultiLine =
                        // Textareas are always multi-line
                        isTextarea ? true :
                        // Inputs are always single-line, even if inside a contentEditable element
                        // IE also treats inputs as contentEditable
                        isInput ? false :
                        // All other element types are determined by whether or not they're contentEditable
                        this.element.prop("isContentEditable");

                    this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
                    this.isNewMenu = true;

                    this.element
                        .addClass("ui-autocomplete-input")
                        .attr("autocomplete", "off");

                    this._on(this.element, {
                        keydown: function(event) {
                            /*jshint maxcomplexity:15*/
                            if (this.element.prop("readOnly")) {
                                suppressKeyPress = true;
                                suppressInput = true;
                                suppressKeyPressRepeat = true;
                                return;
                            }

                            suppressKeyPress = false;
                            suppressInput = false;
                            suppressKeyPressRepeat = false;
                            var keyCode = $.ui.keyCode;
                            switch (event.keyCode) {
                                case keyCode.PAGE_UP:
                                    suppressKeyPress = true;
                                    this._move("previousPage", event);
                                    break;
                                case keyCode.PAGE_DOWN:
                                    suppressKeyPress = true;
                                    this._move("nextPage", event);
                                    break;
                                case keyCode.UP:
                                    suppressKeyPress = true;
                                    this._keyEvent("previous", event);
                                    break;
                                case keyCode.DOWN:
                                    suppressKeyPress = true;
                                    this._keyEvent("next", event);
                                    break;
                                case keyCode.ENTER:
                                case keyCode.NUMPAD_ENTER:
                                    // when menu is open and has focus
                                    if (this.menu.active) {
                                        // #6055 - Opera still allows the keypress to occur
                                        // which causes forms to submit
                                        suppressKeyPress = true;
                                        event.preventDefault();
                                        this.menu.select(event);
                                    }
                                    break;
                                case keyCode.TAB:
                                    if (this.menu.active) {
                                        this.menu.select(event);
                                    }
                                    break;
                                case keyCode.ESCAPE:
                                    if (this.menu.element.is(":visible")) {
                                        this._value(this.term);
                                        this.close(event);
                                        // Different browsers have different default behavior for escape
                                        // Single press can mean undo or clear
                                        // Double press in IE means clear the whole form
                                        event.preventDefault();
                                    }
                                    break;
                                default:
                                    suppressKeyPressRepeat = true;
                                    // search timeout should be triggered before the input value is changed
                                    this._searchTimeout(event);
                                    break;
                            }
                        },
                        keypress: function(event) {
                            if (suppressKeyPress) {
                                suppressKeyPress = false;
                                if (!this.isMultiLine || this.menu.element.is(":visible")) {
                                    event.preventDefault();
                                }
                                return;
                            }
                            if (suppressKeyPressRepeat) {
                                return;
                            }

                            // replicate some key handlers to allow them to repeat in Firefox and Opera
                            var keyCode = $.ui.keyCode;
                            switch (event.keyCode) {
                                case keyCode.PAGE_UP:
                                    this._move("previousPage", event);
                                    break;
                                case keyCode.PAGE_DOWN:
                                    this._move("nextPage", event);
                                    break;
                                case keyCode.UP:
                                    this._keyEvent("previous", event);
                                    break;
                                case keyCode.DOWN:
                                    this._keyEvent("next", event);
                                    break;
                            }
                        },
                        input: function(event) {
                            if (suppressInput) {
                                suppressInput = false;
                                event.preventDefault();
                                return;
                            }
                            this._searchTimeout(event);
                        },
                        focus: function() {
                            this.selectedItem = null;
                            this.previous = this._value();
                        },
                        blur: function(event) {
                            if (this.cancelBlur) {
                                delete this.cancelBlur;
                                return;
                            }

                            clearTimeout(this.searching);
                            this.close(event);
                            this._change(event);
                        }
                    });

                    this._initSource();
                    this.menu = $("<ul>")
                        .addClass("ui-autocomplete ui-front")
                        .appendTo(this._appendTo())
                        .menu({
                            // disable ARIA support, the live region takes care of that
                            role: null
                        })
                        .hide()
                        .data("ui-menu");

                    this._on(this.menu.element, {
                        mousedown: function(event) {
                            // prevent moving focus out of the text field
                            event.preventDefault();

                            // IE doesn't prevent moving focus even with event.preventDefault()
                            // so we set a flag to know when we should ignore the blur event
                            this.cancelBlur = true;
                            this._delay(function() {
                                delete this.cancelBlur;
                            });

                            // clicking on the scrollbar causes focus to shift to the body
                            // but we can't detect a mouseup or a click immediately afterward
                            // so we have to track the next mousedown and close the menu if
                            // the user clicks somewhere outside of the autocomplete
                            var menuElement = this.menu.element[0];
                            if (!$(event.target).closest(".ui-menu-item").length) {
                                this._delay(function() {
                                    var that = this;
                                    this.document.one("mousedown", function(event) {
                                        if (event.target !== that.element[0] &&
                                            event.target !== menuElement &&
                                            !$.contains(menuElement, event.target)) {
                                            that.close();
                                        }
                                    });
                                });
                            }
                        },
                        menufocus: function(event, ui) {
                            // support: Firefox
                            // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                            if (this.isNewMenu) {
                                this.isNewMenu = false;
                                if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                                    this.menu.blur();

                                    this.document.one("mousemove", function() {
                                        $(event.target).trigger(event.originalEvent);
                                    });

                                    return;
                                }
                            }

                            var item = ui.item.data("ui-autocomplete-item");
                            if (false !== this._trigger("focus", event, {
                                    item: item
                                })) {
                                // use value to match what will end up in the input, if it was a key event
                                if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                                    this._value(item.value);
                                }
                            } else {
                                // Normally the input is populated with the item's value as the
                                // menu is navigated, causing screen readers to notice a change and
                                // announce the item. Since the focus event was canceled, this doesn't
                                // happen, so we update the live region so that screen readers can
                                // still notice the change and announce it.
                                this.liveRegion.text(item.value);
                            }
                        },
                        menuselect: function(event, ui) {
                            var item = ui.item.data("ui-autocomplete-item"),
                                previous = this.previous;

                            // only trigger when focus was lost (click on menu)
                            if (this.element[0] !== this.document[0].activeElement) {
                                this.element.focus();
                                this.previous = previous;
                                // #6109 - IE triggers two focus events and the second
                                // is asynchronous, so we need to reset the previous
                                // term synchronously and asynchronously :-(
                                this._delay(function() {
                                    this.previous = previous;
                                    this.selectedItem = item;
                                });
                            }

                            if (false !== this._trigger("select", event, {
                                    item: item
                                })) {
                                this._value(item.value);
                            }
                            // reset the term after the select event
                            // this allows custom select handling to work properly
                            this.term = this._value();

                            this.close(event);
                            this.selectedItem = item;
                        }
                    });

                    this.liveRegion = $("<span>", {
                            role: "status",
                            "aria-live": "polite"
                        })
                        .addClass("ui-helper-hidden-accessible")
                        .insertBefore(this.element);

                    // turning off autocomplete prevents the browser from remembering the
                    // value when navigating through history, so we re-enable autocomplete
                    // if the page is unloaded before the widget is destroyed. #7790
                    this._on(this.window, {
                        beforeunload: function() {
                            this.element.removeAttr("autocomplete");
                        }
                    });
                },

                _destroy: function() {
                    clearTimeout(this.searching);
                    this.element
                        .removeClass("ui-autocomplete-input")
                        .removeAttr("autocomplete");
                    this.menu.element.remove();
                    this.liveRegion.remove();
                },

                _setOption: function(key, value) {
                    this._super(key, value);
                    if (key === "source") {
                        this._initSource();
                    }
                    if (key === "appendTo") {
                        this.menu.element.appendTo(this._appendTo());
                    }
                    if (key === "disabled" && value && this.xhr) {
                        this.xhr.abort();
                    }
                },

                _appendTo: function() {
                    var element = this.options.appendTo;

                    if (element) {
                        element = element.jquery || element.nodeType ?
                            $(element) :
                            this.document.find(element).eq(0);
                    }

                    if (!element) {
                        element = this.element.closest(".ui-front");
                    }

                    if (!element.length) {
                        element = this.document[0].body;
                    }

                    return element;
                },

                _initSource: function() {
                    var array, url,
                        that = this;
                    if ($.isArray(this.options.source)) {
                        array = this.options.source;
                        this.source = function(request, response) {
                            response($.ui.autocomplete.filter(array, request.term));
                        };
                    } else if (typeof this.options.source === "string") {
                        url = this.options.source;
                        this.source = function(request, response) {
                            if (that.xhr) {
                                that.xhr.abort();
                            }
                            that.xhr = $.ajax({
                                url: url,
                                data: request,
                                dataType: "json",
                                success: function(data) {
                                    response(data);
                                },
                                error: function() {
                                    response([]);
                                }
                            });
                        };
                    } else {
                        this.source = this.options.source;
                    }
                },

                _searchTimeout: function(event) {
                    clearTimeout(this.searching);
                    this.searching = this._delay(function() {
                        // only search if the value has changed
                        if (this.term !== this._value()) {
                            this.selectedItem = null;
                            this.search(null, event);
                        }
                    }, this.options.delay);
                },

                search: function(value, event) {
                    value = value != null ? value : this._value();

                    // always save the actual value, not the one passed as an argument
                    this.term = this._value();

                    if (value.length < this.options.minLength) {
                        return this.close(event);
                    }

                    if (this._trigger("search", event) === false) {
                        return;
                    }

                    return this._search(value);
                },

                _search: function(value) {
                    this.pending++;
                    this.element.addClass("ui-autocomplete-loading");
                    this.cancelSearch = false;

                    this.source({
                        term: value
                    }, this._response());
                },

                _response: function() {
                    var that = this,
                        index = ++requestIndex;

                    return function(content) {
                        if (index === requestIndex) {
                            that.__response(content);
                        }

                        that.pending--;
                        if (!that.pending) {
                            that.element.removeClass("ui-autocomplete-loading");
                        }
                    };
                },

                __response: function(content) {
                    if (content) {
                        content = this._normalize(content);
                    }
                    this._trigger("response", null, {
                        content: content
                    });
                    if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                        this._suggest(content);
                        this._trigger("open");
                    } else {
                        // use ._close() instead of .close() so we don't cancel future searches
                        this._close();
                    }
                },

                close: function(event) {
                    this.cancelSearch = true;
                    this._close(event);
                },

                _close: function(event) {
                    if (this.menu.element.is(":visible")) {
                        this.menu.element.hide();
                        this.menu.blur();
                        this.isNewMenu = true;
                        this._trigger("close", event);
                    }
                },

                _change: function(event) {
                    if (this.previous !== this._value()) {
                        this._trigger("change", event, {
                            item: this.selectedItem
                        });
                    }
                },

                _normalize: function(items) {
                    // assume all items have the right format when the first item is complete
                    if (items.length && items[0].label && items[0].value) {
                        return items;
                    }
                    return $.map(items, function(item) {
                        if (typeof item === "string") {
                            return {
                                label: item,
                                value: item
                            };
                        }
                        return $.extend({
                            label: item.label || item.value,
                            value: item.value || item.label
                        }, item);
                    });
                },

                _suggest: function(items) {
                    var ul = this.menu.element.empty();
                    this._renderMenu(ul, items);
                    this.isNewMenu = true;
                    this.menu.refresh();

                    // size and position menu
                    ul.show();
                    this._resizeMenu();
                    ul.position($.extend({ of: this.element
                    }, this.options.position));

                    if (this.options.autoFocus) {
                        this.menu.next();
                    }
                },

                _resizeMenu: function() {
                    var ul = this.menu.element;
                    ul.outerWidth(Math.max(
                        // Firefox wraps long text (possibly a rounding bug)
                        // so we add 1px to avoid the wrapping (#7513)
                        ul.width("").outerWidth() + 1,
                        this.element.outerWidth()
                    ));
                },

                _renderMenu: function(ul, items) {
                    var that = this;
                    $.each(items, function(index, item) {
                        that._renderItemData(ul, item);
                    });
                },

                _renderItemData: function(ul, item) {
                    return this._renderItem(ul, item).data("ui-autocomplete-item", item);
                },

                _renderItem: function(ul, item) {
                    return $("<li>")
                        .append($("<a>").text(item.label))
                        .appendTo(ul);
                },

                _move: function(direction, event) {
                    if (!this.menu.element.is(":visible")) {
                        this.search(null, event);
                        return;
                    }
                    if (this.menu.isFirstItem() && /^previous/.test(direction) ||
                        this.menu.isLastItem() && /^next/.test(direction)) {
                        this._value(this.term);
                        this.menu.blur();
                        return;
                    }
                    this.menu[direction](event);
                },

                widget: function() {
                    return this.menu.element;
                },

                _value: function() {
                    return this.valueMethod.apply(this.element, arguments);
                },

                _keyEvent: function(keyEvent, event) {
                    if (!this.isMultiLine || this.menu.element.is(":visible")) {
                        this._move(keyEvent, event);

                        // prevents moving cursor to beginning/end of the text field in some browsers
                        event.preventDefault();
                    }
                }
            });

            $.extend($.ui.autocomplete, {
                escapeRegex: function(value) {
                    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
                },
                filter: function(array, term) {
                    var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
                    return $.grep(array, function(value) {
                        return matcher.test(value.label || value.value || value);
                    });
                }
            });


            // live region extension, adding a `messages` option
            // NOTE: This is an experimental API. We are still investigating
            // a full solution for string manipulation and internationalization.
            $.widget("ui.autocomplete", $.ui.autocomplete, {
                options: {
                    messages: {
                        noResults: "No search results.",
                        results: function(amount) {
                            return amount + (amount > 1 ? " results are" : " result is") +
                                " available, use up and down arrow keys to navigate.";
                        }
                    }
                },

                __response: function(content) {
                    var message;
                    this._superApply(arguments);
                    if (this.options.disabled || this.cancelSearch) {
                        return;
                    }
                    if (content && content.length) {
                        message = this.options.messages.results(content.length);
                    } else {
                        message = this.options.messages.noResults;
                    }
                    this.liveRegion.text(message);
                }
            });

        }(jQuery));

        (function($, undefined) {

            var lastActive, startXPos, startYPos, clickDragged,
                baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
                stateClasses = "ui-state-hover ui-state-active ",
                typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
                formResetHandler = function() {
                    var form = $(this);
                    setTimeout(function() {
                        form.find(":ui-button").button("refresh");
                    }, 1);
                },
                radioGroup = function(radio) {
                    var name = radio.name,
                        form = radio.form,
                        radios = $([]);
                    if (name) {
                        name = name.replace(/'/g, "\\'");
                        if (form) {
                            radios = $(form).find("[name='" + name + "']");
                        } else {
                            radios = $("[name='" + name + "']", radio.ownerDocument)
                                .filter(function() {
                                    return !this.form;
                                });
                        }
                    }
                    return radios;
                };

            $.widget("ui.button", {
                version: "1.10.3",
                defaultElement: "<button>",
                options: {
                    disabled: null,
                    text: true,
                    label: null,
                    icons: {
                        primary: null,
                        secondary: null
                    }
                },
                _create: function() {
                    this.element.closest("form")
                        .unbind("reset" + this.eventNamespace)
                        .bind("reset" + this.eventNamespace, formResetHandler);

                    if (typeof this.options.disabled !== "boolean") {
                        this.options.disabled = !!this.element.prop("disabled");
                    } else {
                        this.element.prop("disabled", this.options.disabled);
                    }

                    this._determineButtonType();
                    this.hasTitle = !!this.buttonElement.attr("title");

                    var that = this,
                        options = this.options,
                        toggleButton = this.type === "checkbox" || this.type === "radio",
                        activeClass = !toggleButton ? "ui-state-active" : "",
                        focusClass = "ui-state-focus";

                    if (options.label === null) {
                        options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
                    }

                    this._hoverable(this.buttonElement);

                    this.buttonElement
                        .addClass(baseClasses)
                        .attr("role", "button")
                        .bind("mouseenter" + this.eventNamespace, function() {
                            if (options.disabled) {
                                return;
                            }
                            if (this === lastActive) {
                                $(this).addClass("ui-state-active");
                            }
                        })
                        .bind("mouseleave" + this.eventNamespace, function() {
                            if (options.disabled) {
                                return;
                            }
                            $(this).removeClass(activeClass);
                        })
                        .bind("click" + this.eventNamespace, function(event) {
                            if (options.disabled) {
                                event.preventDefault();
                                event.stopImmediatePropagation();
                            }
                        });

                    this.element
                        .bind("focus" + this.eventNamespace, function() {
                            // no need to check disabled, focus won't be triggered anyway
                            that.buttonElement.addClass(focusClass);
                        })
                        .bind("blur" + this.eventNamespace, function() {
                            that.buttonElement.removeClass(focusClass);
                        });

                    if (toggleButton) {
                        this.element.bind("change" + this.eventNamespace, function() {
                            if (clickDragged) {
                                return;
                            }
                            that.refresh();
                        });
                        // if mouse moves between mousedown and mouseup (drag) set clickDragged flag
                        // prevents issue where button state changes but checkbox/radio checked state
                        // does not in Firefox (see ticket #6970)
                        this.buttonElement
                            .bind("mousedown" + this.eventNamespace, function(event) {
                                if (options.disabled) {
                                    return;
                                }
                                clickDragged = false;
                                startXPos = event.pageX;
                                startYPos = event.pageY;
                            })
                            .bind("mouseup" + this.eventNamespace, function(event) {
                                if (options.disabled) {
                                    return;
                                }
                                if (startXPos !== event.pageX || startYPos !== event.pageY) {
                                    clickDragged = true;
                                }
                            });
                    }

                    if (this.type === "checkbox") {
                        this.buttonElement.bind("click" + this.eventNamespace, function() {
                            if (options.disabled || clickDragged) {
                                return false;
                            }
                        });
                    } else if (this.type === "radio") {
                        this.buttonElement.bind("click" + this.eventNamespace, function() {
                            if (options.disabled || clickDragged) {
                                return false;
                            }
                            $(this).addClass("ui-state-active");
                            that.buttonElement.attr("aria-pressed", "true");

                            var radio = that.element[0];
                            radioGroup(radio)
                                .not(radio)
                                .map(function() {
                                    return $(this).button("widget")[0];
                                })
                                .removeClass("ui-state-active")
                                .attr("aria-pressed", "false");
                        });
                    } else {
                        this.buttonElement
                            .bind("mousedown" + this.eventNamespace, function() {
                                if (options.disabled) {
                                    return false;
                                }
                                $(this).addClass("ui-state-active");
                                lastActive = this;
                                that.document.one("mouseup", function() {
                                    lastActive = null;
                                });
                            })
                            .bind("mouseup" + this.eventNamespace, function() {
                                if (options.disabled) {
                                    return false;
                                }
                                $(this).removeClass("ui-state-active");
                            })
                            .bind("keydown" + this.eventNamespace, function(event) {
                                if (options.disabled) {
                                    return false;
                                }
                                if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
                                    $(this).addClass("ui-state-active");
                                }
                            })
                            // see #8559, we bind to blur here in case the button element loses
                            // focus between keydown and keyup, it would be left in an "active" state
                            .bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                                $(this).removeClass("ui-state-active");
                            });

                        if (this.buttonElement.is("a")) {
                            this.buttonElement.keyup(function(event) {
                                if (event.keyCode === $.ui.keyCode.SPACE) {
                                    // TODO pass through original event correctly (just as 2nd argument doesn't work)
                                    $(this).click();
                                }
                            });
                        }
                    }

                    // TODO: pull out $.Widget's handling for the disabled option into
                    // $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
                    // be overridden by individual plugins
                    this._setOption("disabled", options.disabled);
                    this._resetButton();
                },

                _determineButtonType: function() {
                    var ancestor, labelSelector, checked;

                    if (this.element.is("[type=checkbox]")) {
                        this.type = "checkbox";
                    } else if (this.element.is("[type=radio]")) {
                        this.type = "radio";
                    } else if (this.element.is("input")) {
                        this.type = "input";
                    } else {
                        this.type = "button";
                    }

                    if (this.type === "checkbox" || this.type === "radio") {
                        // we don't search against the document in case the element
                        // is disconnected from the DOM
                        ancestor = this.element.parents().last();
                        labelSelector = "label[for='" + this.element.attr("id") + "']";
                        this.buttonElement = ancestor.find(labelSelector);
                        if (!this.buttonElement.length) {
                            ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
                            this.buttonElement = ancestor.filter(labelSelector);
                            if (!this.buttonElement.length) {
                                this.buttonElement = ancestor.find(labelSelector);
                            }
                        }
                        this.element.addClass("ui-helper-hidden-accessible");

                        checked = this.element.is(":checked");
                        if (checked) {
                            this.buttonElement.addClass("ui-state-active");
                        }
                        this.buttonElement.prop("aria-pressed", checked);
                    } else {
                        this.buttonElement = this.element;
                    }
                },

                widget: function() {
                    return this.buttonElement;
                },

                _destroy: function() {
                    this.element
                        .removeClass("ui-helper-hidden-accessible");
                    this.buttonElement
                        .removeClass(baseClasses + " " + stateClasses + " " + typeClasses)
                        .removeAttr("role")
                        .removeAttr("aria-pressed")
                        .html(this.buttonElement.find(".ui-button-text").html());

                    if (!this.hasTitle) {
                        this.buttonElement.removeAttr("title");
                    }
                },

                _setOption: function(key, value) {
                    this._super(key, value);
                    if (key === "disabled") {
                        if (value) {
                            this.element.prop("disabled", true);
                        } else {
                            this.element.prop("disabled", false);
                        }
                        return;
                    }
                    this._resetButton();
                },

                refresh: function() {
                    //See #8237 & #8828
                    var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");

                    if (isDisabled !== this.options.disabled) {
                        this._setOption("disabled", isDisabled);
                    }
                    if (this.type === "radio") {
                        radioGroup(this.element[0]).each(function() {
                            if ($(this).is(":checked")) {
                                $(this).button("widget")
                                    .addClass("ui-state-active")
                                    .attr("aria-pressed", "true");
                            } else {
                                $(this).button("widget")
                                    .removeClass("ui-state-active")
                                    .attr("aria-pressed", "false");
                            }
                        });
                    } else if (this.type === "checkbox") {
                        if (this.element.is(":checked")) {
                            this.buttonElement
                                .addClass("ui-state-active")
                                .attr("aria-pressed", "true");
                        } else {
                            this.buttonElement
                                .removeClass("ui-state-active")
                                .attr("aria-pressed", "false");
                        }
                    }
                },

                _resetButton: function() {
                    if (this.type === "input") {
                        if (this.options.label) {
                            this.element.val(this.options.label);
                        }
                        return;
                    }
                    var buttonElement = this.buttonElement.removeClass(typeClasses),
                        buttonText = $("<span></span>", this.document[0])
                        .addClass("ui-button-text")
                        .html(this.options.label)
                        .appendTo(buttonElement.empty())
                        .text(),
                        icons = this.options.icons,
                        multipleIcons = icons.primary && icons.secondary,
                        buttonClasses = [];

                    if (icons.primary || icons.secondary) {
                        if (this.options.text) {
                            buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : (icons.primary ? "-primary" : "-secondary")));
                        }

                        if (icons.primary) {
                            buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
                        }

                        if (icons.secondary) {
                            buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
                        }

                        if (!this.options.text) {
                            buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only");

                            if (!this.hasTitle) {
                                buttonElement.attr("title", $.trim(buttonText));
                            }
                        }
                    } else {
                        buttonClasses.push("ui-button-text-only");
                    }
                    buttonElement.addClass(buttonClasses.join(" "));
                }
            });

            $.widget("ui.buttonset", {
                version: "1.10.3",
                options: {
                    items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
                },

                _create: function() {
                    this.element.addClass("ui-buttonset");
                },

                _init: function() {
                    this.refresh();
                },

                _setOption: function(key, value) {
                    if (key === "disabled") {
                        this.buttons.button("option", key, value);
                    }

                    this._super(key, value);
                },

                refresh: function() {
                    var rtl = this.element.css("direction") === "rtl";

                    this.buttons = this.element.find(this.options.items)
                        .filter(":ui-button")
                        .button("refresh")
                        .end()
                        .not(":ui-button")
                        .button()
                        .end()
                        .map(function() {
                            return $(this).button("widget")[0];
                        })
                        .removeClass("ui-corner-all ui-corner-left ui-corner-right")
                        .filter(":first")
                        .addClass(rtl ? "ui-corner-right" : "ui-corner-left")
                        .end()
                        .filter(":last")
                        .addClass(rtl ? "ui-corner-left" : "ui-corner-right")
                        .end()
                        .end();
                },

                _destroy: function() {
                    this.element.removeClass("ui-buttonset");
                    this.buttons
                        .map(function() {
                            return $(this).button("widget")[0];
                        })
                        .removeClass("ui-corner-left ui-corner-right")
                        .end()
                        .button("destroy");
                }
            });

        }(jQuery));

        (function($, undefined) {

            $.extend($.ui, {
                datepicker: {
                    version: "1.10.3"
                }
            });

            var PROP_NAME = "datepicker",
                instActive;

            /* Date picker manager.
               Use the singleton instance of this class, $.datepicker, to interact with the date picker.
               Settings for (groups of) date pickers are maintained in an instance object,
               allowing multiple different settings on the same page. */

            function Datepicker() {
                this._curInst = null; // The current instance in use
                this._keyEvent = false; // If the last event was a key event
                this._disabledInputs = []; // List of date picker inputs that have been disabled
                this._datepickerShowing = false; // True if the popup picker is showing , false if not
                this._inDialog = false; // True if showing within a "dialog", false if not
                this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
                this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
                this._appendClass = "ui-datepicker-append"; // The name of the append marker class
                this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
                this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
                this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
                this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
                this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
                this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
                this.regional = []; // Available regional settings, indexed by language code
                this.regional[""] = { // Default regional settings
                    closeText: "Done", // Display text for close link
                    prevText: "Prev", // Display text for previous month link
                    nextText: "Next", // Display text for next month link
                    currentText: "Today", // Display text for current month link
                    monthNames: ["January", "February", "March", "April", "May", "June",
                        "July", "August", "September", "October", "November", "December"
                    ], // Names of months for drop-down and formatting
                    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
                    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
                    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
                    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], // Column headings for days starting at Sunday
                    weekHeader: "Wk", // Column header for week of the year
                    dateFormat: "mm/dd/yy", // See format options on parseDate
                    firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
                    isRTL: false, // True if right-to-left language, false if left-to-right
                    showMonthAfterYear: false, // True if the year select precedes month, false for month then year
                    yearSuffix: "" // Additional text to append to the year in the month headers
                };
                this._defaults = { // Global defaults for all the date picker instances
                    showOn: "focus", // "focus" for popup on focus,
                    // "button" for trigger button, or "both" for either
                    showAnim: "fadeIn", // Name of jQuery animation for popup
                    showOptions: {}, // Options for enhanced animations
                    defaultDate: null, // Used when field is blank: actual date,
                    // +/-number for offset from today, null for today
                    appendText: "", // Display text following the input box, e.g. showing the format
                    buttonText: "...", // Text for trigger button
                    buttonImage: "", // URL for trigger button image
                    buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
                    hideIfNoPrevNext: false, // True to hide next/previous month links
                    // if not applicable, false to just disable them
                    navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
                    gotoCurrent: false, // True if today link goes back to current selection instead
                    changeMonth: false, // True if month can be selected directly, false if only prev/next
                    changeYear: false, // True if year can be selected directly, false if only prev/next
                    yearRange: "c-10:c+10", // Range of years to display in drop-down,
                    // either relative to today's year (-nn:+nn), relative to currently displayed year
                    // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
                    showOtherMonths: false, // True to show dates in other months, false to leave blank
                    selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
                    showWeek: false, // True to show week of the year, false to not show it
                    calculateWeek: this.iso8601Week, // How to calculate the week of the year,
                    // takes a Date and returns the number of the week for it
                    shortYearCutoff: "+10", // Short year values < this are in the current century,
                    // > this are in the previous century,
                    // string value starting with "+" for current year + value
                    minDate: null, // The earliest selectable date, or null for no limit
                    maxDate: null, // The latest selectable date, or null for no limit
                    duration: "fast", // Duration of display/closure
                    beforeShowDay: null, // Function that takes a date and returns an array with
                    // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
                    // [2] = cell title (optional), e.g. $.datepicker.noWeekends
                    beforeShow: null, // Function that takes an input field and
                    // returns a set of custom settings for the date picker
                    onSelect: null, // Define a callback function when a date is selected
                    onChangeMonthYear: null, // Define a callback function when the month or year is changed
                    onClose: null, // Define a callback function when the datepicker is closed
                    numberOfMonths: 1, // Number of months to show at a time
                    showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
                    stepMonths: 1, // Number of months to step back/forward
                    stepBigMonths: 12, // Number of months to step back/forward for the big links
                    altField: "", // Selector for an alternate field to store selected dates into
                    altFormat: "", // The date format to use for the alternate field
                    constrainInput: true, // The input is constrained by the current date format
                    showButtonPanel: false, // True to show button panel, false to not show it
                    autoSize: false, // True to size the input for the date format, false to leave as is
                    disabled: false // The initial disabled state
                };
                $.extend(this._defaults, this.regional[""]);
                this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
            }

            $.extend(Datepicker.prototype, {
                /* Class name added to elements to indicate already configured with a date picker. */
                markerClassName: "hasDatepicker",

                //Keep track of the maximum number of rows displayed (see #7043)
                maxRows: 4,

                // TODO rename to "widget" when switching to widget factory
                _widgetDatepicker: function() {
                    return this.dpDiv;
                },

                /* Override the default settings for all instances of the date picker.
                 * @param  settings  object - the new settings to use as defaults (anonymous object)
                 * @return the manager object
                 */
                setDefaults: function(settings) {
                    extendRemove(this._defaults, settings || {});
                    return this;
                },

                /* Attach the date picker to a jQuery selection.
                 * @param  target   element - the target input field or division or span
                 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
                 */
                _attachDatepicker: function(target, settings) {
                    var nodeName, inline, inst;
                    nodeName = target.nodeName.toLowerCase();
                    inline = (nodeName === "div" || nodeName === "span");
                    if (!target.id) {
                        this.uuid += 1;
                        target.id = "dp" + this.uuid;
                    }
                    inst = this._newInst($(target), inline);
                    inst.settings = $.extend({}, settings || {});
                    if (nodeName === "input") {
                        this._connectDatepicker(target, inst);
                    } else if (inline) {
                        this._inlineDatepicker(target, inst);
                    }
                },

                /* Create a new instance object. */
                _newInst: function(target, inline) {
                    var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
                    return {
                        id: id,
                        input: target, // associated target
                        selectedDay: 0,
                        selectedMonth: 0,
                        selectedYear: 0, // current selection
                        drawMonth: 0,
                        drawYear: 0, // month being drawn
                        inline: inline, // is datepicker inline or not
                        dpDiv: (!inline ? this.dpDiv : // presentation div
                            bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))
                    };
                },

                /* Attach the date picker to an input field. */
                _connectDatepicker: function(target, inst) {
                    var input = $(target);
                    inst.append = $([]);
                    inst.trigger = $([]);
                    if (input.hasClass(this.markerClassName)) {
                        return;
                    }
                    this._attachments(input, inst);
                    input.addClass(this.markerClassName).keydown(this._doKeyDown).
                    keypress(this._doKeyPress).keyup(this._doKeyUp);
                    this._autoSize(inst);
                    $.data(target, PROP_NAME, inst);
                    //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
                    if (inst.settings.disabled) {
                        this._disableDatepicker(target);
                    }
                },

                /* Make attachments based on settings. */
                _attachments: function(input, inst) {
                    var showOn, buttonText, buttonImage,
                        appendText = this._get(inst, "appendText"),
                        isRTL = this._get(inst, "isRTL");

                    if (inst.append) {
                        inst.append.remove();
                    }
                    if (appendText) {
                        inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                        input[isRTL ? "before" : "after"](inst.append);
                    }

                    input.unbind("focus", this._showDatepicker);

                    if (inst.trigger) {
                        inst.trigger.remove();
                    }

                    showOn = this._get(inst, "showOn");
                    if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
                        input.focus(this._showDatepicker);
                    }
                    if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
                        buttonText = this._get(inst, "buttonText");
                        buttonImage = this._get(inst, "buttonImage");
                        inst.trigger = $(this._get(inst, "buttonImageOnly") ?
                            $("<img/>").addClass(this._triggerClass).attr({
                                src: buttonImage,
                                alt: buttonText,
                                title: buttonText
                            }) :
                            $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                                src: buttonImage,
                                alt: buttonText,
                                title: buttonText
                            })));
                        input[isRTL ? "before" : "after"](inst.trigger);
                        inst.trigger.click(function() {
                            if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                                $.datepicker._hideDatepicker();
                            } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                                $.datepicker._hideDatepicker();
                                $.datepicker._showDatepicker(input[0]);
                            } else {
                                $.datepicker._showDatepicker(input[0]);
                            }
                            return false;
                        });
                    }
                },

                /* Apply the maximum length for the date format. */
                _autoSize: function(inst) {
                    if (this._get(inst, "autoSize") && !inst.inline) {
                        var findMax, max, maxI, i,
                            date = new Date(2009, 12 - 1, 20), // Ensure double digits
                            dateFormat = this._get(inst, "dateFormat");

                        if (dateFormat.match(/[DM]/)) {
                            findMax = function(names) {
                                max = 0;
                                maxI = 0;
                                for (i = 0; i < names.length; i++) {
                                    if (names[i].length > max) {
                                        max = names[i].length;
                                        maxI = i;
                                    }
                                }
                                return maxI;
                            };
                            date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                                "monthNames" : "monthNamesShort"))));
                            date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                                "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
                        }
                        inst.input.attr("size", this._formatDate(inst, date).length);
                    }
                },

                /* Attach an inline date picker to a div. */
                _inlineDatepicker: function(target, inst) {
                    var divSpan = $(target);
                    if (divSpan.hasClass(this.markerClassName)) {
                        return;
                    }
                    divSpan.addClass(this.markerClassName).append(inst.dpDiv);
                    $.data(target, PROP_NAME, inst);
                    this._setDate(inst, this._getDefaultDate(inst), true);
                    this._updateDatepicker(inst);
                    this._updateAlternate(inst);
                    //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
                    if (inst.settings.disabled) {
                        this._disableDatepicker(target);
                    }
                    // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
                    // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
                    inst.dpDiv.css("display", "block");
                },

                /* Pop-up the date picker in a "dialog" box.
                 * @param  input element - ignored
                 * @param  date string or Date - the initial date to display
                 * @param  onSelect  function - the function to call when a date is selected
                 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
                 * @param  pos int[2] - coordinates for the dialog's position within the screen or
                 *                  event - with x/y coordinates or
                 *                  leave empty for default (screen centre)
                 * @return the manager object
                 */
                _dialogDatepicker: function(input, date, onSelect, settings, pos) {
                    var id, browserWidth, browserHeight, scrollX, scrollY,
                        inst = this._dialogInst; // internal instance

                    if (!inst) {
                        this.uuid += 1;
                        id = "dp" + this.uuid;
                        this._dialogInput = $("<input type='text' id='" + id +
                            "' style='position: absolute; top: -100px; width: 0px;'/>");
                        this._dialogInput.keydown(this._doKeyDown);
                        $("body").append(this._dialogInput);
                        inst = this._dialogInst = this._newInst(this._dialogInput, false);
                        inst.settings = {};
                        $.data(this._dialogInput[0], PROP_NAME, inst);
                    }
                    extendRemove(inst.settings, settings || {});
                    date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
                    this._dialogInput.val(date);

                    this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
                    if (!this._pos) {
                        browserWidth = document.documentElement.clientWidth;
                        browserHeight = document.documentElement.clientHeight;
                        scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                        scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                        this._pos = // should use actual width/height below
                            [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
                    }

                    // move input on screen for focus, but hidden behind dialog
                    this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
                    inst.settings.onSelect = onSelect;
                    this._inDialog = true;
                    this.dpDiv.addClass(this._dialogClass);
                    this._showDatepicker(this._dialogInput[0]);
                    if ($.blockUI) {
                        $.blockUI(this.dpDiv);
                    }
                    $.data(this._dialogInput[0], PROP_NAME, inst);
                    return this;
                },

                /* Detach a datepicker from its control.
                 * @param  target   element - the target input field or division or span
                 */
                _destroyDatepicker: function(target) {
                    var nodeName,
                        $target = $(target),
                        inst = $.data(target, PROP_NAME);

                    if (!$target.hasClass(this.markerClassName)) {
                        return;
                    }

                    nodeName = target.nodeName.toLowerCase();
                    $.removeData(target, PROP_NAME);
                    if (nodeName === "input") {
                        inst.append.remove();
                        inst.trigger.remove();
                        $target.removeClass(this.markerClassName).
                        unbind("focus", this._showDatepicker).
                        unbind("keydown", this._doKeyDown).
                        unbind("keypress", this._doKeyPress).
                        unbind("keyup", this._doKeyUp);
                    } else if (nodeName === "div" || nodeName === "span") {
                        $target.removeClass(this.markerClassName).empty();
                    }
                },

                /* Enable the date picker to a jQuery selection.
                 * @param  target   element - the target input field or division or span
                 */
                _enableDatepicker: function(target) {
                    var nodeName, inline,
                        $target = $(target),
                        inst = $.data(target, PROP_NAME);

                    if (!$target.hasClass(this.markerClassName)) {
                        return;
                    }

                    nodeName = target.nodeName.toLowerCase();
                    if (nodeName === "input") {
                        target.disabled = false;
                        inst.trigger.filter("button").
                        each(function() {
                            this.disabled = false;
                        }).end().
                        filter("img").css({
                            opacity: "1.0",
                            cursor: ""
                        });
                    } else if (nodeName === "div" || nodeName === "span") {
                        inline = $target.children("." + this._inlineClass);
                        inline.children().removeClass("ui-state-disabled");
                        inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                        prop("disabled", false);
                    }
                    this._disabledInputs = $.map(this._disabledInputs,
                        function(value) {
                            return (value === target ? null : value);
                        }); // delete entry
                },

                /* Disable the date picker to a jQuery selection.
                 * @param  target   element - the target input field or division or span
                 */
                _disableDatepicker: function(target) {
                    var nodeName, inline,
                        $target = $(target),
                        inst = $.data(target, PROP_NAME);

                    if (!$target.hasClass(this.markerClassName)) {
                        return;
                    }

                    nodeName = target.nodeName.toLowerCase();
                    if (nodeName === "input") {
                        target.disabled = true;
                        inst.trigger.filter("button").
                        each(function() {
                            this.disabled = true;
                        }).end().
                        filter("img").css({
                            opacity: "0.5",
                            cursor: "default"
                        });
                    } else if (nodeName === "div" || nodeName === "span") {
                        inline = $target.children("." + this._inlineClass);
                        inline.children().addClass("ui-state-disabled");
                        inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                        prop("disabled", true);
                    }
                    this._disabledInputs = $.map(this._disabledInputs,
                        function(value) {
                            return (value === target ? null : value);
                        }); // delete entry
                    this._disabledInputs[this._disabledInputs.length] = target;
                },

                /* Is the first field in a jQuery collection disabled as a datepicker?
                 * @param  target   element - the target input field or division or span
                 * @return boolean - true if disabled, false if enabled
                 */
                _isDisabledDatepicker: function(target) {
                    if (!target) {
                        return false;
                    }
                    for (var i = 0; i < this._disabledInputs.length; i++) {
                        if (this._disabledInputs[i] === target) {
                            return true;
                        }
                    }
                    return false;
                },

                /* Retrieve the instance data for the target control.
                 * @param  target  element - the target input field or division or span
                 * @return  object - the associated instance data
                 * @throws  error if a jQuery problem getting data
                 */
                _getInst: function(target) {
                    try {
                        return $.data(target, PROP_NAME);
                    } catch (err) {
                        throw "Missing instance data for this datepicker";
                    }
                },

                /* Update or retrieve the settings for a date picker attached to an input field or division.
                 * @param  target  element - the target input field or division or span
                 * @param  name object - the new settings to update or
                 *              string - the name of the setting to change or retrieve,
                 *              when retrieving also "all" for all instance settings or
                 *              "defaults" for all global defaults
                 * @param  value   any - the new value for the setting
                 *              (omit if above is an object or to retrieve a value)
                 */
                _optionDatepicker: function(target, name, value) {
                    var settings, date, minDate, maxDate,
                        inst = this._getInst(target);

                    if (arguments.length === 2 && typeof name === "string") {
                        return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
                            (inst ? (name === "all" ? $.extend({}, inst.settings) :
                                this._get(inst, name)) : null));
                    }

                    settings = name || {};
                    if (typeof name === "string") {
                        settings = {};
                        settings[name] = value;
                    }

                    if (inst) {
                        if (this._curInst === inst) {
                            this._hideDatepicker();
                        }

                        date = this._getDateDatepicker(target, true);
                        minDate = this._getMinMaxDate(inst, "min");
                        maxDate = this._getMinMaxDate(inst, "max");
                        extendRemove(inst.settings, settings);
                        // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                        if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                            inst.settings.minDate = this._formatDate(inst, minDate);
                        }
                        if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                            inst.settings.maxDate = this._formatDate(inst, maxDate);
                        }
                        if ("disabled" in settings) {
                            if (settings.disabled) {
                                this._disableDatepicker(target);
                            } else {
                                this._enableDatepicker(target);
                            }
                        }
                        this._attachments($(target), inst);
                        this._autoSize(inst);
                        this._setDate(inst, date);
                        this._updateAlternate(inst);
                        this._updateDatepicker(inst);
                    }
                },

                // change method deprecated
                _changeDatepicker: function(target, name, value) {
                    this._optionDatepicker(target, name, value);
                },

                /* Redraw the date picker attached to an input field or division.
                 * @param  target  element - the target input field or division or span
                 */
                _refreshDatepicker: function(target) {
                    var inst = this._getInst(target);
                    if (inst) {
                        this._updateDatepicker(inst);
                    }
                },

                /* Set the dates for a jQuery selection.
                 * @param  target element - the target input field or division or span
                 * @param  date Date - the new date
                 */
                _setDateDatepicker: function(target, date) {
                    var inst = this._getInst(target);
                    if (inst) {
                        this._setDate(inst, date);
                        this._updateDatepicker(inst);
                        this._updateAlternate(inst);
                    }
                },

                /* Get the date(s) for the first entry in a jQuery selection.
                 * @param  target element - the target input field or division or span
                 * @param  noDefault boolean - true if no default date is to be used
                 * @return Date - the current date
                 */
                _getDateDatepicker: function(target, noDefault) {
                    var inst = this._getInst(target);
                    if (inst && !inst.inline) {
                        this._setDateFromField(inst, noDefault);
                    }
                    return (inst ? this._getDate(inst) : null);
                },

                /* Handle keystrokes. */
                _doKeyDown: function(event) {
                    var onSelect, dateStr, sel,
                        inst = $.datepicker._getInst(event.target),
                        handled = true,
                        isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

                    inst._keyEvent = true;
                    if ($.datepicker._datepickerShowing) {
                        switch (event.keyCode) {
                            case 9:
                                $.datepicker._hideDatepicker();
                                handled = false;
                                break; // hide on tab out
                            case 13:
                                sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                                    $.datepicker._currentClass + ")", inst.dpDiv);
                                if (sel[0]) {
                                    $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                                }

                                onSelect = $.datepicker._get(inst, "onSelect");
                                if (onSelect) {
                                    dateStr = $.datepicker._formatDate(inst);

                                    // trigger custom callback
                                    onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                                } else {
                                    $.datepicker._hideDatepicker();
                                }

                                return false; // don't submit the form
                            case 27:
                                $.datepicker._hideDatepicker();
                                break; // hide on escape
                            case 33:
                                $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                    -$.datepicker._get(inst, "stepBigMonths") :
                                    -$.datepicker._get(inst, "stepMonths")), "M");
                                break; // previous month/year on page up/+ ctrl
                            case 34:
                                $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                    +$.datepicker._get(inst, "stepBigMonths") :
                                    +$.datepicker._get(inst, "stepMonths")), "M");
                                break; // next month/year on page down/+ ctrl
                            case 35:
                                if (event.ctrlKey || event.metaKey) {
                                    $.datepicker._clearDate(event.target);
                                }
                                handled = event.ctrlKey || event.metaKey;
                                break; // clear on ctrl or command +end
                            case 36:
                                if (event.ctrlKey || event.metaKey) {
                                    $.datepicker._gotoToday(event.target);
                                }
                                handled = event.ctrlKey || event.metaKey;
                                break; // current on ctrl or command +home
                            case 37:
                                if (event.ctrlKey || event.metaKey) {
                                    $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                                }
                                handled = event.ctrlKey || event.metaKey;
                                // -1 day on ctrl or command +left
                                if (event.originalEvent.altKey) {
                                    $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                        -$.datepicker._get(inst, "stepBigMonths") :
                                        -$.datepicker._get(inst, "stepMonths")), "M");
                                }
                                // next month/year on alt +left on Mac
                                break;
                            case 38:
                                if (event.ctrlKey || event.metaKey) {
                                    $.datepicker._adjustDate(event.target, -7, "D");
                                }
                                handled = event.ctrlKey || event.metaKey;
                                break; // -1 week on ctrl or command +up
                            case 39:
                                if (event.ctrlKey || event.metaKey) {
                                    $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                                }
                                handled = event.ctrlKey || event.metaKey;
                                // +1 day on ctrl or command +right
                                if (event.originalEvent.altKey) {
                                    $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                        +$.datepicker._get(inst, "stepBigMonths") :
                                        +$.datepicker._get(inst, "stepMonths")), "M");
                                }
                                // next month/year on alt +right
                                break;
                            case 40:
                                if (event.ctrlKey || event.metaKey) {
                                    $.datepicker._adjustDate(event.target, +7, "D");
                                }
                                handled = event.ctrlKey || event.metaKey;
                                break; // +1 week on ctrl or command +down
                            default:
                                handled = false;
                        }
                    } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
                        $.datepicker._showDatepicker(this);
                    } else {
                        handled = false;
                    }

                    if (handled) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                },

                /* Filter entered characters - based on date format. */
                _doKeyPress: function(event) {
                    var chars, chr,
                        inst = $.datepicker._getInst(event.target);

                    if ($.datepicker._get(inst, "constrainInput")) {
                        chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                        chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                        return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
                    }
                },

                /* Synchronise manual entry and field/alternate field. */
                _doKeyUp: function(event) {
                    var date,
                        inst = $.datepicker._getInst(event.target);

                    if (inst.input.val() !== inst.lastVal) {
                        try {
                            date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                                (inst.input ? inst.input.val() : null),
                                $.datepicker._getFormatConfig(inst));

                            if (date) { // only if valid
                                $.datepicker._setDateFromField(inst);
                                $.datepicker._updateAlternate(inst);
                                $.datepicker._updateDatepicker(inst);
                            }
                        } catch (err) {}
                    }
                    return true;
                },

                /* Pop-up the date picker for a given input field.
                 * If false returned from beforeShow event handler do not show.
                 * @param  input  element - the input field attached to the date picker or
                 *                  event - if triggered by focus
                 */
                _showDatepicker: function(input) {
                    input = input.target || input;
                    if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
                        input = $("input", input.parentNode)[0];
                    }

                    if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
                        return;
                    }

                    var inst, beforeShow, beforeShowSettings, isFixed,
                        offset, showAnim, duration;

                    inst = $.datepicker._getInst(input);
                    if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                        $.datepicker._curInst.dpDiv.stop(true, true);
                        if (inst && $.datepicker._datepickerShowing) {
                            $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                        }
                    }

                    beforeShow = $.datepicker._get(inst, "beforeShow");
                    beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
                    if (beforeShowSettings === false) {
                        return;
                    }
                    extendRemove(inst.settings, beforeShowSettings);

                    inst.lastVal = null;
                    $.datepicker._lastInput = input;
                    $.datepicker._setDateFromField(inst);

                    if ($.datepicker._inDialog) { // hide cursor
                        input.value = "";
                    }
                    if (!$.datepicker._pos) { // position below input
                        $.datepicker._pos = $.datepicker._findPos(input);
                        $.datepicker._pos[1] += input.offsetHeight; // add the height
                    }

                    isFixed = false;
                    $(input).parents().each(function() {
                        isFixed |= $(this).css("position") === "fixed";
                        return !isFixed;
                    });

                    offset = {
                        left: $.datepicker._pos[0],
                        top: $.datepicker._pos[1]
                    };
                    $.datepicker._pos = null;
                    //to avoid flashes on Firefox
                    inst.dpDiv.empty();
                    // determine sizing offscreen
                    inst.dpDiv.css({
                        position: "absolute",
                        display: "block",
                        top: "-1000px"
                    });
                    $.datepicker._updateDatepicker(inst);
                    // fix width for dynamic number of date pickers
                    // and adjust position before showing
                    offset = $.datepicker._checkOffset(inst, offset, isFixed);
                    inst.dpDiv.css({
                        position: ($.datepicker._inDialog && $.blockUI ?
                            "static" : (isFixed ? "fixed" : "absolute")),
                        display: "none",
                        left: offset.left + "px",
                        top: offset.top + "px"
                    });

                    if (!inst.inline) {
                        showAnim = $.datepicker._get(inst, "showAnim");
                        duration = $.datepicker._get(inst, "duration");
                        inst.dpDiv.zIndex($(input).zIndex() + 1);
                        $.datepicker._datepickerShowing = true;

                        if ($.effects && $.effects.effect[showAnim]) {
                            inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                        } else {
                            inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                        }

                        if ($.datepicker._shouldFocusInput(inst)) {
                            inst.input.focus();
                        }

                        $.datepicker._curInst = inst;
                    }
                },

                /* Generate the date picker content. */
                _updateDatepicker: function(inst) {
                    this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
                    instActive = inst; // for delegate hover events
                    inst.dpDiv.empty().append(this._generateHTML(inst));
                    this._attachHandlers(inst);
                    inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

                    var origyearshtml,
                        numMonths = this._getNumberOfMonths(inst),
                        cols = numMonths[1],
                        width = 17;

                    inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
                    if (cols > 1) {
                        inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
                    }
                    inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
                        "Class"]("ui-datepicker-multi");
                    inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
                        "Class"]("ui-datepicker-rtl");

                    if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                        inst.input.focus();
                    }

                    // deffered render of the years select (to avoid flashes on Firefox)
                    if (inst.yearshtml) {
                        origyearshtml = inst.yearshtml;
                        setTimeout(function() {
                            //assure that inst.yearshtml didn't change.
                            if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                                inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                            }
                            origyearshtml = inst.yearshtml = null;
                        }, 0);
                    }
                },

                // #6694 - don't focus the input if it's already focused
                // this breaks the change event in IE
                // Support: IE and jQuery <1.9
                _shouldFocusInput: function(inst) {
                    return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
                },

                /* Check positioning to remain on screen. */
                _checkOffset: function(inst, offset, isFixed) {
                    var dpWidth = inst.dpDiv.outerWidth(),
                        dpHeight = inst.dpDiv.outerHeight(),
                        inputWidth = inst.input ? inst.input.outerWidth() : 0,
                        inputHeight = inst.input ? inst.input.outerHeight() : 0,
                        viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
                        viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

                    offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
                    offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
                    offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

                    // now check if datepicker is showing outside window viewport - move to a better place if so.
                    offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
                        Math.abs(offset.left + dpWidth - viewWidth) : 0);
                    offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                        Math.abs(dpHeight + inputHeight) : 0);

                    return offset;
                },

                /* Find an object's position on the screen. */
                _findPos: function(obj) {
                    var position,
                        inst = this._getInst(obj),
                        isRTL = this._get(inst, "isRTL");

                    while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                        obj = obj[isRTL ? "previousSibling" : "nextSibling"];
                    }

                    position = $(obj).offset();
                    return [position.left, position.top];
                },

                /* Hide the date picker from view.
                 * @param  input  element - the input field attached to the date picker
                 */
                _hideDatepicker: function(input) {
                    var showAnim, duration, postProcess, onClose,
                        inst = this._curInst;

                    if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
                        return;
                    }

                    if (this._datepickerShowing) {
                        showAnim = this._get(inst, "showAnim");
                        duration = this._get(inst, "duration");
                        postProcess = function() {
                            $.datepicker._tidyDialog(inst);
                        };

                        // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                        if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                            inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                        } else {
                            inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
                                (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
                        }

                        if (!showAnim) {
                            postProcess();
                        }
                        this._datepickerShowing = false;

                        onClose = this._get(inst, "onClose");
                        if (onClose) {
                            onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
                        }

                        this._lastInput = null;
                        if (this._inDialog) {
                            this._dialogInput.css({
                                position: "absolute",
                                left: "0",
                                top: "-100px"
                            });
                            if ($.blockUI) {
                                $.unblockUI();
                                $("body").append(this.dpDiv);
                            }
                        }
                        this._inDialog = false;
                    }
                },

                /* Tidy up after a dialog display. */
                _tidyDialog: function(inst) {
                    inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
                },

                /* Close date picker if clicked elsewhere. */
                _checkExternalClick: function(event) {
                    if (!$.datepicker._curInst) {
                        return;
                    }

                    var $target = $(event.target),
                        inst = $.datepicker._getInst($target[0]);

                    if ((($target[0].id !== $.datepicker._mainDivId &&
                            $target.parents("#" + $.datepicker._mainDivId).length === 0 &&
                            !$target.hasClass($.datepicker.markerClassName) &&
                            !$target.closest("." + $.datepicker._triggerClass).length &&
                            $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))) ||
                        ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst)) {
                        $.datepicker._hideDatepicker();
                    }
                },

                /* Adjust one of the date sub-fields. */
                _adjustDate: function(id, offset, period) {
                    var target = $(id),
                        inst = this._getInst(target[0]);

                    if (this._isDisabledDatepicker(target[0])) {
                        return;
                    }
                    this._adjustInstDate(inst, offset +
                        (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
                        period);
                    this._updateDatepicker(inst);
                },

                /* Action for current link. */
                _gotoToday: function(id) {
                    var date,
                        target = $(id),
                        inst = this._getInst(target[0]);

                    if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                        inst.selectedDay = inst.currentDay;
                        inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                        inst.drawYear = inst.selectedYear = inst.currentYear;
                    } else {
                        date = new Date();
                        inst.selectedDay = date.getDate();
                        inst.drawMonth = inst.selectedMonth = date.getMonth();
                        inst.drawYear = inst.selectedYear = date.getFullYear();
                    }
                    this._notifyChange(inst);
                    this._adjustDate(target);
                },

                /* Action for selecting a new month/year. */
                _selectMonthYear: function(id, select, period) {
                    var target = $(id),
                        inst = this._getInst(target[0]);

                    inst["selected" + (period === "M" ? "Month" : "Year")] =
                        inst["draw" + (period === "M" ? "Month" : "Year")] =
                        parseInt(select.options[select.selectedIndex].value, 10);

                    this._notifyChange(inst);
                    this._adjustDate(target);
                },

                /* Action for selecting a day. */
                _selectDay: function(id, month, year, td) {
                    var inst,
                        target = $(id);

                    if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                        return;
                    }

                    inst = this._getInst(target[0]);
                    inst.selectedDay = inst.currentDay = $("a", td).html();
                    inst.selectedMonth = inst.currentMonth = month;
                    inst.selectedYear = inst.currentYear = year;
                    this._selectDate(id, this._formatDate(inst,
                        inst.currentDay, inst.currentMonth, inst.currentYear));
                },

                /* Erase the input field and hide the date picker. */
                _clearDate: function(id) {
                    var target = $(id);
                    this._selectDate(target, "");
                },

                /* Update the input field with the selected date. */
                _selectDate: function(id, dateStr) {
                    var onSelect,
                        target = $(id),
                        inst = this._getInst(target[0]);

                    dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
                    if (inst.input) {
                        inst.input.val(dateStr);
                    }
                    this._updateAlternate(inst);

                    onSelect = this._get(inst, "onSelect");
                    if (onSelect) {
                        onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]); // trigger custom callback
                    } else if (inst.input) {
                        inst.input.trigger("change"); // fire the change event
                    }

                    if (inst.inline) {
                        this._updateDatepicker(inst);
                    } else {
                        this._hideDatepicker();
                        this._lastInput = inst.input[0];
                        if (typeof(inst.input[0]) !== "object") {
                            inst.input.focus(); // restore focus
                        }
                        this._lastInput = null;
                    }
                },

                /* Update any alternate field to synchronise with the main field. */
                _updateAlternate: function(inst) {
                    var altFormat, date, dateStr,
                        altField = this._get(inst, "altField");

                    if (altField) { // update alternate field too
                        altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                        date = this._getDate(inst);
                        dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                        $(altField).each(function() {
                            $(this).val(dateStr);
                        });
                    }
                },

                /* Set as beforeShowDay function to prevent selection of weekends.
                 * @param  date  Date - the date to customise
                 * @return [boolean, string] - is this date selectable?, what is its CSS class?
                 */
                noWeekends: function(date) {
                    var day = date.getDay();
                    return [(day > 0 && day < 6), ""];
                },

                /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
                 * @param  date  Date - the date to get the week for
                 * @return  number - the number of the week within the year that contains this date
                 */
                iso8601Week: function(date) {
                    var time,
                        checkDate = new Date(date.getTime());

                    // Find Thursday of this week starting on Monday
                    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

                    time = checkDate.getTime();
                    checkDate.setMonth(0); // Compare with Jan 1
                    checkDate.setDate(1);
                    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
                },

                /* Parse a string value into a date object.
                 * See formatDate below for the possible formats.
                 *
                 * @param  format string - the expected format of the date
                 * @param  value string - the date in the above format
                 * @param  settings Object - attributes include:
                 *                  shortYearCutoff  number - the cutoff year for determining the century (optional)
                 *                  dayNamesShort   string[7] - abbreviated names of the days from Sunday (optional)
                 *                  dayNames        string[7] - names of the days from Sunday (optional)
                 *                  monthNamesShort string[12] - abbreviated names of the months (optional)
                 *                  monthNames      string[12] - names of the months (optional)
                 * @return  Date - the extracted date value or null if value is blank
                 */
                parseDate: function(format, value, settings) {
                    if (format == null || value == null) {
                        throw "Invalid arguments";
                    }

                    value = (typeof value === "object" ? value.toString() : value + "");
                    if (value === "") {
                        return null;
                    }

                    var iFormat, dim, extra,
                        iValue = 0,
                        shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                        shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                            new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
                        dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                        dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                        monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                        monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                        year = -1,
                        month = -1,
                        day = -1,
                        doy = -1,
                        literal = false,
                        date,
                        // Check whether a format character is doubled
                        lookAhead = function(match) {
                            var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                            if (matches) {
                                iFormat++;
                            }
                            return matches;
                        },
                        // Extract a number from the string value
                        getNumber = function(match) {
                            var isDoubled = lookAhead(match),
                                size = (match === "@" ? 14 : (match === "!" ? 20 :
                                    (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                                digits = new RegExp("^\\d{1," + size + "}"),
                                num = value.substring(iValue).match(digits);
                            if (!num) {
                                throw "Missing number at position " + iValue;
                            }
                            iValue += num[0].length;
                            return parseInt(num[0], 10);
                        },
                        // Extract a name from the string value and convert to an index
                        getName = function(match, shortNames, longNames) {
                            var index = -1,
                                names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                                    return [
                                        [k, v]
                                    ];
                                }).sort(function(a, b) {
                                    return -(a[1].length - b[1].length);
                                });

                            $.each(names, function(i, pair) {
                                var name = pair[1];
                                if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                                    index = pair[0];
                                    iValue += name.length;
                                    return false;
                                }
                            });
                            if (index !== -1) {
                                return index + 1;
                            } else {
                                throw "Unknown name at position " + iValue;
                            }
                        },
                        // Confirm that a literal character matches the string value
                        checkLiteral = function() {
                            if (value.charAt(iValue) !== format.charAt(iFormat)) {
                                throw "Unexpected literal at position " + iValue;
                            }
                            iValue++;
                        };

                    for (iFormat = 0; iFormat < format.length; iFormat++) {
                        if (literal) {
                            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                                literal = false;
                            } else {
                                checkLiteral();
                            }
                        } else {
                            switch (format.charAt(iFormat)) {
                                case "d":
                                    day = getNumber("d");
                                    break;
                                case "D":
                                    getName("D", dayNamesShort, dayNames);
                                    break;
                                case "o":
                                    doy = getNumber("o");
                                    break;
                                case "m":
                                    month = getNumber("m");
                                    break;
                                case "M":
                                    month = getName("M", monthNamesShort, monthNames);
                                    break;
                                case "y":
                                    year = getNumber("y");
                                    break;
                                case "@":
                                    date = new Date(getNumber("@"));
                                    year = date.getFullYear();
                                    month = date.getMonth() + 1;
                                    day = date.getDate();
                                    break;
                                case "!":
                                    date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                                    year = date.getFullYear();
                                    month = date.getMonth() + 1;
                                    day = date.getDate();
                                    break;
                                case "'":
                                    if (lookAhead("'")) {
                                        checkLiteral();
                                    } else {
                                        literal = true;
                                    }
                                    break;
                                default:
                                    checkLiteral();
                            }
                        }
                    }

                    if (iValue < value.length) {
                        extra = value.substr(iValue);
                        if (!/^\s+/.test(extra)) {
                            throw "Extra/unparsed characters found in date: " + extra;
                        }
                    }

                    if (year === -1) {
                        year = new Date().getFullYear();
                    } else if (year < 100) {
                        year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                            (year <= shortYearCutoff ? 0 : -100);
                    }

                    if (doy > -1) {
                        month = 1;
                        day = doy;
                        do {
                            dim = this._getDaysInMonth(year, month - 1);
                            if (day <= dim) {
                                break;
                            }
                            month++;
                            day -= dim;
                        } while (true);
                    }

                    date = this._daylightSavingAdjust(new Date(year, month - 1, day));
                    if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                        throw "Invalid date"; // E.g. 31/02/00
                    }
                    return date;
                },

                /* Standard date formats. */
                ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
                COOKIE: "D, dd M yy",
                ISO_8601: "yy-mm-dd",
                RFC_822: "D, d M y",
                RFC_850: "DD, dd-M-y",
                RFC_1036: "D, d M y",
                RFC_1123: "D, d M yy",
                RFC_2822: "D, d M yy",
                RSS: "D, d M y", // RFC 822
                TICKS: "!",
                TIMESTAMP: "@",
                W3C: "yy-mm-dd", // ISO 8601

                _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
                    Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

                /* Format a date object into a string value.
                 * The format can be combinations of the following:
                 * d  - day of month (no leading zero)
                 * dd - day of month (two digit)
                 * o  - day of year (no leading zeros)
                 * oo - day of year (three digit)
                 * D  - day name short
                 * DD - day name long
                 * m  - month of year (no leading zero)
                 * mm - month of year (two digit)
                 * M  - month name short
                 * MM - month name long
                 * y  - year (two digit)
                 * yy - year (four digit)
                 * @ - Unix timestamp (ms since 01/01/1970)
                 * ! - Windows ticks (100ns since 01/01/0001)
                 * "..." - literal text
                 * '' - single quote
                 *
                 * @param  format string - the desired format of the date
                 * @param  date Date - the date value to format
                 * @param  settings Object - attributes include:
                 *                  dayNamesShort   string[7] - abbreviated names of the days from Sunday (optional)
                 *                  dayNames        string[7] - names of the days from Sunday (optional)
                 *                  monthNamesShort string[12] - abbreviated names of the months (optional)
                 *                  monthNames      string[12] - names of the months (optional)
                 * @return  string - the date in the above format
                 */
                formatDate: function(format, date, settings) {
                    if (!date) {
                        return "";
                    }

                    var iFormat,
                        dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                        dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                        monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                        monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                        // Check whether a format character is doubled
                        lookAhead = function(match) {
                            var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                            if (matches) {
                                iFormat++;
                            }
                            return matches;
                        },
                        // Format a number, with leading zero if necessary
                        formatNumber = function(match, value, len) {
                            var num = "" + value;
                            if (lookAhead(match)) {
                                while (num.length < len) {
                                    num = "0" + num;
                                }
                            }
                            return num;
                        },
                        // Format a name, short or long as requested
                        formatName = function(match, value, shortNames, longNames) {
                            return (lookAhead(match) ? longNames[value] : shortNames[value]);
                        },
                        output = "",
                        literal = false;

                    if (date) {
                        for (iFormat = 0; iFormat < format.length; iFormat++) {
                            if (literal) {
                                if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                                    literal = false;
                                } else {
                                    output += format.charAt(iFormat);
                                }
                            } else {
                                switch (format.charAt(iFormat)) {
                                    case "d":
                                        output += formatNumber("d", date.getDate(), 2);
                                        break;
                                    case "D":
                                        output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                        break;
                                    case "o":
                                        output += formatNumber("o",
                                            Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                                        break;
                                    case "m":
                                        output += formatNumber("m", date.getMonth() + 1, 2);
                                        break;
                                    case "M":
                                        output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                        break;
                                    case "y":
                                        output += (lookAhead("y") ? date.getFullYear() :
                                            (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                                        break;
                                    case "@":
                                        output += date.getTime();
                                        break;
                                    case "!":
                                        output += date.getTime() * 10000 + this._ticksTo1970;
                                        break;
                                    case "'":
                                        if (lookAhead("'")) {
                                            output += "'";
                                        } else {
                                            literal = true;
                                        }
                                        break;
                                    default:
                                        output += format.charAt(iFormat);
                                }
                            }
                        }
                    }
                    return output;
                },

                /* Extract all possible characters from the date format. */
                _possibleChars: function(format) {
                    var iFormat,
                        chars = "",
                        literal = false,
                        // Check whether a format character is doubled
                        lookAhead = function(match) {
                            var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                            if (matches) {
                                iFormat++;
                            }
                            return matches;
                        };

                    for (iFormat = 0; iFormat < format.length; iFormat++) {
                        if (literal) {
                            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                                literal = false;
                            } else {
                                chars += format.charAt(iFormat);
                            }
                        } else {
                            switch (format.charAt(iFormat)) {
                                case "d":
                                case "m":
                                case "y":
                                case "@":
                                    chars += "0123456789";
                                    break;
                                case "D":
                                case "M":
                                    return null; // Accept anything
                                case "'":
                                    if (lookAhead("'")) {
                                        chars += "'";
                                    } else {
                                        literal = true;
                                    }
                                    break;
                                default:
                                    chars += format.charAt(iFormat);
                            }
                        }
                    }
                    return chars;
                },

                /* Get a setting value, defaulting if necessary. */
                _get: function(inst, name) {
                    return inst.settings[name] !== undefined ?
                        inst.settings[name] : this._defaults[name];
                },

                /* Parse existing date and initialise date picker. */
                _setDateFromField: function(inst, noDefault) {
                    if (inst.input.val() === inst.lastVal) {
                        return;
                    }

                    var dateFormat = this._get(inst, "dateFormat"),
                        dates = inst.lastVal = inst.input ? inst.input.val() : null,
                        defaultDate = this._getDefaultDate(inst),
                        date = defaultDate,
                        settings = this._getFormatConfig(inst);

                    try {
                        date = this.parseDate(dateFormat, dates, settings) || defaultDate;
                    } catch (event) {
                        dates = (noDefault ? "" : dates);
                    }
                    inst.selectedDay = date.getDate();
                    inst.drawMonth = inst.selectedMonth = date.getMonth();
                    inst.drawYear = inst.selectedYear = date.getFullYear();
                    inst.currentDay = (dates ? date.getDate() : 0);
                    inst.currentMonth = (dates ? date.getMonth() : 0);
                    inst.currentYear = (dates ? date.getFullYear() : 0);
                    this._adjustInstDate(inst);
                },

                /* Retrieve the default date shown on opening. */
                _getDefaultDate: function(inst) {
                    return this._restrictMinMax(inst,
                        this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
                },

                /* A date may be specified as an exact value or a relative one. */
                _determineDate: function(inst, date, defaultDate) {
                    var offsetNumeric = function(offset) {
                            var date = new Date();
                            date.setDate(date.getDate() + offset);
                            return date;
                        },
                        offsetString = function(offset) {
                            try {
                                return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                                    offset, $.datepicker._getFormatConfig(inst));
                            } catch (e) {
                                // Ignore
                            }

                            var date = (offset.toLowerCase().match(/^c/) ?
                                    $.datepicker._getDate(inst) : null) || new Date(),
                                year = date.getFullYear(),
                                month = date.getMonth(),
                                day = date.getDate(),
                                pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                                matches = pattern.exec(offset);

                            while (matches) {
                                switch (matches[2] || "d") {
                                    case "d":
                                    case "D":
                                        day += parseInt(matches[1], 10);
                                        break;
                                    case "w":
                                    case "W":
                                        day += parseInt(matches[1], 10) * 7;
                                        break;
                                    case "m":
                                    case "M":
                                        month += parseInt(matches[1], 10);
                                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                        break;
                                    case "y":
                                    case "Y":
                                        year += parseInt(matches[1], 10);
                                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                        break;
                                }
                                matches = pattern.exec(offset);
                            }
                            return new Date(year, month, day);
                        },
                        newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
                            (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

                    newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
                    if (newDate) {
                        newDate.setHours(0);
                        newDate.setMinutes(0);
                        newDate.setSeconds(0);
                        newDate.setMilliseconds(0);
                    }
                    return this._daylightSavingAdjust(newDate);
                },

                /* Handle switch to/from daylight saving.
                 * Hours may be non-zero on daylight saving cut-over:
                 * > 12 when midnight changeover, but then cannot generate
                 * midnight datetime, so jump to 1AM, otherwise reset.
                 * @param  date  (Date) the date to check
                 * @return  (Date) the corrected date
                 */
                _daylightSavingAdjust: function(date) {
                    if (!date) {
                        return null;
                    }
                    date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
                    return date;
                },

                /* Set the date(s) directly. */
                _setDate: function(inst, date, noChange) {
                    var clear = !date,
                        origMonth = inst.selectedMonth,
                        origYear = inst.selectedYear,
                        newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

                    inst.selectedDay = inst.currentDay = newDate.getDate();
                    inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
                    inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
                    if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                        this._notifyChange(inst);
                    }
                    this._adjustInstDate(inst);
                    if (inst.input) {
                        inst.input.val(clear ? "" : this._formatDate(inst));
                    }
                },

                /* Retrieve the date(s) directly. */
                _getDate: function(inst) {
                    var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
                        this._daylightSavingAdjust(new Date(
                            inst.currentYear, inst.currentMonth, inst.currentDay)));
                    return startDate;
                },

                /* Attach the onxxx handlers.  These are declared statically so
                 * they work with static code transformers like Caja.
                 */
                _attachHandlers: function(inst) {
                    var stepMonths = this._get(inst, "stepMonths"),
                        id = "#" + inst.id.replace(/\\\\/g, "\\");
                    inst.dpDiv.find("[data-handler]").map(function() {
                        var handler = {
                            prev: function() {
                                $.datepicker._adjustDate(id, -stepMonths, "M");
                            },
                            next: function() {
                                $.datepicker._adjustDate(id, +stepMonths, "M");
                            },
                            hide: function() {
                                $.datepicker._hideDatepicker();
                            },
                            today: function() {
                                $.datepicker._gotoToday(id);
                            },
                            selectDay: function() {
                                $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                                return false;
                            },
                            selectMonth: function() {
                                $.datepicker._selectMonthYear(id, this, "M");
                                return false;
                            },
                            selectYear: function() {
                                $.datepicker._selectMonthYear(id, this, "Y");
                                return false;
                            }
                        };
                        $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
                    });
                },

                /* Generate the HTML for the current state of the date picker. */
                _generateHTML: function(inst) {
                    var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                        controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                        monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                        selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                        cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                        printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                        tempDate = new Date(),
                        today = this._daylightSavingAdjust(
                            new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
                        isRTL = this._get(inst, "isRTL"),
                        showButtonPanel = this._get(inst, "showButtonPanel"),
                        hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                        navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
                        numMonths = this._getNumberOfMonths(inst),
                        showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                        stepMonths = this._get(inst, "stepMonths"),
                        isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
                        currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                            new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
                        minDate = this._getMinMaxDate(inst, "min"),
                        maxDate = this._getMinMaxDate(inst, "max"),
                        drawMonth = inst.drawMonth - showCurrentAtPos,
                        drawYear = inst.drawYear;

                    if (drawMonth < 0) {
                        drawMonth += 12;
                        drawYear--;
                    }
                    if (maxDate) {
                        maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                            maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
                        maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                        while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                            drawMonth--;
                            if (drawMonth < 0) {
                                drawMonth = 11;
                                drawYear--;
                            }
                        }
                    }
                    inst.drawMonth = drawMonth;
                    inst.drawYear = drawYear;

                    prevText = this._get(inst, "prevText");
                    prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
                        this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
                        this._getFormatConfig(inst)));

                    prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
                        "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                        " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
                        (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

                    nextText = this._get(inst, "nextText");
                    nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
                        this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
                        this._getFormatConfig(inst)));

                    next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
                        "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                        " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
                        (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

                    currentText = this._get(inst, "currentText");
                    gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
                    currentText = (!navigationAsDateFormat ? currentText :
                        this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

                    controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                        this._get(inst, "closeText") + "</button>" : "");

                    buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
                        (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                            ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

                    firstDay = parseInt(this._get(inst, "firstDay"), 10);
                    firstDay = (isNaN(firstDay) ? 0 : firstDay);

                    showWeek = this._get(inst, "showWeek");
                    dayNames = this._get(inst, "dayNames");
                    dayNamesMin = this._get(inst, "dayNamesMin");
                    monthNames = this._get(inst, "monthNames");
                    monthNamesShort = this._get(inst, "monthNamesShort");
                    beforeShowDay = this._get(inst, "beforeShowDay");
                    showOtherMonths = this._get(inst, "showOtherMonths");
                    selectOtherMonths = this._get(inst, "selectOtherMonths");
                    defaultDate = this._getDefaultDate(inst);
                    html = "";
                    dow;
                    for (row = 0; row < numMonths[0]; row++) {
                        group = "";
                        this.maxRows = 4;
                        for (col = 0; col < numMonths[1]; col++) {
                            selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                            cornerClass = " ui-corner-all";
                            calender = "";
                            if (isMultiMonth) {
                                calender += "<div class='ui-datepicker-group";
                                if (numMonths[1] > 1) {
                                    switch (col) {
                                        case 0:
                                            calender += " ui-datepicker-group-first";
                                            cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                            break;
                                        case numMonths[1] - 1:
                                            calender += " ui-datepicker-group-last";
                                            cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                            break;
                                        default:
                                            calender += " ui-datepicker-group-middle";
                                            cornerClass = "";
                                            break;
                                    }
                                }
                                calender += "'>";
                            }
                            calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                                (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
                                (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
                                this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                                    row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                                "</div><table class='ui-datepicker-calendar'><thead>" +
                                "<tr>";
                            thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
                            for (dow = 0; dow < 7; dow++) { // days of the week
                                day = (dow + firstDay) % 7;
                                thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
                                    "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                            }
                            calender += thead + "</tr></thead><tbody>";
                            daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                            if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                                inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                            }
                            leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                            curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                            numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                            this.maxRows = numRows;
                            printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                            for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                                calender += "<tr>";
                                tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                                    this._get(inst, "calculateWeek")(printDate) + "</td>");
                                for (dow = 0; dow < 7; dow++) { // create date picker days
                                    daySettings = (beforeShowDay ?
                                        beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                                    otherMonth = (printDate.getMonth() !== drawMonth);
                                    unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                                        (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                                    tbody += "<td class='" +
                                        ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                                        (otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                                        ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                                            (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
                                            // or defaultDate is current printedDate and defaultDate is selectedDate
                                            " " + this._dayOverClass : "") + // highlight selected day
                                        (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + // highlight unselectable days
                                        (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                                            (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                                            (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                                        ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                                        (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                                        (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                            (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                                                (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                                                (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                                                (otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                                                "' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
                                    printDate.setDate(printDate.getDate() + 1);
                                    printDate = this._daylightSavingAdjust(printDate);
                                }
                                calender += tbody + "</tr>";
                            }
                            drawMonth++;
                            if (drawMonth > 11) {
                                drawMonth = 0;
                                drawYear++;
                            }
                            calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                                ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                            group += calender;
                        }
                        html += group;
                    }
                    html += buttonPanel;
                    inst._keyEvent = false;
                    return html;
                },

                /* Generate the month and year header. */
                _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
                    secondary, monthNames, monthNamesShort) {

                    var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                        changeMonth = this._get(inst, "changeMonth"),
                        changeYear = this._get(inst, "changeYear"),
                        showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                        html = "<div class='ui-datepicker-title'>",
                        monthHtml = "";

                    // month selection
                    if (secondary || !changeMonth) {
                        monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
                    } else {
                        inMinYear = (minDate && minDate.getFullYear() === drawYear);
                        inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
                        monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                        for (month = 0; month < 12; month++) {
                            if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                                monthHtml += "<option value='" + month + "'" +
                                    (month === drawMonth ? " selected='selected'" : "") +
                                    ">" + monthNamesShort[month] + "</option>";
                            }
                        }
                        monthHtml += "</select>";
                    }

                    if (!showMonthAfterYear) {
                        html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
                    }

                    // year selection
                    if (!inst.yearshtml) {
                        inst.yearshtml = "";
                        if (secondary || !changeYear) {
                            html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                        } else {
                            // determine range of years to display
                            years = this._get(inst, "yearRange").split(":");
                            thisYear = new Date().getFullYear();
                            determineYear = function(value) {
                                var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                                    (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
                                        parseInt(value, 10)));
                                return (isNaN(year) ? thisYear : year);
                            };
                            year = determineYear(years[0]);
                            endYear = Math.max(year, determineYear(years[1] || ""));
                            year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                            endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                            inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                            for (; year <= endYear; year++) {
                                inst.yearshtml += "<option value='" + year + "'" +
                                    (year === drawYear ? " selected='selected'" : "") +
                                    ">" + year + "</option>";
                            }
                            inst.yearshtml += "</select>";

                            html += inst.yearshtml;
                            inst.yearshtml = null;
                        }
                    }

                    html += this._get(inst, "yearSuffix");
                    if (showMonthAfterYear) {
                        html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
                    }
                    html += "</div>"; // Close datepicker_header
                    return html;
                },

                /* Adjust one of the date sub-fields. */
                _adjustInstDate: function(inst, offset, period) {
                    var year = inst.drawYear + (period === "Y" ? offset : 0),
                        month = inst.drawMonth + (period === "M" ? offset : 0),
                        day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
                        date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

                    inst.selectedDay = date.getDate();
                    inst.drawMonth = inst.selectedMonth = date.getMonth();
                    inst.drawYear = inst.selectedYear = date.getFullYear();
                    if (period === "M" || period === "Y") {
                        this._notifyChange(inst);
                    }
                },

                /* Ensure a date is within any min/max bounds. */
                _restrictMinMax: function(inst, date) {
                    var minDate = this._getMinMaxDate(inst, "min"),
                        maxDate = this._getMinMaxDate(inst, "max"),
                        newDate = (minDate && date < minDate ? minDate : date);
                    return (maxDate && newDate > maxDate ? maxDate : newDate);
                },

                /* Notify change of month/year. */
                _notifyChange: function(inst) {
                    var onChange = this._get(inst, "onChangeMonthYear");
                    if (onChange) {
                        onChange.apply((inst.input ? inst.input[0] : null), [inst.selectedYear, inst.selectedMonth + 1, inst]);
                    }
                },

                /* Determine the number of months to show. */
                _getNumberOfMonths: function(inst) {
                    var numMonths = this._get(inst, "numberOfMonths");
                    return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
                },

                /* Determine the current maximum date - ensure no time components are set. */
                _getMinMaxDate: function(inst, minMax) {
                    return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
                },

                /* Find the number of days in a given month. */
                _getDaysInMonth: function(year, month) {
                    return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
                },

                /* Find the day of the week of the first of a month. */
                _getFirstDayOfMonth: function(year, month) {
                    return new Date(year, month, 1).getDay();
                },

                /* Determines if we should allow a "next/prev" month display change. */
                _canAdjustMonth: function(inst, offset, curYear, curMonth) {
                    var numMonths = this._getNumberOfMonths(inst),
                        date = this._daylightSavingAdjust(new Date(curYear,
                            curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

                    if (offset < 0) {
                        date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
                    }
                    return this._isInRange(inst, date);
                },

                /* Is the given date in the accepted range? */
                _isInRange: function(inst, date) {
                    var yearSplit, currentYear,
                        minDate = this._getMinMaxDate(inst, "min"),
                        maxDate = this._getMinMaxDate(inst, "max"),
                        minYear = null,
                        maxYear = null,
                        years = this._get(inst, "yearRange");
                    if (years) {
                        yearSplit = years.split(":");
                        currentYear = new Date().getFullYear();
                        minYear = parseInt(yearSplit[0], 10);
                        maxYear = parseInt(yearSplit[1], 10);
                        if (yearSplit[0].match(/[+\-].*/)) {
                            minYear += currentYear;
                        }
                        if (yearSplit[1].match(/[+\-].*/)) {
                            maxYear += currentYear;
                        }
                    }

                    return ((!minDate || date.getTime() >= minDate.getTime()) &&
                        (!maxDate || date.getTime() <= maxDate.getTime()) &&
                        (!minYear || date.getFullYear() >= minYear) &&
                        (!maxYear || date.getFullYear() <= maxYear));
                },

                /* Provide the configuration settings for formatting/parsing. */
                _getFormatConfig: function(inst) {
                    var shortYearCutoff = this._get(inst, "shortYearCutoff");
                    shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
                        new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
                    return {
                        shortYearCutoff: shortYearCutoff,
                        dayNamesShort: this._get(inst, "dayNamesShort"),
                        dayNames: this._get(inst, "dayNames"),
                        monthNamesShort: this._get(inst, "monthNamesShort"),
                        monthNames: this._get(inst, "monthNames")
                    };
                },

                /* Format the given date for display. */
                _formatDate: function(inst, day, month, year) {
                    if (!day) {
                        inst.currentDay = inst.selectedDay;
                        inst.currentMonth = inst.selectedMonth;
                        inst.currentYear = inst.selectedYear;
                    }
                    var date = (day ? (typeof day === "object" ? day :
                            this._daylightSavingAdjust(new Date(year, month, day))) :
                        this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
                    return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
                }
            });

            /*
             * Bind hover events for datepicker elements.
             * Done via delegate so the binding only occurs once in the lifetime of the parent div.
             * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
             */
            function bindHover(dpDiv) {
                var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
                return dpDiv.delegate(selector, "mouseout", function() {
                        $(this).removeClass("ui-state-hover");
                        if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                            $(this).removeClass("ui-datepicker-prev-hover");
                        }
                        if (this.className.indexOf("ui-datepicker-next") !== -1) {
                            $(this).removeClass("ui-datepicker-next-hover");
                        }
                    })
                    .delegate(selector, "mouseover", function() {
                        if (!$.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
                            $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                            $(this).addClass("ui-state-hover");
                            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                                $(this).addClass("ui-datepicker-prev-hover");
                            }
                            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                                $(this).addClass("ui-datepicker-next-hover");
                            }
                        }
                    });
            }

            /* jQuery extend now ignores nulls! */
            function extendRemove(target, props) {
                $.extend(target, props);
                for (var name in props) {
                    if (props[name] == null) {
                        target[name] = props[name];
                    }
                }
                return target;
            }

            /* Invoke the datepicker functionality.
               @param  options  string - a command, optionally followed by additional parameters or
                                Object - settings for attaching new datepicker functionality
               @return  jQuery object */
            $.fn.datepicker = function(options) {

                /* Verify an empty collection wasn't passed - Fixes #6976 */
                if (!this.length) {
                    return this;
                }

                /* Initialise the date picker. */
                if (!$.datepicker.initialized) {
                    $(document).mousedown($.datepicker._checkExternalClick);
                    $.datepicker.initialized = true;
                }

                /* Append datepicker main container to body if not exist. */
                if ($("#" + $.datepicker._mainDivId).length === 0) {
                    $("body").append($.datepicker.dpDiv);
                }

                var otherArgs = Array.prototype.slice.call(arguments, 1);
                if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
                    return $.datepicker["_" + options + "Datepicker"].
                    apply($.datepicker, [this[0]].concat(otherArgs));
                }
                if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
                    return $.datepicker["_" + options + "Datepicker"].
                    apply($.datepicker, [this[0]].concat(otherArgs));
                }
                return this.each(function() {
                    typeof options === "string" ?
                        $.datepicker["_" + options + "Datepicker"].
                    apply($.datepicker, [this].concat(otherArgs)):
                        $.datepicker._attachDatepicker(this, options);
                });
            };

            $.datepicker = new Datepicker(); // singleton instance
            $.datepicker.initialized = false;
            $.datepicker.uuid = new Date().getTime();
            $.datepicker.version = "1.10.3";

        })(jQuery);

        (function($, undefined) {

            var sizeRelatedOptions = {
                    buttons: true,
                    height: true,
                    maxHeight: true,
                    maxWidth: true,
                    minHeight: true,
                    minWidth: true,
                    width: true
                },
                resizableRelatedOptions = {
                    maxHeight: true,
                    maxWidth: true,
                    minHeight: true,
                    minWidth: true
                };

            $.widget("ui.dialog", {
                version: "1.10.3",
                options: {
                    appendTo: "body",
                    autoOpen: true,
                    buttons: [],
                    closeOnEscape: true,
                    closeText: "close",
                    dialogClass: "",
                    draggable: true,
                    hide: null,
                    height: "auto",
                    maxHeight: null,
                    maxWidth: null,
                    minHeight: 150,
                    minWidth: 150,
                    modal: false,
                    position: {
                        my: "center",
                        at: "center",
                        of: window,
                        collision: "fit",
                        // Ensure the titlebar is always visible
                        using: function(pos) {
                            var topOffset = $(this).css(pos).offset().top;
                            if (topOffset < 0) {
                                $(this).css("top", pos.top - topOffset);
                            }
                        }
                    },
                    resizable: true,
                    show: null,
                    title: null,
                    width: 300,

                    // callbacks
                    beforeClose: null,
                    close: null,
                    drag: null,
                    dragStart: null,
                    dragStop: null,
                    focus: null,
                    open: null,
                    resize: null,
                    resizeStart: null,
                    resizeStop: null
                },

                _create: function() {
                    this.originalCss = {
                        display: this.element[0].style.display,
                        width: this.element[0].style.width,
                        minHeight: this.element[0].style.minHeight,
                        maxHeight: this.element[0].style.maxHeight,
                        height: this.element[0].style.height
                    };
                    this.originalPosition = {
                        parent: this.element.parent(),
                        index: this.element.parent().children().index(this.element)
                    };
                    this.originalTitle = this.element.attr("title");
                    this.options.title = this.options.title || this.originalTitle;

                    this._createWrapper();

                    this.element
                        .show()
                        .removeAttr("title")
                        .addClass("ui-dialog-content ui-widget-content")
                        .appendTo(this.uiDialog);

                    this._createTitlebar();
                    this._createButtonPane();

                    if (this.options.draggable && $.fn.draggable) {
                        this._makeDraggable();
                    }
                    if (this.options.resizable && $.fn.resizable) {
                        this._makeResizable();
                    }

                    this._isOpen = false;
                },

                _init: function() {
                    if (this.options.autoOpen) {
                        this.open();
                    }
                },

                _appendTo: function() {
                    var element = this.options.appendTo;
                    if (element && (element.jquery || element.nodeType)) {
                        return $(element);
                    }
                    return this.document.find(element || "body").eq(0);
                },

                _destroy: function() {
                    var next,
                        originalPosition = this.originalPosition;

                    this._destroyOverlay();

                    this.element
                        .removeUniqueId()
                        .removeClass("ui-dialog-content ui-widget-content")
                        .css(this.originalCss)
                        // Without detaching first, the following becomes really slow
                        .detach();

                    this.uiDialog.stop(true, true).remove();

                    if (this.originalTitle) {
                        this.element.attr("title", this.originalTitle);
                    }

                    next = originalPosition.parent.children().eq(originalPosition.index);
                    // Don't try to place the dialog next to itself (#8613)
                    if (next.length && next[0] !== this.element[0]) {
                        next.before(this.element);
                    } else {
                        originalPosition.parent.append(this.element);
                    }
                },

                widget: function() {
                    return this.uiDialog;
                },

                disable: $.noop,
                enable: $.noop,

                close: function(event) {
                    var that = this;

                    if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                        return;
                    }

                    this._isOpen = false;
                    this._destroyOverlay();

                    if (!this.opener.filter(":focusable").focus().length) {
                        // Hiding a focused element doesn't trigger blur in WebKit
                        // so in case we have nothing to focus on, explicitly blur the active element
                        // https://bugs.webkit.org/show_bug.cgi?id=47182
                        $(this.document[0].activeElement).blur();
                    }

                    this._hide(this.uiDialog, this.options.hide, function() {
                        that._trigger("close", event);
                    });
                },

                isOpen: function() {
                    return this._isOpen;
                },

                moveToTop: function() {
                    this._moveToTop();
                },

                _moveToTop: function(event, silent) {
                    var moved = !!this.uiDialog.nextAll(":visible").insertBefore(this.uiDialog).length;
                    if (moved && !silent) {
                        this._trigger("focus", event);
                    }
                    return moved;
                },

                open: function() {
                    var that = this;
                    if (this._isOpen) {
                        if (this._moveToTop()) {
                            this._focusTabbable();
                        }
                        return;
                    }

                    this._isOpen = true;
                    this.opener = $(this.document[0].activeElement);

                    this._size();
                    this._position();
                    this._createOverlay();
                    this._moveToTop(null, true);
                    this._show(this.uiDialog, this.options.show, function() {
                        that._focusTabbable();
                        that._trigger("focus");
                    });

                    this._trigger("open");
                },

                _focusTabbable: function() {
                    // Set focus to the first match:
                    // 1. First element inside the dialog matching [autofocus]
                    // 2. Tabbable element inside the content element
                    // 3. Tabbable element inside the buttonpane
                    // 4. The close button
                    // 5. The dialog itself
                    var hasFocus = this.element.find("[autofocus]");
                    if (!hasFocus.length) {
                        hasFocus = this.element.find(":tabbable");
                    }
                    if (!hasFocus.length) {
                        hasFocus = this.uiDialogButtonPane.find(":tabbable");
                    }
                    if (!hasFocus.length) {
                        hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
                    }
                    if (!hasFocus.length) {
                        hasFocus = this.uiDialog;
                    }
                    hasFocus.eq(0).focus();
                },

                _keepFocus: function(event) {
                    function checkFocus() {
                        var activeElement = this.document[0].activeElement,
                            isActive = this.uiDialog[0] === activeElement ||
                            $.contains(this.uiDialog[0], activeElement);
                        if (!isActive) {
                            this._focusTabbable();
                        }
                    }
                    event.preventDefault();
                    checkFocus.call(this);
                    // support: IE
                    // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
                    // so we check again later
                    this._delay(checkFocus);
                },

                _createWrapper: function() {
                    this.uiDialog = $("<div>")
                        .addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
                            this.options.dialogClass)
                        .hide()
                        .attr({
                            // Setting tabIndex makes the div focusable
                            tabIndex: -1,
                            role: "dialog"
                        })
                        .appendTo(this._appendTo());

                    this._on(this.uiDialog, {
                        keydown: function(event) {
                            if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                                event.keyCode === $.ui.keyCode.ESCAPE) {
                                event.preventDefault();
                                this.close(event);
                                return;
                            }

                            // prevent tabbing out of dialogs
                            if (event.keyCode !== $.ui.keyCode.TAB) {
                                return;
                            }
                            var tabbables = this.uiDialog.find(":tabbable"),
                                first = tabbables.filter(":first"),
                                last = tabbables.filter(":last");

                            if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                                first.focus(1);
                                event.preventDefault();
                            } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                                last.focus(1);
                                event.preventDefault();
                            }
                        },
                        mousedown: function(event) {
                            if (this._moveToTop(event)) {
                                this._focusTabbable();
                            }
                        }
                    });

                    // We assume that any existing aria-describedby attribute means
                    // that the dialog content is marked up properly
                    // otherwise we brute force the content as the description
                    if (!this.element.find("[aria-describedby]").length) {
                        this.uiDialog.attr({
                            "aria-describedby": this.element.uniqueId().attr("id")
                        });
                    }
                },

                _createTitlebar: function() {
                    var uiDialogTitle;

                    this.uiDialogTitlebar = $("<div>")
                        .addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix")
                        .prependTo(this.uiDialog);
                    this._on(this.uiDialogTitlebar, {
                        mousedown: function(event) {
                            // Don't prevent click on close button (#8838)
                            // Focusing a dialog that is partially scrolled out of view
                            // causes the browser to scroll it into view, preventing the click event
                            if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                                // Dialog isn't getting focus when dragging (#8063)
                                this.uiDialog.focus();
                            }
                        }
                    });

                    this.uiDialogTitlebarClose = $("<button></button>")
                        .button({
                            label: this.options.closeText,
                            icons: {
                                primary: "ui-icon-closethick"
                            },
                            text: false
                        })
                        .addClass("ui-dialog-titlebar-close")
                        .appendTo(this.uiDialogTitlebar);
                    this._on(this.uiDialogTitlebarClose, {
                        click: function(event) {
                            event.preventDefault();
                            this.close(event);
                        }
                    });

                    uiDialogTitle = $("<span>")
                        .uniqueId()
                        .addClass("ui-dialog-title")
                        .prependTo(this.uiDialogTitlebar);
                    this._title(uiDialogTitle);

                    this.uiDialog.attr({
                        "aria-labelledby": uiDialogTitle.attr("id")
                    });
                },

                _title: function(title) {
                    if (!this.options.title) {
                        title.html("&#160;");
                    }
                    title.text(this.options.title);
                },

                _createButtonPane: function() {
                    this.uiDialogButtonPane = $("<div>")
                        .addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");

                    this.uiButtonSet = $("<div>")
                        .addClass("ui-dialog-buttonset")
                        .appendTo(this.uiDialogButtonPane);

                    this._createButtons();
                },

                _createButtons: function() {
                    var that = this,
                        buttons = this.options.buttons;

                    // if we already have a button pane, remove it
                    this.uiDialogButtonPane.remove();
                    this.uiButtonSet.empty();

                    if ($.isEmptyObject(buttons) || ($.isArray(buttons) && !buttons.length)) {
                        this.uiDialog.removeClass("ui-dialog-buttons");
                        return;
                    }

                    $.each(buttons, function(name, props) {
                        var click, buttonOptions;
                        props = $.isFunction(props) ? {
                                click: props,
                                text: name
                            } :
                            props;
                        // Default to a non-submitting button
                        props = $.extend({
                            type: "button"
                        }, props);
                        // Change the context for the click callback to be the main element
                        click = props.click;
                        props.click = function() {
                            click.apply(that.element[0], arguments);
                        };
                        buttonOptions = {
                            icons: props.icons,
                            text: props.showText
                        };
                        delete props.icons;
                        delete props.showText;
                        $("<button></button>", props)
                            .button(buttonOptions)
                            .appendTo(that.uiButtonSet);
                    });
                    this.uiDialog.addClass("ui-dialog-buttons");
                    this.uiDialogButtonPane.appendTo(this.uiDialog);
                },

                _makeDraggable: function() {
                    var that = this,
                        options = this.options;

                    function filteredUi(ui) {
                        return {
                            position: ui.position,
                            offset: ui.offset
                        };
                    }

                    this.uiDialog.draggable({
                        cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                        handle: ".ui-dialog-titlebar",
                        containment: "document",
                        start: function(event, ui) {
                            $(this).addClass("ui-dialog-dragging");
                            that._blockFrames();
                            that._trigger("dragStart", event, filteredUi(ui));
                        },
                        drag: function(event, ui) {
                            that._trigger("drag", event, filteredUi(ui));
                        },
                        stop: function(event, ui) {
                            options.position = [
                                ui.position.left - that.document.scrollLeft(),
                                ui.position.top - that.document.scrollTop()
                            ];
                            $(this).removeClass("ui-dialog-dragging");
                            that._unblockFrames();
                            that._trigger("dragStop", event, filteredUi(ui));
                        }
                    });
                },

                _makeResizable: function() {
                    var that = this,
                        options = this.options,
                        handles = options.resizable,
                        // .ui-resizable has position: relative defined in the stylesheet
                        // but dialogs have to use absolute or fixed positioning
                        position = this.uiDialog.css("position"),
                        resizeHandles = typeof handles === "string" ?
                        handles :
                        "n,e,s,w,se,sw,ne,nw";

                    function filteredUi(ui) {
                        return {
                            originalPosition: ui.originalPosition,
                            originalSize: ui.originalSize,
                            position: ui.position,
                            size: ui.size
                        };
                    }

                    this.uiDialog.resizable({
                            cancel: ".ui-dialog-content",
                            containment: "document",
                            alsoResize: this.element,
                            maxWidth: options.maxWidth,
                            maxHeight: options.maxHeight,
                            minWidth: options.minWidth,
                            minHeight: this._minHeight(),
                            handles: resizeHandles,
                            start: function(event, ui) {
                                $(this).addClass("ui-dialog-resizing");
                                that._blockFrames();
                                that._trigger("resizeStart", event, filteredUi(ui));
                            },
                            resize: function(event, ui) {
                                that._trigger("resize", event, filteredUi(ui));
                            },
                            stop: function(event, ui) {
                                options.height = $(this).height();
                                options.width = $(this).width();
                                $(this).removeClass("ui-dialog-resizing");
                                that._unblockFrames();
                                that._trigger("resizeStop", event, filteredUi(ui));
                            }
                        })
                        .css("position", position);
                },

                _minHeight: function() {
                    var options = this.options;

                    return options.height === "auto" ?
                        options.minHeight :
                        Math.min(options.minHeight, options.height);
                },

                _position: function() {
                    // Need to show the dialog to get the actual offset in the position plugin
                    var isVisible = this.uiDialog.is(":visible");
                    if (!isVisible) {
                        this.uiDialog.show();
                    }
                    this.uiDialog.position(this.options.position);
                    if (!isVisible) {
                        this.uiDialog.hide();
                    }
                },

                _setOptions: function(options) {
                    var that = this,
                        resize = false,
                        resizableOptions = {};

                    $.each(options, function(key, value) {
                        that._setOption(key, value);

                        if (key in sizeRelatedOptions) {
                            resize = true;
                        }
                        if (key in resizableRelatedOptions) {
                            resizableOptions[key] = value;
                        }
                    });

                    if (resize) {
                        this._size();
                        this._position();
                    }
                    if (this.uiDialog.is(":data(ui-resizable)")) {
                        this.uiDialog.resizable("option", resizableOptions);
                    }
                },

                _setOption: function(key, value) {
                    /*jshint maxcomplexity:15*/
                    var isDraggable, isResizable,
                        uiDialog = this.uiDialog;

                    if (key === "dialogClass") {
                        uiDialog
                            .removeClass(this.options.dialogClass)
                            .addClass(value);
                    }

                    if (key === "disabled") {
                        return;
                    }

                    this._super(key, value);

                    if (key === "appendTo") {
                        this.uiDialog.appendTo(this._appendTo());
                    }

                    if (key === "buttons") {
                        this._createButtons();
                    }

                    if (key === "closeText") {
                        this.uiDialogTitlebarClose.button({
                            // Ensure that we always pass a string
                            label: "" + value
                        });
                    }

                    if (key === "draggable") {
                        isDraggable = uiDialog.is(":data(ui-draggable)");
                        if (isDraggable && !value) {
                            uiDialog.draggable("destroy");
                        }

                        if (!isDraggable && value) {
                            this._makeDraggable();
                        }
                    }

                    if (key === "position") {
                        this._position();
                    }

                    if (key === "resizable") {
                        // currently resizable, becoming non-resizable
                        isResizable = uiDialog.is(":data(ui-resizable)");
                        if (isResizable && !value) {
                            uiDialog.resizable("destroy");
                        }

                        // currently resizable, changing handles
                        if (isResizable && typeof value === "string") {
                            uiDialog.resizable("option", "handles", value);
                        }

                        // currently non-resizable, becoming resizable
                        if (!isResizable && value !== false) {
                            this._makeResizable();
                        }
                    }

                    if (key === "title") {
                        this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
                    }
                },

                _size: function() {
                    // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
                    // divs will both have width and height set, so we need to reset them
                    var nonContentHeight, minContentHeight, maxContentHeight,
                        options = this.options;

                    // Reset content sizing
                    this.element.show().css({
                        width: "auto",
                        minHeight: 0,
                        maxHeight: "none",
                        height: 0
                    });

                    if (options.minWidth > options.width) {
                        options.width = options.minWidth;
                    }

                    // reset wrapper sizing
                    // determine the height of all the non-content elements
                    nonContentHeight = this.uiDialog.css({
                            height: "auto",
                            width: options.width
                        })
                        .outerHeight();
                    minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
                    maxContentHeight = typeof options.maxHeight === "number" ?
                        Math.max(0, options.maxHeight - nonContentHeight) :
                        "none";

                    if (options.height === "auto") {
                        this.element.css({
                            minHeight: minContentHeight,
                            maxHeight: maxContentHeight,
                            height: "auto"
                        });
                    } else {
                        this.element.height(Math.max(0, options.height - nonContentHeight));
                    }

                    if (this.uiDialog.is(":data(ui-resizable)")) {
                        this.uiDialog.resizable("option", "minHeight", this._minHeight());
                    }
                },

                _blockFrames: function() {
                    this.iframeBlocks = this.document.find("iframe").map(function() {
                        var iframe = $(this);

                        return $("<div>")
                            .css({
                                position: "absolute",
                                width: iframe.outerWidth(),
                                height: iframe.outerHeight()
                            })
                            .appendTo(iframe.parent())
                            .offset(iframe.offset())[0];
                    });
                },

                _unblockFrames: function() {
                    if (this.iframeBlocks) {
                        this.iframeBlocks.remove();
                        delete this.iframeBlocks;
                    }
                },

                _allowInteraction: function(event) {
                    if ($(event.target).closest(".ui-dialog").length) {
                        return true;
                    }

                    // TODO: Remove hack when datepicker implements
                    // the .ui-front logic (#8989)
                    return !!$(event.target).closest(".ui-datepicker").length;
                },

                _createOverlay: function() {
                    if (!this.options.modal) {
                        return;
                    }

                    var that = this,
                        widgetFullName = this.widgetFullName;
                    if (!$.ui.dialog.overlayInstances) {
                        // Prevent use of anchors and inputs.
                        // We use a delay in case the overlay is created from an
                        // event that we're going to be cancelling. (#2804)
                        this._delay(function() {
                            // Handle .dialog().dialog("close") (#4065)
                            if ($.ui.dialog.overlayInstances) {
                                this.document.bind("focusin.dialog", function(event) {
                                    if (!that._allowInteraction(event)) {
                                        event.preventDefault();
                                        $(".ui-dialog:visible:last .ui-dialog-content")
                                            .data(widgetFullName)._focusTabbable();
                                    }
                                });
                            }
                        });
                    }

                    this.overlay = $("<div>")
                        .addClass("ui-widget-overlay ui-front")
                        .appendTo(this._appendTo());
                    this._on(this.overlay, {
                        mousedown: "_keepFocus"
                    });
                    $.ui.dialog.overlayInstances++;
                },

                _destroyOverlay: function() {
                    if (!this.options.modal) {
                        return;
                    }

                    if (this.overlay) {
                        $.ui.dialog.overlayInstances--;

                        if (!$.ui.dialog.overlayInstances) {
                            this.document.unbind("focusin.dialog");
                        }
                        this.overlay.remove();
                        this.overlay = null;
                    }
                }
            });

            $.ui.dialog.overlayInstances = 0;

            // DEPRECATED
            if ($.uiBackCompat !== false) {
                // position option with array notation
                // just override with old implementation
                $.widget("ui.dialog", $.ui.dialog, {
                    _position: function() {
                        var position = this.options.position,
                            myAt = [],
                            offset = [0, 0],
                            isVisible;

                        if (position) {
                            if (typeof position === "string" || (typeof position === "object" && "0" in position)) {
                                myAt = position.split ? position.split(" ") : [position[0], position[1]];
                                if (myAt.length === 1) {
                                    myAt[1] = myAt[0];
                                }

                                $.each(["left", "top"], function(i, offsetPosition) {
                                    if (+myAt[i] === myAt[i]) {
                                        offset[i] = myAt[i];
                                        myAt[i] = offsetPosition;
                                    }
                                });

                                position = {
                                    my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
                                        myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
                                    at: myAt.join(" ")
                                };
                            }

                            position = $.extend({}, $.ui.dialog.prototype.options.position, position);
                        } else {
                            position = $.ui.dialog.prototype.options.position;
                        }

                        // need to show the dialog to get the actual offset in the position plugin
                        isVisible = this.uiDialog.is(":visible");
                        if (!isVisible) {
                            this.uiDialog.show();
                        }
                        this.uiDialog.position(position);
                        if (!isVisible) {
                            this.uiDialog.hide();
                        }
                    }
                });
            }

        }(jQuery));

        (function($, undefined) {

            var rvertical = /up|down|vertical/,
                rpositivemotion = /up|left|vertical|horizontal/;

            $.effects.effect.blind = function(o, done) {
                // Create element
                var el = $(this),
                    props = ["position", "top", "bottom", "left", "right", "height", "width"],
                    mode = $.effects.setMode(el, o.mode || "hide"),
                    direction = o.direction || "up",
                    vertical = rvertical.test(direction),
                    ref = vertical ? "height" : "width",
                    ref2 = vertical ? "top" : "left",
                    motion = rpositivemotion.test(direction),
                    animation = {},
                    show = mode === "show",
                    wrapper, distance, margin;

                // if already wrapped, the wrapper's properties are my property. #6245
                if (el.parent().is(".ui-effects-wrapper")) {
                    $.effects.save(el.parent(), props);
                } else {
                    $.effects.save(el, props);
                }
                el.show();
                wrapper = $.effects.createWrapper(el).css({
                    overflow: "hidden"
                });

                distance = wrapper[ref]();
                margin = parseFloat(wrapper.css(ref2)) || 0;

                animation[ref] = show ? distance : 0;
                if (!motion) {
                    el
                        .css(vertical ? "bottom" : "right", 0)
                        .css(vertical ? "top" : "left", "auto")
                        .css({
                            position: "absolute"
                        });

                    animation[ref2] = show ? margin : distance + margin;
                }

                // start at 0 if we are showing
                if (show) {
                    wrapper.css(ref, 0);
                    if (!motion) {
                        wrapper.css(ref2, margin + distance);
                    }
                }

                // Animate
                wrapper.animate(animation, {
                    duration: o.duration,
                    easing: o.easing,
                    queue: false,
                    complete: function() {
                        if (mode === "hide") {
                            el.hide();
                        }
                        $.effects.restore(el, props);
                        $.effects.removeWrapper(el);
                        done();
                    }
                });

            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.bounce = function(o, done) {
                var el = $(this),
                    props = ["position", "top", "bottom", "left", "right", "height", "width"],

                    // defaults:
                    mode = $.effects.setMode(el, o.mode || "effect"),
                    hide = mode === "hide",
                    show = mode === "show",
                    direction = o.direction || "up",
                    distance = o.distance,
                    times = o.times || 5,

                    // number of internal animations
                    anims = times * 2 + (show || hide ? 1 : 0),
                    speed = o.duration / anims,
                    easing = o.easing,

                    // utility:
                    ref = (direction === "up" || direction === "down") ? "top" : "left",
                    motion = (direction === "up" || direction === "left"),
                    i,
                    upAnim,
                    downAnim,

                    // we will need to re-assemble the queue to stack our animations in place
                    queue = el.queue(),
                    queuelen = queue.length;

                // Avoid touching opacity to prevent clearType and PNG issues in IE
                if (show || hide) {
                    props.push("opacity");
                }

                $.effects.save(el, props);
                el.show();
                $.effects.createWrapper(el); // Create Wrapper

                // default distance for the BIGGEST bounce is the outer Distance / 3
                if (!distance) {
                    distance = el[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
                }

                if (show) {
                    downAnim = {
                        opacity: 1
                    };
                    downAnim[ref] = 0;

                    // if we are showing, force opacity 0 and set the initial position
                    // then do the "first" animation
                    el.css("opacity", 0)
                        .css(ref, motion ? -distance * 2 : distance * 2)
                        .animate(downAnim, speed, easing);
                }

                // start at the smallest distance if we are hiding
                if (hide) {
                    distance = distance / Math.pow(2, times - 1);
                }

                downAnim = {};
                downAnim[ref] = 0;
                // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
                for (i = 0; i < times; i++) {
                    upAnim = {};
                    upAnim[ref] = (motion ? "-=" : "+=") + distance;

                    el.animate(upAnim, speed, easing)
                        .animate(downAnim, speed, easing);

                    distance = hide ? distance * 2 : distance / 2;
                }

                // Last Bounce when Hiding
                if (hide) {
                    upAnim = {
                        opacity: 0
                    };
                    upAnim[ref] = (motion ? "-=" : "+=") + distance;

                    el.animate(upAnim, speed, easing);
                }

                el.queue(function() {
                    if (hide) {
                        el.hide();
                    }
                    $.effects.restore(el, props);
                    $.effects.removeWrapper(el);
                    done();
                });

                // inject all the animations we just queued to be first in line (after "inprogress")
                if (queuelen > 1) {
                    queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
                }
                el.dequeue();

            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.clip = function(o, done) {
                // Create element
                var el = $(this),
                    props = ["position", "top", "bottom", "left", "right", "height", "width"],
                    mode = $.effects.setMode(el, o.mode || "hide"),
                    show = mode === "show",
                    direction = o.direction || "vertical",
                    vert = direction === "vertical",
                    size = vert ? "height" : "width",
                    position = vert ? "top" : "left",
                    animation = {},
                    wrapper, animate, distance;

                // Save & Show
                $.effects.save(el, props);
                el.show();

                // Create Wrapper
                wrapper = $.effects.createWrapper(el).css({
                    overflow: "hidden"
                });
                animate = (el[0].tagName === "IMG") ? wrapper : el;
                distance = animate[size]();

                // Shift
                if (show) {
                    animate.css(size, 0);
                    animate.css(position, distance / 2);
                }

                // Create Animation Object:
                animation[size] = show ? distance : 0;
                animation[position] = show ? 0 : distance / 2;

                // Animate
                animate.animate(animation, {
                    queue: false,
                    duration: o.duration,
                    easing: o.easing,
                    complete: function() {
                        if (!show) {
                            el.hide();
                        }
                        $.effects.restore(el, props);
                        $.effects.removeWrapper(el);
                        done();
                    }
                });

            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.drop = function(o, done) {

                var el = $(this),
                    props = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"],
                    mode = $.effects.setMode(el, o.mode || "hide"),
                    show = mode === "show",
                    direction = o.direction || "left",
                    ref = (direction === "up" || direction === "down") ? "top" : "left",
                    motion = (direction === "up" || direction === "left") ? "pos" : "neg",
                    animation = {
                        opacity: show ? 1 : 0
                    },
                    distance;

                // Adjust
                $.effects.save(el, props);
                el.show();
                $.effects.createWrapper(el);

                distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;

                if (show) {
                    el
                        .css("opacity", 0)
                        .css(ref, motion === "pos" ? -distance : distance);
                }

                // Animation
                animation[ref] = (show ?
                        (motion === "pos" ? "+=" : "-=") :
                        (motion === "pos" ? "-=" : "+=")) +
                    distance;

                // Animate
                el.animate(animation, {
                    queue: false,
                    duration: o.duration,
                    easing: o.easing,
                    complete: function() {
                        if (mode === "hide") {
                            el.hide();
                        }
                        $.effects.restore(el, props);
                        $.effects.removeWrapper(el);
                        done();
                    }
                });
            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.explode = function(o, done) {

                var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,
                    cells = rows,
                    el = $(this),
                    mode = $.effects.setMode(el, o.mode || "hide"),
                    show = mode === "show",

                    // show and then visibility:hidden the element before calculating offset
                    offset = el.show().css("visibility", "hidden").offset(),

                    // width and height of a piece
                    width = Math.ceil(el.outerWidth() / cells),
                    height = Math.ceil(el.outerHeight() / rows),
                    pieces = [],

                    // loop
                    i, j, left, top, mx, my;

                // children animate complete:
                function childComplete() {
                    pieces.push(this);
                    if (pieces.length === rows * cells) {
                        animComplete();
                    }
                }

                // clone the element for each row and cell.
                for (i = 0; i < rows; i++) { // ===>
                    top = offset.top + i * height;
                    my = i - (rows - 1) / 2;

                    for (j = 0; j < cells; j++) { // |||
                        left = offset.left + j * width;
                        mx = j - (cells - 1) / 2;

                        // Create a clone of the now hidden main element that will be absolute positioned
                        // within a wrapper div off the -left and -top equal to size of our pieces
                        el
                            .clone()
                            .appendTo("body")
                            .wrap("<div></div>")
                            .css({
                                position: "absolute",
                                visibility: "visible",
                                left: -j * width,
                                top: -i * height
                            })

                            // select the wrapper - make it overflow: hidden and absolute positioned based on
                            // where the original was located +left and +top equal to the size of pieces
                            .parent()
                            .addClass("ui-effects-explode")
                            .css({
                                position: "absolute",
                                overflow: "hidden",
                                width: width,
                                height: height,
                                left: left + (show ? mx * width : 0),
                                top: top + (show ? my * height : 0),
                                opacity: show ? 0 : 1
                            }).animate({
                                left: left + (show ? 0 : mx * width),
                                top: top + (show ? 0 : my * height),
                                opacity: show ? 1 : 0
                            }, o.duration || 500, o.easing, childComplete);
                    }
                }

                function animComplete() {
                    el.css({
                        visibility: "visible"
                    });
                    $(pieces).remove();
                    if (!show) {
                        el.hide();
                    }
                    done();
                }
            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.fade = function(o, done) {
                var el = $(this),
                    mode = $.effects.setMode(el, o.mode || "toggle");

                el.animate({
                    opacity: mode
                }, {
                    queue: false,
                    duration: o.duration,
                    easing: o.easing,
                    complete: done
                });
            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.fold = function(o, done) {

                // Create element
                var el = $(this),
                    props = ["position", "top", "bottom", "left", "right", "height", "width"],
                    mode = $.effects.setMode(el, o.mode || "hide"),
                    show = mode === "show",
                    hide = mode === "hide",
                    size = o.size || 15,
                    percent = /([0-9]+)%/.exec(size),
                    horizFirst = !!o.horizFirst,
                    widthFirst = show !== horizFirst,
                    ref = widthFirst ? ["width", "height"] : ["height", "width"],
                    duration = o.duration / 2,
                    wrapper, distance,
                    animation1 = {},
                    animation2 = {};

                $.effects.save(el, props);
                el.show();

                // Create Wrapper
                wrapper = $.effects.createWrapper(el).css({
                    overflow: "hidden"
                });
                distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];

                if (percent) {
                    size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
                }
                if (show) {
                    wrapper.css(horizFirst ? {
                        height: 0,
                        width: size
                    } : {
                        height: size,
                        width: 0
                    });
                }

                // Animation
                animation1[ref[0]] = show ? distance[0] : size;
                animation2[ref[1]] = show ? distance[1] : 0;

                // Animate
                wrapper
                    .animate(animation1, duration, o.easing)
                    .animate(animation2, duration, o.easing, function() {
                        if (hide) {
                            el.hide();
                        }
                        $.effects.restore(el, props);
                        $.effects.removeWrapper(el);
                        done();
                    });

            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.highlight = function(o, done) {
                var elem = $(this),
                    props = ["backgroundImage", "backgroundColor", "opacity"],
                    mode = $.effects.setMode(elem, o.mode || "show"),
                    animation = {
                        backgroundColor: elem.css("backgroundColor")
                    };

                if (mode === "hide") {
                    animation.opacity = 0;
                }

                $.effects.save(elem, props);

                elem
                    .show()
                    .css({
                        backgroundImage: "none",
                        backgroundColor: o.color || "#ffff99"
                    })
                    .animate(animation, {
                        queue: false,
                        duration: o.duration,
                        easing: o.easing,
                        complete: function() {
                            if (mode === "hide") {
                                elem.hide();
                            }
                            $.effects.restore(elem, props);
                            done();
                        }
                    });
            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.pulsate = function(o, done) {
                var elem = $(this),
                    mode = $.effects.setMode(elem, o.mode || "show"),
                    show = mode === "show",
                    hide = mode === "hide",
                    showhide = (show || mode === "hide"),

                    // showing or hiding leaves of the "last" animation
                    anims = ((o.times || 5) * 2) + (showhide ? 1 : 0),
                    duration = o.duration / anims,
                    animateTo = 0,
                    queue = elem.queue(),
                    queuelen = queue.length,
                    i;

                if (show || !elem.is(":visible")) {
                    elem.css("opacity", 0).show();
                    animateTo = 1;
                }

                // anims - 1 opacity "toggles"
                for (i = 1; i < anims; i++) {
                    elem.animate({
                        opacity: animateTo
                    }, duration, o.easing);
                    animateTo = 1 - animateTo;
                }

                elem.animate({
                    opacity: animateTo
                }, duration, o.easing);

                elem.queue(function() {
                    if (hide) {
                        elem.hide();
                    }
                    done();
                });

                // We just queued up "anims" animations, we need to put them next in the queue
                if (queuelen > 1) {
                    queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
                }
                elem.dequeue();
            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.puff = function(o, done) {
                var elem = $(this),
                    mode = $.effects.setMode(elem, o.mode || "hide"),
                    hide = mode === "hide",
                    percent = parseInt(o.percent, 10) || 150,
                    factor = percent / 100,
                    original = {
                        height: elem.height(),
                        width: elem.width(),
                        outerHeight: elem.outerHeight(),
                        outerWidth: elem.outerWidth()
                    };

                $.extend(o, {
                    effect: "scale",
                    queue: false,
                    fade: true,
                    mode: mode,
                    complete: done,
                    percent: hide ? percent : 100,
                    from: hide ?
                        original : {
                            height: original.height * factor,
                            width: original.width * factor,
                            outerHeight: original.outerHeight * factor,
                            outerWidth: original.outerWidth * factor
                        }
                });

                elem.effect(o);
            };

            $.effects.effect.scale = function(o, done) {

                // Create element
                var el = $(this),
                    options = $.extend(true, {}, o),
                    mode = $.effects.setMode(el, o.mode || "effect"),
                    percent = parseInt(o.percent, 10) ||
                    (parseInt(o.percent, 10) === 0 ? 0 : (mode === "hide" ? 0 : 100)),
                    direction = o.direction || "both",
                    origin = o.origin,
                    original = {
                        height: el.height(),
                        width: el.width(),
                        outerHeight: el.outerHeight(),
                        outerWidth: el.outerWidth()
                    },
                    factor = {
                        y: direction !== "horizontal" ? (percent / 100) : 1,
                        x: direction !== "vertical" ? (percent / 100) : 1
                    };

                // We are going to pass this effect to the size effect:
                options.effect = "size";
                options.queue = false;
                options.complete = done;

                // Set default origin and restore for show/hide
                if (mode !== "effect") {
                    options.origin = origin || ["middle", "center"];
                    options.restore = true;
                }

                options.from = o.from || (mode === "show" ? {
                    height: 0,
                    width: 0,
                    outerHeight: 0,
                    outerWidth: 0
                } : original);
                options.to = {
                    height: original.height * factor.y,
                    width: original.width * factor.x,
                    outerHeight: original.outerHeight * factor.y,
                    outerWidth: original.outerWidth * factor.x
                };

                // Fade option to support puff
                if (options.fade) {
                    if (mode === "show") {
                        options.from.opacity = 0;
                        options.to.opacity = 1;
                    }
                    if (mode === "hide") {
                        options.from.opacity = 1;
                        options.to.opacity = 0;
                    }
                }

                // Animate
                el.effect(options);

            };

            $.effects.effect.size = function(o, done) {

                // Create element
                var original, baseline, factor,
                    el = $(this),
                    props0 = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],

                    // Always restore
                    props1 = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],

                    // Copy for children
                    props2 = ["width", "height", "overflow"],
                    cProps = ["fontSize"],
                    vProps = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
                    hProps = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],

                    // Set options
                    mode = $.effects.setMode(el, o.mode || "effect"),
                    restore = o.restore || mode !== "effect",
                    scale = o.scale || "both",
                    origin = o.origin || ["middle", "center"],
                    position = el.css("position"),
                    props = restore ? props0 : props1,
                    zero = {
                        height: 0,
                        width: 0,
                        outerHeight: 0,
                        outerWidth: 0
                    };

                if (mode === "show") {
                    el.show();
                }
                original = {
                    height: el.height(),
                    width: el.width(),
                    outerHeight: el.outerHeight(),
                    outerWidth: el.outerWidth()
                };

                if (o.mode === "toggle" && mode === "show") {
                    el.from = o.to || zero;
                    el.to = o.from || original;
                } else {
                    el.from = o.from || (mode === "show" ? zero : original);
                    el.to = o.to || (mode === "hide" ? zero : original);
                }

                // Set scaling factor
                factor = {
                    from: {
                        y: el.from.height / original.height,
                        x: el.from.width / original.width
                    },
                    to: {
                        y: el.to.height / original.height,
                        x: el.to.width / original.width
                    }
                };

                // Scale the css box
                if (scale === "box" || scale === "both") {

                    // Vertical props scaling
                    if (factor.from.y !== factor.to.y) {
                        props = props.concat(vProps);
                        el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
                        el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
                    }

                    // Horizontal props scaling
                    if (factor.from.x !== factor.to.x) {
                        props = props.concat(hProps);
                        el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
                        el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
                    }
                }

                // Scale the content
                if (scale === "content" || scale === "both") {

                    // Vertical props scaling
                    if (factor.from.y !== factor.to.y) {
                        props = props.concat(cProps).concat(props2);
                        el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
                        el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
                    }
                }

                $.effects.save(el, props);
                el.show();
                $.effects.createWrapper(el);
                el.css("overflow", "hidden").css(el.from);

                // Adjust
                if (origin) { // Calculate baseline shifts
                    baseline = $.effects.getBaseline(origin, original);
                    el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
                    el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
                    el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
                    el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
                }
                el.css(el.from); // set top & left

                // Animate
                if (scale === "content" || scale === "both") { // Scale the children

                    // Add margins/font-size
                    vProps = vProps.concat(["marginTop", "marginBottom"]).concat(cProps);
                    hProps = hProps.concat(["marginLeft", "marginRight"]);
                    props2 = props0.concat(vProps).concat(hProps);

                    el.find("*[width]").each(function() {
                        var child = $(this),
                            c_original = {
                                height: child.height(),
                                width: child.width(),
                                outerHeight: child.outerHeight(),
                                outerWidth: child.outerWidth()
                            };
                        if (restore) {
                            $.effects.save(child, props2);
                        }

                        child.from = {
                            height: c_original.height * factor.from.y,
                            width: c_original.width * factor.from.x,
                            outerHeight: c_original.outerHeight * factor.from.y,
                            outerWidth: c_original.outerWidth * factor.from.x
                        };
                        child.to = {
                            height: c_original.height * factor.to.y,
                            width: c_original.width * factor.to.x,
                            outerHeight: c_original.height * factor.to.y,
                            outerWidth: c_original.width * factor.to.x
                        };

                        // Vertical props scaling
                        if (factor.from.y !== factor.to.y) {
                            child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
                            child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
                        }

                        // Horizontal props scaling
                        if (factor.from.x !== factor.to.x) {
                            child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
                            child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
                        }

                        // Animate children
                        child.css(child.from);
                        child.animate(child.to, o.duration, o.easing, function() {

                            // Restore children
                            if (restore) {
                                $.effects.restore(child, props2);
                            }
                        });
                    });
                }

                // Animate
                el.animate(el.to, {
                    queue: false,
                    duration: o.duration,
                    easing: o.easing,
                    complete: function() {
                        if (el.to.opacity === 0) {
                            el.css("opacity", el.from.opacity);
                        }
                        if (mode === "hide") {
                            el.hide();
                        }
                        $.effects.restore(el, props);
                        if (!restore) {

                            // we need to calculate our new positioning based on the scaling
                            if (position === "static") {
                                el.css({
                                    position: "relative",
                                    top: el.to.top,
                                    left: el.to.left
                                });
                            } else {
                                $.each(["top", "left"], function(idx, pos) {
                                    el.css(pos, function(_, str) {
                                        var val = parseInt(str, 10),
                                            toRef = idx ? el.to.left : el.to.top;

                                        // if original was "auto", recalculate the new value from wrapper
                                        if (str === "auto") {
                                            return toRef + "px";
                                        }

                                        return val + toRef + "px";
                                    });
                                });
                            }
                        }

                        $.effects.removeWrapper(el);
                        done();
                    }
                });

            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.shake = function(o, done) {

                var el = $(this),
                    props = ["position", "top", "bottom", "left", "right", "height", "width"],
                    mode = $.effects.setMode(el, o.mode || "effect"),
                    direction = o.direction || "left",
                    distance = o.distance || 20,
                    times = o.times || 3,
                    anims = times * 2 + 1,
                    speed = Math.round(o.duration / anims),
                    ref = (direction === "up" || direction === "down") ? "top" : "left",
                    positiveMotion = (direction === "up" || direction === "left"),
                    animation = {},
                    animation1 = {},
                    animation2 = {},
                    i,

                    // we will need to re-assemble the queue to stack our animations in place
                    queue = el.queue(),
                    queuelen = queue.length;

                $.effects.save(el, props);
                el.show();
                $.effects.createWrapper(el);

                // Animation
                animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
                animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
                animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;

                // Animate
                el.animate(animation, speed, o.easing);

                // Shakes
                for (i = 1; i < times; i++) {
                    el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
                }
                el
                    .animate(animation1, speed, o.easing)
                    .animate(animation, speed / 2, o.easing)
                    .queue(function() {
                        if (mode === "hide") {
                            el.hide();
                        }
                        $.effects.restore(el, props);
                        $.effects.removeWrapper(el);
                        done();
                    });

                // inject all the animations we just queued to be first in line (after "inprogress")
                if (queuelen > 1) {
                    queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
                }
                el.dequeue();

            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.slide = function(o, done) {

                // Create element
                var el = $(this),
                    props = ["position", "top", "bottom", "left", "right", "width", "height"],
                    mode = $.effects.setMode(el, o.mode || "show"),
                    show = mode === "show",
                    direction = o.direction || "left",
                    ref = (direction === "up" || direction === "down") ? "top" : "left",
                    positiveMotion = (direction === "up" || direction === "left"),
                    distance,
                    animation = {};

                // Adjust
                $.effects.save(el, props);
                el.show();
                distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true);

                $.effects.createWrapper(el).css({
                    overflow: "hidden"
                });

                if (show) {
                    el.css(ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance);
                }

                // Animation
                animation[ref] = (show ?
                        (positiveMotion ? "+=" : "-=") :
                        (positiveMotion ? "-=" : "+=")) +
                    distance;

                // Animate
                el.animate(animation, {
                    queue: false,
                    duration: o.duration,
                    easing: o.easing,
                    complete: function() {
                        if (mode === "hide") {
                            el.hide();
                        }
                        $.effects.restore(el, props);
                        $.effects.removeWrapper(el);
                        done();
                    }
                });
            };

        })(jQuery);

        (function($, undefined) {

            $.effects.effect.transfer = function(o, done) {
                var elem = $(this),
                    target = $(o.to),
                    targetFixed = target.css("position") === "fixed",
                    body = $("body"),
                    fixTop = targetFixed ? body.scrollTop() : 0,
                    fixLeft = targetFixed ? body.scrollLeft() : 0,
                    endPosition = target.offset(),
                    animation = {
                        top: endPosition.top - fixTop,
                        left: endPosition.left - fixLeft,
                        height: target.innerHeight(),
                        width: target.innerWidth()
                    },
                    startPosition = elem.offset(),
                    transfer = $("<div class='ui-effects-transfer'></div>")
                    .appendTo(document.body)
                    .addClass(o.className)
                    .css({
                        top: startPosition.top - fixTop,
                        left: startPosition.left - fixLeft,
                        height: elem.innerHeight(),
                        width: elem.innerWidth(),
                        position: targetFixed ? "fixed" : "absolute"
                    })
                    .animate(animation, o.duration, o.easing, function() {
                        transfer.remove();
                        done();
                    });
            };

        })(jQuery);

        (function($, undefined) {

            $.widget("ui.menu", {
                version: "1.10.3",
                defaultElement: "<ul>",
                delay: 300,
                options: {
                    icons: {
                        submenu: "ui-icon-carat-1-e"
                    },
                    menus: "ul",
                    position: {
                        my: "left top",
                        at: "right top"
                    },
                    role: "menu",

                    // callbacks
                    blur: null,
                    focus: null,
                    select: null
                },

                _create: function() {
                    this.activeMenu = this.element;
                    // flag used to prevent firing of the click handler
                    // as the event bubbles up through nested menus
                    this.mouseHandled = false;
                    this.element
                        .uniqueId()
                        .addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
                        .toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length)
                        .attr({
                            role: this.options.role,
                            tabIndex: 0
                        })
                        // need to catch all clicks on disabled menu
                        // not possible through _on
                        .bind("click" + this.eventNamespace, $.proxy(function(event) {
                            if (this.options.disabled) {
                                event.preventDefault();
                            }
                        }, this));

                    if (this.options.disabled) {
                        this.element
                            .addClass("ui-state-disabled")
                            .attr("aria-disabled", "true");
                    }

                    this._on({
                        // Prevent focus from sticking to links inside menu after clicking
                        // them (focus should always stay on UL during navigation).
                        "mousedown .ui-menu-item > a": function(event) {
                            event.preventDefault();
                        },
                        "click .ui-state-disabled > a": function(event) {
                            event.preventDefault();
                        },
                        "click .ui-menu-item:has(a)": function(event) {
                            var target = $(event.target).closest(".ui-menu-item");
                            if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                                this.mouseHandled = true;

                                this.select(event);
                                // Open submenu on click
                                if (target.has(".ui-menu").length) {
                                    this.expand(event);
                                } else if (!this.element.is(":focus")) {
                                    // Redirect focus to the menu
                                    this.element.trigger("focus", [true]);

                                    // If the active item is on the top level, let it stay active.
                                    // Otherwise, blur the active item since it is no longer visible.
                                    if (this.active && this.active.parents(".ui-menu").length === 1) {
                                        clearTimeout(this.timer);
                                    }
                                }
                            }
                        },
                        "mouseenter .ui-menu-item": function(event) {
                            var target = $(event.currentTarget);
                            // Remove ui-state-active class from siblings of the newly focused menu item
                            // to avoid a jump caused by adjacent elements both having a class with a border
                            target.siblings().children(".ui-state-active").removeClass("ui-state-active");
                            this.focus(event, target);
                        },
                        mouseleave: "collapseAll",
                        "mouseleave .ui-menu": "collapseAll",
                        focus: function(event, keepActiveItem) {
                            // If there's already an active item, keep it active
                            // If not, activate the first item
                            var item = this.active || this.element.children(".ui-menu-item").eq(0);

                            if (!keepActiveItem) {
                                this.focus(event, item);
                            }
                        },
                        blur: function(event) {
                            this._delay(function() {
                                if (!$.contains(this.element[0], this.document[0].activeElement)) {
                                    this.collapseAll(event);
                                }
                            });
                        },
                        keydown: "_keydown"
                    });

                    this.refresh();

                    // Clicks outside of a menu collapse any open menus
                    this._on(this.document, {
                        click: function(event) {
                            if (!$(event.target).closest(".ui-menu").length) {
                                this.collapseAll(event);
                            }

                            // Reset the mouseHandled flag
                            this.mouseHandled = false;
                        }
                    });
                },

                _destroy: function() {
                    // Destroy (sub)menus
                    this.element
                        .removeAttr("aria-activedescendant")
                        .find(".ui-menu").addBack()
                        .removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons")
                        .removeAttr("role")
                        .removeAttr("tabIndex")
                        .removeAttr("aria-labelledby")
                        .removeAttr("aria-expanded")
                        .removeAttr("aria-hidden")
                        .removeAttr("aria-disabled")
                        .removeUniqueId()
                        .show();

                    // Destroy menu items
                    this.element.find(".ui-menu-item")
                        .removeClass("ui-menu-item")
                        .removeAttr("role")
                        .removeAttr("aria-disabled")
                        .children("a")
                        .removeUniqueId()
                        .removeClass("ui-corner-all ui-state-hover")
                        .removeAttr("tabIndex")
                        .removeAttr("role")
                        .removeAttr("aria-haspopup")
                        .children().each(function() {
                            var elem = $(this);
                            if (elem.data("ui-menu-submenu-carat")) {
                                elem.remove();
                            }
                        });

                    // Destroy menu dividers
                    this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
                },

                _keydown: function(event) {
                    /*jshint maxcomplexity:20*/
                    var match, prev, character, skip, regex,
                        preventDefault = true;

                    function escape(value) {
                        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
                    }

                    switch (event.keyCode) {
                        case $.ui.keyCode.PAGE_UP:
                            this.previousPage(event);
                            break;
                        case $.ui.keyCode.PAGE_DOWN:
                            this.nextPage(event);
                            break;
                        case $.ui.keyCode.HOME:
                            this._move("first", "first", event);
                            break;
                        case $.ui.keyCode.END:
                            this._move("last", "last", event);
                            break;
                        case $.ui.keyCode.UP:
                            this.previous(event);
                            break;
                        case $.ui.keyCode.DOWN:
                            this.next(event);
                            break;
                        case $.ui.keyCode.LEFT:
                            this.collapse(event);
                            break;
                        case $.ui.keyCode.RIGHT:
                            if (this.active && !this.active.is(".ui-state-disabled")) {
                                this.expand(event);
                            }
                            break;
                        case $.ui.keyCode.ENTER:
                        case $.ui.keyCode.SPACE:
                            this._activate(event);
                            break;
                        case $.ui.keyCode.ESCAPE:
                            this.collapse(event);
                            break;
                        default:
                            preventDefault = false;
                            prev = this.previousFilter || "";
                            character = String.fromCharCode(event.keyCode);
                            skip = false;

                            clearTimeout(this.filterTimer);

                            if (character === prev) {
                                skip = true;
                            } else {
                                character = prev + character;
                            }

                            regex = new RegExp("^" + escape(character), "i");
                            match = this.activeMenu.children(".ui-menu-item").filter(function() {
                                return regex.test($(this).children("a").text());
                            });
                            match = skip && match.index(this.active.next()) !== -1 ?
                                this.active.nextAll(".ui-menu-item") :
                                match;

                            // If no matches on the current filter, reset to the last character pressed
                            // to move down the menu to the first item that starts with that character
                            if (!match.length) {
                                character = String.fromCharCode(event.keyCode);
                                regex = new RegExp("^" + escape(character), "i");
                                match = this.activeMenu.children(".ui-menu-item").filter(function() {
                                    return regex.test($(this).children("a").text());
                                });
                            }

                            if (match.length) {
                                this.focus(event, match);
                                if (match.length > 1) {
                                    this.previousFilter = character;
                                    this.filterTimer = this._delay(function() {
                                        delete this.previousFilter;
                                    }, 1000);
                                } else {
                                    delete this.previousFilter;
                                }
                            } else {
                                delete this.previousFilter;
                            }
                    }

                    if (preventDefault) {
                        event.preventDefault();
                    }
                },

                _activate: function(event) {
                    if (!this.active.is(".ui-state-disabled")) {
                        if (this.active.children("a[aria-haspopup='true']").length) {
                            this.expand(event);
                        } else {
                            this.select(event);
                        }
                    }
                },

                refresh: function() {
                    var menus,
                        icon = this.options.icons.submenu,
                        submenus = this.element.find(this.options.menus);

                    // Initialize nested menus
                    submenus.filter(":not(.ui-menu)")
                        .addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
                        .hide()
                        .attr({
                            role: this.options.role,
                            "aria-hidden": "true",
                            "aria-expanded": "false"
                        })
                        .each(function() {
                            var menu = $(this),
                                item = menu.prev("a"),
                                submenuCarat = $("<span>")
                                .addClass("ui-menu-icon ui-icon " + icon)
                                .data("ui-menu-submenu-carat", true);

                            item
                                .attr("aria-haspopup", "true")
                                .prepend(submenuCarat);
                            menu.attr("aria-labelledby", item.attr("id"));
                        });

                    menus = submenus.add(this.element);

                    // Don't refresh list items that are already adapted
                    menus.children(":not(.ui-menu-item):has(a)")
                        .addClass("ui-menu-item")
                        .attr("role", "presentation")
                        .children("a")
                        .uniqueId()
                        .addClass("ui-corner-all")
                        .attr({
                            tabIndex: -1,
                            role: this._itemRole()
                        });

                    // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
                    menus.children(":not(.ui-menu-item)").each(function() {
                        var item = $(this);
                        // hyphen, em dash, en dash
                        if (!/[^\-\u2014\u2013\s]/.test(item.text())) {
                            item.addClass("ui-widget-content ui-menu-divider");
                        }
                    });

                    // Add aria-disabled attribute to any disabled menu item
                    menus.children(".ui-state-disabled").attr("aria-disabled", "true");

                    // If the active item has been removed, blur the menu
                    if (this.active && !$.contains(this.element[0], this.active[0])) {
                        this.blur();
                    }
                },

                _itemRole: function() {
                    return {
                        menu: "menuitem",
                        listbox: "option"
                    }[this.options.role];
                },

                _setOption: function(key, value) {
                    if (key === "icons") {
                        this.element.find(".ui-menu-icon")
                            .removeClass(this.options.icons.submenu)
                            .addClass(value.submenu);
                    }
                    this._super(key, value);
                },

                focus: function(event, item) {
                    var nested, focused;
                    this.blur(event, event && event.type === "focus");

                    this._scrollIntoView(item);

                    this.active = item.first();
                    focused = this.active.children("a").addClass("ui-state-focus");
                    // Only update aria-activedescendant if there's a role
                    // otherwise we assume focus is managed elsewhere
                    if (this.options.role) {
                        this.element.attr("aria-activedescendant", focused.attr("id"));
                    }

                    // Highlight active parent menu item, if any
                    this.active
                        .parent()
                        .closest(".ui-menu-item")
                        .children("a:first")
                        .addClass("ui-state-active");

                    if (event && event.type === "keydown") {
                        this._close();
                    } else {
                        this.timer = this._delay(function() {
                            this._close();
                        }, this.delay);
                    }

                    nested = item.children(".ui-menu");
                    if (nested.length && (/^mouse/.test(event.type))) {
                        this._startOpening(nested);
                    }
                    this.activeMenu = item.parent();

                    this._trigger("focus", event, {
                        item: item
                    });
                },

                _scrollIntoView: function(item) {
                    var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
                    if (this._hasScroll()) {
                        borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                        paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                        offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                        scroll = this.activeMenu.scrollTop();
                        elementHeight = this.activeMenu.height();
                        itemHeight = item.height();

                        if (offset < 0) {
                            this.activeMenu.scrollTop(scroll + offset);
                        } else if (offset + itemHeight > elementHeight) {
                            this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                        }
                    }
                },

                blur: function(event, fromFocus) {
                    if (!fromFocus) {
                        clearTimeout(this.timer);
                    }

                    if (!this.active) {
                        return;
                    }

                    this.active.children("a").removeClass("ui-state-focus");
                    this.active = null;

                    this._trigger("blur", event, {
                        item: this.active
                    });
                },

                _startOpening: function(submenu) {
                    clearTimeout(this.timer);

                    // Don't open if already open fixes a Firefox bug that caused a .5 pixel
                    // shift in the submenu position when mousing over the carat icon
                    if (submenu.attr("aria-hidden") !== "true") {
                        return;
                    }

                    this.timer = this._delay(function() {
                        this._close();
                        this._open(submenu);
                    }, this.delay);
                },

                _open: function(submenu) {
                    var position = $.extend({ of: this.active
                    }, this.options.position);

                    clearTimeout(this.timer);
                    this.element.find(".ui-menu").not(submenu.parents(".ui-menu"))
                        .hide()
                        .attr("aria-hidden", "true");

                    submenu
                        .show()
                        .removeAttr("aria-hidden")
                        .attr("aria-expanded", "true")
                        .position(position);
                },

                collapseAll: function(event, all) {
                    clearTimeout(this.timer);
                    this.timer = this._delay(function() {
                        // If we were passed an event, look for the submenu that contains the event
                        var currentMenu = all ? this.element :
                            $(event && event.target).closest(this.element.find(".ui-menu"));

                        // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
                        if (!currentMenu.length) {
                            currentMenu = this.element;
                        }

                        this._close(currentMenu);

                        this.blur(event);
                        this.activeMenu = currentMenu;
                    }, this.delay);
                },

                // With no arguments, closes the currently active menu - if nothing is active
                // it closes all menus.  If passed an argument, it will search for menus BELOW
                _close: function(startMenu) {
                    if (!startMenu) {
                        startMenu = this.active ? this.active.parent() : this.element;
                    }

                    startMenu
                        .find(".ui-menu")
                        .hide()
                        .attr("aria-hidden", "true")
                        .attr("aria-expanded", "false")
                        .end()
                        .find("a.ui-state-active")
                        .removeClass("ui-state-active");
                },

                collapse: function(event) {
                    var newItem = this.active &&
                        this.active.parent().closest(".ui-menu-item", this.element);
                    if (newItem && newItem.length) {
                        this._close();
                        this.focus(event, newItem);
                    }
                },

                expand: function(event) {
                    var newItem = this.active &&
                        this.active
                        .children(".ui-menu ")
                        .children(".ui-menu-item")
                        .first();

                    if (newItem && newItem.length) {
                        this._open(newItem.parent());

                        // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                        this._delay(function() {
                            this.focus(event, newItem);
                        });
                    }
                },

                next: function(event) {
                    this._move("next", "first", event);
                },

                previous: function(event) {
                    this._move("prev", "last", event);
                },

                isFirstItem: function() {
                    return this.active && !this.active.prevAll(".ui-menu-item").length;
                },

                isLastItem: function() {
                    return this.active && !this.active.nextAll(".ui-menu-item").length;
                },

                _move: function(direction, filter, event) {
                    var next;
                    if (this.active) {
                        if (direction === "first" || direction === "last") {
                            next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item")
                                .eq(-1);
                        } else {
                            next = this.active[direction + "All"](".ui-menu-item")
                                .eq(0);
                        }
                    }
                    if (!next || !next.length || !this.active) {
                        next = this.activeMenu.children(".ui-menu-item")[filter]();
                    }

                    this.focus(event, next);
                },

                nextPage: function(event) {
                    var item, base, height;

                    if (!this.active) {
                        this.next(event);
                        return;
                    }
                    if (this.isLastItem()) {
                        return;
                    }
                    if (this._hasScroll()) {
                        base = this.active.offset().top;
                        height = this.element.height();
                        this.active.nextAll(".ui-menu-item").each(function() {
                            item = $(this);
                            return item.offset().top - base - height < 0;
                        });

                        this.focus(event, item);
                    } else {
                        this.focus(event, this.activeMenu.children(".ui-menu-item")[!this.active ? "first" : "last"]());
                    }
                },

                previousPage: function(event) {
                    var item, base, height;
                    if (!this.active) {
                        this.next(event);
                        return;
                    }
                    if (this.isFirstItem()) {
                        return;
                    }
                    if (this._hasScroll()) {
                        base = this.active.offset().top;
                        height = this.element.height();
                        this.active.prevAll(".ui-menu-item").each(function() {
                            item = $(this);
                            return item.offset().top - base + height > 0;
                        });

                        this.focus(event, item);
                    } else {
                        this.focus(event, this.activeMenu.children(".ui-menu-item").first());
                    }
                },

                _hasScroll: function() {
                    return this.element.outerHeight() < this.element.prop("scrollHeight");
                },

                select: function(event) {
                    // TODO: It should never be possible to not have an active item at this
                    // point, but the tests don't trigger mouseenter before click.
                    this.active = this.active || $(event.target).closest(".ui-menu-item");
                    var ui = {
                        item: this.active
                    };
                    if (!this.active.has(".ui-menu").length) {
                        this.collapseAll(event, true);
                    }
                    this._trigger("select", event, ui);
                }
            });

        }(jQuery));

        (function($, undefined) {

            $.ui = $.ui || {};

            var cachedScrollbarWidth,
                max = Math.max,
                abs = Math.abs,
                round = Math.round,
                rhorizontal = /left|center|right/,
                rvertical = /top|center|bottom/,
                roffset = /[\+\-]\d+(\.[\d]+)?%?/,
                rposition = /^\w+/,
                rpercent = /%$/,
                _position = $.fn.position;

            function getOffsets(offsets, width, height) {
                return [
                    parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
                    parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
                ];
            }

            function parseCss(element, property) {
                return parseInt($.css(element, property), 10) || 0;
            }

            function getDimensions(elem) {
                var raw = elem[0];
                if (raw.nodeType === 9) {
                    return {
                        width: elem.width(),
                        height: elem.height(),
                        offset: {
                            top: 0,
                            left: 0
                        }
                    };
                }
                if ($.isWindow(raw)) {
                    return {
                        width: elem.width(),
                        height: elem.height(),
                        offset: {
                            top: elem.scrollTop(),
                            left: elem.scrollLeft()
                        }
                    };
                }
                if (raw.preventDefault) {
                    return {
                        width: 0,
                        height: 0,
                        offset: {
                            top: raw.pageY,
                            left: raw.pageX
                        }
                    };
                }
                return {
                    width: elem.outerWidth(),
                    height: elem.outerHeight(),
                    offset: elem.offset()
                };
            }

            $.position = {
                scrollbarWidth: function() {
                    if (cachedScrollbarWidth !== undefined) {
                        return cachedScrollbarWidth;
                    }
                    var w1, w2,
                        div = $("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
                        innerDiv = div.children()[0];

                    $("body").append(div);
                    w1 = innerDiv.offsetWidth;
                    div.css("overflow", "scroll");

                    w2 = innerDiv.offsetWidth;

                    if (w1 === w2) {
                        w2 = div[0].clientWidth;
                    }

                    div.remove();

                    return (cachedScrollbarWidth = w1 - w2);
                },
                getScrollInfo: function(within) {
                    var overflowX = within.isWindow ? "" : within.element.css("overflow-x"),
                        overflowY = within.isWindow ? "" : within.element.css("overflow-y"),
                        hasOverflowX = overflowX === "scroll" ||
                        (overflowX === "auto" && within.width < within.element[0].scrollWidth),
                        hasOverflowY = overflowY === "scroll" ||
                        (overflowY === "auto" && within.height < within.element[0].scrollHeight);
                    return {
                        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                        height: hasOverflowX ? $.position.scrollbarWidth() : 0
                    };
                },
                getWithinInfo: function(element) {
                    var withinElement = $(element || window),
                        isWindow = $.isWindow(withinElement[0]);
                    return {
                        element: withinElement,
                        isWindow: isWindow,
                        offset: withinElement.offset() || {
                            left: 0,
                            top: 0
                        },
                        scrollLeft: withinElement.scrollLeft(),
                        scrollTop: withinElement.scrollTop(),
                        width: isWindow ? withinElement.width() : withinElement.outerWidth(),
                        height: isWindow ? withinElement.height() : withinElement.outerHeight()
                    };
                }
            };

            $.fn.position = function(options) {
                if (!options || !options.of) {
                    return _position.apply(this, arguments);
                }

                // make a copy, we don't want to modify arguments
                options = $.extend({}, options);

                var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                    target = $(options.of),
                    within = $.position.getWithinInfo(options.within),
                    scrollInfo = $.position.getScrollInfo(within),
                    collision = (options.collision || "flip").split(" "),
                    offsets = {};

                dimensions = getDimensions(target);
                if (target[0].preventDefault) {
                    // force left top to allow flipping
                    options.at = "left top";
                }
                targetWidth = dimensions.width;
                targetHeight = dimensions.height;
                targetOffset = dimensions.offset;
                // clone to reuse original targetOffset later
                basePosition = $.extend({}, targetOffset);

                // force my and at to have valid horizontal and vertical positions
                // if a value is missing or invalid, it will be converted to center
                $.each(["my", "at"], function() {
                    var pos = (options[this] || "").split(" "),
                        horizontalOffset,
                        verticalOffset;

                    if (pos.length === 1) {
                        pos = rhorizontal.test(pos[0]) ?
                            pos.concat(["center"]) :
                            rvertical.test(pos[0]) ? ["center"].concat(pos) : ["center", "center"];
                    }
                    pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                    pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";

                    // calculate offsets
                    horizontalOffset = roffset.exec(pos[0]);
                    verticalOffset = roffset.exec(pos[1]);
                    offsets[this] = [
                        horizontalOffset ? horizontalOffset[0] : 0,
                        verticalOffset ? verticalOffset[0] : 0
                    ];

                    // reduce to just the positions without the offsets
                    options[this] = [
                        rposition.exec(pos[0])[0],
                        rposition.exec(pos[1])[0]
                    ];
                });

                // normalize collision option
                if (collision.length === 1) {
                    collision[1] = collision[0];
                }

                if (options.at[0] === "right") {
                    basePosition.left += targetWidth;
                } else if (options.at[0] === "center") {
                    basePosition.left += targetWidth / 2;
                }

                if (options.at[1] === "bottom") {
                    basePosition.top += targetHeight;
                } else if (options.at[1] === "center") {
                    basePosition.top += targetHeight / 2;
                }

                atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
                basePosition.left += atOffset[0];
                basePosition.top += atOffset[1];

                return this.each(function() {
                    var collisionPosition, using,
                        elem = $(this),
                        elemWidth = elem.outerWidth(),
                        elemHeight = elem.outerHeight(),
                        marginLeft = parseCss(this, "marginLeft"),
                        marginTop = parseCss(this, "marginTop"),
                        collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
                        collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
                        position = $.extend({}, basePosition),
                        myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

                    if (options.my[0] === "right") {
                        position.left -= elemWidth;
                    } else if (options.my[0] === "center") {
                        position.left -= elemWidth / 2;
                    }

                    if (options.my[1] === "bottom") {
                        position.top -= elemHeight;
                    } else if (options.my[1] === "center") {
                        position.top -= elemHeight / 2;
                    }

                    position.left += myOffset[0];
                    position.top += myOffset[1];

                    // if the browser doesn't support fractions, then round for consistent results
                    if (!$.support.offsetFractions) {
                        position.left = round(position.left);
                        position.top = round(position.top);
                    }

                    collisionPosition = {
                        marginLeft: marginLeft,
                        marginTop: marginTop
                    };

                    $.each(["left", "top"], function(i, dir) {
                        if ($.ui.position[collision[i]]) {
                            $.ui.position[collision[i]][dir](position, {
                                targetWidth: targetWidth,
                                targetHeight: targetHeight,
                                elemWidth: elemWidth,
                                elemHeight: elemHeight,
                                collisionPosition: collisionPosition,
                                collisionWidth: collisionWidth,
                                collisionHeight: collisionHeight,
                                offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                                my: options.my,
                                at: options.at,
                                within: within,
                                elem: elem
                            });
                        }
                    });

                    if (options.using) {
                        // adds feedback as second argument to using callback, if present
                        using = function(props) {
                            var left = targetOffset.left - position.left,
                                right = left + targetWidth - elemWidth,
                                top = targetOffset.top - position.top,
                                bottom = top + targetHeight - elemHeight,
                                feedback = {
                                    target: {
                                        element: target,
                                        left: targetOffset.left,
                                        top: targetOffset.top,
                                        width: targetWidth,
                                        height: targetHeight
                                    },
                                    element: {
                                        element: elem,
                                        left: position.left,
                                        top: position.top,
                                        width: elemWidth,
                                        height: elemHeight
                                    },
                                    horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                    vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                                };
                            if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                                feedback.horizontal = "center";
                            }
                            if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                                feedback.vertical = "middle";
                            }
                            if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                                feedback.important = "horizontal";
                            } else {
                                feedback.important = "vertical";
                            }
                            options.using.call(this, props, feedback);
                        };
                    }

                    elem.offset($.extend(position, {
                        using: using
                    }));
                });
            };

            $.ui.position = {
                fit: {
                    left: function(position, data) {
                        var within = data.within,
                            withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                            outerWidth = within.width,
                            collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                            overLeft = withinOffset - collisionPosLeft,
                            overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                            newOverRight;

                        // element is wider than within
                        if (data.collisionWidth > outerWidth) {
                            // element is initially over the left side of within
                            if (overLeft > 0 && overRight <= 0) {
                                newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                                position.left += overLeft - newOverRight;
                                // element is initially over right side of within
                            } else if (overRight > 0 && overLeft <= 0) {
                                position.left = withinOffset;
                                // element is initially over both left and right sides of within
                            } else {
                                if (overLeft > overRight) {
                                    position.left = withinOffset + outerWidth - data.collisionWidth;
                                } else {
                                    position.left = withinOffset;
                                }
                            }
                            // too far left -> align with left edge
                        } else if (overLeft > 0) {
                            position.left += overLeft;
                            // too far right -> align with right edge
                        } else if (overRight > 0) {
                            position.left -= overRight;
                            // adjust based on position and margin
                        } else {
                            position.left = max(position.left - collisionPosLeft, position.left);
                        }
                    },
                    top: function(position, data) {
                        var within = data.within,
                            withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                            outerHeight = data.within.height,
                            collisionPosTop = position.top - data.collisionPosition.marginTop,
                            overTop = withinOffset - collisionPosTop,
                            overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                            newOverBottom;

                        // element is taller than within
                        if (data.collisionHeight > outerHeight) {
                            // element is initially over the top of within
                            if (overTop > 0 && overBottom <= 0) {
                                newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                                position.top += overTop - newOverBottom;
                                // element is initially over bottom of within
                            } else if (overBottom > 0 && overTop <= 0) {
                                position.top = withinOffset;
                                // element is initially over both top and bottom of within
                            } else {
                                if (overTop > overBottom) {
                                    position.top = withinOffset + outerHeight - data.collisionHeight;
                                } else {
                                    position.top = withinOffset;
                                }
                            }
                            // too far up -> align with top
                        } else if (overTop > 0) {
                            position.top += overTop;
                            // too far down -> align with bottom edge
                        } else if (overBottom > 0) {
                            position.top -= overBottom;
                            // adjust based on position and margin
                        } else {
                            position.top = max(position.top - collisionPosTop, position.top);
                        }
                    }
                },
                flip: {
                    left: function(position, data) {
                        var within = data.within,
                            withinOffset = within.offset.left + within.scrollLeft,
                            outerWidth = within.width,
                            offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                            collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                            overLeft = collisionPosLeft - offsetLeft,
                            overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                            myOffset = data.my[0] === "left" ?
                            -data.elemWidth :
                            data.my[0] === "right" ?
                            data.elemWidth :
                            0,
                            atOffset = data.at[0] === "left" ?
                            data.targetWidth :
                            data.at[0] === "right" ?
                            -data.targetWidth :
                            0,
                            offset = -2 * data.offset[0],
                            newOverRight,
                            newOverLeft;

                        if (overLeft < 0) {
                            newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                            if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                                position.left += myOffset + atOffset + offset;
                            }
                        } else if (overRight > 0) {
                            newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                            if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                                position.left += myOffset + atOffset + offset;
                            }
                        }
                    },
                    top: function(position, data) {
                        var within = data.within,
                            withinOffset = within.offset.top + within.scrollTop,
                            outerHeight = within.height,
                            offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                            collisionPosTop = position.top - data.collisionPosition.marginTop,
                            overTop = collisionPosTop - offsetTop,
                            overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                            top = data.my[1] === "top",
                            myOffset = top ?
                            -data.elemHeight :
                            data.my[1] === "bottom" ?
                            data.elemHeight :
                            0,
                            atOffset = data.at[1] === "top" ?
                            data.targetHeight :
                            data.at[1] === "bottom" ?
                            -data.targetHeight :
                            0,
                            offset = -2 * data.offset[1],
                            newOverTop,
                            newOverBottom;
                        if (overTop < 0) {
                            newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                            if ((position.top + myOffset + atOffset + offset) > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
                                position.top += myOffset + atOffset + offset;
                            }
                        } else if (overBottom > 0) {
                            newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                            if ((position.top + myOffset + atOffset + offset) > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
                                position.top += myOffset + atOffset + offset;
                            }
                        }
                    }
                },
                flipfit: {
                    left: function() {
                        $.ui.position.flip.left.apply(this, arguments);
                        $.ui.position.fit.left.apply(this, arguments);
                    },
                    top: function() {
                        $.ui.position.flip.top.apply(this, arguments);
                        $.ui.position.fit.top.apply(this, arguments);
                    }
                }
            };

            // fraction support test
            (function() {
                var testElement, testElementParent, testElementStyle, offsetLeft, i,
                    body = document.getElementsByTagName("body")[0],
                    div = document.createElement("div");

                //Create a "fake body" for testing based on method used in jQuery.support
                testElement = document.createElement(body ? "div" : "body");
                testElementStyle = {
                    visibility: "hidden",
                    width: 0,
                    height: 0,
                    border: 0,
                    margin: 0,
                    background: "none"
                };
                if (body) {
                    $.extend(testElementStyle, {
                        position: "absolute",
                        left: "-1000px",
                        top: "-1000px"
                    });
                }
                for (i in testElementStyle) {
                    testElement.style[i] = testElementStyle[i];
                }
                testElement.appendChild(div);
                testElementParent = body || document.documentElement;
                testElementParent.insertBefore(testElement, testElementParent.firstChild);

                div.style.cssText = "position: absolute; left: 10.7432222px;";

                offsetLeft = $(div).offset().left;
                $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

                testElement.innerHTML = "";
                testElementParent.removeChild(testElement);
            })();

        }(jQuery));

        (function($, undefined) {

            $.widget("ui.progressbar", {
                version: "1.10.3",
                options: {
                    max: 100,
                    value: 0,

                    change: null,
                    complete: null
                },

                min: 0,

                _create: function() {
                    // Constrain initial value
                    this.oldValue = this.options.value = this._constrainedValue();

                    this.element
                        .addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all")
                        .attr({
                            // Only set static values, aria-valuenow and aria-valuemax are
                            // set inside _refreshValue()
                            role: "progressbar",
                            "aria-valuemin": this.min
                        });

                    this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>")
                        .appendTo(this.element);

                    this._refreshValue();
                },

                _destroy: function() {
                    this.element
                        .removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all")
                        .removeAttr("role")
                        .removeAttr("aria-valuemin")
                        .removeAttr("aria-valuemax")
                        .removeAttr("aria-valuenow");

                    this.valueDiv.remove();
                },

                value: function(newValue) {
                    if (newValue === undefined) {
                        return this.options.value;
                    }

                    this.options.value = this._constrainedValue(newValue);
                    this._refreshValue();
                },

                _constrainedValue: function(newValue) {
                    if (newValue === undefined) {
                        newValue = this.options.value;
                    }

                    this.indeterminate = newValue === false;

                    // sanitize value
                    if (typeof newValue !== "number") {
                        newValue = 0;
                    }

                    return this.indeterminate ? false :
                        Math.min(this.options.max, Math.max(this.min, newValue));
                },

                _setOptions: function(options) {
                    // Ensure "value" option is set after other values (like max)
                    var value = options.value;
                    delete options.value;

                    this._super(options);

                    this.options.value = this._constrainedValue(value);
                    this._refreshValue();
                },

                _setOption: function(key, value) {
                    if (key === "max") {
                        // Don't allow a max less than min
                        value = Math.max(this.min, value);
                    }

                    this._super(key, value);
                },

                _percentage: function() {
                    return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
                },

                _refreshValue: function() {
                    var value = this.options.value,
                        percentage = this._percentage();

                    this.valueDiv
                        .toggle(this.indeterminate || value > this.min)
                        .toggleClass("ui-corner-right", value === this.options.max)
                        .width(percentage.toFixed(0) + "%");

                    this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate);

                    if (this.indeterminate) {
                        this.element.removeAttr("aria-valuenow");
                        if (!this.overlayDiv) {
                            this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
                        }
                    } else {
                        this.element.attr({
                            "aria-valuemax": this.options.max,
                            "aria-valuenow": value
                        });
                        if (this.overlayDiv) {
                            this.overlayDiv.remove();
                            this.overlayDiv = null;
                        }
                    }

                    if (this.oldValue !== value) {
                        this.oldValue = value;
                        this._trigger("change");
                    }
                    if (value === this.options.max) {
                        this._trigger("complete");
                    }
                }
            });

        })(jQuery);

        (function($, undefined) {

            // number of pages in a slider
            // (how many times can you page up/down to go through the whole range)
            var numPages = 5;

            $.widget("ui.slider", $.ui.mouse, {
                version: "1.10.3",
                widgetEventPrefix: "slide",

                options: {
                    animate: false,
                    distance: 0,
                    max: 100,
                    min: 0,
                    orientation: "horizontal",
                    range: false,
                    step: 1,
                    value: 0,
                    values: null,

                    // callbacks
                    change: null,
                    slide: null,
                    start: null,
                    stop: null
                },

                _create: function() {
                    this._keySliding = false;
                    this._mouseSliding = false;
                    this._animateOff = true;
                    this._handleIndex = null;
                    this._detectOrientation();
                    this._mouseInit();

                    this.element
                        .addClass("ui-slider" +
                            " ui-slider-" + this.orientation +
                            " ui-widget" +
                            " ui-widget-content" +
                            " ui-corner-all");

                    this._refresh();
                    this._setOption("disabled", this.options.disabled);

                    this._animateOff = false;
                },

                _refresh: function() {
                    this._createRange();
                    this._createHandles();
                    this._setupEvents();
                    this._refreshValue();
                },

                _createHandles: function() {
                    var i, handleCount,
                        options = this.options,
                        existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
                        handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
                        handles = [];

                    handleCount = (options.values && options.values.length) || 1;

                    if (existingHandles.length > handleCount) {
                        existingHandles.slice(handleCount).remove();
                        existingHandles = existingHandles.slice(0, handleCount);
                    }

                    for (i = existingHandles.length; i < handleCount; i++) {
                        handles.push(handle);
                    }

                    this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

                    this.handle = this.handles.eq(0);

                    this.handles.each(function(i) {
                        $(this).data("ui-slider-handle-index", i);
                    });
                },

                _createRange: function() {
                    var options = this.options,
                        classes = "";

                    if (options.range) {
                        if (options.range === true) {
                            if (!options.values) {
                                options.values = [this._valueMin(), this._valueMin()];
                            } else if (options.values.length && options.values.length !== 2) {
                                options.values = [options.values[0], options.values[0]];
                            } else if ($.isArray(options.values)) {
                                options.values = options.values.slice(0);
                            }
                        }

                        if (!this.range || !this.range.length) {
                            this.range = $("<div></div>")
                                .appendTo(this.element);

                            classes = "ui-slider-range" +
                                // note: this isn't the most fittingly semantic framework class for this element,
                                // but worked best visually with a variety of themes
                                " ui-widget-header ui-corner-all";
                        } else {
                            this.range.removeClass("ui-slider-range-min ui-slider-range-max")
                                // Handle range switching from true to min/max
                                .css({
                                    "left": "",
                                    "bottom": ""
                                });
                        }

                        this.range.addClass(classes +
                            ((options.range === "min" || options.range === "max") ? " ui-slider-range-" + options.range : ""));
                    } else {
                        this.range = $([]);
                    }
                },

                _setupEvents: function() {
                    var elements = this.handles.add(this.range).filter("a");
                    this._off(elements);
                    this._on(elements, this._handleEvents);
                    this._hoverable(elements);
                    this._focusable(elements);
                },

                _destroy: function() {
                    this.handles.remove();
                    this.range.remove();

                    this.element
                        .removeClass("ui-slider" +
                            " ui-slider-horizontal" +
                            " ui-slider-vertical" +
                            " ui-widget" +
                            " ui-widget-content" +
                            " ui-corner-all");

                    this._mouseDestroy();
                },

                _mouseCapture: function(event) {
                    var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                        that = this,
                        o = this.options;

                    if (o.disabled) {
                        return false;
                    }

                    this.elementSize = {
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight()
                    };
                    this.elementOffset = this.element.offset();

                    position = {
                        x: event.pageX,
                        y: event.pageY
                    };
                    normValue = this._normValueFromMouse(position);
                    distance = this._valueMax() - this._valueMin() + 1;
                    this.handles.each(function(i) {
                        var thisDistance = Math.abs(normValue - that.values(i));
                        if ((distance > thisDistance) ||
                            (distance === thisDistance &&
                                (i === that._lastChangedValue || that.values(i) === o.min))) {
                            distance = thisDistance;
                            closestHandle = $(this);
                            index = i;
                        }
                    });

                    allowed = this._start(event, index);
                    if (allowed === false) {
                        return false;
                    }
                    this._mouseSliding = true;

                    this._handleIndex = index;

                    closestHandle
                        .addClass("ui-state-active")
                        .focus();

                    offset = closestHandle.offset();
                    mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
                    this._clickOffset = mouseOverHandle ? {
                        left: 0,
                        top: 0
                    } : {
                        left: event.pageX - offset.left - (closestHandle.width() / 2),
                        top: event.pageY - offset.top -
                            (closestHandle.height() / 2) -
                            (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) -
                            (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) +
                            (parseInt(closestHandle.css("marginTop"), 10) || 0)
                    };

                    if (!this.handles.hasClass("ui-state-hover")) {
                        this._slide(event, index, normValue);
                    }
                    this._animateOff = true;
                    return true;
                },

                _mouseStart: function() {
                    return true;
                },

                _mouseDrag: function(event) {
                    var position = {
                            x: event.pageX,
                            y: event.pageY
                        },
                        normValue = this._normValueFromMouse(position);

                    this._slide(event, this._handleIndex, normValue);

                    return false;
                },

                _mouseStop: function(event) {
                    this.handles.removeClass("ui-state-active");
                    this._mouseSliding = false;

                    this._stop(event, this._handleIndex);
                    this._change(event, this._handleIndex);

                    this._handleIndex = null;
                    this._clickOffset = null;
                    this._animateOff = false;

                    return false;
                },

                _detectOrientation: function() {
                    this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
                },

                _normValueFromMouse: function(position) {
                    var pixelTotal,
                        pixelMouse,
                        percentMouse,
                        valueTotal,
                        valueMouse;

                    if (this.orientation === "horizontal") {
                        pixelTotal = this.elementSize.width;
                        pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
                    } else {
                        pixelTotal = this.elementSize.height;
                        pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
                    }

                    percentMouse = (pixelMouse / pixelTotal);
                    if (percentMouse > 1) {
                        percentMouse = 1;
                    }
                    if (percentMouse < 0) {
                        percentMouse = 0;
                    }
                    if (this.orientation === "vertical") {
                        percentMouse = 1 - percentMouse;
                    }

                    valueTotal = this._valueMax() - this._valueMin();
                    valueMouse = this._valueMin() + percentMouse * valueTotal;

                    return this._trimAlignValue(valueMouse);
                },

                _start: function(event, index) {
                    var uiHash = {
                        handle: this.handles[index],
                        value: this.value()
                    };
                    if (this.options.values && this.options.values.length) {
                        uiHash.value = this.values(index);
                        uiHash.values = this.values();
                    }
                    return this._trigger("start", event, uiHash);
                },

                _slide: function(event, index, newVal) {
                    var otherVal,
                        newValues,
                        allowed;

                    if (this.options.values && this.options.values.length) {
                        otherVal = this.values(index ? 0 : 1);

                        if ((this.options.values.length === 2 && this.options.range === true) &&
                            ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))
                        ) {
                            newVal = otherVal;
                        }

                        if (newVal !== this.values(index)) {
                            newValues = this.values();
                            newValues[index] = newVal;
                            // A slide can be canceled by returning false from the slide callback
                            allowed = this._trigger("slide", event, {
                                handle: this.handles[index],
                                value: newVal,
                                values: newValues
                            });
                            otherVal = this.values(index ? 0 : 1);
                            if (allowed !== false) {
                                this.values(index, newVal, true);
                            }
                        }
                    } else {
                        if (newVal !== this.value()) {
                            // A slide can be canceled by returning false from the slide callback
                            allowed = this._trigger("slide", event, {
                                handle: this.handles[index],
                                value: newVal
                            });
                            if (allowed !== false) {
                                this.value(newVal);
                            }
                        }
                    }
                },

                _stop: function(event, index) {
                    var uiHash = {
                        handle: this.handles[index],
                        value: this.value()
                    };
                    if (this.options.values && this.options.values.length) {
                        uiHash.value = this.values(index);
                        uiHash.values = this.values();
                    }

                    this._trigger("stop", event, uiHash);
                },

                _change: function(event, index) {
                    if (!this._keySliding && !this._mouseSliding) {
                        var uiHash = {
                            handle: this.handles[index],
                            value: this.value()
                        };
                        if (this.options.values && this.options.values.length) {
                            uiHash.value = this.values(index);
                            uiHash.values = this.values();
                        }

                        //store the last changed value index for reference when handles overlap
                        this._lastChangedValue = index;

                        this._trigger("change", event, uiHash);
                    }
                },

                value: function(newValue) {
                    if (arguments.length) {
                        this.options.value = this._trimAlignValue(newValue);
                        this._refreshValue();
                        this._change(null, 0);
                        return;
                    }

                    return this._value();
                },

                values: function(index, newValue) {
                    var vals,
                        newValues,
                        i;

                    if (arguments.length > 1) {
                        this.options.values[index] = this._trimAlignValue(newValue);
                        this._refreshValue();
                        this._change(null, index);
                        return;
                    }

                    if (arguments.length) {
                        if ($.isArray(arguments[0])) {
                            vals = this.options.values;
                            newValues = arguments[0];
                            for (i = 0; i < vals.length; i += 1) {
                                vals[i] = this._trimAlignValue(newValues[i]);
                                this._change(null, i);
                            }
                            this._refreshValue();
                        } else {
                            if (this.options.values && this.options.values.length) {
                                return this._values(index);
                            } else {
                                return this.value();
                            }
                        }
                    } else {
                        return this._values();
                    }
                },

                _setOption: function(key, value) {
                    var i,
                        valsLength = 0;

                    if (key === "range" && this.options.range === true) {
                        if (value === "min") {
                            this.options.value = this._values(0);
                            this.options.values = null;
                        } else if (value === "max") {
                            this.options.value = this._values(this.options.values.length - 1);
                            this.options.values = null;
                        }
                    }

                    if ($.isArray(this.options.values)) {
                        valsLength = this.options.values.length;
                    }

                    $.Widget.prototype._setOption.apply(this, arguments);

                    switch (key) {
                        case "orientation":
                            this._detectOrientation();
                            this.element
                                .removeClass("ui-slider-horizontal ui-slider-vertical")
                                .addClass("ui-slider-" + this.orientation);
                            this._refreshValue();
                            break;
                        case "value":
                            this._animateOff = true;
                            this._refreshValue();
                            this._change(null, 0);
                            this._animateOff = false;
                            break;
                        case "values":
                            this._animateOff = true;
                            this._refreshValue();
                            for (i = 0; i < valsLength; i += 1) {
                                this._change(null, i);
                            }
                            this._animateOff = false;
                            break;
                        case "min":
                        case "max":
                            this._animateOff = true;
                            this._refreshValue();
                            this._animateOff = false;
                            break;
                        case "range":
                            this._animateOff = true;
                            this._refresh();
                            this._animateOff = false;
                            break;
                    }
                },

                //internal value getter
                // _value() returns value trimmed by min and max, aligned by step
                _value: function() {
                    var val = this.options.value;
                    val = this._trimAlignValue(val);

                    return val;
                },

                //internal values getter
                // _values() returns array of values trimmed by min and max, aligned by step
                // _values( index ) returns single value trimmed by min and max, aligned by step
                _values: function(index) {
                    var val,
                        vals,
                        i;

                    if (arguments.length) {
                        val = this.options.values[index];
                        val = this._trimAlignValue(val);

                        return val;
                    } else if (this.options.values && this.options.values.length) {
                        // .slice() creates a copy of the array
                        // this copy gets trimmed by min and max and then returned
                        vals = this.options.values.slice();
                        for (i = 0; i < vals.length; i += 1) {
                            vals[i] = this._trimAlignValue(vals[i]);
                        }

                        return vals;
                    } else {
                        return [];
                    }
                },

                // returns the step-aligned value that val is closest to, between (inclusive) min and max
                _trimAlignValue: function(val) {
                    if (val <= this._valueMin()) {
                        return this._valueMin();
                    }
                    if (val >= this._valueMax()) {
                        return this._valueMax();
                    }
                    var step = (this.options.step > 0) ? this.options.step : 1,
                        valModStep = (val - this._valueMin()) % step,
                        alignValue = val - valModStep;

                    if (Math.abs(valModStep) * 2 >= step) {
                        alignValue += (valModStep > 0) ? step : (-step);
                    }

                    // Since JavaScript has problems with large floats, round
                    // the final value to 5 digits after the decimal point (see #4124)
                    return parseFloat(alignValue.toFixed(5));
                },

                _valueMin: function() {
                    return this.options.min;
                },

                _valueMax: function() {
                    return this.options.max;
                },

                _refreshValue: function() {
                    var lastValPercent, valPercent, value, valueMin, valueMax,
                        oRange = this.options.range,
                        o = this.options,
                        that = this,
                        animate = (!this._animateOff) ? o.animate : false,
                        _set = {};

                    if (this.options.values && this.options.values.length) {
                        this.handles.each(function(i) {
                            valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                            _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                            $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                            if (that.options.range === true) {
                                if (that.orientation === "horizontal") {
                                    if (i === 0) {
                                        that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                            left: valPercent + "%"
                                        }, o.animate);
                                    }
                                    if (i === 1) {
                                        that.range[animate ? "animate" : "css"]({
                                            width: (valPercent - lastValPercent) + "%"
                                        }, {
                                            queue: false,
                                            duration: o.animate
                                        });
                                    }
                                } else {
                                    if (i === 0) {
                                        that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                            bottom: (valPercent) + "%"
                                        }, o.animate);
                                    }
                                    if (i === 1) {
                                        that.range[animate ? "animate" : "css"]({
                                            height: (valPercent - lastValPercent) + "%"
                                        }, {
                                            queue: false,
                                            duration: o.animate
                                        });
                                    }
                                }
                            }
                            lastValPercent = valPercent;
                        });
                    } else {
                        value = this.value();
                        valueMin = this._valueMin();
                        valueMax = this._valueMax();
                        valPercent = (valueMax !== valueMin) ?
                            (value - valueMin) / (valueMax - valueMin) * 100 :
                            0;
                        _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                        this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

                        if (oRange === "min" && this.orientation === "horizontal") {
                            this.range.stop(1, 1)[animate ? "animate" : "css"]({
                                width: valPercent + "%"
                            }, o.animate);
                        }
                        if (oRange === "max" && this.orientation === "horizontal") {
                            this.range[animate ? "animate" : "css"]({
                                width: (100 - valPercent) + "%"
                            }, {
                                queue: false,
                                duration: o.animate
                            });
                        }
                        if (oRange === "min" && this.orientation === "vertical") {
                            this.range.stop(1, 1)[animate ? "animate" : "css"]({
                                height: valPercent + "%"
                            }, o.animate);
                        }
                        if (oRange === "max" && this.orientation === "vertical") {
                            this.range[animate ? "animate" : "css"]({
                                height: (100 - valPercent) + "%"
                            }, {
                                queue: false,
                                duration: o.animate
                            });
                        }
                    }
                },

                _handleEvents: {
                    keydown: function(event) {
                        /*jshint maxcomplexity:25*/
                        var allowed, curVal, newVal, step,
                            index = $(event.target).data("ui-slider-handle-index");

                        switch (event.keyCode) {
                            case $.ui.keyCode.HOME:
                            case $.ui.keyCode.END:
                            case $.ui.keyCode.PAGE_UP:
                            case $.ui.keyCode.PAGE_DOWN:
                            case $.ui.keyCode.UP:
                            case $.ui.keyCode.RIGHT:
                            case $.ui.keyCode.DOWN:
                            case $.ui.keyCode.LEFT:
                                event.preventDefault();
                                if (!this._keySliding) {
                                    this._keySliding = true;
                                    $(event.target).addClass("ui-state-active");
                                    allowed = this._start(event, index);
                                    if (allowed === false) {
                                        return;
                                    }
                                }
                                break;
                        }

                        step = this.options.step;
                        if (this.options.values && this.options.values.length) {
                            curVal = newVal = this.values(index);
                        } else {
                            curVal = newVal = this.value();
                        }

                        switch (event.keyCode) {
                            case $.ui.keyCode.HOME:
                                newVal = this._valueMin();
                                break;
                            case $.ui.keyCode.END:
                                newVal = this._valueMax();
                                break;
                            case $.ui.keyCode.PAGE_UP:
                                newVal = this._trimAlignValue(curVal + ((this._valueMax() - this._valueMin()) / numPages));
                                break;
                            case $.ui.keyCode.PAGE_DOWN:
                                newVal = this._trimAlignValue(curVal - ((this._valueMax() - this._valueMin()) / numPages));
                                break;
                            case $.ui.keyCode.UP:
                            case $.ui.keyCode.RIGHT:
                                if (curVal === this._valueMax()) {
                                    return;
                                }
                                newVal = this._trimAlignValue(curVal + step);
                                break;
                            case $.ui.keyCode.DOWN:
                            case $.ui.keyCode.LEFT:
                                if (curVal === this._valueMin()) {
                                    return;
                                }
                                newVal = this._trimAlignValue(curVal - step);
                                break;
                        }

                        this._slide(event, index, newVal);
                    },
                    click: function(event) {
                        event.preventDefault();
                    },
                    keyup: function(event) {
                        var index = $(event.target).data("ui-slider-handle-index");

                        if (this._keySliding) {
                            this._keySliding = false;
                            this._stop(event, index);
                            this._change(event, index);
                            $(event.target).removeClass("ui-state-active");
                        }
                    }
                }

            });

        }(jQuery));

        (function($) {

            function modifier(fn) {
                return function() {
                    var previous = this.element.val();
                    fn.apply(this, arguments);
                    this._refresh();
                    if (previous !== this.element.val()) {
                        this._trigger("change");
                    }
                };
            }

            $.widget("ui.spinner", {
                version: "1.10.3",
                defaultElement: "<input>",
                widgetEventPrefix: "spin",
                options: {
                    culture: null,
                    icons: {
                        down: "ui-icon-triangle-1-s",
                        up: "ui-icon-triangle-1-n"
                    },
                    incremental: true,
                    max: null,
                    min: null,
                    numberFormat: null,
                    page: 10,
                    step: 1,

                    change: null,
                    spin: null,
                    start: null,
                    stop: null
                },

                _create: function() {
                    // handle string values that need to be parsed
                    this._setOption("max", this.options.max);
                    this._setOption("min", this.options.min);
                    this._setOption("step", this.options.step);

                    // format the value, but don't constrain
                    this._value(this.element.val(), true);

                    this._draw();
                    this._on(this._events);
                    this._refresh();

                    // turning off autocomplete prevents the browser from remembering the
                    // value when navigating through history, so we re-enable autocomplete
                    // if the page is unloaded before the widget is destroyed. #7790
                    this._on(this.window, {
                        beforeunload: function() {
                            this.element.removeAttr("autocomplete");
                        }
                    });
                },

                _getCreateOptions: function() {
                    var options = {},
                        element = this.element;

                    $.each(["min", "max", "step"], function(i, option) {
                        var value = element.attr(option);
                        if (value !== undefined && value.length) {
                            options[option] = value;
                        }
                    });

                    return options;
                },

                _events: {
                    keydown: function(event) {
                        if (this._start(event) && this._keydown(event)) {
                            event.preventDefault();
                        }
                    },
                    keyup: "_stop",
                    focus: function() {
                        this.previous = this.element.val();
                    },
                    blur: function(event) {
                        if (this.cancelBlur) {
                            delete this.cancelBlur;
                            return;
                        }

                        this._stop();
                        this._refresh();
                        if (this.previous !== this.element.val()) {
                            this._trigger("change", event);
                        }
                    },
                    mousewheel: function(event, delta) {
                        if (!delta) {
                            return;
                        }
                        if (!this.spinning && !this._start(event)) {
                            return false;
                        }

                        this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                        clearTimeout(this.mousewheelTimer);
                        this.mousewheelTimer = this._delay(function() {
                            if (this.spinning) {
                                this._stop(event);
                            }
                        }, 100);
                        event.preventDefault();
                    },
                    "mousedown .ui-spinner-button": function(event) {
                        var previous;

                        // We never want the buttons to have focus; whenever the user is
                        // interacting with the spinner, the focus should be on the input.
                        // If the input is focused then this.previous is properly set from
                        // when the input first received focus. If the input is not focused
                        // then we need to set this.previous based on the value before spinning.
                        previous = this.element[0] === this.document[0].activeElement ?
                            this.previous : this.element.val();

                        function checkFocus() {
                            var isActive = this.element[0] === this.document[0].activeElement;
                            if (!isActive) {
                                this.element.focus();
                                this.previous = previous;
                                // support: IE
                                // IE sets focus asynchronously, so we need to check if focus
                                // moved off of the input because the user clicked on the button.
                                this._delay(function() {
                                    this.previous = previous;
                                });
                            }
                        }

                        // ensure focus is on (or stays on) the text field
                        event.preventDefault();
                        checkFocus.call(this);

                        // support: IE
                        // IE doesn't prevent moving focus even with event.preventDefault()
                        // so we set a flag to know when we should ignore the blur event
                        // and check (again) if focus moved off of the input.
                        this.cancelBlur = true;
                        this._delay(function() {
                            delete this.cancelBlur;
                            checkFocus.call(this);
                        });

                        if (this._start(event) === false) {
                            return;
                        }

                        this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
                    },
                    "mouseup .ui-spinner-button": "_stop",
                    "mouseenter .ui-spinner-button": function(event) {
                        // button will add ui-state-active if mouse was down while mouseleave and kept down
                        if (!$(event.currentTarget).hasClass("ui-state-active")) {
                            return;
                        }

                        if (this._start(event) === false) {
                            return false;
                        }
                        this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
                    },
                    // TODO: do we really want to consider this a stop?
                    // shouldn't we just stop the repeater and wait until mouseup before
                    // we trigger the stop event?
                    "mouseleave .ui-spinner-button": "_stop"
                },

                _draw: function() {
                    var uiSpinner = this.uiSpinner = this.element
                        .addClass("ui-spinner-input")
                        .attr("autocomplete", "off")
                        .wrap(this._uiSpinnerHtml())
                        .parent()
                        // add buttons
                        .append(this._buttonHtml());

                    this.element.attr("role", "spinbutton");

                    // button bindings
                    this.buttons = uiSpinner.find(".ui-spinner-button")
                        .attr("tabIndex", -1)
                        .button()
                        .removeClass("ui-corner-all");

                    // IE 6 doesn't understand height: 50% for the buttons
                    // unless the wrapper has an explicit height
                    if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) &&
                        uiSpinner.height() > 0) {
                        uiSpinner.height(uiSpinner.height());
                    }

                    // disable spinner if element was already disabled
                    if (this.options.disabled) {
                        this.disable();
                    }
                },

                _keydown: function(event) {
                    var options = this.options,
                        keyCode = $.ui.keyCode;

                    switch (event.keyCode) {
                        case keyCode.UP:
                            this._repeat(null, 1, event);
                            return true;
                        case keyCode.DOWN:
                            this._repeat(null, -1, event);
                            return true;
                        case keyCode.PAGE_UP:
                            this._repeat(null, options.page, event);
                            return true;
                        case keyCode.PAGE_DOWN:
                            this._repeat(null, -options.page, event);
                            return true;
                    }

                    return false;
                },

                _uiSpinnerHtml: function() {
                    return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
                },

                _buttonHtml: function() {
                    return "" +
                        "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
                        "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
                        "</a>" +
                        "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
                        "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
                        "</a>";
                },

                _start: function(event) {
                    if (!this.spinning && this._trigger("start", event) === false) {
                        return false;
                    }

                    if (!this.counter) {
                        this.counter = 1;
                    }
                    this.spinning = true;
                    return true;
                },

                _repeat: function(i, steps, event) {
                    i = i || 500;

                    clearTimeout(this.timer);
                    this.timer = this._delay(function() {
                        this._repeat(40, steps, event);
                    }, i);

                    this._spin(steps * this.options.step, event);
                },

                _spin: function(step, event) {
                    var value = this.value() || 0;

                    if (!this.counter) {
                        this.counter = 1;
                    }

                    value = this._adjustValue(value + step * this._increment(this.counter));

                    if (!this.spinning || this._trigger("spin", event, {
                            value: value
                        }) !== false) {
                        this._value(value);
                        this.counter++;
                    }
                },

                _increment: function(i) {
                    var incremental = this.options.incremental;

                    if (incremental) {
                        return $.isFunction(incremental) ?
                            incremental(i) :
                            Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
                    }

                    return 1;
                },

                _precision: function() {
                    var precision = this._precisionOf(this.options.step);
                    if (this.options.min !== null) {
                        precision = Math.max(precision, this._precisionOf(this.options.min));
                    }
                    return precision;
                },

                _precisionOf: function(num) {
                    var str = num.toString(),
                        decimal = str.indexOf(".");
                    return decimal === -1 ? 0 : str.length - decimal - 1;
                },

                _adjustValue: function(value) {
                    var base, aboveMin,
                        options = this.options;

                    // make sure we're at a valid step
                    // - find out where we are relative to the base (min or 0)
                    base = options.min !== null ? options.min : 0;
                    aboveMin = value - base;
                    // - round to the nearest step
                    aboveMin = Math.round(aboveMin / options.step) * options.step;
                    // - rounding is based on 0, so adjust back to our base
                    value = base + aboveMin;

                    // fix precision from bad JS floating point math
                    value = parseFloat(value.toFixed(this._precision()));

                    // clamp the value
                    if (options.max !== null && value > options.max) {
                        return options.max;
                    }
                    if (options.min !== null && value < options.min) {
                        return options.min;
                    }

                    return value;
                },

                _stop: function(event) {
                    if (!this.spinning) {
                        return;
                    }

                    clearTimeout(this.timer);
                    clearTimeout(this.mousewheelTimer);
                    this.counter = 0;
                    this.spinning = false;
                    this._trigger("stop", event);
                },

                _setOption: function(key, value) {
                    if (key === "culture" || key === "numberFormat") {
                        var prevValue = this._parse(this.element.val());
                        this.options[key] = value;
                        this.element.val(this._format(prevValue));
                        return;
                    }

                    if (key === "max" || key === "min" || key === "step") {
                        if (typeof value === "string") {
                            value = this._parse(value);
                        }
                    }
                    if (key === "icons") {
                        this.buttons.first().find(".ui-icon")
                            .removeClass(this.options.icons.up)
                            .addClass(value.up);
                        this.buttons.last().find(".ui-icon")
                            .removeClass(this.options.icons.down)
                            .addClass(value.down);
                    }

                    this._super(key, value);

                    if (key === "disabled") {
                        if (value) {
                            this.element.prop("disabled", true);
                            this.buttons.button("disable");
                        } else {
                            this.element.prop("disabled", false);
                            this.buttons.button("enable");
                        }
                    }
                },

                _setOptions: modifier(function(options) {
                    this._super(options);
                    this._value(this.element.val());
                }),

                _parse: function(val) {
                    if (typeof val === "string" && val !== "") {
                        val = window.Globalize && this.options.numberFormat ?
                            Globalize.parseFloat(val, 10, this.options.culture) : +val;
                    }
                    return val === "" || isNaN(val) ? null : val;
                },

                _format: function(value) {
                    if (value === "") {
                        return "";
                    }
                    return window.Globalize && this.options.numberFormat ?
                        Globalize.format(value, this.options.numberFormat, this.options.culture) :
                        value;
                },

                _refresh: function() {
                    this.element.attr({
                        "aria-valuemin": this.options.min,
                        "aria-valuemax": this.options.max,
                        // TODO: what should we do with values that can't be parsed?
                        "aria-valuenow": this._parse(this.element.val())
                    });
                },

                // update the value without triggering change
                _value: function(value, allowAny) {
                    var parsed;
                    if (value !== "") {
                        parsed = this._parse(value);
                        if (parsed !== null) {
                            if (!allowAny) {
                                parsed = this._adjustValue(parsed);
                            }
                            value = this._format(parsed);
                        }
                    }
                    this.element.val(value);
                    this._refresh();
                },

                _destroy: function() {
                    this.element
                        .removeClass("ui-spinner-input")
                        .prop("disabled", false)
                        .removeAttr("autocomplete")
                        .removeAttr("role")
                        .removeAttr("aria-valuemin")
                        .removeAttr("aria-valuemax")
                        .removeAttr("aria-valuenow");
                    this.uiSpinner.replaceWith(this.element);
                },

                stepUp: modifier(function(steps) {
                    this._stepUp(steps);
                }),
                _stepUp: function(steps) {
                    if (this._start()) {
                        this._spin((steps || 1) * this.options.step);
                        this._stop();
                    }
                },

                stepDown: modifier(function(steps) {
                    this._stepDown(steps);
                }),
                _stepDown: function(steps) {
                    if (this._start()) {
                        this._spin((steps || 1) * -this.options.step);
                        this._stop();
                    }
                },

                pageUp: modifier(function(pages) {
                    this._stepUp((pages || 1) * this.options.page);
                }),

                pageDown: modifier(function(pages) {
                    this._stepDown((pages || 1) * this.options.page);
                }),

                value: function(newVal) {
                    if (!arguments.length) {
                        return this._parse(this.element.val());
                    }
                    modifier(this._value).call(this, newVal);
                },

                widget: function() {
                    return this.uiSpinner;
                }
            });

        }(jQuery));

        (function($, undefined) {

            var tabId = 0,
                rhash = /#.*$/;

            function getNextTabId() {
                return ++tabId;
            }

            function isLocal(anchor) {
                return anchor.hash.length > 1 &&
                    decodeURIComponent(anchor.href.replace(rhash, "")) ===
                    decodeURIComponent(location.href.replace(rhash, ""));
            }

            $.widget("ui.tabs", {
                version: "1.10.3",
                delay: 300,
                options: {
                    active: null,
                    collapsible: false,
                    event: "click",
                    heightStyle: "content",
                    hide: null,
                    show: null,

                    // callbacks
                    activate: null,
                    beforeActivate: null,
                    beforeLoad: null,
                    load: null
                },

                _create: function() {
                    var that = this,
                        options = this.options;

                    this.running = false;

                    this.element
                        .addClass("ui-tabs ui-widget ui-widget-content ui-corner-all")
                        .toggleClass("ui-tabs-collapsible", options.collapsible)
                        // Prevent users from focusing disabled tabs via click
                        .delegate(".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function(event) {
                            if ($(this).is(".ui-state-disabled")) {
                                event.preventDefault();
                            }
                        })
                        // support: IE <9
                        // Preventing the default action in mousedown doesn't prevent IE
                        // from focusing the element, so if the anchor gets focused, blur.
                        // We don't have to worry about focusing the previously focused
                        // element since clicking on a non-focusable element should focus
                        // the body anyway.
                        .delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                            if ($(this).closest("li").is(".ui-state-disabled")) {
                                this.blur();
                            }
                        });

                    this._processTabs();
                    options.active = this._initialActive();

                    // Take disabling tabs via class attribute from HTML
                    // into account and update option properly.
                    if ($.isArray(options.disabled)) {
                        options.disabled = $.unique(options.disabled.concat(
                            $.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                                return that.tabs.index(li);
                            })
                        )).sort();
                    }

                    // check for length avoids error when initializing empty list
                    if (this.options.active !== false && this.anchors.length) {
                        this.active = this._findActive(options.active);
                    } else {
                        this.active = $();
                    }

                    this._refresh();

                    if (this.active.length) {
                        this.load(options.active);
                    }
                },

                _initialActive: function() {
                    var active = this.options.active,
                        collapsible = this.options.collapsible,
                        locationHash = location.hash.substring(1);

                    if (active === null) {
                        // check the fragment identifier in the URL
                        if (locationHash) {
                            this.tabs.each(function(i, tab) {
                                if ($(tab).attr("aria-controls") === locationHash) {
                                    active = i;
                                    return false;
                                }
                            });
                        }

                        // check for a tab marked active via a class
                        if (active === null) {
                            active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                        }

                        // no active tab, set to false
                        if (active === null || active === -1) {
                            active = this.tabs.length ? 0 : false;
                        }
                    }

                    // handle numbers: negative, out of range
                    if (active !== false) {
                        active = this.tabs.index(this.tabs.eq(active));
                        if (active === -1) {
                            active = collapsible ? false : 0;
                        }
                    }

                    // don't allow collapsible: false and active: false
                    if (!collapsible && active === false && this.anchors.length) {
                        active = 0;
                    }

                    return active;
                },

                _getCreateEventData: function() {
                    return {
                        tab: this.active,
                        panel: !this.active.length ? $() : this._getPanelForTab(this.active)
                    };
                },

                _tabKeydown: function(event) {
                    /*jshint maxcomplexity:15*/
                    var focusedTab = $(this.document[0].activeElement).closest("li"),
                        selectedIndex = this.tabs.index(focusedTab),
                        goingForward = true;

                    if (this._handlePageNav(event)) {
                        return;
                    }

                    switch (event.keyCode) {
                        case $.ui.keyCode.RIGHT:
                        case $.ui.keyCode.DOWN:
                            selectedIndex++;
                            break;
                        case $.ui.keyCode.UP:
                        case $.ui.keyCode.LEFT:
                            goingForward = false;
                            selectedIndex--;
                            break;
                        case $.ui.keyCode.END:
                            selectedIndex = this.anchors.length - 1;
                            break;
                        case $.ui.keyCode.HOME:
                            selectedIndex = 0;
                            break;
                        case $.ui.keyCode.SPACE:
                            // Activate only, no collapsing
                            event.preventDefault();
                            clearTimeout(this.activating);
                            this._activate(selectedIndex);
                            return;
                        case $.ui.keyCode.ENTER:
                            // Toggle (cancel delayed activation, allow collapsing)
                            event.preventDefault();
                            clearTimeout(this.activating);
                            // Determine if we should collapse or activate
                            this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                            return;
                        default:
                            return;
                    }

                    // Focus the appropriate tab, based on which key was pressed
                    event.preventDefault();
                    clearTimeout(this.activating);
                    selectedIndex = this._focusNextTab(selectedIndex, goingForward);

                    // Navigating with control key will prevent automatic activation
                    if (!event.ctrlKey) {
                        // Update aria-selected immediately so that AT think the tab is already selected.
                        // Otherwise AT may confuse the user by stating that they need to activate the tab,
                        // but the tab will already be activated by the time the announcement finishes.
                        focusedTab.attr("aria-selected", "false");
                        this.tabs.eq(selectedIndex).attr("aria-selected", "true");

                        this.activating = this._delay(function() {
                            this.option("active", selectedIndex);
                        }, this.delay);
                    }
                },

                _panelKeydown: function(event) {
                    if (this._handlePageNav(event)) {
                        return;
                    }

                    // Ctrl+up moves focus to the current tab
                    if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                        event.preventDefault();
                        this.active.focus();
                    }
                },

                // Alt+page up/down moves focus to the previous/next tab (and activates)
                _handlePageNav: function(event) {
                    if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                        this._activate(this._focusNextTab(this.options.active - 1, false));
                        return true;
                    }
                    if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                        this._activate(this._focusNextTab(this.options.active + 1, true));
                        return true;
                    }
                },

                _findNextTab: function(index, goingForward) {
                    var lastTabIndex = this.tabs.length - 1;

                    function constrain() {
                        if (index > lastTabIndex) {
                            index = 0;
                        }
                        if (index < 0) {
                            index = lastTabIndex;
                        }
                        return index;
                    }

                    while ($.inArray(constrain(), this.options.disabled) !== -1) {
                        index = goingForward ? index + 1 : index - 1;
                    }

                    return index;
                },

                _focusNextTab: function(index, goingForward) {
                    index = this._findNextTab(index, goingForward);
                    this.tabs.eq(index).focus();
                    return index;
                },

                _setOption: function(key, value) {
                    if (key === "active") {
                        // _activate() will handle invalid values and update this.options
                        this._activate(value);
                        return;
                    }

                    if (key === "disabled") {
                        // don't use the widget factory's disabled handling
                        this._setupDisabled(value);
                        return;
                    }

                    this._super(key, value);

                    if (key === "collapsible") {
                        this.element.toggleClass("ui-tabs-collapsible", value);
                        // Setting collapsible: false while collapsed; open first panel
                        if (!value && this.options.active === false) {
                            this._activate(0);
                        }
                    }

                    if (key === "event") {
                        this._setupEvents(value);
                    }

                    if (key === "heightStyle") {
                        this._setupHeightStyle(value);
                    }
                },

                _tabId: function(tab) {
                    return tab.attr("aria-controls") || "ui-tabs-" + getNextTabId();
                },

                _sanitizeSelector: function(hash) {
                    return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
                },

                refresh: function() {
                    var options = this.options,
                        lis = this.tablist.children(":has(a[href])");

                    // get disabled tabs from class attribute from HTML
                    // this will get converted to a boolean if needed in _refresh()
                    options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                        return lis.index(tab);
                    });

                    this._processTabs();

                    // was collapsed or no tabs
                    if (options.active === false || !this.anchors.length) {
                        options.active = false;
                        this.active = $();
                        // was active, but active tab is gone
                    } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                        // all remaining tabs are disabled
                        if (this.tabs.length === options.disabled.length) {
                            options.active = false;
                            this.active = $();
                            // activate previous tab
                        } else {
                            this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                        }
                        // was active, active tab still exists
                    } else {
                        // make sure active index is correct
                        options.active = this.tabs.index(this.active);
                    }

                    this._refresh();
                },

                _refresh: function() {
                    this._setupDisabled(this.options.disabled);
                    this._setupEvents(this.options.event);
                    this._setupHeightStyle(this.options.heightStyle);

                    this.tabs.not(this.active).attr({
                        "aria-selected": "false",
                        tabIndex: -1
                    });
                    this.panels.not(this._getPanelForTab(this.active))
                        .hide()
                        .attr({
                            "aria-expanded": "false",
                            "aria-hidden": "true"
                        });

                    // Make sure one tab is in the tab order
                    if (!this.active.length) {
                        this.tabs.eq(0).attr("tabIndex", 0);
                    } else {
                        this.active
                            .addClass("ui-tabs-active ui-state-active")
                            .attr({
                                "aria-selected": "true",
                                tabIndex: 0
                            });
                        this._getPanelForTab(this.active)
                            .show()
                            .attr({
                                "aria-expanded": "true",
                                "aria-hidden": "false"
                            });
                    }
                },

                _processTabs: function() {
                    var that = this;

                    this.tablist = this._getList()
                        .addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all")
                        .attr("role", "tablist");

                    this.tabs = this.tablist.find("> li:has(a[href])")
                        .addClass("ui-state-default ui-corner-top")
                        .attr({
                            role: "tab",
                            tabIndex: -1
                        });

                    this.anchors = this.tabs.map(function() {
                            return $("a", this)[0];
                        })
                        .addClass("ui-tabs-anchor")
                        .attr({
                            role: "presentation",
                            tabIndex: -1
                        });

                    this.panels = $();

                    this.anchors.each(function(i, anchor) {
                        var selector, panel, panelId,
                            anchorId = $(anchor).uniqueId().attr("id"),
                            tab = $(anchor).closest("li"),
                            originalAriaControls = tab.attr("aria-controls");

                        // inline tab
                        if (isLocal(anchor)) {
                            selector = anchor.hash;
                            panel = that.element.find(that._sanitizeSelector(selector));
                            // remote tab
                        } else {
                            panelId = that._tabId(tab);
                            selector = "#" + panelId;
                            panel = that.element.find(selector);
                            if (!panel.length) {
                                panel = that._createPanel(panelId);
                                panel.insertAfter(that.panels[i - 1] || that.tablist);
                            }
                            panel.attr("aria-live", "polite");
                        }

                        if (panel.length) {
                            that.panels = that.panels.add(panel);
                        }
                        if (originalAriaControls) {
                            tab.data("ui-tabs-aria-controls", originalAriaControls);
                        }
                        tab.attr({
                            "aria-controls": selector.substring(1),
                            "aria-labelledby": anchorId
                        });
                        panel.attr("aria-labelledby", anchorId);
                    });

                    this.panels
                        .addClass("ui-tabs-panel ui-widget-content ui-corner-bottom")
                        .attr("role", "tabpanel");
                },

                // allow overriding how to find the list for rare usage scenarios (#7715)
                _getList: function() {
                    return this.element.find("ol,ul").eq(0);
                },

                _createPanel: function(id) {
                    return $("<div>")
                        .attr("id", id)
                        .addClass("ui-tabs-panel ui-widget-content ui-corner-bottom")
                        .data("ui-tabs-destroy", true);
                },

                _setupDisabled: function(disabled) {
                    if ($.isArray(disabled)) {
                        if (!disabled.length) {
                            disabled = false;
                        } else if (disabled.length === this.anchors.length) {
                            disabled = true;
                        }
                    }

                    // disable tabs
                    for (var i = 0, li;
                        (li = this.tabs[i]); i++) {
                        if (disabled === true || $.inArray(i, disabled) !== -1) {
                            $(li)
                                .addClass("ui-state-disabled")
                                .attr("aria-disabled", "true");
                        } else {
                            $(li)
                                .removeClass("ui-state-disabled")
                                .removeAttr("aria-disabled");
                        }
                    }

                    this.options.disabled = disabled;
                },

                _setupEvents: function(event) {
                    var events = {
                        click: function(event) {
                            event.preventDefault();
                        }
                    };
                    if (event) {
                        $.each(event.split(" "), function(index, eventName) {
                            events[eventName] = "_eventHandler";
                        });
                    }

                    this._off(this.anchors.add(this.tabs).add(this.panels));
                    this._on(this.anchors, events);
                    this._on(this.tabs, {
                        keydown: "_tabKeydown"
                    });
                    this._on(this.panels, {
                        keydown: "_panelKeydown"
                    });

                    this._focusable(this.tabs);
                    this._hoverable(this.tabs);
                },

                _setupHeightStyle: function(heightStyle) {
                    var maxHeight,
                        parent = this.element.parent();

                    if (heightStyle === "fill") {
                        maxHeight = parent.height();
                        maxHeight -= this.element.outerHeight() - this.element.height();

                        this.element.siblings(":visible").each(function() {
                            var elem = $(this),
                                position = elem.css("position");

                            if (position === "absolute" || position === "fixed") {
                                return;
                            }
                            maxHeight -= elem.outerHeight(true);
                        });

                        this.element.children().not(this.panels).each(function() {
                            maxHeight -= $(this).outerHeight(true);
                        });

                        this.panels.each(function() {
                                $(this).height(Math.max(0, maxHeight -
                                    $(this).innerHeight() + $(this).height()));
                            })
                            .css("overflow", "auto");
                    } else if (heightStyle === "auto") {
                        maxHeight = 0;
                        this.panels.each(function() {
                            maxHeight = Math.max(maxHeight, $(this).height("").height());
                        }).height(maxHeight);
                    }
                },

                _eventHandler: function(event) {
                    var options = this.options,
                        active = this.active,
                        anchor = $(event.currentTarget),
                        tab = anchor.closest("li"),
                        clickedIsActive = tab[0] === active[0],
                        collapsing = clickedIsActive && options.collapsible,
                        toShow = collapsing ? $() : this._getPanelForTab(tab),
                        toHide = !active.length ? $() : this._getPanelForTab(active),
                        eventData = {
                            oldTab: active,
                            oldPanel: toHide,
                            newTab: collapsing ? $() : tab,
                            newPanel: toShow
                        };

                    event.preventDefault();

                    if (tab.hasClass("ui-state-disabled") ||
                        // tab is already loading
                        tab.hasClass("ui-tabs-loading") ||
                        // can't switch durning an animation
                        this.running ||
                        // click on active header, but not collapsible
                        (clickedIsActive && !options.collapsible) ||
                        // allow canceling activation
                        (this._trigger("beforeActivate", event, eventData) === false)) {
                        return;
                    }

                    options.active = collapsing ? false : this.tabs.index(tab);

                    this.active = clickedIsActive ? $() : tab;
                    if (this.xhr) {
                        this.xhr.abort();
                    }

                    if (!toHide.length && !toShow.length) {
                        $.error("jQuery UI Tabs: Mismatching fragment identifier.");
                    }

                    if (toShow.length) {
                        this.load(this.tabs.index(tab), event);
                    }
                    this._toggle(event, eventData);
                },

                // handles show/hide for selecting tabs
                _toggle: function(event, eventData) {
                    var that = this,
                        toShow = eventData.newPanel,
                        toHide = eventData.oldPanel;

                    this.running = true;

                    function complete() {
                        that.running = false;
                        that._trigger("activate", event, eventData);
                    }

                    function show() {
                        eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");

                        if (toShow.length && that.options.show) {
                            that._show(toShow, that.options.show, complete);
                        } else {
                            toShow.show();
                            complete();
                        }
                    }

                    // start out by hiding, then showing, then completing
                    if (toHide.length && this.options.hide) {
                        this._hide(toHide, this.options.hide, function() {
                            eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                            show();
                        });
                    } else {
                        eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                        toHide.hide();
                        show();
                    }

                    toHide.attr({
                        "aria-expanded": "false",
                        "aria-hidden": "true"
                    });
                    eventData.oldTab.attr("aria-selected", "false");
                    // If we're switching tabs, remove the old tab from the tab order.
                    // If we're opening from collapsed state, remove the previous tab from the tab order.
                    // If we're collapsing, then keep the collapsing tab in the tab order.
                    if (toShow.length && toHide.length) {
                        eventData.oldTab.attr("tabIndex", -1);
                    } else if (toShow.length) {
                        this.tabs.filter(function() {
                                return $(this).attr("tabIndex") === 0;
                            })
                            .attr("tabIndex", -1);
                    }

                    toShow.attr({
                        "aria-expanded": "true",
                        "aria-hidden": "false"
                    });
                    eventData.newTab.attr({
                        "aria-selected": "true",
                        tabIndex: 0
                    });
                },

                _activate: function(index) {
                    var anchor,
                        active = this._findActive(index);

                    // trying to activate the already active panel
                    if (active[0] === this.active[0]) {
                        return;
                    }

                    // trying to collapse, simulate a click on the current active header
                    if (!active.length) {
                        active = this.active;
                    }

                    anchor = active.find(".ui-tabs-anchor")[0];
                    this._eventHandler({
                        target: anchor,
                        currentTarget: anchor,
                        preventDefault: $.noop
                    });
                },

                _findActive: function(index) {
                    return index === false ? $() : this.tabs.eq(index);
                },

                _getIndex: function(index) {
                    // meta-function to give users option to provide a href string instead of a numerical index.
                    if (typeof index === "string") {
                        index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
                    }

                    return index;
                },

                _destroy: function() {
                    if (this.xhr) {
                        this.xhr.abort();
                    }

                    this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");

                    this.tablist
                        .removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all")
                        .removeAttr("role");

                    this.anchors
                        .removeClass("ui-tabs-anchor")
                        .removeAttr("role")
                        .removeAttr("tabIndex")
                        .removeUniqueId();

                    this.tabs.add(this.panels).each(function() {
                        if ($.data(this, "ui-tabs-destroy")) {
                            $(this).remove();
                        } else {
                            $(this)
                                .removeClass("ui-state-default ui-state-active ui-state-disabled " +
                                    "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel")
                                .removeAttr("tabIndex")
                                .removeAttr("aria-live")
                                .removeAttr("aria-busy")
                                .removeAttr("aria-selected")
                                .removeAttr("aria-labelledby")
                                .removeAttr("aria-hidden")
                                .removeAttr("aria-expanded")
                                .removeAttr("role");
                        }
                    });

                    this.tabs.each(function() {
                        var li = $(this),
                            prev = li.data("ui-tabs-aria-controls");
                        if (prev) {
                            li
                                .attr("aria-controls", prev)
                                .removeData("ui-tabs-aria-controls");
                        } else {
                            li.removeAttr("aria-controls");
                        }
                    });

                    this.panels.show();

                    if (this.options.heightStyle !== "content") {
                        this.panels.css("height", "");
                    }
                },

                enable: function(index) {
                    var disabled = this.options.disabled;
                    if (disabled === false) {
                        return;
                    }

                    if (index === undefined) {
                        disabled = false;
                    } else {
                        index = this._getIndex(index);
                        if ($.isArray(disabled)) {
                            disabled = $.map(disabled, function(num) {
                                return num !== index ? num : null;
                            });
                        } else {
                            disabled = $.map(this.tabs, function(li, num) {
                                return num !== index ? num : null;
                            });
                        }
                    }
                    this._setupDisabled(disabled);
                },

                disable: function(index) {
                    var disabled = this.options.disabled;
                    if (disabled === true) {
                        return;
                    }

                    if (index === undefined) {
                        disabled = true;
                    } else {
                        index = this._getIndex(index);
                        if ($.inArray(index, disabled) !== -1) {
                            return;
                        }
                        if ($.isArray(disabled)) {
                            disabled = $.merge([index], disabled).sort();
                        } else {
                            disabled = [index];
                        }
                    }
                    this._setupDisabled(disabled);
                },

                load: function(index, event) {
                    index = this._getIndex(index);
                    var that = this,
                        tab = this.tabs.eq(index),
                        anchor = tab.find(".ui-tabs-anchor"),
                        panel = this._getPanelForTab(tab),
                        eventData = {
                            tab: tab,
                            panel: panel
                        };

                    // not remote
                    if (isLocal(anchor[0])) {
                        return;
                    }

                    this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));

                    // support: jQuery <1.8
                    // jQuery <1.8 returns false if the request is canceled in beforeSend,
                    // but as of 1.8, $.ajax() always returns a jqXHR object.
                    if (this.xhr && this.xhr.statusText !== "canceled") {
                        tab.addClass("ui-tabs-loading");
                        panel.attr("aria-busy", "true");

                        this.xhr
                            .success(function(response) {
                                // support: jQuery <1.8
                                // http://bugs.jquery.com/ticket/11778
                                setTimeout(function() {
                                    panel.html(response);
                                    that._trigger("load", event, eventData);
                                }, 1);
                            })
                            .complete(function(jqXHR, status) {
                                // support: jQuery <1.8
                                // http://bugs.jquery.com/ticket/11778
                                setTimeout(function() {
                                    if (status === "abort") {
                                        that.panels.stop(false, true);
                                    }

                                    tab.removeClass("ui-tabs-loading");
                                    panel.removeAttr("aria-busy");

                                    if (jqXHR === that.xhr) {
                                        delete that.xhr;
                                    }
                                }, 1);
                            });
                    }
                },

                _ajaxSettings: function(anchor, event, eventData) {
                    var that = this;
                    return {
                        url: anchor.attr("href"),
                        beforeSend: function(jqXHR, settings) {
                            return that._trigger("beforeLoad", event,
                                $.extend({
                                    jqXHR: jqXHR,
                                    ajaxSettings: settings
                                }, eventData));
                        }
                    };
                },

                _getPanelForTab: function(tab) {
                    var id = $(tab).attr("aria-controls");
                    return this.element.find(this._sanitizeSelector("#" + id));
                }
            });

        })(jQuery);

        (function($) {

            var increments = 0;

            function addDescribedBy(elem, id) {
                var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
                describedby.push(id);
                elem
                    .data("ui-tooltip-id", id)
                    .attr("aria-describedby", $.trim(describedby.join(" ")));
            }

            function removeDescribedBy(elem) {
                var id = elem.data("ui-tooltip-id"),
                    describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
                    index = $.inArray(id, describedby);
                if (index !== -1) {
                    describedby.splice(index, 1);
                }

                elem.removeData("ui-tooltip-id");
                describedby = $.trim(describedby.join(" "));
                if (describedby) {
                    elem.attr("aria-describedby", describedby);
                } else {
                    elem.removeAttr("aria-describedby");
                }
            }

            $.widget("ui.tooltip", {
                version: "1.10.3",
                options: {
                    content: function() {
                        // support: IE<9, Opera in jQuery <1.7
                        // .text() can't accept undefined, so coerce to a string
                        var title = $(this).attr("title") || "";
                        // Escape title, since we're going from an attribute to raw HTML
                        return $("<a>").text(title).html();
                    },
                    hide: true,
                    // Disabled elements have inconsistent behavior across browsers (#8661)
                    items: "[title]:not([disabled])",
                    position: {
                        my: "left top+15",
                        at: "left bottom",
                        collision: "flipfit flip"
                    },
                    show: true,
                    tooltipClass: null,
                    track: false,

                    // callbacks
                    close: null,
                    open: null
                },

                _create: function() {
                    this._on({
                        mouseover: "open",
                        focusin: "open"
                    });

                    // IDs of generated tooltips, needed for destroy
                    this.tooltips = {};
                    // IDs of parent tooltips where we removed the title attribute
                    this.parents = {};

                    if (this.options.disabled) {
                        this._disable();
                    }
                },

                _setOption: function(key, value) {
                    var that = this;

                    if (key === "disabled") {
                        this[value ? "_disable" : "_enable"]();
                        this.options[key] = value;
                        // disable element style changes
                        return;
                    }

                    this._super(key, value);

                    if (key === "content") {
                        $.each(this.tooltips, function(id, element) {
                            that._updateContent(element);
                        });
                    }
                },

                _disable: function() {
                    var that = this;

                    // close open tooltips
                    $.each(this.tooltips, function(id, element) {
                        var event = $.Event("blur");
                        event.target = event.currentTarget = element[0];
                        that.close(event, true);
                    });

                    // remove title attributes to prevent native tooltips
                    this.element.find(this.options.items).addBack().each(function() {
                        var element = $(this);
                        if (element.is("[title]")) {
                            element
                                .data("ui-tooltip-title", element.attr("title"))
                                .attr("title", "");
                        }
                    });
                },

                _enable: function() {
                    // restore title attributes
                    this.element.find(this.options.items).addBack().each(function() {
                        var element = $(this);
                        if (element.data("ui-tooltip-title")) {
                            element.attr("title", element.data("ui-tooltip-title"));
                        }
                    });
                },

                open: function(event) {
                    var that = this,
                        target = $(event ? event.target : this.element)
                        // we need closest here due to mouseover bubbling,
                        // but always pointing at the same event target
                        .closest(this.options.items);

                    // No element to show a tooltip for or the tooltip is already open
                    if (!target.length || target.data("ui-tooltip-id")) {
                        return;
                    }

                    if (target.attr("title")) {
                        target.data("ui-tooltip-title", target.attr("title"));
                    }

                    target.data("ui-tooltip-open", true);

                    // kill parent tooltips, custom or native, for hover
                    if (event && event.type === "mouseover") {
                        target.parents().each(function() {
                            var parent = $(this),
                                blurEvent;
                            if (parent.data("ui-tooltip-open")) {
                                blurEvent = $.Event("blur");
                                blurEvent.target = blurEvent.currentTarget = this;
                                that.close(blurEvent, true);
                            }
                            if (parent.attr("title")) {
                                parent.uniqueId();
                                that.parents[this.id] = {
                                    element: this,
                                    title: parent.attr("title")
                                };
                                parent.attr("title", "");
                            }
                        });
                    }

                    this._updateContent(target, event);
                },

                _updateContent: function(target, event) {
                    var content,
                        contentOption = this.options.content,
                        that = this,
                        eventType = event ? event.type : null;

                    if (typeof contentOption === "string") {
                        return this._open(event, target, contentOption);
                    }

                    content = contentOption.call(target[0], function(response) {
                        // ignore async response if tooltip was closed already
                        if (!target.data("ui-tooltip-open")) {
                            return;
                        }
                        // IE may instantly serve a cached response for ajax requests
                        // delay this call to _open so the other call to _open runs first
                        that._delay(function() {
                            // jQuery creates a special event for focusin when it doesn't
                            // exist natively. To improve performance, the native event
                            // object is reused and the type is changed. Therefore, we can't
                            // rely on the type being correct after the event finished
                            // bubbling, so we set it back to the previous value. (#8740)
                            if (event) {
                                event.type = eventType;
                            }
                            this._open(event, target, response);
                        });
                    });
                    if (content) {
                        this._open(event, target, content);
                    }
                },

                _open: function(event, target, content) {
                    var tooltip, events, delayedShow,
                        positionOption = $.extend({}, this.options.position);

                    if (!content) {
                        return;
                    }

                    // Content can be updated multiple times. If the tooltip already
                    // exists, then just update the content and bail.
                    tooltip = this._find(target);
                    if (tooltip.length) {
                        tooltip.find(".ui-tooltip-content").html(content);
                        return;
                    }

                    // if we have a title, clear it to prevent the native tooltip
                    // we have to check first to avoid defining a title if none exists
                    // (we don't want to cause an element to start matching [title])
                    //
                    // We use removeAttr only for key events, to allow IE to export the correct
                    // accessible attributes. For mouse events, set to empty string to avoid
                    // native tooltip showing up (happens only when removing inside mouseover).
                    if (target.is("[title]")) {
                        if (event && event.type === "mouseover") {
                            target.attr("title", "");
                        } else {
                            target.removeAttr("title");
                        }
                    }

                    tooltip = this._tooltip(target);
                    addDescribedBy(target, tooltip.attr("id"));
                    tooltip.find(".ui-tooltip-content").html(content);

                    function position(event) {
                        positionOption.of = event;
                        if (tooltip.is(":hidden")) {
                            return;
                        }
                        tooltip.position(positionOption);
                    }
                    if (this.options.track && event && /^mouse/.test(event.type)) {
                        this._on(this.document, {
                            mousemove: position
                        });
                        // trigger once to override element-relative positioning
                        position(event);
                    } else {
                        tooltip.position($.extend({ of: target
                        }, this.options.position));
                    }

                    tooltip.hide();

                    this._show(tooltip, this.options.show);
                    // Handle tracking tooltips that are shown with a delay (#8644). As soon
                    // as the tooltip is visible, position the tooltip using the most recent
                    // event.
                    if (this.options.show && this.options.show.delay) {
                        delayedShow = this.delayedShow = setInterval(function() {
                            if (tooltip.is(":visible")) {
                                position(positionOption.of);
                                clearInterval(delayedShow);
                            }
                        }, $.fx.interval);
                    }

                    this._trigger("open", event, {
                        tooltip: tooltip
                    });

                    events = {
                        keyup: function(event) {
                            if (event.keyCode === $.ui.keyCode.ESCAPE) {
                                var fakeEvent = $.Event(event);
                                fakeEvent.currentTarget = target[0];
                                this.close(fakeEvent, true);
                            }
                        },
                        remove: function() {
                            this._removeTooltip(tooltip);
                        }
                    };
                    if (!event || event.type === "mouseover") {
                        events.mouseleave = "close";
                    }
                    if (!event || event.type === "focusin") {
                        events.focusout = "close";
                    }
                    this._on(true, target, events);
                },

                close: function(event) {
                    var that = this,
                        target = $(event ? event.currentTarget : this.element),
                        tooltip = this._find(target);

                    // disabling closes the tooltip, so we need to track when we're closing
                    // to avoid an infinite loop in case the tooltip becomes disabled on close
                    if (this.closing) {
                        return;
                    }

                    // Clear the interval for delayed tracking tooltips
                    clearInterval(this.delayedShow);

                    // only set title if we had one before (see comment in _open())
                    if (target.data("ui-tooltip-title")) {
                        target.attr("title", target.data("ui-tooltip-title"));
                    }

                    removeDescribedBy(target);

                    tooltip.stop(true);
                    this._hide(tooltip, this.options.hide, function() {
                        that._removeTooltip($(this));
                    });

                    target.removeData("ui-tooltip-open");
                    this._off(target, "mouseleave focusout keyup");
                    // Remove 'remove' binding only on delegated targets
                    if (target[0] !== this.element[0]) {
                        this._off(target, "remove");
                    }
                    this._off(this.document, "mousemove");

                    if (event && event.type === "mouseleave") {
                        $.each(this.parents, function(id, parent) {
                            $(parent.element).attr("title", parent.title);
                            delete that.parents[id];
                        });
                    }

                    this.closing = true;
                    this._trigger("close", event, {
                        tooltip: tooltip
                    });
                    this.closing = false;
                },

                _tooltip: function(element) {
                    var id = "ui-tooltip-" + increments++,
                        tooltip = $("<div>")
                        .attr({
                            id: id,
                            role: "tooltip"
                        })
                        .addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " +
                            (this.options.tooltipClass || ""));
                    $("<div>")
                        .addClass("ui-tooltip-content")
                        .appendTo(tooltip);
                    tooltip.appendTo(this.document[0].body);
                    this.tooltips[id] = element;
                    return tooltip;
                },

                _find: function(target) {
                    var id = target.data("ui-tooltip-id");
                    return id ? $("#" + id) : $();
                },

                _removeTooltip: function(tooltip) {
                    tooltip.remove();
                    delete this.tooltips[tooltip.attr("id")];
                },

                _destroy: function() {
                    var that = this;

                    // close open tooltips
                    $.each(this.tooltips, function(id, element) {
                        // Delegate to close method to handle common cleanup
                        var event = $.Event("blur");
                        event.target = event.currentTarget = element[0];
                        that.close(event, true);

                        // Remove immediately; destroying an open tooltip doesn't use the
                        // hide animation
                        $("#" + id).remove();

                        // Restore the title
                        if (element.data("ui-tooltip-title")) {
                            element.attr("title", element.data("ui-tooltip-title"));
                            element.removeData("ui-tooltip-title");
                        }
                    });
                }
            });

        }(jQuery));


        /***/
    }),
    /* 132 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        (function(factory, window) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof exports === 'object') {
                module.exports = factory(require('leaflet'));
            }
            if (typeof window !== 'undefined' && window.L) {
                window.L.PolylineOffset = factory(L);
            }
        }(function(L) {

            function forEachPair(list, callback) {
                if (!list || list.length < 1) {
                    return;
                }
                for (var i = 1, l = list.length; i < l; i++) {
                    callback(list[i - 1], list[i]);
                }
            }

            /**
            Find the coefficients (a,b) of a line of equation y = a.x + b,
            or the constant x for vertical lines
            Return null if there's no equation possible
            */
            function lineEquation(pt1, pt2) {
                if (pt1.x === pt2.x) {
                    return pt1.y === pt2.y ? null : {
                        x: pt1.x
                    };
                }

                var a = (pt2.y - pt1.y) / (pt2.x - pt1.x);
                return {
                    a: a,
                    b: pt1.y - a * pt1.x,
                };
            }

            /**
            Return the intersection point of two lines defined by two points each
            Return null when there's no unique intersection
            */
            function intersection(l1a, l1b, l2a, l2b) {
                var line1 = lineEquation(l1a, l1b);
                var line2 = lineEquation(l2a, l2b);

                if (line1 === null || line2 === null) {
                    return null;
                }

                if (line1.hasOwnProperty('x')) {
                    return line2.hasOwnProperty('x') ?
                        null :
                        {
                            x: line1.x,
                            y: line2.a * line1.x + line2.b,
                        };
                }
                if (line2.hasOwnProperty('x')) {
                    return {
                        x: line2.x,
                        y: line1.a * line2.x + line1.b,
                    };
                }

                if (line1.a === line2.a) {
                    return null;
                }

                var x = (line2.b - line1.b) / (line1.a - line2.a);
                return {
                    x: x,
                    y: line1.a * x + line1.b,
                };
            }

            function translatePoint(pt, dist, heading) {
                return {
                    x: pt.x + dist * Math.cos(heading),
                    y: pt.y + dist * Math.sin(heading),
                };
            }

            var PolylineOffset = {
                offsetPointLine: function(points, distance) {
                    var offsetSegments = [];

                    forEachPair(points, L.bind(function(a, b) {
                        if (a.x === b.x && a.y === b.y) {
                            return;
                        }

                        // angles in (-PI, PI]
                        var segmentAngle = Math.atan2(a.y - b.y, a.x - b.x);
                        var offsetAngle = segmentAngle - Math.PI / 2;

                        offsetSegments.push({
                            offsetAngle: offsetAngle,
                            original: [a, b],
                            offset: [
                                translatePoint(a, distance, offsetAngle),
                                translatePoint(b, distance, offsetAngle)
                            ]
                        });
                    }, this));

                    return offsetSegments;
                },

                offsetPoints: function(pts, offset) {
                    var offsetSegments = this.offsetPointLine(pts, offset);
                    return this.joinLineSegments(offsetSegments, offset);
                },

                /**
                Join 2 line segments defined by 2 points each with a circular arc
                */
                joinSegments: function(s1, s2, offset) {
                    // TODO: different join styles
                    return this.circularArc(s1, s2, offset)
                        .filter(function(x) {
                            return x;
                        })
                },

                joinLineSegments: function(segments, offset) {
                    var joinedPoints = [];
                    var first = segments[0];
                    var last = segments[segments.length - 1];

                    if (first && last) {
                        joinedPoints.push(first.offset[0]);
                        forEachPair(segments, L.bind(function(s1, s2) {
                            joinedPoints = joinedPoints.concat(this.joinSegments(s1, s2, offset));
                        }, this));
                        joinedPoints.push(last.offset[1]);
                    }

                    return joinedPoints;
                },

                segmentAsVector: function(s) {
                    return {
                        x: s[1].x - s[0].x,
                        y: s[1].y - s[0].y,
                    };
                },

                getSignedAngle: function(s1, s2) {
                    const a = this.segmentAsVector(s1);
                    const b = this.segmentAsVector(s2);
                    return Math.atan2(a.x * b.y - a.y * b.x, a.x * b.x + a.y * b.y);
                },

                /**
                Interpolates points between two offset segments in a circular form
                */
                circularArc: function(s1, s2, distance) {
                    // if the segments are the same angle,
                    // there should be a single join point
                    if (s1.offsetAngle === s2.offsetAngle) {
                        return [s1.offset[1]];
                    }

                    const signedAngle = this.getSignedAngle(s1.offset, s2.offset);
                    // for inner angles, just find the offset segments intersection
                    if ((signedAngle * distance > 0) &&
                        (signedAngle * this.getSignedAngle(s1.offset, [s1.offset[0], s2.offset[1]]) > 0)) {
                        return [intersection(s1.offset[0], s1.offset[1], s2.offset[0], s2.offset[1])];
                    }

                    // draws a circular arc with R = offset distance, C = original meeting point
                    var points = [];
                    var center = s1.original[1];
                    // ensure angles go in the anti-clockwise direction
                    var rightOffset = distance > 0;
                    var startAngle = rightOffset ? s2.offsetAngle : s1.offsetAngle;
                    var endAngle = rightOffset ? s1.offsetAngle : s2.offsetAngle;
                    // and that the end angle is bigger than the start angle
                    if (endAngle < startAngle) {
                        endAngle += Math.PI * 2;
                    }
                    var step = Math.PI / 8;
                    for (var alpha = startAngle; alpha < endAngle; alpha += step) {
                        points.push(translatePoint(center, distance, alpha));
                    }
                    points.push(translatePoint(center, distance, endAngle));

                    return rightOffset ? points.reverse() : points;
                }
            }

            // Modify the L.Polyline class by overwriting the projection function
            L.Polyline.include({
                _projectLatlngs: function(latlngs, result, projectedBounds) {
                    var isFlat = latlngs.length > 0 && latlngs[0] instanceof L.LatLng;

                    if (isFlat) {
                        var ring = latlngs.map(L.bind(function(ll) {
                            var point = this._map.latLngToLayerPoint(ll);
                            if (projectedBounds) {
                                projectedBounds.extend(point);
                            }
                            return point;
                        }, this));

                        // Offset management hack ---
                        if (this.options.offset) {
                            ring = L.PolylineOffset.offsetPoints(ring, this.options.offset);
                        }
                        // Offset management hack END ---

                        result.push(ring);
                    } else {
                        latlngs.forEach(L.bind(function(ll) {
                            this._projectLatlngs(ll, result, projectedBounds);
                        }, this));
                    }
                }
            });

            L.Polyline.include({
                setOffset: function(offset) {
                    this.options.offset = offset;
                    this.redraw();
                    return this;
                }
            });

            return PolylineOffset;

        }, window));


        /***/
    }),
    /* 133 */
    /***/
    (function(module, exports) {

        /*
         * Leaflet.locationfilter - leaflet location filter plugin
         * Copyright (C) 2012, Tripbirds.com
         * http://tripbirds.com
         *
         * Licensed under the MIT License.
         *
         * Date: 2012-09-24
         * Version: 0.1
         */
        L.LatLngBounds.prototype.modify = function(map, amount) {
            var sw = this.getSouthWest(),
                ne = this.getNorthEast(),
                swPoint = map.latLngToLayerPoint(sw),
                nePoint = map.latLngToLayerPoint(ne);

            sw = map.layerPointToLatLng(new L.Point(swPoint.x - amount, swPoint.y + amount));
            ne = map.layerPointToLatLng(new L.Point(nePoint.x + amount, nePoint.y - amount));

            return new L.LatLngBounds(sw, ne);
        };

        L.Control.Button = L.Class.extend({
            initialize: function(options) {
                L.Util.setOptions(this, options);
            },

            addTo: function(container) {
                container.addButton(this);
                return this;
            },

            onAdd: function(buttonContainer) {
                this._buttonContainer = buttonContainer;
                this._button = L.DomUtil.create('a', this.options.className, this._buttonContainer.getContainer());
                this._button.href = '#';
                this.setText(this.options.text);

                var that = this;
                this._onClick = function(event) {
                    that.options.onClick.call(that, event);
                };

                L.DomEvent
                    .on(this._button, 'click', L.DomEvent.stopPropagation)
                    .on(this._button, 'mousedown', L.DomEvent.stopPropagation)
                    .on(this._button, 'dblclick', L.DomEvent.stopPropagation)
                    .on(this._button, 'click', L.DomEvent.preventDefault)
                    .on(this._button, 'click', this._onClick, this);
            },

            remove: function() {
                L.DomEvent.off(this._button, "click", this._onClick);
                this._buttonContainer.getContainer().removeChild(this._button);
            },

            setText: function(text) {
                this._button.title = text;
                this._button.innerHTML = text;
            }
        });

        L.Control.ButtonContainer = L.Control.extend({
            options: {
                position: 'topleft'
            },

            getContainer: function() {
                if (!this._container) {
                    this._container = L.DomUtil.create('div', this.options.className);
                }
                return this._container;
            },

            onAdd: function(map) {
                this._map = map;
                return this.getContainer();
            },

            addButton: function(button) {
                button.onAdd(this);
            },

            addClass: function(className) {
                L.DomUtil.addClass(this.getContainer(), className);
            },

            removeClass: function(className) {
                L.DomUtil.removeClass(this.getContainer(), className);
            }
        });

        L.LocationFilter = L.Class.extend({
            includes: L.Mixin.Events,

            options: {
                enableButton: {
                    enableText: "Select area",
                    disableText: "Remove selection"
                },
                adjustButton: {
                    text: "Select area within current zoom"
                },
                buttonPosition: 'topleft'
            },

            initialize: function(options) {
                L.Util.setOptions(this, options);
            },

            addTo: function(map) {
                map.addLayer(this);
                return this;
            },

            onAdd: function(map) {
                this._map = map;

                if (this.options.enableButton || this.options.adjustButton) {
                    this._initializeButtonContainer();
                }

                if (this.options.enable) {
                    this.enable();
                }
            },

            onRemove: function(map) {
                this.disable();
                if (this._buttonContainer) {
                    this._buttonContainer.removeFrom(map);
                }
            },

            /* Get the current filter bounds */
            getBounds: function() {
                return new L.LatLngBounds(this._sw, this._ne);
            },

            setBounds: function(bounds) {
                this._nw = bounds.getNorthWest();
                this._ne = bounds.getNorthEast();
                this._sw = bounds.getSouthWest();
                this._se = bounds.getSouthEast();
                if (this.isEnabled()) {
                    this._draw();
                    this.fire("change", {
                        bounds: bounds
                    });
                }
            },

            isEnabled: function() {
                return this._enabled;
            },

            /* Draw a rectangle */
            _drawRectangle: function(bounds, options) {
                options = options || {};
                var defaultOptions = {
                    stroke: false,
                    fill: true,
                    fillColor: "black",
                    fillOpacity: 0.3,
                    clickable: false
                };
                options = L.Util.extend(defaultOptions, options);
                var rect = new L.Rectangle(bounds, options);
                rect.addTo(this._layer);
                return rect;
            },

            /* Draw a draggable marker */
            _drawImageMarker: function(point, options) {
                var marker = new L.Marker(point, {
                    icon: new L.DivIcon({
                        iconAnchor: options.anchor,
                        iconSize: options.size,
                        className: options.className
                    }),
                    draggable: true
                });
                marker.addTo(this._layer);
                return marker;
            },

            /* Draw a move marker. Sets up drag listener that updates the
               filter corners and redraws the filter when the move marker is
               moved */
            _drawMoveMarker: function(point) {
                var that = this;
                this._moveMarker = this._drawImageMarker(point, {
                    "className": "location-filter move-marker",
                    "anchor": [-10, -10],
                    "size": [13, 13]
                });
                this._moveMarker.on('drag', function(e) {
                    var markerPos = that._moveMarker.getLatLng(),
                        latDelta = markerPos.lat - that._nw.lat,
                        lngDelta = markerPos.lng - that._nw.lng;
                    that._nw = new L.LatLng(that._nw.lat + latDelta, that._nw.lng + lngDelta, true);
                    that._ne = new L.LatLng(that._ne.lat + latDelta, that._ne.lng + lngDelta, true);
                    that._sw = new L.LatLng(that._sw.lat + latDelta, that._sw.lng + lngDelta, true);
                    that._se = new L.LatLng(that._se.lat + latDelta, that._se.lng + lngDelta, true);
                    that._draw();
                });
                this._setupDragendListener(this._moveMarker);
                return this._moveMarker;
            },

            /* Draw a resize marker */
            _drawResizeMarker: function(point, latFollower, lngFollower, otherPos) {
                return this._drawImageMarker(point, {
                    "className": "location-filter resize-marker",
                    "anchor": [7, 6],
                    "size": [13, 12]
                });
            },

            /* Track moving of the given resize marker and update the markers
               given in options.moveAlong to match the position of the moved
               marker. Update filter corners and redraw the filter */
            _setupResizeMarkerTracking: function(marker, options) {
                var that = this;
                marker.on('drag', function(e) {
                    var curPosition = marker.getLatLng(),
                        latMarker = options.moveAlong.lat,
                        lngMarker = options.moveAlong.lng;
                    // Move follower markers when this marker is moved
                    latMarker.setLatLng(new L.LatLng(curPosition.lat, latMarker.getLatLng().lng, true));
                    lngMarker.setLatLng(new L.LatLng(lngMarker.getLatLng().lat, curPosition.lng, true));
                    // Sort marker positions in nw, ne, sw, se order
                    var corners = [that._nwMarker.getLatLng(),
                        that._neMarker.getLatLng(),
                        that._swMarker.getLatLng(),
                        that._seMarker.getLatLng()
                    ];
                    corners.sort(function(a, b) {
                        if (a.lat != b.lat)
                            return b.lat - a.lat;
                        else
                            return a.lng - b.lng;
                    });
                    // Update corner points and redraw everything except the resize markers
                    that._nw = corners[0];
                    that._ne = corners[1];
                    that._sw = corners[2];
                    that._se = corners[3];
                    that._draw({
                        repositionResizeMarkers: false
                    });
                });
                this._setupDragendListener(marker);
            },

            /* Emit a change event whenever dragend is triggered on the
               given marker */
            _setupDragendListener: function(marker) {
                var that = this;
                marker.on('dragend', function(e) {
                    that.fire("change", {
                        bounds: that.getBounds()
                    });
                });
            },

            /* Create bounds for the mask rectangles and the location
               filter rectangle */
            _calculateBounds: function() {
                var mapBounds = this._map.getBounds(),
                    outerBounds = new L.LatLngBounds(
                        new L.LatLng(mapBounds.getSouthWest().lat - 0.1,
                            mapBounds.getSouthWest().lng - 0.1, true),
                        new L.LatLng(mapBounds.getNorthEast().lat + 0.1,
                            mapBounds.getNorthEast().lng + 0.1, true)
                    );

                // The south west and north east points of the mask */
                this._osw = outerBounds.getSouthWest();
                this._one = outerBounds.getNorthEast();

                // Bounds for the mask rectangles
                this._northBounds = new L.LatLngBounds(new L.LatLng(this._ne.lat, this._osw.lng, true), this._one);
                this._westBounds = new L.LatLngBounds(new L.LatLng(this._sw.lat, this._osw.lng, true), this._nw);
                this._eastBounds = new L.LatLngBounds(this._se, new L.LatLng(this._ne.lat, this._one.lng, true));
                this._southBounds = new L.LatLngBounds(this._osw, new L.LatLng(this._sw.lat, this._one.lng, true));
            },

            /* Initializes rectangles and markers */
            _initialDraw: function() {
                if (this._initialDrawCalled) {
                    return;
                }

                this._layer = new L.LayerGroup();

                // Calculate filter bounds
                this._calculateBounds();

                // Create rectangles
                this._northRect = this._drawRectangle(this._northBounds);
                this._westRect = this._drawRectangle(this._westBounds);
                this._eastRect = this._drawRectangle(this._eastBounds);
                this._southRect = this._drawRectangle(this._southBounds);
                this._innerRect = this._drawRectangle(this.getBounds(), {
                    fillOpacity: 0,
                    stroke: true,
                    color: "white",
                    weight: 1,
                    opacity: 0.9
                });

                // Create resize markers
                this._nwMarker = this._drawResizeMarker(this._nw);
                this._neMarker = this._drawResizeMarker(this._ne);
                this._swMarker = this._drawResizeMarker(this._sw);
                this._seMarker = this._drawResizeMarker(this._se);

                // Setup tracking of resize markers. Each marker has pair of
                // follower markers that must be moved whenever the marker is
                // moved. For example, whenever the north west resize marker
                // moves, the south west marker must move along on the x-axis
                // and the north east marker must move on the y axis
                this._setupResizeMarkerTracking(this._nwMarker, {
                    moveAlong: {
                        lat: this._neMarker,
                        lng: this._swMarker
                    }
                });
                this._setupResizeMarkerTracking(this._neMarker, {
                    moveAlong: {
                        lat: this._nwMarker,
                        lng: this._seMarker
                    }
                });
                this._setupResizeMarkerTracking(this._swMarker, {
                    moveAlong: {
                        lat: this._seMarker,
                        lng: this._nwMarker
                    }
                });
                this._setupResizeMarkerTracking(this._seMarker, {
                    moveAlong: {
                        lat: this._swMarker,
                        lng: this._neMarker
                    }
                });

                // Create move marker
                this._moveMarker = this._drawMoveMarker(this._nw);

                this._initialDrawCalled = true;
            },

            /* Reposition all rectangles and markers to the current filter bounds. */
            _draw: function(options) {
                options = L.Util.extend({
                    repositionResizeMarkers: true
                }, options);

                // Calculate filter bounds
                this._calculateBounds();

                // Reposition rectangles
                this._northRect.setBounds(this._northBounds);
                this._westRect.setBounds(this._westBounds);
                this._eastRect.setBounds(this._eastBounds);
                this._southRect.setBounds(this._southBounds);
                this._innerRect.setBounds(this.getBounds());

                // Reposition resize markers
                if (options.repositionResizeMarkers) {
                    this._nwMarker.setLatLng(this._nw);
                    this._neMarker.setLatLng(this._ne);
                    this._swMarker.setLatLng(this._sw);
                    this._seMarker.setLatLng(this._se);
                }

                // Reposition the move marker
                this._moveMarker.setLatLng(this._nw);
            },

            /* Adjust the location filter to the current map bounds */
            _adjustToMap: function() {
                this.setBounds(this._map.getBounds());
                this._map.zoomOut();
            },

            /* Enable the location filter */
            enable: function() {
                if (this._enabled) {
                    return;
                }

                // Initialize corners
                var bounds;
                if (this._sw && this._ne) {
                    bounds = new L.LatLngBounds(this._sw, this._ne);
                } else if (this.options.bounds) {
                    bounds = this.options.bounds;
                } else {
                    bounds = this._map.getBounds();
                }
                this._map.invalidateSize();
                this._nw = bounds.getNorthWest();
                this._ne = bounds.getNorthEast();
                this._sw = bounds.getSouthWest();
                this._se = bounds.getSouthEast();


                // Update buttons
                if (this._buttonContainer) {
                    this._buttonContainer.addClass("enabled");
                }

                if (this._enableButton) {
                    this._enableButton.setText(this.options.enableButton.disableText);
                }

                if (this.options.adjustButton) {
                    this._createAdjustButton();
                }

                // Draw filter
                this._initialDraw();
                this._draw();

                // Set up map move event listener
                var that = this;
                this._moveHandler = function() {
                    that._draw();
                };
                this._map.on("move", this._moveHandler);

                // Add the filter layer to the map
                this._layer.addTo(this._map);

                // Zoom out the map if necessary
                var mapBounds = this._map.getBounds();
                bounds = new L.LatLngBounds(this._sw, this._ne).modify(this._map, 10);
                if (!mapBounds.contains(bounds.getSouthWest()) || !mapBounds.contains(bounds.getNorthEast())) {
                    this._map.fitBounds(bounds);
                }

                this._enabled = true;

                // Fire the enabled event
                this.fire("enabled");
            },

            /* Disable the location filter */
            disable: function() {
                if (!this._enabled) {
                    return;
                }

                // Update buttons
                if (this._buttonContainer) {
                    this._buttonContainer.removeClass("enabled");
                }

                if (this._enableButton) {
                    this._enableButton.setText(this.options.enableButton.enableText);
                }

                if (this._adjustButton) {
                    this._adjustButton.remove();
                }

                // Remove event listener
                this._map.off("move", this._moveHandler);

                // Remove rectangle layer from map
                this._map.removeLayer(this._layer);

                this._enabled = false;

                // Fire the disabled event
                this.fire("disabled");
            },

            /* Create a button that allows the user to adjust the location
               filter to the current zoom */
            _createAdjustButton: function() {
                var that = this;
                this._adjustButton = new L.Control.Button({
                    className: "adjust-button",
                    text: this.options.adjustButton.text,

                    onClick: function(event) {
                        that._adjustToMap();
                        that.fire("adjustToZoomClick");
                    }
                }).addTo(this._buttonContainer);
            },

            /* Create the location filter button container and the button that
               toggles the location filter */
            _initializeButtonContainer: function() {
                var that = this;
                this._buttonContainer = new L.Control.ButtonContainer({
                    className: "location-filter button-container",
                    position: this.options.buttonPosition
                });

                if (this.options.enableButton) {
                    this._enableButton = new L.Control.Button({
                        className: "enable-button",
                        text: this.options.enableButton.enableText,

                        onClick: function(event) {
                            if (!that._enabled) {
                                // Enable the location filter
                                that.enable();
                                that.fire("enableClick");
                            } else {
                                // Disable the location filter
                                that.disable();
                                that.fire("disableClick");
                            }
                        }
                    }).addTo(this._buttonContainer);
                }

                this._buttonContainer.addTo(this._map);
            }
        });


        /***/
    }),
    /* 134 */
    /***/
    (function(module, exports, __webpack_require__) {

        var map = {
            "./iD_presets_ca.json": [
                177,
                51
            ],
            "./iD_presets_da.json": [
                178,
                50
            ],
            "./iD_presets_de.json": [
                179,
                49
            ],
            "./iD_presets_el.json": [
                180,
                48
            ],
            "./iD_presets_en.json": [
                181,
                47
            ],
            "./iD_presets_es.json": [
                182,
                46
            ],
            "./iD_presets_et.json": [
                183,
                45
            ],
            "./iD_presets_fa.json": [
                184,
                44
            ],
            "./iD_presets_fr.json": [
                185,
                43
            ],
            "./iD_presets_hr.json": [
                186,
                42
            ],
            "./iD_presets_hu.json": [
                187,
                41
            ],
            "./iD_presets_it.json": [
                188,
                40
            ],
            "./iD_presets_ja.json": [
                189,
                39
            ],
            "./iD_presets_nl.json": [
                190,
                38
            ],
            "./iD_presets_no.json": [
                191,
                37
            ],
            "./iD_presets_pl.json": [
                192,
                36
            ],
            "./iD_presets_pt-BR.json": [
                193,
                35
            ],
            "./iD_presets_pt.json": [
                194,
                34
            ],
            "./iD_presets_ro.json": [
                195,
                33
            ],
            "./iD_presets_ru.json": [
                196,
                32
            ],
            "./iD_presets_sl.json": [
                197,
                31
            ],
            "./iD_presets_sv.json": [
                198,
                30
            ],
            "./iD_presets_uk.json": [
                199,
                29
            ],
            "./iD_presets_vi.json": [
                200,
                28
            ],
            "./iD_presets_zh-TW.json": [
                201,
                27
            ]
        };

        function webpackAsyncContext(req) {
            var ids = map[req];
            if (!ids)
                return Promise.reject(new Error("Cannot find module '" + req + "'."));
            return __webpack_require__.e(ids[1]).then(function() {
                return __webpack_require__(ids[0]);
            });
        };
        webpackAsyncContext.keys = function webpackAsyncContextKeys() {
            return Object.keys(map);
        };
        module.exports = webpackAsyncContext;
        webpackAsyncContext.id = 134;

        /***/
    }),
    /* 135 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = autorepair;
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(2);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__misc__ = __webpack_require__(7);
        // query autorepair module




        function autorepair(q, lng) {
            var repair = {};

            var comments = {};

            (function init() {
                // replace comments with placeholders
                // (we do not want to autorepair stuff which is commented out.)
                if (lng == "xml") {
                    var cs = q.match(/<!--[\s\S]*?-->/g) || [];
                    for (var i = 0; i < cs.length; i++) {
                        var placeholder =
                            "<!--" + __WEBPACK_IMPORTED_MODULE_1__misc__["c" /* Base64 */ ].encode(Math.random().toString()) + "-->"; //todo: use some kind of checksum or hash maybe?
                        q = q.replace(cs[i], placeholder);
                        comments[placeholder] = cs[i];
                    }
                } else {
                    var cs = q.match(/\/\*[\s\S]*?\*\//g) || []; // multiline comments: /*...*/
                    for (var i = 0; i < cs.length; i++) {
                        var placeholder = "/*" + __WEBPACK_IMPORTED_MODULE_1__misc__["c" /* Base64 */ ].encode(Math.random().toString()) + "*/"; //todo: use some kind of checksum or hash maybe?
                        q = q.replace(cs[i], placeholder);
                        comments[placeholder] = cs[i];
                    }
                    var cs = q.match(/\/\/[^\n]*/g) || []; // single line coments: //...
                    for (var i = 0; i < cs.length; i++) {
                        var placeholder = "/*" + __WEBPACK_IMPORTED_MODULE_1__misc__["c" /* Base64 */ ].encode(Math.random().toString()) + "*/"; //todo: use some kind of checksum or hash maybe?
                        q = q.replace(cs[i], placeholder);
                        comments[placeholder] = cs[i];
                    }
                }
            })();

            repair.getQuery = function() {
                // expand placeholded comments
                for (var placeholder in comments) {
                    q = q.replace(placeholder, comments[placeholder]);
                }
                return q;
            };

            repair.recurse = function() {
                if (lng == "xml") {
                    // do some fancy mixture between regex magic and xml as html parsing :
                    var prints = q.match(/(\n?[^\S\n]*<print[\s\S]*?(\/>|<\/print>))/g) || [];
                    for (var i = 0; i < prints.length; i++) {
                        var ws = prints[i].match(/^\n?(\s*)/)[1]; // amount of whitespace in front of each print statement
                        var from = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("print", __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.parseXML(prints[i])).attr("from");
                        var add1, add2, add3;
                        if (from) {
                            add1 = ' into="' + from + '"';
                            add2 = ' set="' + from + '"';
                            add3 = ' from="' + from + '"';
                        } else {
                            add1 = "";
                            add2 = "";
                            add3 = "";
                        }
                        q = q.replace(
                            prints[i],
                            "\n" +
                            ws +
                            "<!-- added by auto repair -->\n" +
                            ws +
                            "<union" +
                            add1 +
                            ">\n" +
                            ws +
                            "  <item" +
                            add2 +
                            "/>\n" +
                            ws +
                            "  <recurse" +
                            add3 +
                            ' type="down"/>\n' +
                            ws +
                            "</union>\n" +
                            ws +
                            "<!-- end of auto repair --><autorepair>" +
                            i +
                            "</autorepair>"
                        );
                    }
                    for (var i = 0; i < prints.length; i++)
                        q = q.replace("<autorepair>" + i + "</autorepair>", prints[i]);
                } else {
                    var outs = q.match(/(\n?[^\S\n]*(\.[^.;]+)?out[^:;"\]]*;)/g) || [];
                    for (var i = 0; i < outs.length; i++) {
                        var ws = outs[i].match(/^\n?(\s*)/)[0]; // amount of whitespace
                        var from = outs[i].match(/\.([^;.]+?)\s+out/);
                        var add;
                        if (from)
                            add = "(." + from[1] + ";." + from[1] + " >;)->." + from[1] + ";";
                        else add = "(._;>;);";
                        q = q.replace(
                            outs[i],
                            ws +
                            "/*added by auto repair*/" +
                            ws +
                            add +
                            ws +
                            "/*end of auto repair*/<autorepair>" +
                            i +
                            "</autorepair>"
                        );
                    }
                    for (var i = 0; i < outs.length; i++)
                        q = q.replace("<autorepair>" + i + "</autorepair>", outs[i]);
                }
                return true;
            };

            repair.editors = function() {
                if (lng == "xml") {
                    // 1. fix <osm-script output=*
                    var src = q.match(/<osm-script([^>]*)>/);
                    if (src) {
                        var output = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm-script", __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.parseXML(src[0] + "</osm-script>")).attr(
                            "output"
                        );
                        if (output && output != "xml") {
                            var new_src = src[0].replace(output, "xml");
                            q = q.replace(src[0], new_src + "<!-- fixed by auto repair -->");
                        }
                    }
                    // 2. fix <print mode=*
                    var prints = q.match(/(<print[\s\S]*?(\/>|<\/print>))/g) || [];
                    for (var i = 0; i < prints.length; i++) {
                        var print = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("print", __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.parseXML(prints[i])),
                            mode = print.attr("mode"),
                            geometry = print.attr("geometry");
                        var add = "",
                            new_print,
                            repaired = false;
                        if (mode !== "meta") {
                            print.attr("mode", "meta");
                            repaired = true;
                        }
                        if (geometry && geometry !== "skeleton") {
                            print.attr("geometry", null);
                            var out_set = print.attr("from");
                            if (!out_set) {
                                add = '<union><item/><recurse type="down"/></union>';
                            } else {
                                add =
                                    '<union into="' +
                                    out_set +
                                    '"><item set="' +
                                    out_set +
                                    '"/><recurse from="' +
                                    out_set +
                                    '" type="down"/></union>';
                            }
                            repaired = true;
                        }
                        if (repaired) {
                            new_print = add + new XMLSerializer().serializeToString(print[0]);
                            new_print += "<!-- fixed by auto repair -->";
                            q = q.replace(prints[i], new_print);
                        }
                    }
                } else {
                    // 1. fix [out:*]
                    var out = q.match(/\[\s*out\s*:\s*([^\]\s]+)\s*\]\s*;?/);
                    ///^\s*\[\s*out\s*:\s*([^\]\s]+)/);
                    if (out && out[1] != "xml")
                        q = q.replace(
                            /(\[\s*out\s*:\s*)([^\]\s]+)(\s*\]\s*;?)/,
                            "$1xml$3/*fixed by auto repair*/"
                        );
                    // 2. fix print statements: non meta output, overpass geometries
                    var prints = q.match(/(\.([^;.]+?)\s+)?(out[^:;"\]]*;)/g) || [];
                    for (var i = 0; i < prints.length; i++) {
                        var print = prints[i].match(/(\.([^;.]+?)\s+)?(out[^:;"\]]*;)/);
                        var out_statement = print[3],
                            out_set = print[2],
                            print = print[0];
                        var new_print = print;
                        // non meta output
                        if (
                            out_statement.match(/\s(body|skel|ids|tags)/) ||
                            !out_statement.match(/\s(meta)/)
                        ) {
                            var new_out_statement = out_statement
                                .replace(/\s(body|skel|ids|tags|meta)/g, "")
                                .replace(/^out/, "out meta");
                            new_print = new_print.replace(out_statement, new_out_statement);
                            out_statement = new_out_statement;
                        }
                        // overpass geometry modes
                        if (out_statement.match(/\s(center|bb|geom)/)) {
                            var new_out_statement = out_statement.replace(
                                /\s(center|bb|geom)/g,
                                ""
                            );
                            new_print = new_print.replace(out_statement, new_out_statement);
                            out_statement = new_out_statement;
                            if (out_set) {
                                new_print =
                                    "(." +
                                    out_set +
                                    ";." +
                                    out_set +
                                    " >;)->." +
                                    out_set +
                                    "; " +
                                    new_print;
                            } else {
                                new_print = "(._;>;); " + new_print;
                            }
                        }
                        if (new_print != print)
                            q = q.replace(print, new_print + "/*fixed by auto repair*/");
                    }
                }
                return true;
            };

            return repair;
        }

        autorepair.detect = {};
        autorepair.detect.editors = function(q, lng) {
            // todo: test this
            // todo: move into autorepair "module" /// todo. done?
            q = q.replace(/{{.*?}}/g, "");
            var err = {};
            if (lng == "xml") {
                try {
                    var xml = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.parseXML("<x>" + q + "</x>");
                    var out = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("osm-script", xml).attr("output");
                    if (out !== undefined && out !== "xml") err.output = true;
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("print", xml).each(function(i, p) {
                        if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(p).attr("mode") !== "meta") err.meta = true;
                    });
                    __WEBPACK_IMPORTED_MODULE_0_jquery___default()("print", xml).each(function(i, p) {
                        if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(p).attr("geometry").match(/(center|bounds|full)/))
                            err.geometry = true;
                    });
                } catch (e) {} // ignore xml syntax errors ?!
            } else {
                // ignore comments
                q = q.replace(/\/\*[\s\S]*?\*\//g, "");
                q = q.replace(/\/\/[^\n]*/g, "");
                var out = q.match(/\[\s*out\s*:\s*([^\]\s]+)\s*\]/);
                if (out && out[1] != "xml") err.output = true;
                var prints = q.match(/out([^:;]*);/g);
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(prints).each(function(i, p) {
                    if (p.match(/\s(body|skel|ids|tags)/) || !p.match(/meta/))
                        err.meta = true;
                });
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(prints).each(function(i, p) {
                    if (p.match(/\s(center|bb|geom)/)) err.geometry = true;
                });
            }
            return __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.isEmptyObject(err);
        };


        /***/
    }),
    /* 136 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = ffs_free;
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(2);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__promise_polyfill__ = __webpack_require__(23);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2__i18n__ = __webpack_require__(38);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3__misc__ = __webpack_require__(7);
        // ffs/wizard module




        var freeFormQuery = {};
        var presets = {};
        var loaded = false;

        function ffs_free(callback) {
            if (loaded) {
                callback(freeFormQuery);
            } else {
                loadPresets().then(loadPresetTranslations).then(function() {
                    callback(freeFormQuery);
                });
            }

            // load presets
            function loadPresets() {
                return __webpack_require__.e /* import() */ (52).then(__webpack_require__.bind(null, 176))
                    .then(function(data) {
                        presets = data;
                        Object.keys(presets).forEach(function(key) {
                            var preset = data[key];
                            preset.nameCased = preset.name;
                            preset.name = preset.name.toLowerCase();
                            preset.terms = !preset.terms ?
                                [] :
                                preset.terms.map(function(term) {
                                    return term.toLowerCase();
                                });
                        });
                    })
                    .catch(function() {
                        throw new Error("failed to load presets file");
                    });
            }
            // load preset translations
            function loadPresetTranslations() {
                var language = __WEBPACK_IMPORTED_MODULE_2__i18n__["a" /* default */ ].getLanguage();
                if (language == "en") return;
                __webpack_require__(134)("./iD_presets_" + language + ".json")
                    .then(function(data) {
                        // load translated names and terms into presets object
                        Object.keys(data).forEach(function(preset) {
                            var translation = data[preset];
                            preset = presets[preset];
                            preset.translated = true;
                            // save original preset name under alternative terms
                            var oriPresetName = preset.name;
                            // save translated preset name
                            preset.nameCased = translation.name;
                            preset.name = translation.name.toLowerCase();
                            // add new terms
                            if (translation.terms)
                                preset.terms = translation.terms
                                .split(",")
                                .map(function(term) {
                                    return term.trim().toLowerCase();
                                })
                                .concat(preset.terms);
                            // add this to the front to allow exact (english) preset names to match before terms
                            preset.terms.unshift(oriPresetName);
                        });
                    })
                    .catch(function() {
                        throw new Error("failed to load preset translations file: " + language);
                    });
            }
        }

        freeFormQuery.get_query_clause = function(condition) {
            // search presets for ffs term
            var search = condition.free.toLowerCase();
            var candidates = Object.keys(presets)
                .map(function(key) {
                    return presets[key];
                })
                .filter(function(preset) {
                    if (preset.searchable === false) return false;
                    if (preset.name === search) return true;
                    preset._termsIndex = preset.terms.indexOf(search);
                    return preset._termsIndex != -1;
                });
            if (candidates.length === 0) return false;
            // sort candidates
            candidates.sort(function(a, b) {
                // prefer exact name matches
                if (a.name === search) return -1;
                if (b.name === search) return 1;
                return a._termsIndex - b._termsIndex;
            });
            var preset = candidates[0];
            var types = [];
            preset.geometry.forEach(function(g) {
                switch (g) {
                    case "point":
                    case "vertex":
                        types.push("node");
                        break;
                    case "line":
                        types.push("way");
                        break;
                    case "area":
                        types.push("way");
                        types.push("relation"); // todo: additionally add type=multipolygon?
                        break;
                    case "relation":
                        types.push("relation");
                        break;
                    default:
                        console.log("unknown geometry type " + g + " of preset " + preset.name);
                }
            });

            function onlyUnique(value, index, self) {
                return self.indexOf(value) === index;
            }
            return {
                types: types.filter(onlyUnique),
                conditions: Object.keys(preset.tags).map(function(k) {
                    var v = preset.tags[k];
                    return {
                        query: v === "*" ? "key" : "eq",
                        key: k,
                        val: v
                    };
                })
            };
        };

        freeFormQuery.fuzzy_search = function(condition) {
            // search presets for ffs term
            var search = condition.free.toLowerCase();
            // fuzzyness: max lev.dist allowed to still match
            var fuzzyness = 2 + Math.floor(search.length / 7);

            function fuzzyMatch(term) {
                return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__misc__["e" /* levenshteinDistance */ ])(term, search) <= fuzzyness;
            }
            var candidates = Object.keys(presets)
                .map(function(key) {
                    return presets[key];
                })
                .filter(function(preset) {
                    if (preset.searchable === false) return false;
                    if (fuzzyMatch(preset.name)) return true;
                    return preset.terms.some(fuzzyMatch);
                });
            if (candidates.length === 0) return false;
            // sort candidates
            function preset_weight(preset) {
                return [preset.name]
                    .concat(preset.terms)
                    .map(function(term, index) {
                        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__misc__["e" /* levenshteinDistance */ ])(term, search);
                    })
                    .reduce(function min(a, b) {
                        return a <= b ? a : b;
                    });
            }
            candidates.sort(function(a, b) {
                return preset_weight(a) - preset_weight(b);
            });
            var preset = candidates[0];
            return preset.nameCased;
        };


        /***/
    }),
    /* 137 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        Object.defineProperty(__webpack_exports__, "__esModule", {
            value: true
        });
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(2);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_jquery_ui__ = __webpack_require__(131);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1_jquery_ui___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery_ui__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2_leaflet__ = __webpack_require__(3);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2_leaflet___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_leaflet__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3_leaflet_polylineoffset__ = __webpack_require__(132);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_3_leaflet_polylineoffset___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_leaflet_polylineoffset__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_4_leaflet_locationfilter__ = __webpack_require__(133);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_4_leaflet_locationfilter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_leaflet_locationfilter__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_5_codemirror_lib_codemirror__ = __webpack_require__(35);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_5_codemirror_lib_codemirror___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_codemirror_lib_codemirror__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_6_codemirror_mode_javascript_javascript__ = __webpack_require__(123);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_6_codemirror_mode_javascript_javascript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_codemirror_mode_javascript_javascript__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_7_codemirror_mode_xml_xml__ = __webpack_require__(124);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_7_codemirror_mode_xml_xml___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_codemirror_mode_xml_xml__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_8_codemirror_mode_clike_clike__ = __webpack_require__(121);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_8_codemirror_mode_clike_clike___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_codemirror_mode_clike_clike__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_9_codemirror_mode_css_css__ = __webpack_require__(122);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_9_codemirror_mode_css_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_codemirror_mode_css_css__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_10_codemirror_lib_util_multiplex__ = __webpack_require__(120);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_10_codemirror_lib_util_multiplex___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_codemirror_lib_util_multiplex__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_11_codemirror_lib_util_closetag__ = __webpack_require__(119);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_11_codemirror_lib_util_closetag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_codemirror_lib_util_closetag__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_12_html2canvas__ = __webpack_require__(36);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_12_html2canvas___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_html2canvas__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_13_codemirror_lib_codemirror_css__ = __webpack_require__(128);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_13_codemirror_lib_codemirror_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_codemirror_lib_codemirror_css__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_14_leaflet_dist_leaflet_css__ = __webpack_require__(12);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_14_leaflet_dist_leaflet_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_leaflet_dist_leaflet_css__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_15_leaflet_locationfilter_src_locationfilter_css__ = __webpack_require__(130);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_15_leaflet_locationfilter_src_locationfilter_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_leaflet_locationfilter_src_locationfilter_css__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_16_jquery_ui_themes_base_jquery_ui_css__ = __webpack_require__(129);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_16_jquery_ui_themes_base_jquery_ui_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_jquery_ui_themes_base_jquery_ui_css__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_17__css_default_css__ = __webpack_require__(126);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_17__css_default_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17__css_default_css__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_18__css_compact_css__ = __webpack_require__(125);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_18__css_compact_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18__css_compact_css__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_19__ide__ = __webpack_require__(118);




        // include the CSS files




        // initialize ide on document ready

        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document).ready(__WEBPACK_IMPORTED_MODULE_19__ide__["a" /* default */ ].init);
        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document).ready(initClickHandler);

        function initClickHandler() {
            __WEBPACK_IMPORTED_MODULE_0_jquery___default()("*[data-ide-handler]").each(function() {
                var handlerDefinition = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).attr("data-ide-handler").split(/:/);
                var event = handlerDefinition[0];
                var handlerName = handlerDefinition[1];
                var handler = __WEBPACK_IMPORTED_MODULE_19__ide__["a" /* default */ ][handlerName];
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).on(event, handler);
            });
        }


        /***/
    }),
    /* 138 */
    ,
    /* 139 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(2);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__configs__ = __webpack_require__(5);
        // nominatim module




        /* harmony default export */
        __webpack_exports__["a"] = (function() {
            var cache = {};

            var nominatim = {};

            function request(search, callback) {
                // ajax (GET) request to nominatim
                __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.ajax(
                    "https://nominatim.openstreetmap.org/search" +
                    "?X-Requested-With=" +
                    __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname, {
                        data: {
                            format: "json",
                            q: search
                        },
                        success: function(data) {
                            // hacky firefox hack :( (it is not properly detecting json from the content-type header)
                            if (typeof data == "string") {
                                // if the data is a string, but looks more like a json object
                                try {
                                    data = JSON.parse(data);
                                } catch (e) {}
                            }
                            cache[search] = data;
                            callback(undefined, data);
                        },
                        error: function() {
                            var err =
                                "An error occurred while contacting the osm search server nominatim.openstreetmap.org :(";
                            console.log(err);
                            callback(err, null);
                        }
                    }
                );
            }

            nominatim.get = function(search, callback) {
                if (cache[search] === undefined) request(search, callback);
                else callback(undefined, cache[search]);
                return nominatim;
            };

            nominatim.getBest = function(search, filter, callback) {
                // shift parameters if filter is omitted
                if (!callback) {
                    callback = filter;
                    filter = null;
                }
                nominatim.get(search, function(err, data) {
                    if (err) {
                        callback(err, null);
                        return;
                    }
                    if (filter) data = data.filter(filter);
                    if (data.length === 0) callback("No result found", null);
                    else callback(err, data[0]);
                });
                return nominatim;
            };

            return nominatim;
        });


        /***/
    }),
    /* 140 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_osm_auth__ = __webpack_require__(151);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0_osm_auth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_osm_auth__);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__configs__ = __webpack_require__(5);



        var enabled =
            __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].osmAuth &&
            __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].osmAuth.oauth_consumer_key &&
            __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].osmAuth.oauth_secret;

        var auth;
        if (enabled) auth = __WEBPACK_IMPORTED_MODULE_0_osm_auth___default()(__WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].osmAuth);

        /* harmony default export */
        __webpack_exports__["a"] = ({
            enabled: enabled,
            load: function(callback) {
                if (!auth.authenticated()) {
                    auth.authenticate(function(err) {
                        //check err param exists
                        if (err) return callback(err);
                        loadQueries(callback);
                    });
                } else {
                    loadQueries(callback);
                }
            },
            save: function(query, callback) {
                if (!auth.authenticated()) {
                    auth.authenticate(function(err) {
                        //check err param exists
                        if (err) return callback(err);
                        saveQuery(query, callback);
                    });
                } else {
                    saveQuery(query, callback);
                }
            },
            delete: function(query, callback) {
                if (!auth.authenticated())
                    return callback(new Error("must be logged in to delete a synced query"));
                query = {
                    name: query,
                    deleteMe: true
                };
                saveQuery(query, callback);
            },
            logout: function(callback) {
                if (auth.authenticated()) auth.logout();
            },
            authenticated: function() {
                return enabled && auth.authenticated();
            }
        });

        function loadQueries(callback) {
            auth.xhr({
                    method: "GET",
                    path: "/api/0.6/user/preferences"
                },
                function(err, res) {
                    if (err) return callback(err);

                    var pref_count = 0,
                        cnt_elem;
                    if (
                        (cnt_elem = res.querySelector(
                            'preference[k="' + __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname + '_query-count"]'
                        ))
                    )
                        pref_count = +cnt_elem.getAttribute("v");

                    var result = [];
                    for (var i = 0; i < pref_count; i++) {
                        var pref_elem = res.querySelector(
                            'preference[k="' + __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname + "_query_" + i + '_0"]'
                        );
                        if (!pref_elem) continue;
                        var first_chunk = pref_elem.getAttribute("v").split("&");
                        var length = +first_chunk[0].slice(2);
                        var name = first_chunk[1].slice(2);
                        var query = first_chunk[2].slice(2);
                        for (var j = 1; j < length; j++) {
                            query += res
                                .querySelector(
                                    'preference[k="' +
                                    __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname +
                                    "_query_" +
                                    i +
                                    "_" +
                                    j +
                                    '"]'
                                )
                                .getAttribute("v");
                        }
                        result.push({
                            name: name,
                            query: query
                        });
                    }

                    callback(null, result, res);
                }
            );
        }

        function saveQuery(new_query, callback) {
            loadQueries(function(err, existing_queries, dom) {
                if (err) return callback(err);

                var preferences = dom.querySelector("preferences");
                // clean up existing data
                var existing = preferences.querySelectorAll(
                    'preference[k^="' + __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname + '_query"]'
                );
                for (var i = 0; i < existing.length; i++) {
                    preferences.removeChild(existing[i]);
                }
                // insert new query into list of existing ones
                var is_new = true;
                existing_queries.forEach(function(q, idx) {
                    if (q.name == new_query.name) {
                        q.query = new_query.query;
                        is_new = idx;
                    }
                });
                if (is_new === true) {
                    existing_queries.push(new_query);
                } else if (new_query.deleteMe) {
                    existing_queries.splice(is_new, 1);
                }
                // construct new preferences xml
                var new_elem = dom.createElement("preference");
                new_elem.setAttribute("k", __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname + "_query-count");
                new_elem.setAttribute("v", existing_queries.length);
                preferences.appendChild(new_elem);
                for (var i = 0; i < existing_queries.length; i++) {
                    var q = existing_queries[i];
                    if (q.name.length > 200)
                        return callback(
                            new Error("query name too long to be saved on osm.org")
                        );
                    var numParts = Math.ceil((q.query.length + q.name.length + 8) / 255);
                    if (numParts > 9)
                        return callback(new Error("query too long to be saved on osm.org"));
                    var queryStr = "p=" + numParts;
                    queryStr += "&n=" + q.name;
                    queryStr += "&q=" + q.query;
                    // split into chunks of max 255 characters length
                    queryStr = queryStr.match(/.{1,255}/g);

                    for (var j = 0; j < numParts; j++) {
                        var new_elem = dom.createElement("preference");
                        new_elem.setAttribute("k", __WEBPACK_IMPORTED_MODULE_1__configs__["a" /* default */ ].appname + "_query_" + i + "_" + j);
                        new_elem.setAttribute("v", queryStr[j]);
                        preferences.appendChild(new_elem);
                    }
                }
                // upload to osm.org
                auth.xhr({
                        method: "PUT",
                        path: "/api/0.6/user/preferences",
                        options: {
                            header: {
                                "Content-Type": "text/xml"
                            }
                        },
                        content: dom.firstChild.outerHTML
                    },
                    function(err, res) {
                        if (err) return callback(err);
                        callback(null, existing_queries);
                    }
                );
            });
        }


        /***/
    }),
    /* 141 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = urlParameters;
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__ffs__ = __webpack_require__(37);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_1__settings__ = __webpack_require__(8);
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_2__misc__ = __webpack_require__(7);
        // urlParameters module




        function urlParameters(param_str) {
            // defaults
            var t = {
                has_query: false,
                query: undefined,
                has_coords: false,
                coords: undefined,
                has_zoom: false,
                zoom: undefined,
                run_query: false
            };

            // split parameter string to arguments
            function split(param_str) {
                var args = {};
                if (typeof param_str === "string" && param_str.length > 0) {
                    var get = param_str.substring(1).split("&");
                    for (var i = 0; i < get.length; i++) {
                        var kv = get[i].split("=");
                        var key = decodeURIComponent(kv.shift().replace(/\+/g, "%20"));
                        var val = kv.length > 0 ?
                            decodeURIComponent(kv.join("=").replace(/\+/g, "%20")) :
                            true;
                        args[key] = val;
                    }
                }
                return args;
            }
            var args = split(param_str);

            // interpret arguments
            if (args.q) {
                // compressed query set in url
                t.query = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__misc__["b" /* lzw_decode */ ])(__WEBPACK_IMPORTED_MODULE_2__misc__["c" /* Base64 */ ].decode(args.q));
                t.has_query = true;
            }
            if (args.Q) {
                // uncompressed query set in url
                t.query = args.Q;
                t.has_query = true;
            }
            if (args.c) {
                // map center & zoom (compressed)
                var tmp = args.c.match(/([A-Za-z0-9\-_]+)([A-Za-z0-9\-_])/);
                var decode_coords = function(str) {
                    var coords_cpr = __WEBPACK_IMPORTED_MODULE_2__misc__["c" /* Base64 */ ].decodeNum(str);
                    var res = {};
                    res.lat = coords_cpr % (180 * 100000) / 100000 - 90;
                    res.lng = Math.floor(coords_cpr / (180 * 100000)) / 100000 - 180;
                    return res;
                };
                t.coords = decode_coords(tmp[1]);
                t.has_coords = true;
                t.zoom = __WEBPACK_IMPORTED_MODULE_2__misc__["c" /* Base64 */ ].decodeNum(tmp[2]);
                t.has_zoom = true;
            }
            if (args.C) {
                // map center & zoom (uncompressed)
                var tmp = args.C.match(/(-?[\d.]+);(-?[\d.]+);(\d+)/);
                t.coords = {
                    lat: +tmp[1],
                    lng: +tmp[2]
                };
                t.has_coords = true;
                t.zoom = +tmp[3];
                t.has_zoom = true;
            }
            if (args.lat && args.lon) {
                // map center coords (ols style osm.org parameters)
                t.coords = {
                    lat: +args.lat,
                    lng: +args.lon
                };
                t.has_coords = true;
            }
            if (args.zoom) {
                // map zoom level (old style osm.org parameter)
                t.zoom = +args.zoom;
                t.has_zoom = true;
            }
            if (args.template) {
                // load a template
                var template = __WEBPACK_IMPORTED_MODULE_1__settings__["a" /* default */ ].saves[args.template];
                if (template && template.type == "template") {
                    // build query
                    var q = template.wizard;
                    var params = template.parameters;
                    for (var i = 0; i < params.length; i++) {
                        var param = params[i];
                        var value = args[param];
                        if (typeof value !== "string") value = "???";
                        q = q.replace("{{" + param + "}}", quotes(value));
                    }
                    args.w = q; // let the wizard do the work
                    var wizard_comment = template.comment;
                } else {
                    console.log("template not found: " + args.template);
                }
            }
            if (args.w) {
                // construct a query using the wizard
                __WEBPACK_IMPORTED_MODULE_0__ffs__["a" /* default */ ].construct_query(args.w, wizard_comment, function(err, query) {
                    if (!err) {
                        t.query = query;
                        t.has_query = true;
                    } else {
                        console.log("invalid wizard syntax:\n  " + args.w);
                    }
                });
            }
            if (args.R !== undefined) {
                // indicates that the supplied query shall be executed immediately
                if (
                    t.has_query // only run if there is also a query to execute
                )
                    t.run_query = true;
            }

            return t;
        }

        function quotes(s) {
            if (s.match(/^[a-zA-Z0-9_]+$/) === null)
                return '"' + s.replace(/"/g, '\\"') + '"';
            return s;
        }


        /***/
    }),
    /* 142 */
    /***/
    (function(module, exports, __webpack_require__) {

        var map = {
            "./ca.json": [
                202,
                26
            ],
            "./da.json": [
                203,
                25
            ],
            "./de.json": [
                204,
                24
            ],
            "./el.json": [
                205,
                23
            ],
            "./en.json": [
                206,
                22
            ],
            "./eo.json": [
                207,
                21
            ],
            "./es.json": [
                208,
                20
            ],
            "./et.json": [
                209,
                19
            ],
            "./fa.json": [
                210,
                18
            ],
            "./fr.json": [
                211,
                17
            ],
            "./hr.json": [
                212,
                16
            ],
            "./hu.json": [
                213,
                15
            ],
            "./it.json": [
                214,
                14
            ],
            "./ja.json": [
                215,
                13
            ],
            "./nl.json": [
                216,
                12
            ],
            "./no.json": [
                217,
                11
            ],
            "./pl.json": [
                218,
                10
            ],
            "./pt-BR.json": [
                219,
                9
            ],
            "./pt.json": [
                220,
                8
            ],
            "./ro.json": [
                221,
                7
            ],
            "./ru.json": [
                222,
                6
            ],
            "./sl.json": [
                223,
                5
            ],
            "./sv.json": [
                224,
                4
            ],
            "./tr-TR.json": [
                225,
                3
            ],
            "./uk.json": [
                226,
                2
            ],
            "./vi.json": [
                227,
                1
            ],
            "./zh-TW.json": [
                228,
                0
            ]
        };

        function webpackAsyncContext(req) {
            var ids = map[req];
            if (!ids)
                return Promise.reject(new Error("Cannot find module '" + req + "'."));
            return __webpack_require__.e(ids[1]).then(function() {
                return __webpack_require__(ids[0]);
            });
        };
        webpackAsyncContext.keys = function webpackAsyncContextKeys() {
            return Object.keys(map);
        };
        module.exports = webpackAsyncContext;
        webpackAsyncContext.id = 142;

        /***/
    }),
    /* 143 */
    /***/
    (function(module, exports) {

        /* canvas-toBlob.js
         * A canvas.toBlob() implementation.
         * 2016-05-26
         * 
         * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
         * License: MIT
         *   See https://github.com/eligrey/canvas-toBlob.js/blob/master/LICENSE.md
         */

        /*global self */
        /*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
          plusplus: true */

        /*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */

        (function(view) {
            "use strict";
            var
                Uint8Array = view.Uint8Array,
                HTMLCanvasElement = view.HTMLCanvasElement,
                canvas_proto = HTMLCanvasElement && HTMLCanvasElement.prototype,
                is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i,
                to_data_url = "toDataURL",
                base64_ranks, decode_base64 = function(base64) {
                    var
                        len = base64.length,
                        buffer = new Uint8Array(len / 4 * 3 | 0),
                        i = 0,
                        outptr = 0,
                        last = [0, 0],
                        state = 0,
                        save = 0,
                        rank, code, undef;
                    while (len--) {
                        code = base64.charCodeAt(i++);
                        rank = base64_ranks[code - 43];
                        if (rank !== 255 && rank !== undef) {
                            last[1] = last[0];
                            last[0] = code;
                            save = (save << 6) | rank;
                            state++;
                            if (state === 4) {
                                buffer[outptr++] = save >>> 16;
                                if (last[1] !== 61 /* padding character */ ) {
                                    buffer[outptr++] = save >>> 8;
                                }
                                if (last[0] !== 61 /* padding character */ ) {
                                    buffer[outptr++] = save;
                                }
                                state = 0;
                            }
                        }
                    }
                    // 2/3 chance there's going to be some null bytes at the end, but that
                    // doesn't really matter with most image formats.
                    // If it somehow matters for you, truncate the buffer up outptr.
                    return buffer;
                };
            if (Uint8Array) {
                base64_ranks = new Uint8Array([
                    62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
                ]);
            }
            if (HTMLCanvasElement && (!canvas_proto.toBlob || !canvas_proto.toBlobHD)) {
                if (!canvas_proto.toBlob)
                    canvas_proto.toBlob = function(callback, type /*, ...args*/ ) {
                        if (!type) {
                            type = "image/png";
                        }
                        if (this.mozGetAsFile) {
                            callback(this.mozGetAsFile("canvas", type));
                            return;
                        }
                        if (this.msToBlob && /^\s*image\/png\s*(?:$|;)/i.test(type)) {
                            callback(this.msToBlob());
                            return;
                        }

                        var
                            args = Array.prototype.slice.call(arguments, 1),
                            dataURI = this[to_data_url].apply(this, args),
                            header_end = dataURI.indexOf(","),
                            data = dataURI.substring(header_end + 1),
                            is_base64 = is_base64_regex.test(dataURI.substring(0, header_end)),
                            blob;
                        if (Blob.fake) {
                            // no reason to decode a data: URI that's just going to become a data URI again
                            blob = new Blob
                            if (is_base64) {
                                blob.encoding = "base64";
                            } else {
                                blob.encoding = "URI";
                            }
                            blob.data = data;
                            blob.size = data.length;
                        } else if (Uint8Array) {
                            if (is_base64) {
                                blob = new Blob([decode_base64(data)], {
                                    type: type
                                });
                            } else {
                                blob = new Blob([decodeURIComponent(data)], {
                                    type: type
                                });
                            }
                        }
                        callback(blob);
                    };

                if (!canvas_proto.toBlobHD && canvas_proto.toDataURLHD) {
                    canvas_proto.toBlobHD = function() {
                        to_data_url = "toDataURLHD";
                        var blob = this.toBlob();
                        to_data_url = "toDataURL";
                        return blob;
                    }
                } else {
                    canvas_proto.toBlobHD = canvas_proto.toBlob;
                }
            }
        }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));


        /***/
    }),
    /* 144 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*
         * canvg.js - Javascript SVG parser and renderer on Canvas
         * MIT Licensed
         * Gabe Lerner (gabelerner@gmail.com)
         * http://code.google.com/p/canvg/
         *
         * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
         */
        (function(global, factory) {

            'use strict';

            // export as AMD...
            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(155), __webpack_require__(157)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }

            // ...or as browserify
            else if (typeof module !== 'undefined' && module.exports) {
                module.exports = factory(require('rgbcolor'), require('stackblur'));
            }

            global.canvg = factory(global.RGBColor, global.stackBlur);

        }(typeof window !== 'undefined' ? window : this, function(RGBColor, stackBlur) {

            // canvg(target, s)
            // empty parameters: replace all 'svg' elements on page with 'canvas' elements
            // target: canvas element or the id of a canvas element
            // s: svg string, url to svg file, or xml document
            // opts: optional hash of options
            //       ignoreMouse: true => ignore mouse events
            //       ignoreAnimation: true => ignore animations
            //       ignoreDimensions: true => does not try to resize canvas
            //       ignoreClear: true => does not clear canvas
            //       offsetX: int => draws at a x offset
            //       offsetY: int => draws at a y offset
            //       scaleWidth: int => scales horizontally to width
            //       scaleHeight: int => scales vertically to height
            //       renderCallback: function => will call the function after the first render is completed
            //       forceRedraw: function => will call the function on every frame, if it returns true, will redraw
            var canvg = function(target, s, opts) {
                // no parameters
                if (target == null && s == null && opts == null) {
                    var svgTags = document.querySelectorAll('svg');
                    for (var i = 0; i < svgTags.length; i++) {
                        var svgTag = svgTags[i];
                        var c = document.createElement('canvas');
                        c.width = svgTag.clientWidth;
                        c.height = svgTag.clientHeight;
                        svgTag.parentNode.insertBefore(c, svgTag);
                        svgTag.parentNode.removeChild(svgTag);
                        var div = document.createElement('div');
                        div.appendChild(svgTag);
                        canvg(c, div.innerHTML);
                    }
                    return;
                }

                if (typeof target == 'string') {
                    target = document.getElementById(target);
                }

                // store class on canvas
                if (target.svg != null) target.svg.stop();
                var svg = build(opts || {});
                // on i.e. 8 for flash canvas, we can't assign the property so check for it
                if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;

                var ctx = target.getContext('2d');
                if (typeof(s.documentElement) != 'undefined') {
                    // load from xml doc
                    svg.loadXmlDoc(ctx, s);
                } else if (s.substr(0, 1) == '<') {
                    // load from xml string
                    svg.loadXml(ctx, s);
                } else {
                    // load from url
                    svg.load(ctx, s);
                }
            }

            // see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
            var matchesSelector;
            if (typeof(Element.prototype.matches) != 'undefined') {
                matchesSelector = function(node, selector) {
                    return node.matches(selector);
                };
            } else if (typeof(Element.prototype.webkitMatchesSelector) != 'undefined') {
                matchesSelector = function(node, selector) {
                    return node.webkitMatchesSelector(selector);
                };
            } else if (typeof(Element.prototype.mozMatchesSelector) != 'undefined') {
                matchesSelector = function(node, selector) {
                    return node.mozMatchesSelector(selector);
                };
            } else if (typeof(Element.prototype.msMatchesSelector) != 'undefined') {
                matchesSelector = function(node, selector) {
                    return node.msMatchesSelector(selector);
                };
            } else if (typeof(Element.prototype.oMatchesSelector) != 'undefined') {
                matchesSelector = function(node, selector) {
                    return node.oMatchesSelector(selector);
                };
            } else {
                // requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation
                // or jQuery: http://jquery.com/download/
                // or Zepto: http://zeptojs.com/#
                // without it, this is a ReferenceError

                if (typeof jQuery === 'function' || typeof Zepto === 'function') {
                    matchesSelector = function(node, selector) {
                        return $(node).is(selector);
                    };
                }

                if (typeof matchesSelector === 'undefined') {
                    matchesSelector = Sizzle.matchesSelector;
                }
            }

            // slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
            var attributeRegex = /(\[[^\]]+\])/g;
            var idRegex = /(#[^\s\+>~\.\[:]+)/g;
            var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
            var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi;
            var pseudoClassWithBracketsRegex = /(:[\w-]+\([^\)]*\))/gi;
            var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
            var elementRegex = /([^\s\+>~\.\[:]+)/g;

            function getSelectorSpecificity(selector) {
                var typeCount = [0, 0, 0];
                var findMatch = function(regex, type) {
                    var matches = selector.match(regex);
                    if (matches == null) {
                        return;
                    }
                    typeCount[type] += matches.length;
                    selector = selector.replace(regex, ' ');
                };

                selector = selector.replace(/:not\(([^\)]*)\)/g, '     $1 ');
                selector = selector.replace(/{[^]*/gm, ' ');
                findMatch(attributeRegex, 1);
                findMatch(idRegex, 0);
                findMatch(classRegex, 1);
                findMatch(pseudoElementRegex, 2);
                findMatch(pseudoClassWithBracketsRegex, 1);
                findMatch(pseudoClassRegex, 1);
                selector = selector.replace(/[\*\s\+>~]/g, ' ');
                selector = selector.replace(/[#\.]/g, ' ');
                findMatch(elementRegex, 2);
                return typeCount.join('');
            }

            function build(opts) {
                var svg = {
                    opts: opts
                };

                svg.FRAMERATE = 30;
                svg.MAX_VIRTUAL_PIXELS = 30000;

                svg.log = function(msg) {};
                if (svg.opts['log'] == true && typeof(console) != 'undefined') {
                    svg.log = function(msg) {
                        console.log(msg);
                    };
                };

                // globals
                svg.init = function(ctx) {
                    var uniqueId = 0;
                    svg.UniqueId = function() {
                        uniqueId++;
                        return 'canvg' + uniqueId;
                    };
                    svg.Definitions = {};
                    svg.Styles = {};
                    svg.StylesSpecificity = {};
                    svg.Animations = [];
                    svg.Images = [];
                    svg.ctx = ctx;
                    svg.ViewPort = new(function() {
                        this.viewPorts = [];
                        this.Clear = function() {
                            this.viewPorts = [];
                        }
                        this.SetCurrent = function(width, height) {
                            this.viewPorts.push({
                                width: width,
                                height: height
                            });
                        }
                        this.RemoveCurrent = function() {
                            this.viewPorts.pop();
                        }
                        this.Current = function() {
                            return this.viewPorts[this.viewPorts.length - 1];
                        }
                        this.width = function() {
                            return this.Current().width;
                        }
                        this.height = function() {
                            return this.Current().height;
                        }
                        this.ComputeSize = function(d) {
                            if (d != null && typeof(d) == 'number') return d;
                            if (d == 'x') return this.width();
                            if (d == 'y') return this.height();
                            return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
                        }
                    });
                }
                svg.init();

                // images loaded
                svg.ImagesLoaded = function() {
                    for (var i = 0; i < svg.Images.length; i++) {
                        if (!svg.Images[i].loaded) return false;
                    }
                    return true;
                }

                // trim
                svg.trim = function(s) {
                    return s.replace(/^\s+|\s+$/g, '');
                }

                // compress spaces
                svg.compressSpaces = function(s) {
                    return s.replace(/[\s\r\t\n]+/gm, ' ');
                }

                // ajax
                svg.ajax = function(url) {
                    var AJAX;
                    if (window.XMLHttpRequest) {
                        AJAX = new XMLHttpRequest();
                    } else {
                        AJAX = new ActiveXObject('Microsoft.XMLHTTP');
                    }
                    if (AJAX) {
                        AJAX.open('GET', url, false);
                        AJAX.send(null);
                        return AJAX.responseText;
                    }
                    return null;
                }

                // parse xml
                svg.parseXml = function(xml) {
                    if (typeof(Windows) != 'undefined' && typeof(Windows.Data) != 'undefined' && typeof(Windows.Data.Xml) != 'undefined') {
                        var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
                        var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
                        settings.prohibitDtd = false;
                        xmlDoc.loadXml(xml, settings);
                        return xmlDoc;
                    } else if (window.DOMParser) {
                        var parser = new DOMParser();
                        return parser.parseFromString(xml, 'text/xml');
                    } else {
                        xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
                        var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                        xmlDoc.async = 'false';
                        xmlDoc.loadXML(xml);
                        return xmlDoc;
                    }
                }

                svg.Property = function(name, value) {
                    this.name = name;
                    this.value = value;
                }
                svg.Property.prototype.getValue = function() {
                    return this.value;
                }

                svg.Property.prototype.hasValue = function() {
                    return (this.value != null && this.value !== '');
                }

                // return the numerical value of the property
                svg.Property.prototype.numValue = function() {
                    if (!this.hasValue()) return 0;

                    var n = parseFloat(this.value);
                    if ((this.value + '').match(/%$/)) {
                        n = n / 100.0;
                    }
                    return n;
                }

                svg.Property.prototype.valueOrDefault = function(def) {
                    if (this.hasValue()) return this.value;
                    return def;
                }

                svg.Property.prototype.numValueOrDefault = function(def) {
                    if (this.hasValue()) return this.numValue();
                    return def;
                }

                // color extensions
                // augment the current color value with the opacity
                svg.Property.prototype.addOpacity = function(opacityProp) {
                    var newValue = this.value;
                    if (opacityProp.value != null && opacityProp.value != '' && typeof(this.value) == 'string') { // can only add opacity to colors, not patterns
                        var color = new RGBColor(this.value);
                        if (color.ok) {
                            newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
                        }
                    }
                    return new svg.Property(this.name, newValue);
                }

                // definition extensions
                // get the definition from the definitions table
                svg.Property.prototype.getDefinition = function() {
                    var name = this.value.match(/#([^\)'"]+)/);
                    if (name) {
                        name = name[1];
                    }
                    if (!name) {
                        name = this.value;
                    }
                    return svg.Definitions[name];
                }

                svg.Property.prototype.isUrlDefinition = function() {
                    return this.value.indexOf('url(') == 0
                }

                svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
                    var def = this.getDefinition();

                    // gradient
                    if (def != null && def.createGradient) {
                        return def.createGradient(svg.ctx, e, opacityProp);
                    }

                    // pattern
                    if (def != null && def.createPattern) {
                        if (def.getHrefAttribute().hasValue()) {
                            var pt = def.attribute('patternTransform');
                            def = def.getHrefAttribute().getDefinition();
                            if (pt.hasValue()) {
                                def.attribute('patternTransform', true).value = pt.value;
                            }
                        }
                        return def.createPattern(svg.ctx, e);
                    }

                    return null;
                }

                // length extensions
                svg.Property.prototype.getDPI = function(viewPort) {
                    return 96.0; // TODO: compute?
                }

                svg.Property.prototype.getEM = function(viewPort) {
                    var em = 12;

                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);

                    return em;
                }

                svg.Property.prototype.getUnits = function() {
                    var s = this.value + '';
                    return s.replace(/[0-9\.\-]/g, '');
                }

                // get the length as pixels
                svg.Property.prototype.toPixels = function(viewPort, processPercent) {
                    if (!this.hasValue()) return 0;
                    var s = this.value + '';
                    if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
                    if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
                    if (s.match(/px$/)) return this.numValue();
                    if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
                    if (s.match(/pc$/)) return this.numValue() * 15;
                    if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
                    if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
                    if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
                    if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
                    var n = this.numValue();
                    if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
                    return n;
                }

                // time extensions
                // get the time as milliseconds
                svg.Property.prototype.toMilliseconds = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value + '';
                    if (s.match(/s$/)) return this.numValue() * 1000;
                    if (s.match(/ms$/)) return this.numValue();
                    return this.numValue();
                }

                // angle extensions
                // get the angle as radians
                svg.Property.prototype.toRadians = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value + '';
                    if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
                    if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
                    if (s.match(/rad$/)) return this.numValue();
                    return this.numValue() * (Math.PI / 180.0);
                }

                // text extensions
                // get the text baseline
                var textBaselineMapping = {
                    'baseline': 'alphabetic',
                    'before-edge': 'top',
                    'text-before-edge': 'top',
                    'middle': 'middle',
                    'central': 'middle',
                    'after-edge': 'bottom',
                    'text-after-edge': 'bottom',
                    'ideographic': 'ideographic',
                    'alphabetic': 'alphabetic',
                    'hanging': 'hanging',
                    'mathematical': 'alphabetic'
                };
                svg.Property.prototype.toTextBaseline = function() {
                    if (!this.hasValue()) return null;
                    return textBaselineMapping[this.value];
                }

                // fonts
                svg.Font = new(function() {
                    this.Styles = 'normal|italic|oblique|inherit';
                    this.Variants = 'normal|small-caps|inherit';
                    this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

                    this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                        var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                        return {
                            fontFamily: fontFamily || f.fontFamily,
                            fontSize: fontSize || f.fontSize,
                            fontStyle: fontStyle || f.fontStyle,
                            fontWeight: fontWeight || f.fontWeight,
                            fontVariant: fontVariant || f.fontVariant,
                            toString: function() {
                                return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ')
                            }
                        }
                    }

                    var that = this;
                    this.Parse = function(s) {
                        var f = {};
                        var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                        var set = {
                            fontSize: false,
                            fontStyle: false,
                            fontWeight: false,
                            fontVariant: false
                        }
                        var ff = '';
                        for (var i = 0; i < d.length; i++) {
                            if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) {
                                if (d[i] != 'inherit') f.fontStyle = d[i];
                                set.fontStyle = true;
                            } else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) {
                                if (d[i] != 'inherit') f.fontVariant = d[i];
                                set.fontStyle = set.fontVariant = true;
                            } else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {
                                if (d[i] != 'inherit') f.fontWeight = d[i];
                                set.fontStyle = set.fontVariant = set.fontWeight = true;
                            } else if (!set.fontSize) {
                                if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0];
                                set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true;
                            } else {
                                if (d[i] != 'inherit') ff += d[i];
                            }
                        }
                        if (ff != '') f.fontFamily = ff;
                        return f;
                    }
                });

                // points and paths
                svg.ToNumberArray = function(s) {
                    var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
                    for (var i = 0; i < a.length; i++) {
                        a[i] = parseFloat(a[i]);
                    }
                    return a;
                }
                svg.Point = function(x, y) {
                    this.x = x;
                    this.y = y;
                }
                svg.Point.prototype.angleTo = function(p) {
                    return Math.atan2(p.y - this.y, p.x - this.x);
                }

                svg.Point.prototype.applyTransform = function(v) {
                    var xp = this.x * v[0] + this.y * v[2] + v[4];
                    var yp = this.x * v[1] + this.y * v[3] + v[5];
                    this.x = xp;
                    this.y = yp;
                }

                svg.CreatePoint = function(s) {
                    var a = svg.ToNumberArray(s);
                    return new svg.Point(a[0], a[1]);
                }
                svg.CreatePath = function(s) {
                    var a = svg.ToNumberArray(s);
                    var path = [];
                    for (var i = 0; i < a.length; i += 2) {
                        path.push(new svg.Point(a[i], a[i + 1]));
                    }
                    return path;
                }

                // bounding box
                svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
                    this.x1 = Number.NaN;
                    this.y1 = Number.NaN;
                    this.x2 = Number.NaN;
                    this.y2 = Number.NaN;

                    this.x = function() {
                        return this.x1;
                    }
                    this.y = function() {
                        return this.y1;
                    }
                    this.width = function() {
                        return this.x2 - this.x1;
                    }
                    this.height = function() {
                        return this.y2 - this.y1;
                    }

                    this.addPoint = function(x, y) {
                        if (x != null) {
                            if (isNaN(this.x1) || isNaN(this.x2)) {
                                this.x1 = x;
                                this.x2 = x;
                            }
                            if (x < this.x1) this.x1 = x;
                            if (x > this.x2) this.x2 = x;
                        }

                        if (y != null) {
                            if (isNaN(this.y1) || isNaN(this.y2)) {
                                this.y1 = y;
                                this.y2 = y;
                            }
                            if (y < this.y1) this.y1 = y;
                            if (y > this.y2) this.y2 = y;
                        }
                    }
                    this.addX = function(x) {
                        this.addPoint(x, null);
                    }
                    this.addY = function(y) {
                        this.addPoint(null, y);
                    }

                    this.addBoundingBox = function(bb) {
                        this.addPoint(bb.x1, bb.y1);
                        this.addPoint(bb.x2, bb.y2);
                    }

                    this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                        var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
                        var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
                        var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
                        var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
                        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
                    }

                    this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                        // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
                        var p0 = [p0x, p0y],
                            p1 = [p1x, p1y],
                            p2 = [p2x, p2y],
                            p3 = [p3x, p3y];
                        this.addPoint(p0[0], p0[1]);
                        this.addPoint(p3[0], p3[1]);

                        for (i = 0; i <= 1; i++) {
                            var f = function(t) {
                                return Math.pow(1 - t, 3) * p0[i] +
                                    3 * Math.pow(1 - t, 2) * t * p1[i] +
                                    3 * (1 - t) * Math.pow(t, 2) * p2[i] +
                                    Math.pow(t, 3) * p3[i];
                            }

                            var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                            var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                            var c = 3 * p1[i] - 3 * p0[i];

                            if (a == 0) {
                                if (b == 0) continue;
                                var t = -c / b;
                                if (0 < t && t < 1) {
                                    if (i == 0) this.addX(f(t));
                                    if (i == 1) this.addY(f(t));
                                }
                                continue;
                            }

                            var b2ac = Math.pow(b, 2) - 4 * c * a;
                            if (b2ac < 0) continue;
                            var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                            if (0 < t1 && t1 < 1) {
                                if (i == 0) this.addX(f(t1));
                                if (i == 1) this.addY(f(t1));
                            }
                            var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                            if (0 < t2 && t2 < 1) {
                                if (i == 0) this.addX(f(t2));
                                if (i == 1) this.addY(f(t2));
                            }
                        }
                    }

                    this.isPointInBox = function(x, y) {
                        return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
                    }

                    this.addPoint(x1, y1);
                    this.addPoint(x2, y2);
                }

                // transforms
                svg.Transform = function(v) {
                    var that = this;
                    this.Type = {}

                    // translate
                    this.Type.translate = function(s) {
                        this.p = svg.CreatePoint(s);
                        this.apply = function(ctx) {
                            ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
                        }
                        this.unapply = function(ctx) {
                            ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
                        }
                        this.applyToPoint = function(p) {
                            p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                        }
                    }

                    // rotate
                    this.Type.rotate = function(s) {
                        var a = svg.ToNumberArray(s);
                        this.angle = new svg.Property('angle', a[0]);
                        this.cx = a[1] || 0;
                        this.cy = a[2] || 0;
                        this.apply = function(ctx) {
                            ctx.translate(this.cx, this.cy);
                            ctx.rotate(this.angle.toRadians());
                            ctx.translate(-this.cx, -this.cy);
                        }
                        this.unapply = function(ctx) {
                            ctx.translate(this.cx, this.cy);
                            ctx.rotate(-1.0 * this.angle.toRadians());
                            ctx.translate(-this.cx, -this.cy);
                        }
                        this.applyToPoint = function(p) {
                            var a = this.angle.toRadians();
                            p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                            p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                            p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
                        }
                    }

                    this.Type.scale = function(s) {
                        this.p = svg.CreatePoint(s);
                        this.apply = function(ctx) {
                            ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
                        }
                        this.unapply = function(ctx) {
                            ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
                        }
                        this.applyToPoint = function(p) {
                            p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
                        }
                    }

                    this.Type.matrix = function(s) {
                        this.m = svg.ToNumberArray(s);
                        this.apply = function(ctx) {
                            ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                        }
                        this.unapply = function(ctx) {
                            var a = this.m[0];
                            var b = this.m[2];
                            var c = this.m[4];
                            var d = this.m[1];
                            var e = this.m[3];
                            var f = this.m[5];
                            var g = 0.0;
                            var h = 0.0;
                            var i = 1.0;
                            var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));
                            ctx.transform(
                                det * (e * i - f * h),
                                det * (f * g - d * i),
                                det * (c * h - b * i),
                                det * (a * i - c * g),
                                det * (b * f - c * e),
                                det * (c * d - a * f)
                            );
                        }
                        this.applyToPoint = function(p) {
                            p.applyTransform(this.m);
                        }
                    }

                    this.Type.SkewBase = function(s) {
                        this.base = that.Type.matrix;
                        this.base(s);
                        this.angle = new svg.Property('angle', s);
                    }
                    this.Type.SkewBase.prototype = new this.Type.matrix;

                    this.Type.skewX = function(s) {
                        this.base = that.Type.SkewBase;
                        this.base(s);
                        this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
                    }
                    this.Type.skewX.prototype = new this.Type.SkewBase;

                    this.Type.skewY = function(s) {
                        this.base = that.Type.SkewBase;
                        this.base(s);
                        this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
                    }
                    this.Type.skewY.prototype = new this.Type.SkewBase;

                    this.transforms = [];

                    this.apply = function(ctx) {
                        for (var i = 0; i < this.transforms.length; i++) {
                            this.transforms[i].apply(ctx);
                        }
                    }

                    this.unapply = function(ctx) {
                        for (var i = this.transforms.length - 1; i >= 0; i--) {
                            this.transforms[i].unapply(ctx);
                        }
                    }

                    this.applyToPoint = function(p) {
                        for (var i = 0; i < this.transforms.length; i++) {
                            this.transforms[i].applyToPoint(p);
                        }
                    }

                    var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g, ') ').split(/\s(?=[a-z])/);
                    for (var i = 0; i < data.length; i++) {
                        var type = svg.trim(data[i].split('(')[0]);
                        var s = data[i].split('(')[1].replace(')', '');
                        var transform = new this.Type[type](s);
                        transform.type = type;
                        this.transforms.push(transform);
                    }
                }

                // aspect ratio
                svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
                    // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
                    aspectRatio = svg.compressSpaces(aspectRatio);
                    aspectRatio = aspectRatio.replace(/^defer\s/, ''); // ignore defer
                    var align = aspectRatio.split(' ')[0] || 'xMidYMid';
                    var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';

                    // calculate scale
                    var scaleX = width / desiredWidth;
                    var scaleY = height / desiredHeight;
                    var scaleMin = Math.min(scaleX, scaleY);
                    var scaleMax = Math.max(scaleX, scaleY);
                    if (meetOrSlice == 'meet') {
                        desiredWidth *= scaleMin;
                        desiredHeight *= scaleMin;
                    }
                    if (meetOrSlice == 'slice') {
                        desiredWidth *= scaleMax;
                        desiredHeight *= scaleMax;
                    }

                    refX = new svg.Property('refX', refX);
                    refY = new svg.Property('refY', refY);
                    if (refX.hasValue() && refY.hasValue()) {
                        ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
                    } else {
                        // align
                        if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
                        if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
                        if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);
                        if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);
                    }

                    // scale
                    if (align == 'none') ctx.scale(scaleX, scaleY);
                    else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);
                    else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);

                    // translate
                    ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
                }

                // elements
                svg.Element = {}

                svg.EmptyProperty = new svg.Property('EMPTY', '');

                svg.Element.ElementBase = function(node) {
                    this.attributes = {};
                    this.styles = {};
                    this.stylesSpecificity = {};
                    this.children = [];

                    // get or create attribute
                    this.attribute = function(name, createIfNotExists) {
                        var a = this.attributes[name];
                        if (a != null) return a;

                        if (createIfNotExists == true) {
                            a = new svg.Property(name, '');
                            this.attributes[name] = a;
                        }
                        return a || svg.EmptyProperty;
                    }

                    this.getHrefAttribute = function() {
                        for (var a in this.attributes) {
                            if (a == 'href' || a.match(/:href$/)) {
                                return this.attributes[a];
                            }
                        }
                        return svg.EmptyProperty;
                    }

                    // get or create style, crawls up node tree
                    this.style = function(name, createIfNotExists, skipAncestors) {
                        var s = this.styles[name];
                        if (s != null) return s;

                        var a = this.attribute(name);
                        if (a != null && a.hasValue()) {
                            this.styles[name] = a; // move up to me to cache
                            return a;
                        }

                        if (skipAncestors != true) {
                            var p = this.parent;
                            if (p != null) {
                                var ps = p.style(name);
                                if (ps != null && ps.hasValue()) {
                                    return ps;
                                }
                            }
                        }

                        if (createIfNotExists == true) {
                            s = new svg.Property(name, '');
                            this.styles[name] = s;
                        }
                        return s || svg.EmptyProperty;
                    }

                    // base render
                    this.render = function(ctx) {
                        // don't render display=none
                        if (this.style('display').value == 'none') return;

                        // don't render visibility=hidden
                        if (this.style('visibility').value == 'hidden') return;

                        ctx.save();
                        if (this.style('mask').hasValue()) { // mask
                            var mask = this.style('mask').getDefinition();
                            if (mask != null) mask.apply(ctx, this);
                        } else if (this.style('filter').hasValue()) { // filter
                            var filter = this.style('filter').getDefinition();
                            if (filter != null) filter.apply(ctx, this);
                        } else {
                            this.setContext(ctx);
                            this.renderChildren(ctx);
                            this.clearContext(ctx);
                        }
                        ctx.restore();
                    }

                    // base set context
                    this.setContext = function(ctx) {
                        // OVERRIDE ME!
                    }

                    // base clear context
                    this.clearContext = function(ctx) {
                        // OVERRIDE ME!
                    }

                    // base render children
                    this.renderChildren = function(ctx) {
                        for (var i = 0; i < this.children.length; i++) {
                            this.children[i].render(ctx);
                        }
                    }

                    this.addChild = function(childNode, create) {
                        var child = childNode;
                        if (create) child = svg.CreateElement(childNode);
                        child.parent = this;
                        if (child.type != 'title') {
                            this.children.push(child);
                        }
                    }

                    this.addStylesFromStyleDefinition = function() {
                        // add styles
                        for (var selector in svg.Styles) {
                            if (selector[0] != '@' && matchesSelector(node, selector)) {
                                var styles = svg.Styles[selector];
                                var specificity = svg.StylesSpecificity[selector];
                                if (styles != null) {
                                    for (var name in styles) {
                                        var existingSpecificity = this.stylesSpecificity[name];
                                        if (typeof(existingSpecificity) == 'undefined') {
                                            existingSpecificity = '000';
                                        }
                                        if (specificity > existingSpecificity) {
                                            this.styles[name] = styles[name];
                                            this.stylesSpecificity[name] = specificity;
                                        }
                                    }
                                }
                            }
                        }
                    };

                    if (node != null && node.nodeType == 1) { //ELEMENT_NODE
                        // add attributes
                        for (var i = 0; i < node.attributes.length; i++) {
                            var attribute = node.attributes[i];
                            this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.value);
                        }

                        this.addStylesFromStyleDefinition();

                        // add inline styles
                        if (this.attribute('style').hasValue()) {
                            var styles = this.attribute('style').value.split(';');
                            for (var i = 0; i < styles.length; i++) {
                                if (svg.trim(styles[i]) != '') {
                                    var style = styles[i].split(':');
                                    var name = svg.trim(style[0]);
                                    var value = svg.trim(style[1]);
                                    this.styles[name] = new svg.Property(name, value);
                                }
                            }
                        }

                        // add id
                        if (this.attribute('id').hasValue()) {
                            if (svg.Definitions[this.attribute('id').value] == null) {
                                svg.Definitions[this.attribute('id').value] = this;
                            }
                        }

                        // add children
                        for (var i = 0; i < node.childNodes.length; i++) {
                            var childNode = node.childNodes[i];
                            if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
                            if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
                                var text = childNode.value || childNode.text || childNode.textContent || '';
                                if (svg.compressSpaces(text) != '') {
                                    this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
                                }
                            }
                        }
                    }
                }

                svg.Element.RenderedElementBase = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.setContext = function(ctx) {
                        // fill
                        if (this.style('fill').isUrlDefinition()) {
                            var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
                            if (fs != null) ctx.fillStyle = fs;
                        } else if (this.style('fill').hasValue()) {
                            var fillStyle = this.style('fill');
                            if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
                            if (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
                        }
                        if (this.style('fill-opacity').hasValue()) {
                            var fillStyle = new svg.Property('fill', ctx.fillStyle);
                            fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
                            ctx.fillStyle = fillStyle.value;
                        }

                        // stroke
                        if (this.style('stroke').isUrlDefinition()) {
                            var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
                            if (fs != null) ctx.strokeStyle = fs;
                        } else if (this.style('stroke').hasValue()) {
                            var strokeStyle = this.style('stroke');
                            if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
                            if (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
                        }
                        if (this.style('stroke-opacity').hasValue()) {
                            var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
                            strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
                            ctx.strokeStyle = strokeStyle.value;
                        }
                        if (this.style('stroke-width').hasValue()) {
                            var newLineWidth = this.style('stroke-width').toPixels();
                            ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
                        }
                        if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
                        if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
                        if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
                        if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
                            var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
                            if (typeof(ctx.setLineDash) != 'undefined') {
                                ctx.setLineDash(gaps);
                            } else if (typeof(ctx.webkitLineDash) != 'undefined') {
                                ctx.webkitLineDash = gaps;
                            } else if (typeof(ctx.mozDash) != 'undefined' && !(gaps.length == 1 && gaps[0] == 0)) {
                                ctx.mozDash = gaps;
                            }

                            var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
                            if (typeof(ctx.lineDashOffset) != 'undefined') {
                                ctx.lineDashOffset = offset;
                            } else if (typeof(ctx.webkitLineDashOffset) != 'undefined') {
                                ctx.webkitLineDashOffset = offset;
                            } else if (typeof(ctx.mozDashOffset) != 'undefined') {
                                ctx.mozDashOffset = offset;
                            }
                        }

                        // font
                        if (typeof(ctx.font) != 'undefined') {
                            ctx.font = svg.Font.CreateFont(
                                this.style('font-style').value,
                                this.style('font-variant').value,
                                this.style('font-weight').value,
                                this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',
                                this.style('font-family').value).toString();
                        }

                        // transform
                        if (this.style('transform', false, true).hasValue()) {
                            var transform = new svg.Transform(this.style('transform', false, true).value);
                            transform.apply(ctx);
                        }

                        // clip
                        if (this.style('clip-path', false, true).hasValue()) {
                            var clip = this.style('clip-path', false, true).getDefinition();
                            if (clip != null) clip.apply(ctx);
                        }

                        // opacity
                        if (this.style('opacity').hasValue()) {
                            ctx.globalAlpha = this.style('opacity').numValue();
                        }
                    }
                }
                svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;

                svg.Element.PathElementBase = function(node) {
                    this.base = svg.Element.RenderedElementBase;
                    this.base(node);

                    this.path = function(ctx) {
                        if (ctx != null) ctx.beginPath();
                        return new svg.BoundingBox();
                    }

                    this.renderChildren = function(ctx) {
                        this.path(ctx);
                        svg.Mouse.checkPath(this, ctx);
                        if (ctx.fillStyle != '') {
                            if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') {
                                ctx.fill(this.style('fill-rule').value);
                            } else {
                                ctx.fill();
                            }
                        }
                        if (ctx.strokeStyle != '') ctx.stroke();

                        var markers = this.getMarkers();
                        if (markers != null) {
                            if (this.style('marker-start').isUrlDefinition()) {
                                var marker = this.style('marker-start').getDefinition();
                                marker.render(ctx, markers[0][0], markers[0][1]);
                            }
                            if (this.style('marker-mid').isUrlDefinition()) {
                                var marker = this.style('marker-mid').getDefinition();
                                for (var i = 1; i < markers.length - 1; i++) {
                                    marker.render(ctx, markers[i][0], markers[i][1]);
                                }
                            }
                            if (this.style('marker-end').isUrlDefinition()) {
                                var marker = this.style('marker-end').getDefinition();
                                marker.render(ctx, markers[markers.length - 1][0], markers[markers.length - 1][1]);
                            }
                        }
                    }

                    this.getBoundingBox = function() {
                        return this.path();
                    }

                    this.getMarkers = function() {
                        return null;
                    }
                }
                svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;

                // svg element
                svg.Element.svg = function(node) {
                    this.base = svg.Element.RenderedElementBase;
                    this.base(node);

                    this.baseClearContext = this.clearContext;
                    this.clearContext = function(ctx) {
                        this.baseClearContext(ctx);
                        svg.ViewPort.RemoveCurrent();
                    }

                    this.baseSetContext = this.setContext;
                    this.setContext = function(ctx) {
                        // initial values and defaults
                        ctx.strokeStyle = 'rgba(0,0,0,0)';
                        ctx.lineCap = 'butt';
                        ctx.lineJoin = 'miter';
                        ctx.miterLimit = 4;
                        if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
                            ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
                        }

                        this.baseSetContext(ctx);

                        // create new view port
                        if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
                        if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
                        ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));

                        var width = svg.ViewPort.width();
                        var height = svg.ViewPort.height();

                        if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
                        if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
                        if (typeof(this.root) == 'undefined') {
                            width = this.attribute('width').toPixels('x');
                            height = this.attribute('height').toPixels('y');

                            var x = 0;
                            var y = 0;
                            if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
                                x = -this.attribute('refX').toPixels('x');
                                y = -this.attribute('refY').toPixels('y');
                            }

                            if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(width, y);
                                ctx.lineTo(width, height);
                                ctx.lineTo(x, height);
                                ctx.closePath();
                                ctx.clip();
                            }
                        }
                        svg.ViewPort.SetCurrent(width, height);

                        // viewbox
                        if (this.attribute('viewBox').hasValue()) {
                            var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                            var minX = viewBox[0];
                            var minY = viewBox[1];
                            width = viewBox[2];
                            height = viewBox[3];

                            svg.AspectRatio(ctx,
                                this.attribute('preserveAspectRatio').value,
                                svg.ViewPort.width(),
                                width,
                                svg.ViewPort.height(),
                                height,
                                minX,
                                minY,
                                this.attribute('refX').value,
                                this.attribute('refY').value);

                            svg.ViewPort.RemoveCurrent();
                            svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
                        }
                    }
                }
                svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

                // rect element
                svg.Element.rect = function(node) {
                    this.base = svg.Element.PathElementBase;
                    this.base(node);

                    this.path = function(ctx) {
                        var x = this.attribute('x').toPixels('x');
                        var y = this.attribute('y').toPixels('y');
                        var width = this.attribute('width').toPixels('x');
                        var height = this.attribute('height').toPixels('y');
                        var rx = this.attribute('rx').toPixels('x');
                        var ry = this.attribute('ry').toPixels('y');
                        if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
                        if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
                        rx = Math.min(rx, width / 2.0);
                        ry = Math.min(ry, height / 2.0);
                        if (ctx != null) {
                            ctx.beginPath();
                            ctx.moveTo(x + rx, y);
                            ctx.lineTo(x + width - rx, y);
                            ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
                            ctx.lineTo(x + width, y + height - ry);
                            ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
                            ctx.lineTo(x + rx, y + height);
                            ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
                            ctx.lineTo(x, y + ry);
                            ctx.quadraticCurveTo(x, y, x + rx, y)
                            ctx.closePath();
                        }

                        return new svg.BoundingBox(x, y, x + width, y + height);
                    }
                }
                svg.Element.rect.prototype = new svg.Element.PathElementBase;

                // circle element
                svg.Element.circle = function(node) {
                    this.base = svg.Element.PathElementBase;
                    this.base(node);

                    this.path = function(ctx) {
                        var cx = this.attribute('cx').toPixels('x');
                        var cy = this.attribute('cy').toPixels('y');
                        var r = this.attribute('r').toPixels();

                        if (ctx != null) {
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
                            ctx.closePath();
                        }

                        return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
                    }
                }
                svg.Element.circle.prototype = new svg.Element.PathElementBase;

                // ellipse element
                svg.Element.ellipse = function(node) {
                    this.base = svg.Element.PathElementBase;
                    this.base(node);

                    this.path = function(ctx) {
                        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                        var rx = this.attribute('rx').toPixels('x');
                        var ry = this.attribute('ry').toPixels('y');
                        var cx = this.attribute('cx').toPixels('x');
                        var cy = this.attribute('cy').toPixels('y');

                        if (ctx != null) {
                            ctx.beginPath();
                            ctx.moveTo(cx, cy - ry);
                            ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry, cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                            ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                            ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                            ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                            ctx.closePath();
                        }

                        return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
                    }
                }
                svg.Element.ellipse.prototype = new svg.Element.PathElementBase;

                // line element
                svg.Element.line = function(node) {
                    this.base = svg.Element.PathElementBase;
                    this.base(node);

                    this.getPoints = function() {
                        return [
                            new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
                            new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))
                        ];
                    }

                    this.path = function(ctx) {
                        var points = this.getPoints();

                        if (ctx != null) {
                            ctx.beginPath();
                            ctx.moveTo(points[0].x, points[0].y);
                            ctx.lineTo(points[1].x, points[1].y);
                        }

                        return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
                    }

                    this.getMarkers = function() {
                        var points = this.getPoints();
                        var a = points[0].angleTo(points[1]);
                        return [
                            [points[0], a],
                            [points[1], a]
                        ];
                    }
                }
                svg.Element.line.prototype = new svg.Element.PathElementBase;

                // polyline element
                svg.Element.polyline = function(node) {
                    this.base = svg.Element.PathElementBase;
                    this.base(node);

                    this.points = svg.CreatePath(this.attribute('points').value);
                    this.path = function(ctx) {
                        var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                        if (ctx != null) {
                            ctx.beginPath();
                            ctx.moveTo(this.points[0].x, this.points[0].y);
                        }
                        for (var i = 1; i < this.points.length; i++) {
                            bb.addPoint(this.points[i].x, this.points[i].y);
                            if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
                        }
                        return bb;
                    }

                    this.getMarkers = function() {
                        var markers = [];
                        for (var i = 0; i < this.points.length - 1; i++) {
                            markers.push([this.points[i], this.points[i].angleTo(this.points[i + 1])]);
                        }
                        markers.push([this.points[this.points.length - 1], markers[markers.length - 1][1]]);
                        return markers;
                    }
                }
                svg.Element.polyline.prototype = new svg.Element.PathElementBase;

                // polygon element
                svg.Element.polygon = function(node) {
                    this.base = svg.Element.polyline;
                    this.base(node);

                    this.basePath = this.path;
                    this.path = function(ctx) {
                        var bb = this.basePath(ctx);
                        if (ctx != null) {
                            ctx.lineTo(this.points[0].x, this.points[0].y);
                            ctx.closePath();
                        }
                        return bb;
                    }
                }
                svg.Element.polygon.prototype = new svg.Element.polyline;

                // path element
                svg.Element.path = function(node) {
                    this.base = svg.Element.PathElementBase;
                    this.base(node);

                    var d = this.attribute('d').value;
                    // TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
                    d = d.replace(/,/gm, ' '); // get rid of all commas
                    // As the end of a match can also be the start of the next match, we need to run this replace twice.
                    for (var i = 0; i < 2; i++)
                        d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, '$1 $2'); // suffix commands with spaces
                    d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, '$1 $2'); // prefix commands with spaces
                    d = d.replace(/([0-9])([+\-])/gm, '$1 $2'); // separate digits on +- signs
                    // Again, we need to run this twice to find all occurances
                    for (var i = 0; i < 2; i++)
                        d = d.replace(/(\.[0-9]*)(\.)/gm, '$1 $2'); // separate digits when they start with a comma
                    d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, '$1 $3 $4 '); // shorthand elliptical arc path syntax
                    d = svg.compressSpaces(d); // compress multiple spaces
                    d = svg.trim(d);
                    this.PathParser = new(function(d) {
                        this.tokens = d.split(' ');

                        this.reset = function() {
                            this.i = -1;
                            this.command = '';
                            this.previousCommand = '';
                            this.start = new svg.Point(0, 0);
                            this.control = new svg.Point(0, 0);
                            this.current = new svg.Point(0, 0);
                            this.points = [];
                            this.angles = [];
                        }

                        this.isEnd = function() {
                            return this.i >= this.tokens.length - 1;
                        }

                        this.isCommandOrEnd = function() {
                            if (this.isEnd()) return true;
                            return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
                        }

                        this.isRelativeCommand = function() {
                            switch (this.command) {
                                case 'm':
                                case 'l':
                                case 'h':
                                case 'v':
                                case 'c':
                                case 's':
                                case 'q':
                                case 't':
                                case 'a':
                                case 'z':
                                    return true;
                                    break;
                            }
                            return false;
                        }

                        this.getToken = function() {
                            this.i++;
                            return this.tokens[this.i];
                        }

                        this.getScalar = function() {
                            return parseFloat(this.getToken());
                        }

                        this.nextCommand = function() {
                            this.previousCommand = this.command;
                            this.command = this.getToken();
                        }

                        this.getPoint = function() {
                            var p = new svg.Point(this.getScalar(), this.getScalar());
                            return this.makeAbsolute(p);
                        }

                        this.getAsControlPoint = function() {
                            var p = this.getPoint();
                            this.control = p;
                            return p;
                        }

                        this.getAsCurrentPoint = function() {
                            var p = this.getPoint();
                            this.current = p;
                            return p;
                        }

                        this.getReflectedControlPoint = function() {
                            if (this.previousCommand.toLowerCase() != 'c' &&
                                this.previousCommand.toLowerCase() != 's' &&
                                this.previousCommand.toLowerCase() != 'q' &&
                                this.previousCommand.toLowerCase() != 't') {
                                return this.current;
                            }

                            // reflect point
                            var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
                            return p;
                        }

                        this.makeAbsolute = function(p) {
                            if (this.isRelativeCommand()) {
                                p.x += this.current.x;
                                p.y += this.current.y;
                            }
                            return p;
                        }

                        this.addMarker = function(p, from, priorTo) {
                            // if the last angle isn't filled in because we didn't have this point yet ...
                            if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null) {
                                this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(priorTo);
                            }
                            this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
                        }

                        this.addMarkerAngle = function(p, a) {
                            this.points.push(p);
                            this.angles.push(a);
                        }

                        this.getMarkerPoints = function() {
                            return this.points;
                        }
                        this.getMarkerAngles = function() {
                            for (var i = 0; i < this.angles.length; i++) {
                                if (this.angles[i] == null) {
                                    for (var j = i + 1; j < this.angles.length; j++) {
                                        if (this.angles[j] != null) {
                                            this.angles[i] = this.angles[j];
                                            break;
                                        }
                                    }
                                }
                            }
                            return this.angles;
                        }
                    })(d);

                    this.path = function(ctx) {
                        var pp = this.PathParser;
                        pp.reset();

                        var bb = new svg.BoundingBox();
                        if (ctx != null) ctx.beginPath();
                        while (!pp.isEnd()) {
                            pp.nextCommand();
                            switch (pp.command) {
                                case 'M':
                                case 'm':
                                    var p = pp.getAsCurrentPoint();
                                    pp.addMarker(p);
                                    bb.addPoint(p.x, p.y);
                                    if (ctx != null) ctx.moveTo(p.x, p.y);
                                    pp.start = pp.current;
                                    while (!pp.isCommandOrEnd()) {
                                        var p = pp.getAsCurrentPoint();
                                        pp.addMarker(p, pp.start);
                                        bb.addPoint(p.x, p.y);
                                        if (ctx != null) ctx.lineTo(p.x, p.y);
                                    }
                                    break;
                                case 'L':
                                case 'l':
                                    while (!pp.isCommandOrEnd()) {
                                        var c = pp.current;
                                        var p = pp.getAsCurrentPoint();
                                        pp.addMarker(p, c);
                                        bb.addPoint(p.x, p.y);
                                        if (ctx != null) ctx.lineTo(p.x, p.y);
                                    }
                                    break;
                                case 'H':
                                case 'h':
                                    while (!pp.isCommandOrEnd()) {
                                        var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                                        pp.addMarker(newP, pp.current);
                                        pp.current = newP;
                                        bb.addPoint(pp.current.x, pp.current.y);
                                        if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                                    }
                                    break;
                                case 'V':
                                case 'v':
                                    while (!pp.isCommandOrEnd()) {
                                        var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                                        pp.addMarker(newP, pp.current);
                                        pp.current = newP;
                                        bb.addPoint(pp.current.x, pp.current.y);
                                        if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                                    }
                                    break;
                                case 'C':
                                case 'c':
                                    while (!pp.isCommandOrEnd()) {
                                        var curr = pp.current;
                                        var p1 = pp.getPoint();
                                        var cntrl = pp.getAsControlPoint();
                                        var cp = pp.getAsCurrentPoint();
                                        pp.addMarker(cp, cntrl, p1);
                                        bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                        if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                    }
                                    break;
                                case 'S':
                                case 's':
                                    while (!pp.isCommandOrEnd()) {
                                        var curr = pp.current;
                                        var p1 = pp.getReflectedControlPoint();
                                        var cntrl = pp.getAsControlPoint();
                                        var cp = pp.getAsCurrentPoint();
                                        pp.addMarker(cp, cntrl, p1);
                                        bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                        if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                    }
                                    break;
                                case 'Q':
                                case 'q':
                                    while (!pp.isCommandOrEnd()) {
                                        var curr = pp.current;
                                        var cntrl = pp.getAsControlPoint();
                                        var cp = pp.getAsCurrentPoint();
                                        pp.addMarker(cp, cntrl, cntrl);
                                        bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                        if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                                    }
                                    break;
                                case 'T':
                                case 't':
                                    while (!pp.isCommandOrEnd()) {
                                        var curr = pp.current;
                                        var cntrl = pp.getReflectedControlPoint();
                                        pp.control = cntrl;
                                        var cp = pp.getAsCurrentPoint();
                                        pp.addMarker(cp, cntrl, cntrl);
                                        bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                        if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                                    }
                                    break;
                                case 'A':
                                case 'a':
                                    while (!pp.isCommandOrEnd()) {
                                        var curr = pp.current;
                                        var rx = pp.getScalar();
                                        var ry = pp.getScalar();
                                        var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                                        var largeArcFlag = pp.getScalar();
                                        var sweepFlag = pp.getScalar();
                                        var cp = pp.getAsCurrentPoint();

                                        // Conversion from endpoint to center parameterization
                                        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                                        // x1', y1'
                                        var currp = new svg.Point(
                                            Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0, -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                                        );
                                        // adjust radii
                                        var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                                        if (l > 1) {
                                            rx *= Math.sqrt(l);
                                            ry *= Math.sqrt(l);
                                        }
                                        // cx', cy'
                                        var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                                            ((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currp.y, 2)) - (Math.pow(ry, 2) * Math.pow(currp.x, 2))) /
                                            (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2))
                                        );
                                        if (isNaN(s)) s = 0;
                                        var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                                        // cx, cy
                                        var centp = new svg.Point(
                                            (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                                            (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                                        );
                                        // vector magnitude
                                        var m = function(v) {
                                            return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
                                        }
                                        // ratio between two vectors
                                        var r = function(u, v) {
                                            return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v))
                                        }
                                        // angle between two vectors
                                        var a = function(u, v) {
                                            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v));
                                        }
                                        // initial angle
                                        var a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);
                                        // angle delta
                                        var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];
                                        var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];
                                        var ad = a(u, v);
                                        if (r(u, v) <= -1) ad = Math.PI;
                                        if (r(u, v) >= 1) ad = 0;

                                        // for markers
                                        var dir = 1 - sweepFlag ? 1.0 : -1.0;
                                        var ah = a1 + dir * (ad / 2.0);
                                        var halfWay = new svg.Point(
                                            centp.x + rx * Math.cos(ah),
                                            centp.y + ry * Math.sin(ah)
                                        );
                                        pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                                        pp.addMarkerAngle(cp, ah - dir * Math.PI);

                                        bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
                                        if (ctx != null) {
                                            var r = rx > ry ? rx : ry;
                                            var sx = rx > ry ? 1 : rx / ry;
                                            var sy = rx > ry ? ry / rx : 1;

                                            ctx.translate(centp.x, centp.y);
                                            ctx.rotate(xAxisRotation);
                                            ctx.scale(sx, sy);
                                            ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                            ctx.scale(1 / sx, 1 / sy);
                                            ctx.rotate(-xAxisRotation);
                                            ctx.translate(-centp.x, -centp.y);
                                        }
                                    }
                                    break;
                                case 'Z':
                                case 'z':
                                    if (ctx != null) ctx.closePath();
                                    pp.current = pp.start;
                            }
                        }

                        return bb;
                    }

                    this.getMarkers = function() {
                        var points = this.PathParser.getMarkerPoints();
                        var angles = this.PathParser.getMarkerAngles();

                        var markers = [];
                        for (var i = 0; i < points.length; i++) {
                            markers.push([points[i], angles[i]]);
                        }
                        return markers;
                    }
                }
                svg.Element.path.prototype = new svg.Element.PathElementBase;

                // pattern element
                svg.Element.pattern = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.createPattern = function(ctx, element) {
                        var width = this.attribute('width').toPixels('x', true);
                        var height = this.attribute('height').toPixels('y', true);

                        // render me using a temporary svg element
                        var tempSvg = new svg.Element.svg();
                        tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                        tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
                        tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
                        tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
                        tempSvg.children = this.children;

                        var c = document.createElement('canvas');
                        c.width = width;
                        c.height = height;
                        var cctx = c.getContext('2d');
                        if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
                            cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
                        }
                        // render 3x3 grid so when we transform there's no white space on edges
                        for (var x = -1; x <= 1; x++) {
                            for (var y = -1; y <= 1; y++) {
                                cctx.save();
                                tempSvg.attributes['x'] = new svg.Property('x', x * c.width);
                                tempSvg.attributes['y'] = new svg.Property('y', y * c.height);
                                tempSvg.render(cctx);
                                cctx.restore();
                            }
                        }
                        var pattern = ctx.createPattern(c, 'repeat');
                        return pattern;
                    }
                }
                svg.Element.pattern.prototype = new svg.Element.ElementBase;

                // marker element
                svg.Element.marker = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.baseRender = this.render;
                    this.render = function(ctx, point, angle) {
                        ctx.translate(point.x, point.y);
                        if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
                        if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
                        ctx.save();

                        // render me using a temporary svg element
                        var tempSvg = new svg.Element.svg();
                        tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                        tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                        tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                        tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                        tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                        tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                        tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                        tempSvg.children = this.children;
                        tempSvg.render(ctx);

                        ctx.restore();
                        if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
                        if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
                        ctx.translate(-point.x, -point.y);
                    }
                }
                svg.Element.marker.prototype = new svg.Element.ElementBase;

                // definitions element
                svg.Element.defs = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.render = function(ctx) {
                        // NOOP
                    }
                }
                svg.Element.defs.prototype = new svg.Element.ElementBase;

                // base for gradients
                svg.Element.GradientBase = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.stops = [];
                    for (var i = 0; i < this.children.length; i++) {
                        var child = this.children[i];
                        if (child.type == 'stop') this.stops.push(child);
                    }

                    this.getGradient = function() {
                        // OVERRIDE ME!
                    }

                    this.gradientUnits = function() {
                        return this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
                    }

                    this.attributesToInherit = ['gradientUnits'];

                    this.inheritStopContainer = function(stopsContainer) {
                        for (var i = 0; i < this.attributesToInherit.length; i++) {
                            var attributeToInherit = this.attributesToInherit[i];
                            if (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {
                                this.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;
                            }
                        }
                    }

                    this.createGradient = function(ctx, element, parentOpacityProp) {
                        var stopsContainer = this;
                        if (this.getHrefAttribute().hasValue()) {
                            stopsContainer = this.getHrefAttribute().getDefinition();
                            this.inheritStopContainer(stopsContainer);
                        }

                        var addParentOpacity = function(color) {
                            if (parentOpacityProp.hasValue()) {
                                var p = new svg.Property('color', color);
                                return p.addOpacity(parentOpacityProp).value;
                            }
                            return color;
                        };

                        var g = this.getGradient(ctx, element);
                        if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                        for (var i = 0; i < stopsContainer.stops.length; i++) {
                            g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
                        }

                        if (this.attribute('gradientTransform').hasValue()) {
                            // render as transformed pattern on temporary canvas
                            var rootView = svg.ViewPort.viewPorts[0];

                            var rect = new svg.Element.rect();
                            rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS / 3.0);
                            rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS / 3.0);
                            rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                            rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);

                            var group = new svg.Element.g();
                            group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                            group.children = [rect];

                            var tempSvg = new svg.Element.svg();
                            tempSvg.attributes['x'] = new svg.Property('x', 0);
                            tempSvg.attributes['y'] = new svg.Property('y', 0);
                            tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                            tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                            tempSvg.children = [group];

                            var c = document.createElement('canvas');
                            c.width = rootView.width;
                            c.height = rootView.height;
                            var tempCtx = c.getContext('2d');
                            tempCtx.fillStyle = g;
                            tempSvg.render(tempCtx);
                            return tempCtx.createPattern(c, 'no-repeat');
                        }

                        return g;
                    }
                }
                svg.Element.GradientBase.prototype = new svg.Element.ElementBase;

                // linear gradient element
                svg.Element.linearGradient = function(node) {
                    this.base = svg.Element.GradientBase;
                    this.base(node);

                    this.attributesToInherit.push('x1');
                    this.attributesToInherit.push('y1');
                    this.attributesToInherit.push('x2');
                    this.attributesToInherit.push('y2');

                    this.getGradient = function(ctx, element) {
                        var bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;

                        if (!this.attribute('x1').hasValue() &&
                            !this.attribute('y1').hasValue() &&
                            !this.attribute('x2').hasValue() &&
                            !this.attribute('y2').hasValue()) {
                            this.attribute('x1', true).value = 0;
                            this.attribute('y1', true).value = 0;
                            this.attribute('x2', true).value = 1;
                            this.attribute('y2', true).value = 0;
                        }

                        var x1 = (this.gradientUnits() == 'objectBoundingBox' ?
                            bb.x() + bb.width() * this.attribute('x1').numValue() :
                            this.attribute('x1').toPixels('x'));
                        var y1 = (this.gradientUnits() == 'objectBoundingBox' ?
                            bb.y() + bb.height() * this.attribute('y1').numValue() :
                            this.attribute('y1').toPixels('y'));
                        var x2 = (this.gradientUnits() == 'objectBoundingBox' ?
                            bb.x() + bb.width() * this.attribute('x2').numValue() :
                            this.attribute('x2').toPixels('x'));
                        var y2 = (this.gradientUnits() == 'objectBoundingBox' ?
                            bb.y() + bb.height() * this.attribute('y2').numValue() :
                            this.attribute('y2').toPixels('y'));

                        if (x1 == x2 && y1 == y2) return null;
                        return ctx.createLinearGradient(x1, y1, x2, y2);
                    }
                }
                svg.Element.linearGradient.prototype = new svg.Element.GradientBase;

                // radial gradient element
                svg.Element.radialGradient = function(node) {
                    this.base = svg.Element.GradientBase;
                    this.base(node);

                    this.attributesToInherit.push('cx');
                    this.attributesToInherit.push('cy');
                    this.attributesToInherit.push('r');
                    this.attributesToInherit.push('fx');
                    this.attributesToInherit.push('fy');

                    this.getGradient = function(ctx, element) {
                        var bb = element.getBoundingBox();

                        if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
                        if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
                        if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';

                        var cx = (this.gradientUnits() == 'objectBoundingBox' ?
                            bb.x() + bb.width() * this.attribute('cx').numValue() :
                            this.attribute('cx').toPixels('x'));
                        var cy = (this.gradientUnits() == 'objectBoundingBox' ?
                            bb.y() + bb.height() * this.attribute('cy').numValue() :
                            this.attribute('cy').toPixels('y'));

                        var fx = cx;
                        var fy = cy;
                        if (this.attribute('fx').hasValue()) {
                            fx = (this.gradientUnits() == 'objectBoundingBox' ?
                                bb.x() + bb.width() * this.attribute('fx').numValue() :
                                this.attribute('fx').toPixels('x'));
                        }
                        if (this.attribute('fy').hasValue()) {
                            fy = (this.gradientUnits() == 'objectBoundingBox' ?
                                bb.y() + bb.height() * this.attribute('fy').numValue() :
                                this.attribute('fy').toPixels('y'));
                        }

                        var r = (this.gradientUnits() == 'objectBoundingBox' ?
                            (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue() :
                            this.attribute('r').toPixels());

                        return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
                    }
                }
                svg.Element.radialGradient.prototype = new svg.Element.GradientBase;

                // gradient stop element
                svg.Element.stop = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.offset = this.attribute('offset').numValue();
                    if (this.offset < 0) this.offset = 0;
                    if (this.offset > 1) this.offset = 1;

                    var stopColor = this.style('stop-color', true);
                    if (stopColor.value === '') stopColor.value = '#000';
                    if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
                    this.color = stopColor.value;
                }
                svg.Element.stop.prototype = new svg.Element.ElementBase;

                // animation base element
                svg.Element.AnimateBase = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    svg.Animations.push(this);

                    this.duration = 0.0;
                    this.begin = this.attribute('begin').toMilliseconds();
                    this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();

                    this.getProperty = function() {
                        var attributeType = this.attribute('attributeType').value;
                        var attributeName = this.attribute('attributeName').value;

                        if (attributeType == 'CSS') {
                            return this.parent.style(attributeName, true);
                        }
                        return this.parent.attribute(attributeName, true);
                    };

                    this.initialValue = null;
                    this.initialUnits = '';
                    this.removed = false;

                    this.calcValue = function() {
                        // OVERRIDE ME!
                        return '';
                    }

                    this.update = function(delta) {
                        // set initial value
                        if (this.initialValue == null) {
                            this.initialValue = this.getProperty().value;
                            this.initialUnits = this.getProperty().getUnits();
                        }

                        // if we're past the end time
                        if (this.duration > this.maxDuration) {
                            // loop for indefinitely repeating animations
                            if (this.attribute('repeatCount').value == 'indefinite' ||
                                this.attribute('repeatDur').value == 'indefinite') {
                                this.duration = 0.0
                            } else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
                                this.frozen = true;
                                this.parent.animationFrozen = true;
                                this.parent.animationFrozenValue = this.getProperty().value;
                            } else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
                                this.removed = true;
                                this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
                                return true;
                            }
                            return false;
                        }
                        this.duration = this.duration + delta;

                        // if we're past the begin time
                        var updated = false;
                        if (this.begin < this.duration) {
                            var newValue = this.calcValue(); // tween

                            if (this.attribute('type').hasValue()) {
                                // for transform, etc.
                                var type = this.attribute('type').value;
                                newValue = type + '(' + newValue + ')';
                            }

                            this.getProperty().value = newValue;
                            updated = true;
                        }

                        return updated;
                    }

                    this.from = this.attribute('from');
                    this.to = this.attribute('to');
                    this.values = this.attribute('values');
                    if (this.values.hasValue()) this.values.value = this.values.value.split(';');

                    // fraction of duration we've covered
                    this.progress = function() {
                        var ret = {
                            progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
                        };
                        if (this.values.hasValue()) {
                            var p = ret.progress * (this.values.value.length - 1);
                            var lb = Math.floor(p),
                                ub = Math.ceil(p);
                            ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
                            ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
                            ret.progress = (p - lb) / (ub - lb);
                        } else {
                            ret.from = this.from;
                            ret.to = this.to;
                        }
                        return ret;
                    }
                }
                svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;

                // animate element
                svg.Element.animate = function(node) {
                    this.base = svg.Element.AnimateBase;
                    this.base(node);

                    this.calcValue = function() {
                        var p = this.progress();

                        // tween value linearly
                        var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
                        return newValue + this.initialUnits;
                    };
                }
                svg.Element.animate.prototype = new svg.Element.AnimateBase;

                // animate color element
                svg.Element.animateColor = function(node) {
                    this.base = svg.Element.AnimateBase;
                    this.base(node);

                    this.calcValue = function() {
                        var p = this.progress();
                        var from = new RGBColor(p.from.value);
                        var to = new RGBColor(p.to.value);

                        if (from.ok && to.ok) {
                            // tween color linearly
                            var r = from.r + (to.r - from.r) * p.progress;
                            var g = from.g + (to.g - from.g) * p.progress;
                            var b = from.b + (to.b - from.b) * p.progress;
                            return 'rgb(' + parseInt(r, 10) + ',' + parseInt(g, 10) + ',' + parseInt(b, 10) + ')';
                        }
                        return this.attribute('from').value;
                    };
                }
                svg.Element.animateColor.prototype = new svg.Element.AnimateBase;

                // animate transform element
                svg.Element.animateTransform = function(node) {
                    this.base = svg.Element.AnimateBase;
                    this.base(node);

                    this.calcValue = function() {
                        var p = this.progress();

                        // tween value linearly
                        var from = svg.ToNumberArray(p.from.value);
                        var to = svg.ToNumberArray(p.to.value);
                        var newValue = '';
                        for (var i = 0; i < from.length; i++) {
                            newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
                        }
                        return newValue;
                    };
                }
                svg.Element.animateTransform.prototype = new svg.Element.animate;

                // font element
                svg.Element.font = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.horizAdvX = this.attribute('horiz-adv-x').numValue();

                    this.isRTL = false;
                    this.isArabic = false;
                    this.fontFace = null;
                    this.missingGlyph = null;
                    this.glyphs = [];
                    for (var i = 0; i < this.children.length; i++) {
                        var child = this.children[i];
                        if (child.type == 'font-face') {
                            this.fontFace = child;
                            if (child.style('font-family').hasValue()) {
                                svg.Definitions[child.style('font-family').value] = this;
                            }
                        } else if (child.type == 'missing-glyph') this.missingGlyph = child;
                        else if (child.type == 'glyph') {
                            if (child.arabicForm != '') {
                                this.isRTL = true;
                                this.isArabic = true;
                                if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
                                this.glyphs[child.unicode][child.arabicForm] = child;
                            } else {
                                this.glyphs[child.unicode] = child;
                            }
                        }
                    }
                }
                svg.Element.font.prototype = new svg.Element.ElementBase;

                // font-face element
                svg.Element.fontface = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.ascent = this.attribute('ascent').value;
                    this.descent = this.attribute('descent').value;
                    this.unitsPerEm = this.attribute('units-per-em').numValue();
                }
                svg.Element.fontface.prototype = new svg.Element.ElementBase;

                // missing-glyph element
                svg.Element.missingglyph = function(node) {
                    this.base = svg.Element.path;
                    this.base(node);

                    this.horizAdvX = 0;
                }
                svg.Element.missingglyph.prototype = new svg.Element.path;

                // glyph element
                svg.Element.glyph = function(node) {
                    this.base = svg.Element.path;
                    this.base(node);

                    this.horizAdvX = this.attribute('horiz-adv-x').numValue();
                    this.unicode = this.attribute('unicode').value;
                    this.arabicForm = this.attribute('arabic-form').value;
                }
                svg.Element.glyph.prototype = new svg.Element.path;

                // text element
                svg.Element.text = function(node) {
                    this.captureTextNodes = true;
                    this.base = svg.Element.RenderedElementBase;
                    this.base(node);

                    this.baseSetContext = this.setContext;
                    this.setContext = function(ctx) {
                        this.baseSetContext(ctx);

                        var textBaseline = this.style('dominant-baseline').toTextBaseline();
                        if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
                        if (textBaseline != null) ctx.textBaseline = textBaseline;
                    }

                    this.getBoundingBox = function() {
                        var x = this.attribute('x').toPixels('x');
                        var y = this.attribute('y').toPixels('y');
                        var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                        return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
                    }

                    this.renderChildren = function(ctx) {
                        this.x = this.attribute('x').toPixels('x');
                        this.y = this.attribute('y').toPixels('y');
                        if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
                        if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
                        this.x += this.getAnchorDelta(ctx, this, 0);
                        for (var i = 0; i < this.children.length; i++) {
                            this.renderChild(ctx, this, i);
                        }
                    }

                    this.getAnchorDelta = function(ctx, parent, startI) {
                        var textAnchor = this.style('text-anchor').valueOrDefault('start');
                        if (textAnchor != 'start') {
                            var width = 0;
                            for (var i = startI; i < parent.children.length; i++) {
                                var child = parent.children[i];
                                if (i > startI && child.attribute('x').hasValue()) break; // new group
                                width += child.measureTextRecursive(ctx);
                            }
                            return -1 * (textAnchor == 'end' ? width : width / 2.0);
                        }
                        return 0;
                    }

                    this.renderChild = function(ctx, parent, i) {
                        var child = parent.children[i];
                        if (child.attribute('x').hasValue()) {
                            child.x = child.attribute('x').toPixels('x') + parent.getAnchorDelta(ctx, parent, i);
                            if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
                        } else {
                            if (child.attribute('dx').hasValue()) parent.x += child.attribute('dx').toPixels('x');
                            child.x = parent.x;
                        }
                        parent.x = child.x + child.measureText(ctx);

                        if (child.attribute('y').hasValue()) {
                            child.y = child.attribute('y').toPixels('y');
                            if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
                        } else {
                            if (child.attribute('dy').hasValue()) parent.y += child.attribute('dy').toPixels('y');
                            child.y = parent.y;
                        }
                        parent.y = child.y;

                        child.render(ctx);

                        for (var i = 0; i < child.children.length; i++) {
                            parent.renderChild(ctx, child, i);
                        }
                    }
                }
                svg.Element.text.prototype = new svg.Element.RenderedElementBase;

                // text base
                svg.Element.TextElementBase = function(node) {
                    this.base = svg.Element.RenderedElementBase;
                    this.base(node);

                    this.getGlyph = function(font, text, i) {
                        var c = text[i];
                        var glyph = null;
                        if (font.isArabic) {
                            var arabicForm = 'isolated';
                            if ((i == 0 || text[i - 1] == ' ') && i < text.length - 2 && text[i + 1] != ' ') arabicForm = 'terminal';
                            if (i > 0 && text[i - 1] != ' ' && i < text.length - 2 && text[i + 1] != ' ') arabicForm = 'medial';
                            if (i > 0 && text[i - 1] != ' ' && (i == text.length - 1 || text[i + 1] == ' ')) arabicForm = 'initial';
                            if (typeof(font.glyphs[c]) != 'undefined') {
                                glyph = font.glyphs[c][arabicForm];
                                if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
                            }
                        } else {
                            glyph = font.glyphs[c];
                        }
                        if (glyph == null) glyph = font.missingGlyph;
                        return glyph;
                    }

                    this.renderChildren = function(ctx) {
                        var customFont = this.parent.style('font-family').getDefinition();
                        if (customFont != null) {
                            var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                            var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                            var text = this.getText();
                            if (customFont.isRTL) text = text.split("").reverse().join("");

                            var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                            for (var i = 0; i < text.length; i++) {
                                var glyph = this.getGlyph(customFont, text, i);
                                var scale = fontSize / customFont.fontFace.unitsPerEm;
                                ctx.translate(this.x, this.y);
                                ctx.scale(scale, -scale);
                                var lw = ctx.lineWidth;
                                ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                                if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
                                glyph.render(ctx);
                                if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
                                ctx.lineWidth = lw;
                                ctx.scale(1 / scale, -1 / scale);
                                ctx.translate(-this.x, -this.y);

                                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                                if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                                    this.x += dx[i];
                                }
                            }
                            return;
                        }

                        if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
                        if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
                    }

                    this.getText = function() {
                        // OVERRIDE ME
                    }

                    this.measureTextRecursive = function(ctx) {
                        var width = this.measureText(ctx);
                        for (var i = 0; i < this.children.length; i++) {
                            width += this.children[i].measureTextRecursive(ctx);
                        }
                        return width;
                    }

                    this.measureText = function(ctx) {
                        var customFont = this.parent.style('font-family').getDefinition();
                        if (customFont != null) {
                            var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                            var measure = 0;
                            var text = this.getText();
                            if (customFont.isRTL) text = text.split("").reverse().join("");
                            var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                            for (var i = 0; i < text.length; i++) {
                                var glyph = this.getGlyph(customFont, text, i);
                                measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                                if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                                    measure += dx[i];
                                }
                            }
                            return measure;
                        }

                        var textToMeasure = svg.compressSpaces(this.getText());
                        if (!ctx.measureText) return textToMeasure.length * 10;

                        ctx.save();
                        this.setContext(ctx);
                        var width = ctx.measureText(textToMeasure).width;
                        ctx.restore();
                        return width;
                    }
                }
                svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

                // tspan
                svg.Element.tspan = function(node) {
                    this.captureTextNodes = true;
                    this.base = svg.Element.TextElementBase;
                    this.base(node);

                    this.text = svg.compressSpaces(node.value || node.text || node.textContent || '');
                    this.getText = function() {
                        // if this node has children, then they own the text
                        if (this.children.length > 0) {
                            return '';
                        }
                        return this.text;
                    }
                }
                svg.Element.tspan.prototype = new svg.Element.TextElementBase;

                // tref
                svg.Element.tref = function(node) {
                    this.base = svg.Element.TextElementBase;
                    this.base(node);

                    this.getText = function() {
                        var element = this.getHrefAttribute().getDefinition();
                        if (element != null) return element.children[0].getText();
                    }
                }
                svg.Element.tref.prototype = new svg.Element.TextElementBase;

                // a element
                svg.Element.a = function(node) {
                    this.base = svg.Element.TextElementBase;
                    this.base(node);

                    this.hasText = node.childNodes.length > 0;
                    for (var i = 0; i < node.childNodes.length; i++) {
                        if (node.childNodes[i].nodeType != 3) this.hasText = false;
                    }

                    // this might contain text
                    this.text = this.hasText ? node.childNodes[0].value : '';
                    this.getText = function() {
                        return this.text;
                    }

                    this.baseRenderChildren = this.renderChildren;
                    this.renderChildren = function(ctx) {
                        if (this.hasText) {
                            // render as text element
                            this.baseRenderChildren(ctx);
                            var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                            svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
                        } else if (this.children.length > 0) {
                            // render as temporary group
                            var g = new svg.Element.g();
                            g.children = this.children;
                            g.parent = this;
                            g.render(ctx);
                        }
                    }

                    this.onclick = function() {
                        window.open(this.getHrefAttribute().value);
                    }

                    this.onmousemove = function() {
                        svg.ctx.canvas.style.cursor = 'pointer';
                    }
                }
                svg.Element.a.prototype = new svg.Element.TextElementBase;

                // image element
                svg.Element.image = function(node) {
                    this.base = svg.Element.RenderedElementBase;
                    this.base(node);

                    var href = this.getHrefAttribute().value;
                    if (href == '') {
                        return;
                    }
                    var isSvg = href.match(/\.svg$/)

                    svg.Images.push(this);
                    this.loaded = false;
                    if (!isSvg) {
                        this.img = document.createElement('img');
                        if (svg.opts['useCORS'] == true) {
                            this.img.crossOrigin = 'Anonymous';
                        }
                        var self = this;
                        this.img.onload = function() {
                            self.loaded = true;
                        }
                        this.img.onerror = function() {
                            svg.log('ERROR: image "' + href + '" not found');
                            self.loaded = true;
                        }
                        this.img.src = href;
                    } else {
                        this.img = svg.ajax(href);
                        this.loaded = true;
                    }

                    this.renderChildren = function(ctx) {
                        var x = this.attribute('x').toPixels('x');
                        var y = this.attribute('y').toPixels('y');

                        var width = this.attribute('width').toPixels('x');
                        var height = this.attribute('height').toPixels('y');
                        if (width == 0 || height == 0) return;

                        ctx.save();
                        if (isSvg) {
                            ctx.drawSvg(this.img, x, y, width, height);
                        } else {
                            ctx.translate(x, y);
                            svg.AspectRatio(ctx,
                                this.attribute('preserveAspectRatio').value,
                                width,
                                this.img.width,
                                height,
                                this.img.height,
                                0,
                                0);
                            ctx.drawImage(this.img, 0, 0);
                        }
                        ctx.restore();
                    }

                    this.getBoundingBox = function() {
                        var x = this.attribute('x').toPixels('x');
                        var y = this.attribute('y').toPixels('y');
                        var width = this.attribute('width').toPixels('x');
                        var height = this.attribute('height').toPixels('y');
                        return new svg.BoundingBox(x, y, x + width, y + height);
                    }
                }
                svg.Element.image.prototype = new svg.Element.RenderedElementBase;

                // group element
                svg.Element.g = function(node) {
                    this.base = svg.Element.RenderedElementBase;
                    this.base(node);

                    this.getBoundingBox = function() {
                        var bb = new svg.BoundingBox();
                        for (var i = 0; i < this.children.length; i++) {
                            bb.addBoundingBox(this.children[i].getBoundingBox());
                        }
                        return bb;
                    };
                }
                svg.Element.g.prototype = new svg.Element.RenderedElementBase;

                // symbol element
                svg.Element.symbol = function(node) {
                    this.base = svg.Element.RenderedElementBase;
                    this.base(node);

                    this.render = function(ctx) {
                        // NO RENDER
                    };
                }
                svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;

                // style element
                svg.Element.style = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    // text, or spaces then CDATA
                    var css = ''
                    for (var i = 0; i < node.childNodes.length; i++) {
                        css += node.childNodes[i].data;
                    }
                    css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
                    css = svg.compressSpaces(css); // replace whitespace
                    var cssDefs = css.split('}');
                    for (var i = 0; i < cssDefs.length; i++) {
                        if (svg.trim(cssDefs[i]) != '') {
                            var cssDef = cssDefs[i].split('{');
                            var cssClasses = cssDef[0].split(',');
                            var cssProps = cssDef[1].split(';');
                            for (var j = 0; j < cssClasses.length; j++) {
                                var cssClass = svg.trim(cssClasses[j]);
                                if (cssClass != '') {
                                    var props = svg.Styles[cssClass] || {};
                                    for (var k = 0; k < cssProps.length; k++) {
                                        var prop = cssProps[k].indexOf(':');
                                        var name = cssProps[k].substr(0, prop);
                                        var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                        if (name != null && value != null) {
                                            props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
                                        }
                                    }
                                    svg.Styles[cssClass] = props;
                                    svg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
                                    if (cssClass == '@font-face') {
                                        var fontFamily = props['font-family'].value.replace(/"/g, '');
                                        var srcs = props['src'].value.split(',');
                                        for (var s = 0; s < srcs.length; s++) {
                                            if (srcs[s].indexOf('format("svg")') > 0) {
                                                var urlStart = srcs[s].indexOf('url');
                                                var urlEnd = srcs[s].indexOf(')', urlStart);
                                                var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                                var doc = svg.parseXml(svg.ajax(url));
                                                var fonts = doc.getElementsByTagName('font');
                                                for (var f = 0; f < fonts.length; f++) {
                                                    var font = svg.CreateElement(fonts[f]);
                                                    svg.Definitions[fontFamily] = font;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                svg.Element.style.prototype = new svg.Element.ElementBase;

                // use element
                svg.Element.use = function(node) {
                    this.base = svg.Element.RenderedElementBase;
                    this.base(node);

                    this.baseSetContext = this.setContext;
                    this.setContext = function(ctx) {
                        this.baseSetContext(ctx);
                        if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
                        if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
                    }

                    var element = this.getHrefAttribute().getDefinition();

                    this.path = function(ctx) {
                        if (element != null) element.path(ctx);
                    }

                    this.getBoundingBox = function() {
                        if (element != null) return element.getBoundingBox();
                    }

                    this.renderChildren = function(ctx) {
                        if (element != null) {
                            var tempSvg = element;
                            if (element.type == 'symbol') {
                                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
                                tempSvg = new svg.Element.svg();
                                tempSvg.type = 'svg';
                                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
                                tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
                                tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
                                tempSvg.children = element.children;
                            }
                            if (tempSvg.type == 'svg') {
                                // if symbol or svg, inherit width/height from me
                                if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
                                if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
                            }
                            var oldParent = tempSvg.parent;
                            tempSvg.parent = null;
                            tempSvg.render(ctx);
                            tempSvg.parent = oldParent;
                        }
                    }
                }
                svg.Element.use.prototype = new svg.Element.RenderedElementBase;

                // mask element
                svg.Element.mask = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.apply = function(ctx, element) {
                        // render as temp svg
                        var x = this.attribute('x').toPixels('x');
                        var y = this.attribute('y').toPixels('y');
                        var width = this.attribute('width').toPixels('x');
                        var height = this.attribute('height').toPixels('y');

                        if (width == 0 && height == 0) {
                            var bb = new svg.BoundingBox();
                            for (var i = 0; i < this.children.length; i++) {
                                bb.addBoundingBox(this.children[i].getBoundingBox());
                            }
                            var x = Math.floor(bb.x1);
                            var y = Math.floor(bb.y1);
                            var width = Math.floor(bb.width());
                            var height = Math.floor(bb.height());
                        }

                        // temporarily remove mask to avoid recursion
                        var mask = element.attribute('mask').value;
                        element.attribute('mask').value = '';

                        var cMask = document.createElement('canvas');
                        cMask.width = x + width;
                        cMask.height = y + height;
                        var maskCtx = cMask.getContext('2d');
                        this.renderChildren(maskCtx);

                        var c = document.createElement('canvas');
                        c.width = x + width;
                        c.height = y + height;
                        var tempCtx = c.getContext('2d');
                        element.render(tempCtx);
                        tempCtx.globalCompositeOperation = 'destination-in';
                        tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                        tempCtx.fillRect(0, 0, x + width, y + height);

                        ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                        ctx.fillRect(0, 0, x + width, y + height);

                        // reassign mask
                        element.attribute('mask').value = mask;
                    }

                    this.render = function(ctx) {
                        // NO RENDER
                    }
                }
                svg.Element.mask.prototype = new svg.Element.ElementBase;

                // clip element
                svg.Element.clipPath = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.apply = function(ctx) {
                        var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
                        CanvasRenderingContext2D.prototype.beginPath = function() {};

                        var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
                        CanvasRenderingContext2D.prototype.closePath = function() {};

                        oldBeginPath.call(ctx);
                        for (var i = 0; i < this.children.length; i++) {
                            var child = this.children[i];
                            if (typeof(child.path) != 'undefined') {
                                var transform = null;
                                if (child.style('transform', false, true).hasValue()) {
                                    transform = new svg.Transform(child.style('transform', false, true).value);
                                    transform.apply(ctx);
                                }
                                child.path(ctx);
                                CanvasRenderingContext2D.prototype.closePath = oldClosePath;
                                if (transform) {
                                    transform.unapply(ctx);
                                }
                            }
                        }
                        oldClosePath.call(ctx);
                        ctx.clip();

                        CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
                        CanvasRenderingContext2D.prototype.closePath = oldClosePath;
                    }

                    this.render = function(ctx) {
                        // NO RENDER
                    }
                }
                svg.Element.clipPath.prototype = new svg.Element.ElementBase;

                // filters
                svg.Element.filter = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.apply = function(ctx, element) {
                        // render as temp svg
                        var bb = element.getBoundingBox();
                        var x = Math.floor(bb.x1);
                        var y = Math.floor(bb.y1);
                        var width = Math.floor(bb.width());
                        var height = Math.floor(bb.height());

                        // temporarily remove filter to avoid recursion
                        var filter = element.style('filter').value;
                        element.style('filter').value = '';

                        var px = 0,
                            py = 0;
                        for (var i = 0; i < this.children.length; i++) {
                            var efd = this.children[i].extraFilterDistance || 0;
                            px = Math.max(px, efd);
                            py = Math.max(py, efd);
                        }

                        var c = document.createElement('canvas');
                        c.width = width + 2 * px;
                        c.height = height + 2 * py;
                        var tempCtx = c.getContext('2d');
                        tempCtx.translate(-x + px, -y + py);
                        element.render(tempCtx);

                        // apply filters
                        for (var i = 0; i < this.children.length; i++) {
                            if (typeof(this.children[i].apply) === 'function') {
                                this.children[i].apply(tempCtx, 0, 0, width + 2 * px, height + 2 * py);
                            }
                        }

                        // render on me
                        ctx.drawImage(c, 0, 0, width + 2 * px, height + 2 * py, x - px, y - py, width + 2 * px, height + 2 * py);

                        // reassign filter
                        element.style('filter', true).value = filter;
                    }

                    this.render = function(ctx) {
                        // NO RENDER
                    }
                }
                svg.Element.filter.prototype = new svg.Element.ElementBase;

                svg.Element.feMorphology = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.apply = function(ctx, x, y, width, height) {
                        // TODO: implement
                    }
                }
                svg.Element.feMorphology.prototype = new svg.Element.ElementBase;

                svg.Element.feComposite = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.apply = function(ctx, x, y, width, height) {
                        // TODO: implement
                    }
                }
                svg.Element.feComposite.prototype = new svg.Element.ElementBase;

                svg.Element.feColorMatrix = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    var matrix = svg.ToNumberArray(this.attribute('values').value);
                    switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
                        case 'saturate':
                            var s = matrix[0];
                            matrix = [0.213 + 0.787 * s, 0.715 - 0.715 * s, 0.072 - 0.072 * s, 0, 0,
                                0.213 - 0.213 * s, 0.715 + 0.285 * s, 0.072 - 0.072 * s, 0, 0,
                                0.213 - 0.213 * s, 0.715 - 0.715 * s, 0.072 + 0.928 * s, 0, 0,
                                0, 0, 0, 1, 0,
                                0, 0, 0, 0, 1
                            ];
                            break;
                        case 'hueRotate':
                            var a = matrix[0] * Math.PI / 180.0;
                            var c = function(m1, m2, m3) {
                                return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;
                            };
                            matrix = [c(0.213, 0.787, -0.213), c(0.715, -0.715, -0.715), c(0.072, -0.072, 0.928), 0, 0,
                                c(0.213, -0.213, 0.143), c(0.715, 0.285, 0.140), c(0.072, -0.072, -0.283), 0, 0,
                                c(0.213, -0.213, -0.787), c(0.715, -0.715, 0.715), c(0.072, 0.928, 0.072), 0, 0,
                                0, 0, 0, 1, 0,
                                0, 0, 0, 0, 1
                            ];
                            break;
                        case 'luminanceToAlpha':
                            matrix = [0, 0, 0, 0, 0,
                                0, 0, 0, 0, 0,
                                0, 0, 0, 0, 0,
                                0.2125, 0.7154, 0.0721, 0, 0,
                                0, 0, 0, 0, 1
                            ];
                            break;
                    }

                    function imGet(img, x, y, width, height, rgba) {
                        return img[y * width * 4 + x * 4 + rgba];
                    }

                    function imSet(img, x, y, width, height, rgba, val) {
                        img[y * width * 4 + x * 4 + rgba] = val;
                    }

                    function m(i, v) {
                        var mi = matrix[i];
                        return mi * (mi < 0 ? v - 255 : v);
                    }

                    this.apply = function(ctx, x, y, width, height) {
                        // assuming x==0 && y==0 for now
                        var srcData = ctx.getImageData(0, 0, width, height);
                        for (var y = 0; y < height; y++) {
                            for (var x = 0; x < width; x++) {
                                var r = imGet(srcData.data, x, y, width, height, 0);
                                var g = imGet(srcData.data, x, y, width, height, 1);
                                var b = imGet(srcData.data, x, y, width, height, 2);
                                var a = imGet(srcData.data, x, y, width, height, 3);
                                imSet(srcData.data, x, y, width, height, 0, m(0, r) + m(1, g) + m(2, b) + m(3, a) + m(4, 1));
                                imSet(srcData.data, x, y, width, height, 1, m(5, r) + m(6, g) + m(7, b) + m(8, a) + m(9, 1));
                                imSet(srcData.data, x, y, width, height, 2, m(10, r) + m(11, g) + m(12, b) + m(13, a) + m(14, 1));
                                imSet(srcData.data, x, y, width, height, 3, m(15, r) + m(16, g) + m(17, b) + m(18, a) + m(19, 1));
                            }
                        }
                        ctx.clearRect(0, 0, width, height);
                        ctx.putImageData(srcData, 0, 0);
                    }
                }
                svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;

                svg.Element.feGaussianBlur = function(node) {
                    this.base = svg.Element.ElementBase;
                    this.base(node);

                    this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
                    this.extraFilterDistance = this.blurRadius;

                    this.apply = function(ctx, x, y, width, height) {
                        if (typeof(stackBlur.canvasRGBA) == 'undefined') {
                            svg.log('ERROR: StackBlur.js must be included for blur to work');
                            return;
                        }

                        // StackBlur requires canvas be on document
                        ctx.canvas.id = svg.UniqueId();
                        ctx.canvas.style.display = 'none';
                        document.body.appendChild(ctx.canvas);
                        stackBlur.canvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
                        document.body.removeChild(ctx.canvas);
                    }
                }
                svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;

                // title element, do nothing
                svg.Element.title = function(node) {}
                svg.Element.title.prototype = new svg.Element.ElementBase;

                // desc element, do nothing
                svg.Element.desc = function(node) {}
                svg.Element.desc.prototype = new svg.Element.ElementBase;

                svg.Element.MISSING = function(node) {
                    svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
                }
                svg.Element.MISSING.prototype = new svg.Element.ElementBase;

                // element factory
                svg.CreateElement = function(node) {
                    var className = node.nodeName.replace(/^[^:]+:/, ''); // remove namespace
                    className = className.replace(/\-/g, ''); // remove dashes
                    var e = null;
                    if (typeof(svg.Element[className]) != 'undefined') {
                        e = new svg.Element[className](node);
                    } else {
                        e = new svg.Element.MISSING(node);
                    }

                    e.type = node.nodeName;
                    return e;
                }

                // load from url
                svg.load = function(ctx, url) {
                    svg.loadXml(ctx, svg.ajax(url));
                }

                // load from xml
                svg.loadXml = function(ctx, xml) {
                    svg.loadXmlDoc(ctx, svg.parseXml(xml));
                }

                svg.loadXmlDoc = function(ctx, dom) {
                    svg.init(ctx);

                    var mapXY = function(p) {
                        var e = ctx.canvas;
                        while (e) {
                            p.x -= e.offsetLeft;
                            p.y -= e.offsetTop;
                            e = e.offsetParent;
                        }
                        if (window.scrollX) p.x += window.scrollX;
                        if (window.scrollY) p.y += window.scrollY;
                        return p;
                    }

                    // bind mouse
                    if (svg.opts['ignoreMouse'] != true) {
                        ctx.canvas.onclick = function(e) {
                            var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                            svg.Mouse.onclick(p.x, p.y);
                        };
                        ctx.canvas.onmousemove = function(e) {
                            var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                            svg.Mouse.onmousemove(p.x, p.y);
                        };
                    }

                    var e = svg.CreateElement(dom.documentElement);
                    e.root = true;
                    e.addStylesFromStyleDefinition();

                    // render loop
                    var isFirstRender = true;
                    var draw = function() {
                        svg.ViewPort.Clear();
                        if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);

                        if (svg.opts['ignoreDimensions'] != true) {
                            // set canvas size
                            if (e.style('width').hasValue()) {
                                ctx.canvas.width = e.style('width').toPixels('x');
                                ctx.canvas.style.width = ctx.canvas.width + 'px';
                            }
                            if (e.style('height').hasValue()) {
                                ctx.canvas.height = e.style('height').toPixels('y');
                                ctx.canvas.style.height = ctx.canvas.height + 'px';
                            }
                        }
                        var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                        var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                        if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
                            cWidth = e.style('width').toPixels('x');
                            cHeight = e.style('height').toPixels('y');
                        }
                        svg.ViewPort.SetCurrent(cWidth, cHeight);

                        if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
                        if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
                        if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
                            var xRatio = null,
                                yRatio = null,
                                viewBox = svg.ToNumberArray(e.attribute('viewBox').value);

                            if (svg.opts['scaleWidth'] != null) {
                                if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
                                else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
                            }

                            if (svg.opts['scaleHeight'] != null) {
                                if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
                                else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
                            }

                            if (xRatio == null) {
                                xRatio = yRatio;
                            }
                            if (yRatio == null) {
                                yRatio = xRatio;
                            }

                            e.attribute('width', true).value = svg.opts['scaleWidth'];
                            e.attribute('height', true).value = svg.opts['scaleHeight'];
                            e.style('transform', true, true).value += ' scale(' + (1.0 / xRatio) + ',' + (1.0 / yRatio) + ')';
                        }

                        // clear and render
                        if (svg.opts['ignoreClear'] != true) {
                            ctx.clearRect(0, 0, cWidth, cHeight);
                        }
                        e.render(ctx);
                        if (isFirstRender) {
                            isFirstRender = false;
                            if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
                        }
                    }

                    var waitingForImages = true;
                    if (svg.ImagesLoaded()) {
                        waitingForImages = false;
                        draw();
                    }
                    svg.intervalID = setInterval(function() {
                        var needUpdate = false;

                        if (waitingForImages && svg.ImagesLoaded()) {
                            waitingForImages = false;
                            needUpdate = true;
                        }

                        // need update from mouse events?
                        if (svg.opts['ignoreMouse'] != true) {
                            needUpdate = needUpdate | svg.Mouse.hasEvents();
                        }

                        // need update from animations?
                        if (svg.opts['ignoreAnimation'] != true) {
                            for (var i = 0; i < svg.Animations.length; i++) {
                                needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
                            }
                        }

                        // need update from redraw?
                        if (typeof(svg.opts['forceRedraw']) == 'function') {
                            if (svg.opts['forceRedraw']() == true) needUpdate = true;
                        }

                        // render if needed
                        if (needUpdate) {
                            draw();
                            svg.Mouse.runEvents(); // run and clear our events
                        }
                    }, 1000 / svg.FRAMERATE);
                }

                svg.stop = function() {
                    if (svg.intervalID) {
                        clearInterval(svg.intervalID);
                    }
                }

                svg.Mouse = new(function() {
                    this.events = [];
                    this.hasEvents = function() {
                        return this.events.length != 0;
                    }

                    this.onclick = function(x, y) {
                        this.events.push({
                            type: 'onclick',
                            x: x,
                            y: y,
                            run: function(e) {
                                if (e.onclick) e.onclick();
                            }
                        });
                    }

                    this.onmousemove = function(x, y) {
                        this.events.push({
                            type: 'onmousemove',
                            x: x,
                            y: y,
                            run: function(e) {
                                if (e.onmousemove) e.onmousemove();
                            }
                        });
                    }

                    this.eventElements = [];

                    this.checkPath = function(element, ctx) {
                        for (var i = 0; i < this.events.length; i++) {
                            var e = this.events[i];
                            if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
                        }
                    }

                    this.checkBoundingBox = function(element, bb) {
                        for (var i = 0; i < this.events.length; i++) {
                            var e = this.events[i];
                            if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
                        }
                    }

                    this.runEvents = function() {
                        svg.ctx.canvas.style.cursor = '';

                        for (var i = 0; i < this.events.length; i++) {
                            var e = this.events[i];
                            var element = this.eventElements[i];
                            while (element) {
                                e.run(element);
                                element = element.parent;
                            }
                        }

                        // done running, clear
                        this.events = [];
                        this.eventElements = [];
                    }
                });

                return svg;
            };

            if (typeof(CanvasRenderingContext2D) != 'undefined') {
                CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
                    canvg(this.canvas, s, {
                        ignoreMouse: true,
                        ignoreAnimation: true,
                        ignoreDimensions: true,
                        ignoreClear: true,
                        offsetX: dx,
                        offsetY: dy,
                        scaleWidth: dw,
                        scaleHeight: dh
                    });
                }
            }

            return canvg;

        }));


        /***/
    }),
    /* 145 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_RESULT__;
        /**
         * A class to parse color values
         * @author Stoyan Stefanov <sstoo@gmail.com>
         * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
         * @license Use it if you like it
         */

        (function(global) {

            function RGBColor(color_string) {
                this.ok = false;

                // strip any leading #
                if (color_string.charAt(0) == '#') { // remove # if any
                    color_string = color_string.substr(1, 6);
                }

                color_string = color_string.replace(/ /g, '');
                color_string = color_string.toLowerCase();

                // before getting into regexps, try simple matches
                // and overwrite the input
                var simple_colors = {
                    aliceblue: 'f0f8ff',
                    antiquewhite: 'faebd7',
                    aqua: '00ffff',
                    aquamarine: '7fffd4',
                    azure: 'f0ffff',
                    beige: 'f5f5dc',
                    bisque: 'ffe4c4',
                    black: '000000',
                    blanchedalmond: 'ffebcd',
                    blue: '0000ff',
                    blueviolet: '8a2be2',
                    brown: 'a52a2a',
                    burlywood: 'deb887',
                    cadetblue: '5f9ea0',
                    chartreuse: '7fff00',
                    chocolate: 'd2691e',
                    coral: 'ff7f50',
                    cornflowerblue: '6495ed',
                    cornsilk: 'fff8dc',
                    crimson: 'dc143c',
                    cyan: '00ffff',
                    darkblue: '00008b',
                    darkcyan: '008b8b',
                    darkgoldenrod: 'b8860b',
                    darkgray: 'a9a9a9',
                    darkgreen: '006400',
                    darkkhaki: 'bdb76b',
                    darkmagenta: '8b008b',
                    darkolivegreen: '556b2f',
                    darkorange: 'ff8c00',
                    darkorchid: '9932cc',
                    darkred: '8b0000',
                    darksalmon: 'e9967a',
                    darkseagreen: '8fbc8f',
                    darkslateblue: '483d8b',
                    darkslategray: '2f4f4f',
                    darkturquoise: '00ced1',
                    darkviolet: '9400d3',
                    deeppink: 'ff1493',
                    deepskyblue: '00bfff',
                    dimgray: '696969',
                    dodgerblue: '1e90ff',
                    feldspar: 'd19275',
                    firebrick: 'b22222',
                    floralwhite: 'fffaf0',
                    forestgreen: '228b22',
                    fuchsia: 'ff00ff',
                    gainsboro: 'dcdcdc',
                    ghostwhite: 'f8f8ff',
                    gold: 'ffd700',
                    goldenrod: 'daa520',
                    gray: '808080',
                    green: '008000',
                    greenyellow: 'adff2f',
                    honeydew: 'f0fff0',
                    hotpink: 'ff69b4',
                    indianred: 'cd5c5c',
                    indigo: '4b0082',
                    ivory: 'fffff0',
                    khaki: 'f0e68c',
                    lavender: 'e6e6fa',
                    lavenderblush: 'fff0f5',
                    lawngreen: '7cfc00',
                    lemonchiffon: 'fffacd',
                    lightblue: 'add8e6',
                    lightcoral: 'f08080',
                    lightcyan: 'e0ffff',
                    lightgoldenrodyellow: 'fafad2',
                    lightgrey: 'd3d3d3',
                    lightgreen: '90ee90',
                    lightpink: 'ffb6c1',
                    lightsalmon: 'ffa07a',
                    lightseagreen: '20b2aa',
                    lightskyblue: '87cefa',
                    lightslateblue: '8470ff',
                    lightslategray: '778899',
                    lightsteelblue: 'b0c4de',
                    lightyellow: 'ffffe0',
                    lime: '00ff00',
                    limegreen: '32cd32',
                    linen: 'faf0e6',
                    magenta: 'ff00ff',
                    maroon: '800000',
                    mediumaquamarine: '66cdaa',
                    mediumblue: '0000cd',
                    mediumorchid: 'ba55d3',
                    mediumpurple: '9370d8',
                    mediumseagreen: '3cb371',
                    mediumslateblue: '7b68ee',
                    mediumspringgreen: '00fa9a',
                    mediumturquoise: '48d1cc',
                    mediumvioletred: 'c71585',
                    midnightblue: '191970',
                    mintcream: 'f5fffa',
                    mistyrose: 'ffe4e1',
                    moccasin: 'ffe4b5',
                    navajowhite: 'ffdead',
                    navy: '000080',
                    oldlace: 'fdf5e6',
                    olive: '808000',
                    olivedrab: '6b8e23',
                    orange: 'ffa500',
                    orangered: 'ff4500',
                    orchid: 'da70d6',
                    palegoldenrod: 'eee8aa',
                    palegreen: '98fb98',
                    paleturquoise: 'afeeee',
                    palevioletred: 'd87093',
                    papayawhip: 'ffefd5',
                    peachpuff: 'ffdab9',
                    peru: 'cd853f',
                    pink: 'ffc0cb',
                    plum: 'dda0dd',
                    powderblue: 'b0e0e6',
                    purple: '800080',
                    red: 'ff0000',
                    rosybrown: 'bc8f8f',
                    royalblue: '4169e1',
                    saddlebrown: '8b4513',
                    salmon: 'fa8072',
                    sandybrown: 'f4a460',
                    seagreen: '2e8b57',
                    seashell: 'fff5ee',
                    sienna: 'a0522d',
                    silver: 'c0c0c0',
                    skyblue: '87ceeb',
                    slateblue: '6a5acd',
                    slategray: '708090',
                    snow: 'fffafa',
                    springgreen: '00ff7f',
                    steelblue: '4682b4',
                    tan: 'd2b48c',
                    teal: '008080',
                    thistle: 'd8bfd8',
                    tomato: 'ff6347',
                    turquoise: '40e0d0',
                    violet: 'ee82ee',
                    violetred: 'd02090',
                    wheat: 'f5deb3',
                    white: 'ffffff',
                    whitesmoke: 'f5f5f5',
                    yellow: 'ffff00',
                    yellowgreen: '9acd32'
                };
                for (var key in simple_colors) {
                    if (color_string == key) {
                        color_string = simple_colors[key];
                    }
                }
                // emd of simple type-in colors

                // array of color definition objects
                var color_defs = [{
                        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                        example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
                        process: function(bits) {
                            return [
                                parseInt(bits[1]),
                                parseInt(bits[2]),
                                parseInt(bits[3])
                            ];
                        }
                    },
                    {
                        re: /^(\w{2})(\w{2})(\w{2})$/,
                        example: ['#00ff00', '336699'],
                        process: function(bits) {
                            return [
                                parseInt(bits[1], 16),
                                parseInt(bits[2], 16),
                                parseInt(bits[3], 16)
                            ];
                        }
                    },
                    {
                        re: /^(\w{1})(\w{1})(\w{1})$/,
                        example: ['#fb0', 'f0f'],
                        process: function(bits) {
                            return [
                                parseInt(bits[1] + bits[1], 16),
                                parseInt(bits[2] + bits[2], 16),
                                parseInt(bits[3] + bits[3], 16)
                            ];
                        }
                    }
                ];

                // search through the definitions to find a match
                for (var i = 0; i < color_defs.length; i++) {
                    var re = color_defs[i].re;
                    var processor = color_defs[i].process;
                    var bits = re.exec(color_string);
                    if (bits) {
                        channels = processor(bits);
                        this.r = channels[0];
                        this.g = channels[1];
                        this.b = channels[2];
                        this.ok = true;
                    }

                }

                // validate/cleanup values
                this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
                this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
                this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

                // some getters
                this.toRGB = function() {
                    return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
                }
                this.toHex = function() {
                    var r = this.r.toString(16);
                    var g = this.g.toString(16);
                    var b = this.b.toString(16);
                    if (r.length == 1) r = '0' + r;
                    if (g.length == 1) g = '0' + g;
                    if (b.length == 1) b = '0' + b;
                    return '#' + r + g + b;
                }

                // help
                this.getHelpXML = function() {

                    var examples = new Array();
                    // add regexps
                    for (var i = 0; i < color_defs.length; i++) {
                        var example = color_defs[i].example;
                        for (var j = 0; j < example.length; j++) {
                            examples[examples.length] = example[j];
                        }
                    }
                    // add type-in colors
                    for (var sc in simple_colors) {
                        examples[examples.length] = sc;
                    }

                    var xml = document.createElement('ul');
                    xml.setAttribute('id', 'rgbcolor-examples');
                    for (var i = 0; i < examples.length; i++) {
                        try {
                            var list_item = document.createElement('li');
                            var list_color = new RGBColor(examples[i]);
                            var example_div = document.createElement('div');
                            example_div.style.cssText =
                                'margin: 3px; ' +
                                'border: 1px solid black; ' +
                                'background:' + list_color.toHex() + '; ' +
                                'color:' + list_color.toHex();
                            example_div.appendChild(document.createTextNode('test'));
                            var list_item_value = document.createTextNode(
                                ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                            );
                            list_item.appendChild(example_div);
                            list_item.appendChild(list_item_value);
                            xml.appendChild(list_item);

                        } catch (e) {}
                    }
                    return xml;

                }

            }

            // export as AMD...
            if (true) {
                !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return RGBColor;
                    }.call(exports, __webpack_require__, exports, module),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }

            // ...or as browserify
            else if (typeof module !== 'undefined' && module.exports) {
                module.exports = RGBColor;
            }

            global.RGBColor = RGBColor;

        }(typeof window !== 'undefined' ? window : this));

        /***/
    }),
    /* 146 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_RESULT__;
        /* FileSaver.js
         * A saveAs() FileSaver implementation.
         * 1.3.2
         * 2016-06-16 18:25:19
         *
         * By Eli Grey, http://eligrey.com
         * License: MIT
         *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
         */

        /*global self */
        /*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

        /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

        var saveAs = saveAs || (function(view) {
            "use strict";
            // IE <10 is explicitly unsupported
            if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
                return;
            }
            var
                doc = view.document
                // only get URL when necessary in case Blob.js hasn't overridden it yet
                ,
                get_URL = function() {
                    return view.URL || view.webkitURL || view;
                },
                save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
                can_use_save_link = "download" in save_link,
                click = function(node) {
                    var event = new MouseEvent("click");
                    node.dispatchEvent(event);
                },
                is_safari = /constructor/i.test(view.HTMLElement) || view.safari,
                is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent),
                throw_outside = function(ex) {
                    (view.setImmediate || view.setTimeout)(function() {
                        throw ex;
                    }, 0);
                },
                force_saveable_type = "application/octet-stream"
                // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
                ,
                arbitrary_revoke_timeout = 1000 * 40 // in ms
                ,
                revoke = function(file) {
                    var revoker = function() {
                        if (typeof file === "string") { // file is an object URL
                            get_URL().revokeObjectURL(file);
                        } else { // file is a File
                            file.remove();
                        }
                    };
                    setTimeout(revoker, arbitrary_revoke_timeout);
                },
                dispatch = function(filesaver, event_types, event) {
                    event_types = [].concat(event_types);
                    var i = event_types.length;
                    while (i--) {
                        var listener = filesaver["on" + event_types[i]];
                        if (typeof listener === "function") {
                            try {
                                listener.call(filesaver, event || filesaver);
                            } catch (ex) {
                                throw_outside(ex);
                            }
                        }
                    }
                },
                auto_bom = function(blob) {
                    // prepend BOM for UTF-8 XML and text/* types (including HTML)
                    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
                    if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                        return new Blob([String.fromCharCode(0xFEFF), blob], {
                            type: blob.type
                        });
                    }
                    return blob;
                },
                FileSaver = function(blob, name, no_auto_bom) {
                    if (!no_auto_bom) {
                        blob = auto_bom(blob);
                    }
                    // First try a.download, then web filesystem, then object URLs
                    var
                        filesaver = this,
                        type = blob.type,
                        force = type === force_saveable_type,
                        object_url, dispatch_all = function() {
                            dispatch(filesaver, "writestart progress write writeend".split(" "));
                        }
                        // on any filesys errors revert to saving with object URLs
                        ,
                        fs_error = function() {
                            if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
                                // Safari doesn't allow downloading of blob urls
                                var reader = new FileReader();
                                reader.onloadend = function() {
                                    var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                                    var popup = view.open(url, '_blank');
                                    if (!popup) view.location.href = url;
                                    url = undefined; // release reference before dispatching
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch_all();
                                };
                                reader.readAsDataURL(blob);
                                filesaver.readyState = filesaver.INIT;
                                return;
                            }
                            // don't create more object URLs than needed
                            if (!object_url) {
                                object_url = get_URL().createObjectURL(blob);
                            }
                            if (force) {
                                view.location.href = object_url;
                            } else {
                                var opened = view.open(object_url, "_blank");
                                if (!opened) {
                                    // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                                    view.location.href = object_url;
                                }
                            }
                            filesaver.readyState = filesaver.DONE;
                            dispatch_all();
                            revoke(object_url);
                        };
                    filesaver.readyState = filesaver.INIT;

                    if (can_use_save_link) {
                        object_url = get_URL().createObjectURL(blob);
                        setTimeout(function() {
                            save_link.href = object_url;
                            save_link.download = name;
                            click(save_link);
                            dispatch_all();
                            revoke(object_url);
                            filesaver.readyState = filesaver.DONE;
                        });
                        return;
                    }

                    fs_error();
                },
                FS_proto = FileSaver.prototype,
                saveAs = function(blob, name, no_auto_bom) {
                    return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
                };
            // IE 10+ (native saveAs)
            if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
                return function(blob, name, no_auto_bom) {
                    name = name || blob.name || "download";

                    if (!no_auto_bom) {
                        blob = auto_bom(blob);
                    }
                    return navigator.msSaveOrOpenBlob(blob, name);
                };
            }

            FS_proto.abort = function() {};
            FS_proto.readyState = FS_proto.INIT = 0;
            FS_proto.WRITING = 1;
            FS_proto.DONE = 2;

            FS_proto.error =
                FS_proto.onwritestart =
                FS_proto.onprogress =
                FS_proto.onwrite =
                FS_proto.onabort =
                FS_proto.onerror =
                FS_proto.onwriteend =
                null;

            return saveAs;
        }(
            typeof self !== "undefined" && self ||
            typeof window !== "undefined" && window ||
            this.content
        ));
        // `self` is undefined in Firefox for Android content script context
        // while `this` is nsIContentFrameMessageManager
        // with an attribute `content` that corresponds to the window

        if (typeof module !== "undefined" && module.exports) {
            module.exports.saveAs = saveAs;
        } else if (("function" !== "undefined" && __webpack_require__(173) !== null) && (__webpack_require__(174) !== null)) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return saveAs;
                }.call(exports, __webpack_require__, exports, module),
                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }


        /***/
    }),
    /* 147 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            /**
             * jshashes - https://github.com/h2non/jshashes
             * Released under the "New BSD" license
             *
             * Algorithms specification:
             *
             * MD5 - http://www.ietf.org/rfc/rfc1321.txt
             * RIPEMD-160 - http://homes.esat.kuleuven.be/~bosselae/ripemd160.html
             * SHA1   - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
             * SHA256 - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
             * SHA512 - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
             * HMAC - http://www.ietf.org/rfc/rfc2104.txt
             */
            (function() {
                var Hashes;

                function utf8Encode(str) {
                    var x, y, output = '',
                        i = -1,
                        l;

                    if (str && str.length) {
                        l = str.length;
                        while ((i += 1) < l) {
                            /* Decode utf-16 surrogate pairs */
                            x = str.charCodeAt(i);
                            y = i + 1 < l ? str.charCodeAt(i + 1) : 0;
                            if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
                                x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
                                i += 1;
                            }
                            /* Encode output as utf-8 */
                            if (x <= 0x7F) {
                                output += String.fromCharCode(x);
                            } else if (x <= 0x7FF) {
                                output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F),
                                    0x80 | (x & 0x3F));
                            } else if (x <= 0xFFFF) {
                                output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6) & 0x3F),
                                    0x80 | (x & 0x3F));
                            } else if (x <= 0x1FFFFF) {
                                output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6) & 0x3F),
                                    0x80 | (x & 0x3F));
                            }
                        }
                    }
                    return output;
                }

                function utf8Decode(str) {
                    var i, ac, c1, c2, c3, arr = [],
                        l;
                    i = ac = c1 = c2 = c3 = 0;

                    if (str && str.length) {
                        l = str.length;
                        str += '';

                        while (i < l) {
                            c1 = str.charCodeAt(i);
                            ac += 1;
                            if (c1 < 128) {
                                arr[ac] = String.fromCharCode(c1);
                                i += 1;
                            } else if (c1 > 191 && c1 < 224) {
                                c2 = str.charCodeAt(i + 1);
                                arr[ac] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
                                i += 2;
                            } else {
                                c2 = str.charCodeAt(i + 1);
                                c3 = str.charCodeAt(i + 2);
                                arr[ac] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                                i += 3;
                            }
                        }
                    }
                    return arr.join('');
                }

                /**
                 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
                 * to work around bugs in some JS interpreters.
                 */

                function safe_add(x, y) {
                    var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                        msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                    return (msw << 16) | (lsw & 0xFFFF);
                }

                /**
                 * Bitwise rotate a 32-bit number to the left.
                 */

                function bit_rol(num, cnt) {
                    return (num << cnt) | (num >>> (32 - cnt));
                }

                /**
                 * Convert a raw string to a hex string
                 */

                function rstr2hex(input, hexcase) {
                    var hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef',
                        output = '',
                        x, i = 0,
                        l = input.length;
                    for (; i < l; i += 1) {
                        x = input.charCodeAt(i);
                        output += hex_tab.charAt((x >>> 4) & 0x0F) + hex_tab.charAt(x & 0x0F);
                    }
                    return output;
                }

                /**
                 * Encode a string as utf-16
                 */

                function str2rstr_utf16le(input) {
                    var i, l = input.length,
                        output = '';
                    for (i = 0; i < l; i += 1) {
                        output += String.fromCharCode(input.charCodeAt(i) & 0xFF, (input.charCodeAt(i) >>> 8) & 0xFF);
                    }
                    return output;
                }

                function str2rstr_utf16be(input) {
                    var i, l = input.length,
                        output = '';
                    for (i = 0; i < l; i += 1) {
                        output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF, input.charCodeAt(i) & 0xFF);
                    }
                    return output;
                }

                /**
                 * Convert an array of big-endian words to a string
                 */

                function binb2rstr(input) {
                    var i, l = input.length * 32,
                        output = '';
                    for (i = 0; i < l; i += 8) {
                        output += String.fromCharCode((input[i >> 5] >>> (24 - i % 32)) & 0xFF);
                    }
                    return output;
                }

                /**
                 * Convert an array of little-endian words to a string
                 */

                function binl2rstr(input) {
                    var i, l = input.length * 32,
                        output = '';
                    for (i = 0; i < l; i += 8) {
                        output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
                    }
                    return output;
                }

                /**
                 * Convert a raw string to an array of little-endian words
                 * Characters >255 have their high-byte silently ignored.
                 */

                function rstr2binl(input) {
                    var i, l = input.length * 8,
                        output = Array(input.length >> 2),
                        lo = output.length;
                    for (i = 0; i < lo; i += 1) {
                        output[i] = 0;
                    }
                    for (i = 0; i < l; i += 8) {
                        output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
                    }
                    return output;
                }

                /**
                 * Convert a raw string to an array of big-endian words
                 * Characters >255 have their high-byte silently ignored.
                 */

                function rstr2binb(input) {
                    var i, l = input.length * 8,
                        output = Array(input.length >> 2),
                        lo = output.length;
                    for (i = 0; i < lo; i += 1) {
                        output[i] = 0;
                    }
                    for (i = 0; i < l; i += 8) {
                        output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
                    }
                    return output;
                }

                /**
                 * Convert a raw string to an arbitrary string encoding
                 */

                function rstr2any(input, encoding) {
                    var divisor = encoding.length,
                        remainders = Array(),
                        i, q, x, ld, quotient, dividend, output, full_length;

                    /* Convert to an array of 16-bit big-endian values, forming the dividend */
                    dividend = Array(Math.ceil(input.length / 2));
                    ld = dividend.length;
                    for (i = 0; i < ld; i += 1) {
                        dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
                    }

                    /**
                     * Repeatedly perform a long division. The binary array forms the dividend,
                     * the length of the encoding is the divisor. Once computed, the quotient
                     * forms the dividend for the next step. We stop when the dividend is zerHashes.
                     * All remainders are stored for later use.
                     */
                    while (dividend.length > 0) {
                        quotient = Array();
                        x = 0;
                        for (i = 0; i < dividend.length; i += 1) {
                            x = (x << 16) + dividend[i];
                            q = Math.floor(x / divisor);
                            x -= q * divisor;
                            if (quotient.length > 0 || q > 0) {
                                quotient[quotient.length] = q;
                            }
                        }
                        remainders[remainders.length] = x;
                        dividend = quotient;
                    }

                    /* Convert the remainders to the output string */
                    output = '';
                    for (i = remainders.length - 1; i >= 0; i--) {
                        output += encoding.charAt(remainders[i]);
                    }

                    /* Append leading zero equivalents */
                    full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
                    for (i = output.length; i < full_length; i += 1) {
                        output = encoding[0] + output;
                    }
                    return output;
                }

                /**
                 * Convert a raw string to a base-64 string
                 */

                function rstr2b64(input, b64pad) {
                    var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
                        output = '',
                        len = input.length,
                        i, j, triplet;
                    b64pad = b64pad || '=';
                    for (i = 0; i < len; i += 3) {
                        triplet = (input.charCodeAt(i) << 16) | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
                        for (j = 0; j < 4; j += 1) {
                            if (i * 8 + j * 6 > input.length * 8) {
                                output += b64pad;
                            } else {
                                output += tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);
                            }
                        }
                    }
                    return output;
                }

                Hashes = {
                    /**
                     * @property {String} version
                     * @readonly
                     */
                    VERSION: '1.0.6',
                    /**
                     * @member Hashes
                     * @class Base64
                     * @constructor
                     */
                    Base64: function() {
                        // private properties
                        var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
                            pad = '=', // default pad according with the RFC standard
                            url = false, // URL encoding support @todo
                            utf8 = true; // by default enable UTF-8 support encoding

                        // public method for encoding
                        this.encode = function(input) {
                            var i, j, triplet,
                                output = '',
                                len = input.length;

                            pad = pad || '=';
                            input = (utf8) ? utf8Encode(input) : input;

                            for (i = 0; i < len; i += 3) {
                                triplet = (input.charCodeAt(i) << 16) | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
                                for (j = 0; j < 4; j += 1) {
                                    if (i * 8 + j * 6 > len * 8) {
                                        output += pad;
                                    } else {
                                        output += tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);
                                    }
                                }
                            }
                            return output;
                        };

                        // public method for decoding
                        this.decode = function(input) {
                            // var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                            var i, o1, o2, o3, h1, h2, h3, h4, bits, ac,
                                dec = '',
                                arr = [];
                            if (!input) {
                                return input;
                            }

                            i = ac = 0;
                            input = input.replace(new RegExp('\\' + pad, 'gi'), ''); // use '='
                            //input += '';

                            do { // unpack four hexets into three octets using index points in b64
                                h1 = tab.indexOf(input.charAt(i += 1));
                                h2 = tab.indexOf(input.charAt(i += 1));
                                h3 = tab.indexOf(input.charAt(i += 1));
                                h4 = tab.indexOf(input.charAt(i += 1));

                                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                                o1 = bits >> 16 & 0xff;
                                o2 = bits >> 8 & 0xff;
                                o3 = bits & 0xff;
                                ac += 1;

                                if (h3 === 64) {
                                    arr[ac] = String.fromCharCode(o1);
                                } else if (h4 === 64) {
                                    arr[ac] = String.fromCharCode(o1, o2);
                                } else {
                                    arr[ac] = String.fromCharCode(o1, o2, o3);
                                }
                            } while (i < input.length);

                            dec = arr.join('');
                            dec = (utf8) ? utf8Decode(dec) : dec;

                            return dec;
                        };

                        // set custom pad string
                        this.setPad = function(str) {
                            pad = str || pad;
                            return this;
                        };
                        // set custom tab string characters
                        this.setTab = function(str) {
                            tab = str || tab;
                            return this;
                        };
                        this.setUTF8 = function(bool) {
                            if (typeof bool === 'boolean') {
                                utf8 = bool;
                            }
                            return this;
                        };
                    },

                    /**
                     * CRC-32 calculation
                     * @member Hashes
                     * @method CRC32
                     * @static
                     * @param {String} str Input String
                     * @return {String}
                     */
                    CRC32: function(str) {
                        var crc = 0,
                            x = 0,
                            y = 0,
                            table, i, iTop;
                        str = utf8Encode(str);

                        table = [
                            '00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 ',
                            '79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 ',
                            '84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F ',
                            '63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD ',
                            'A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC ',
                            '51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 ',
                            'B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 ',
                            '06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 ',
                            'E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 ',
                            '12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 ',
                            'D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 ',
                            '33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 ',
                            'CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 ',
                            '9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E ',
                            '7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D ',
                            '806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 ',
                            '60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA ',
                            'AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 ',
                            '5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 ',
                            'B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 ',
                            '05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 ',
                            'F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA ',
                            '11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 ',
                            'D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F ',
                            '30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E ',
                            'C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D'
                        ].join('');

                        crc = crc ^ (-1);
                        for (i = 0, iTop = str.length; i < iTop; i += 1) {
                            y = (crc ^ str.charCodeAt(i)) & 0xFF;
                            x = '0x' + table.substr(y * 9, 8);
                            crc = (crc >>> 8) ^ x;
                        }
                        // always return a positive number (that's what >>> 0 does)
                        return (crc ^ (-1)) >>> 0;
                    },
                    /**
                     * @member Hashes
                     * @class MD5
                     * @constructor
                     * @param {Object} [config]
                     *
                     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
                     * Digest Algorithm, as defined in RFC 1321.
                     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
                     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                     * See <http://pajhome.org.uk/crypt/md5> for more infHashes.
                     */
                    MD5: function(options) {
                        /**
                         * Private config properties. You may need to tweak these to be compatible with
                         * the server-side, but the defaults work in most cases.
                         * See {@link Hashes.MD5#method-setUpperCase} and {@link Hashes.SHA1#method-setUpperCase}
                         */
                        var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false, // hexadecimal output case format. false - lowercase; true - uppercase
                            b64pad = (options && typeof options.pad === 'string') ? options.pad : '=', // base-64 pad character. Defaults to '=' for strict RFC compliance
                            utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true; // enable/disable utf8 encoding

                        // privileged (public) methods
                        this.hex = function(s) {
                            return rstr2hex(rstr(s, utf8), hexcase);
                        };
                        this.b64 = function(s) {
                            return rstr2b64(rstr(s), b64pad);
                        };
                        this.any = function(s, e) {
                            return rstr2any(rstr(s, utf8), e);
                        };
                        this.raw = function(s) {
                            return rstr(s, utf8);
                        };
                        this.hex_hmac = function(k, d) {
                            return rstr2hex(rstr_hmac(k, d), hexcase);
                        };
                        this.b64_hmac = function(k, d) {
                            return rstr2b64(rstr_hmac(k, d), b64pad);
                        };
                        this.any_hmac = function(k, d, e) {
                            return rstr2any(rstr_hmac(k, d), e);
                        };
                        /**
                         * Perform a simple self-test to see if the VM is working
                         * @return {String} Hexadecimal hash sample
                         */
                        this.vm_test = function() {
                            return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
                        };
                        /**
                         * Enable/disable uppercase hexadecimal returned string
                         * @param {Boolean}
                         * @return {Object} this
                         */
                        this.setUpperCase = function(a) {
                            if (typeof a === 'boolean') {
                                hexcase = a;
                            }
                            return this;
                        };
                        /**
                         * Defines a base64 pad string
                         * @param {String} Pad
                         * @return {Object} this
                         */
                        this.setPad = function(a) {
                            b64pad = a || b64pad;
                            return this;
                        };
                        /**
                         * Defines a base64 pad string
                         * @param {Boolean}
                         * @return {Object} [this]
                         */
                        this.setUTF8 = function(a) {
                            if (typeof a === 'boolean') {
                                utf8 = a;
                            }
                            return this;
                        };

                        // private methods

                        /**
                         * Calculate the MD5 of a raw string
                         */

                        function rstr(s) {
                            s = (utf8) ? utf8Encode(s) : s;
                            return binl2rstr(binl(rstr2binl(s), s.length * 8));
                        }

                        /**
                         * Calculate the HMAC-MD5, of a key and some data (raw strings)
                         */

                        function rstr_hmac(key, data) {
                            var bkey, ipad, opad, hash, i;

                            key = (utf8) ? utf8Encode(key) : key;
                            data = (utf8) ? utf8Encode(data) : data;
                            bkey = rstr2binl(key);
                            if (bkey.length > 16) {
                                bkey = binl(bkey, key.length * 8);
                            }

                            ipad = Array(16), opad = Array(16);
                            for (i = 0; i < 16; i += 1) {
                                ipad[i] = bkey[i] ^ 0x36363636;
                                opad[i] = bkey[i] ^ 0x5C5C5C5C;
                            }
                            hash = binl(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
                            return binl2rstr(binl(opad.concat(hash), 512 + 128));
                        }

                        /**
                         * Calculate the MD5 of an array of little-endian words, and a bit length.
                         */

                        function binl(x, len) {
                            var i, olda, oldb, oldc, oldd,
                                a = 1732584193,
                                b = -271733879,
                                c = -1732584194,
                                d = 271733878;

                            /* append padding */
                            x[len >> 5] |= 0x80 << ((len) % 32);
                            x[(((len + 64) >>> 9) << 4) + 14] = len;

                            for (i = 0; i < x.length; i += 16) {
                                olda = a;
                                oldb = b;
                                oldc = c;
                                oldd = d;

                                a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
                                d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
                                c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
                                b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
                                a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
                                d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
                                c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
                                b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
                                a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
                                d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
                                c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
                                b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
                                a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
                                d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
                                c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
                                b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

                                a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
                                d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
                                c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
                                b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
                                a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
                                d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
                                c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
                                b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
                                a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
                                d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
                                c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
                                b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
                                a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
                                d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
                                c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
                                b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

                                a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
                                d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
                                c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
                                b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
                                a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
                                d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
                                c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
                                b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
                                a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
                                d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
                                c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
                                b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
                                a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
                                d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
                                c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
                                b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

                                a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
                                d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
                                c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
                                b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
                                a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
                                d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
                                c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
                                b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
                                a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
                                d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
                                c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
                                b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
                                a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
                                d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
                                c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
                                b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

                                a = safe_add(a, olda);
                                b = safe_add(b, oldb);
                                c = safe_add(c, oldc);
                                d = safe_add(d, oldd);
                            }
                            return Array(a, b, c, d);
                        }

                        /**
                         * These functions implement the four basic operations the algorithm uses.
                         */

                        function md5_cmn(q, a, b, x, s, t) {
                            return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
                        }

                        function md5_ff(a, b, c, d, x, s, t) {
                            return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
                        }

                        function md5_gg(a, b, c, d, x, s, t) {
                            return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
                        }

                        function md5_hh(a, b, c, d, x, s, t) {
                            return md5_cmn(b ^ c ^ d, a, b, x, s, t);
                        }

                        function md5_ii(a, b, c, d, x, s, t) {
                            return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
                        }
                    },
                    /**
                     * @member Hashes
                     * @class Hashes.SHA1
                     * @param {Object} [config]
                     * @constructor
                     *
                     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined in FIPS 180-1
                     * Version 2.2 Copyright Paul Johnston 2000 - 2009.
                     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                     * See http://pajhome.org.uk/crypt/md5 for details.
                     */
                    SHA1: function(options) {
                        /**
                         * Private config properties. You may need to tweak these to be compatible with
                         * the server-side, but the defaults work in most cases.
                         * See {@link Hashes.MD5#method-setUpperCase} and {@link Hashes.SHA1#method-setUpperCase}
                         */
                        var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false, // hexadecimal output case format. false - lowercase; true - uppercase
                            b64pad = (options && typeof options.pad === 'string') ? options.pad : '=', // base-64 pad character. Defaults to '=' for strict RFC compliance
                            utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true; // enable/disable utf8 encoding

                        // public methods
                        this.hex = function(s) {
                            return rstr2hex(rstr(s, utf8), hexcase);
                        };
                        this.b64 = function(s) {
                            return rstr2b64(rstr(s, utf8), b64pad);
                        };
                        this.any = function(s, e) {
                            return rstr2any(rstr(s, utf8), e);
                        };
                        this.raw = function(s) {
                            return rstr(s, utf8);
                        };
                        this.hex_hmac = function(k, d) {
                            return rstr2hex(rstr_hmac(k, d));
                        };
                        this.b64_hmac = function(k, d) {
                            return rstr2b64(rstr_hmac(k, d), b64pad);
                        };
                        this.any_hmac = function(k, d, e) {
                            return rstr2any(rstr_hmac(k, d), e);
                        };
                        /**
                         * Perform a simple self-test to see if the VM is working
                         * @return {String} Hexadecimal hash sample
                         * @public
                         */
                        this.vm_test = function() {
                            return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
                        };
                        /**
                         * @description Enable/disable uppercase hexadecimal returned string
                         * @param {boolean}
                         * @return {Object} this
                         * @public
                         */
                        this.setUpperCase = function(a) {
                            if (typeof a === 'boolean') {
                                hexcase = a;
                            }
                            return this;
                        };
                        /**
                         * @description Defines a base64 pad string
                         * @param {string} Pad
                         * @return {Object} this
                         * @public
                         */
                        this.setPad = function(a) {
                            b64pad = a || b64pad;
                            return this;
                        };
                        /**
                         * @description Defines a base64 pad string
                         * @param {boolean}
                         * @return {Object} this
                         * @public
                         */
                        this.setUTF8 = function(a) {
                            if (typeof a === 'boolean') {
                                utf8 = a;
                            }
                            return this;
                        };

                        // private methods

                        /**
                         * Calculate the SHA-512 of a raw string
                         */

                        function rstr(s) {
                            s = (utf8) ? utf8Encode(s) : s;
                            return binb2rstr(binb(rstr2binb(s), s.length * 8));
                        }

                        /**
                         * Calculate the HMAC-SHA1 of a key and some data (raw strings)
                         */

                        function rstr_hmac(key, data) {
                            var bkey, ipad, opad, i, hash;
                            key = (utf8) ? utf8Encode(key) : key;
                            data = (utf8) ? utf8Encode(data) : data;
                            bkey = rstr2binb(key);

                            if (bkey.length > 16) {
                                bkey = binb(bkey, key.length * 8);
                            }
                            ipad = Array(16), opad = Array(16);
                            for (i = 0; i < 16; i += 1) {
                                ipad[i] = bkey[i] ^ 0x36363636;
                                opad[i] = bkey[i] ^ 0x5C5C5C5C;
                            }
                            hash = binb(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
                            return binb2rstr(binb(opad.concat(hash), 512 + 160));
                        }

                        /**
                         * Calculate the SHA-1 of an array of big-endian words, and a bit length
                         */

                        function binb(x, len) {
                            var i, j, t, olda, oldb, oldc, oldd, olde,
                                w = Array(80),
                                a = 1732584193,
                                b = -271733879,
                                c = -1732584194,
                                d = 271733878,
                                e = -1009589776;

                            /* append padding */
                            x[len >> 5] |= 0x80 << (24 - len % 32);
                            x[((len + 64 >> 9) << 4) + 15] = len;

                            for (i = 0; i < x.length; i += 16) {
                                olda = a;
                                oldb = b;
                                oldc = c;
                                oldd = d;
                                olde = e;

                                for (j = 0; j < 80; j += 1) {
                                    if (j < 16) {
                                        w[j] = x[i + j];
                                    } else {
                                        w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                                    }
                                    t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),
                                        safe_add(safe_add(e, w[j]), sha1_kt(j)));
                                    e = d;
                                    d = c;
                                    c = bit_rol(b, 30);
                                    b = a;
                                    a = t;
                                }

                                a = safe_add(a, olda);
                                b = safe_add(b, oldb);
                                c = safe_add(c, oldc);
                                d = safe_add(d, oldd);
                                e = safe_add(e, olde);
                            }
                            return Array(a, b, c, d, e);
                        }

                        /**
                         * Perform the appropriate triplet combination function for the current
                         * iteration
                         */

                        function sha1_ft(t, b, c, d) {
                            if (t < 20) {
                                return (b & c) | ((~b) & d);
                            }
                            if (t < 40) {
                                return b ^ c ^ d;
                            }
                            if (t < 60) {
                                return (b & c) | (b & d) | (c & d);
                            }
                            return b ^ c ^ d;
                        }

                        /**
                         * Determine the appropriate additive constant for the current iteration
                         */

                        function sha1_kt(t) {
                            return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 :
                                (t < 60) ? -1894007588 : -899497514;
                        }
                    },
                    /**
                     * @class Hashes.SHA256
                     * @param {config}
                     *
                     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined in FIPS 180-2
                     * Version 2.2 Copyright Angel Marin, Paul Johnston 2000 - 2009.
                     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                     * See http://pajhome.org.uk/crypt/md5 for details.
                     * Also http://anmar.eu.org/projects/jssha2/
                     */
                    SHA256: function(options) {
                        /**
                         * Private properties configuration variables. You may need to tweak these to be compatible with
                         * the server-side, but the defaults work in most cases.
                         * @see this.setUpperCase() method
                         * @see this.setPad() method
                         */
                        var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false, // hexadecimal output case format. false - lowercase; true - uppercase  */
                            b64pad = (options && typeof options.pad === 'string') ? options.pad : '=',
                            /* base-64 pad character. Default '=' for strict RFC compliance   */
                            utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true,
                            /* enable/disable utf8 encoding */
                            sha256_K;

                        /* privileged (public) methods */
                        this.hex = function(s) {
                            return rstr2hex(rstr(s, utf8));
                        };
                        this.b64 = function(s) {
                            return rstr2b64(rstr(s, utf8), b64pad);
                        };
                        this.any = function(s, e) {
                            return rstr2any(rstr(s, utf8), e);
                        };
                        this.raw = function(s) {
                            return rstr(s, utf8);
                        };
                        this.hex_hmac = function(k, d) {
                            return rstr2hex(rstr_hmac(k, d));
                        };
                        this.b64_hmac = function(k, d) {
                            return rstr2b64(rstr_hmac(k, d), b64pad);
                        };
                        this.any_hmac = function(k, d, e) {
                            return rstr2any(rstr_hmac(k, d), e);
                        };
                        /**
                         * Perform a simple self-test to see if the VM is working
                         * @return {String} Hexadecimal hash sample
                         * @public
                         */
                        this.vm_test = function() {
                            return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
                        };
                        /**
                         * Enable/disable uppercase hexadecimal returned string
                         * @param {boolean}
                         * @return {Object} this
                         * @public
                         */
                        this.setUpperCase = function(a) {
                            if (typeof a === 'boolean') {
                                hexcase = a;
                            }
                            return this;
                        };
                        /**
                         * @description Defines a base64 pad string
                         * @param {string} Pad
                         * @return {Object} this
                         * @public
                         */
                        this.setPad = function(a) {
                            b64pad = a || b64pad;
                            return this;
                        };
                        /**
                         * Defines a base64 pad string
                         * @param {boolean}
                         * @return {Object} this
                         * @public
                         */
                        this.setUTF8 = function(a) {
                            if (typeof a === 'boolean') {
                                utf8 = a;
                            }
                            return this;
                        };

                        // private methods

                        /**
                         * Calculate the SHA-512 of a raw string
                         */

                        function rstr(s, utf8) {
                            s = (utf8) ? utf8Encode(s) : s;
                            return binb2rstr(binb(rstr2binb(s), s.length * 8));
                        }

                        /**
                         * Calculate the HMAC-sha256 of a key and some data (raw strings)
                         */

                        function rstr_hmac(key, data) {
                            key = (utf8) ? utf8Encode(key) : key;
                            data = (utf8) ? utf8Encode(data) : data;
                            var hash, i = 0,
                                bkey = rstr2binb(key),
                                ipad = Array(16),
                                opad = Array(16);

                            if (bkey.length > 16) {
                                bkey = binb(bkey, key.length * 8);
                            }

                            for (; i < 16; i += 1) {
                                ipad[i] = bkey[i] ^ 0x36363636;
                                opad[i] = bkey[i] ^ 0x5C5C5C5C;
                            }

                            hash = binb(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
                            return binb2rstr(binb(opad.concat(hash), 512 + 256));
                        }

                        /*
                         * Main sha256 function, with its support functions
                         */

                        function sha256_S(X, n) {
                            return (X >>> n) | (X << (32 - n));
                        }

                        function sha256_R(X, n) {
                            return (X >>> n);
                        }

                        function sha256_Ch(x, y, z) {
                            return ((x & y) ^ ((~x) & z));
                        }

                        function sha256_Maj(x, y, z) {
                            return ((x & y) ^ (x & z) ^ (y & z));
                        }

                        function sha256_Sigma0256(x) {
                            return (sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22));
                        }

                        function sha256_Sigma1256(x) {
                            return (sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25));
                        }

                        function sha256_Gamma0256(x) {
                            return (sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3));
                        }

                        function sha256_Gamma1256(x) {
                            return (sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10));
                        }

                        function sha256_Sigma0512(x) {
                            return (sha256_S(x, 28) ^ sha256_S(x, 34) ^ sha256_S(x, 39));
                        }

                        function sha256_Sigma1512(x) {
                            return (sha256_S(x, 14) ^ sha256_S(x, 18) ^ sha256_S(x, 41));
                        }

                        function sha256_Gamma0512(x) {
                            return (sha256_S(x, 1) ^ sha256_S(x, 8) ^ sha256_R(x, 7));
                        }

                        function sha256_Gamma1512(x) {
                            return (sha256_S(x, 19) ^ sha256_S(x, 61) ^ sha256_R(x, 6));
                        }

                        sha256_K = [
                            1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987,
                            1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522,
                            264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585,
                            113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
                            1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344,
                            430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
                            1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998
                        ];

                        function binb(m, l) {
                            var HASH = [1779033703, -1150833019, 1013904242, -1521486534,
                                1359893119, -1694144372, 528734635, 1541459225
                            ];
                            var W = new Array(64);
                            var a, b, c, d, e, f, g, h;
                            var i, j, T1, T2;

                            /* append padding */
                            m[l >> 5] |= 0x80 << (24 - l % 32);
                            m[((l + 64 >> 9) << 4) + 15] = l;

                            for (i = 0; i < m.length; i += 16) {
                                a = HASH[0];
                                b = HASH[1];
                                c = HASH[2];
                                d = HASH[3];
                                e = HASH[4];
                                f = HASH[5];
                                g = HASH[6];
                                h = HASH[7];

                                for (j = 0; j < 64; j += 1) {
                                    if (j < 16) {
                                        W[j] = m[j + i];
                                    } else {
                                        W[j] = safe_add(safe_add(safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]),
                                            sha256_Gamma0256(W[j - 15])), W[j - 16]);
                                    }

                                    T1 = safe_add(safe_add(safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)),
                                        sha256_K[j]), W[j]);
                                    T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c));
                                    h = g;
                                    g = f;
                                    f = e;
                                    e = safe_add(d, T1);
                                    d = c;
                                    c = b;
                                    b = a;
                                    a = safe_add(T1, T2);
                                }

                                HASH[0] = safe_add(a, HASH[0]);
                                HASH[1] = safe_add(b, HASH[1]);
                                HASH[2] = safe_add(c, HASH[2]);
                                HASH[3] = safe_add(d, HASH[3]);
                                HASH[4] = safe_add(e, HASH[4]);
                                HASH[5] = safe_add(f, HASH[5]);
                                HASH[6] = safe_add(g, HASH[6]);
                                HASH[7] = safe_add(h, HASH[7]);
                            }
                            return HASH;
                        }

                    },

                    /**
                     * @class Hashes.SHA512
                     * @param {config}
                     *
                     * A JavaScript implementation of the Secure Hash Algorithm, SHA-512, as defined in FIPS 180-2
                     * Version 2.2 Copyright Anonymous Contributor, Paul Johnston 2000 - 2009.
                     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                     * See http://pajhome.org.uk/crypt/md5 for details.
                     */
                    SHA512: function(options) {
                        /**
                         * Private properties configuration variables. You may need to tweak these to be compatible with
                         * the server-side, but the defaults work in most cases.
                         * @see this.setUpperCase() method
                         * @see this.setPad() method
                         */
                        var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false,
                            /* hexadecimal output case format. false - lowercase; true - uppercase  */
                            b64pad = (options && typeof options.pad === 'string') ? options.pad : '=',
                            /* base-64 pad character. Default '=' for strict RFC compliance   */
                            utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true,
                            /* enable/disable utf8 encoding */
                            sha512_k;

                        /* privileged (public) methods */
                        this.hex = function(s) {
                            return rstr2hex(rstr(s));
                        };
                        this.b64 = function(s) {
                            return rstr2b64(rstr(s), b64pad);
                        };
                        this.any = function(s, e) {
                            return rstr2any(rstr(s), e);
                        };
                        this.raw = function(s) {
                            return rstr(s, utf8);
                        };
                        this.hex_hmac = function(k, d) {
                            return rstr2hex(rstr_hmac(k, d));
                        };
                        this.b64_hmac = function(k, d) {
                            return rstr2b64(rstr_hmac(k, d), b64pad);
                        };
                        this.any_hmac = function(k, d, e) {
                            return rstr2any(rstr_hmac(k, d), e);
                        };
                        /**
                         * Perform a simple self-test to see if the VM is working
                         * @return {String} Hexadecimal hash sample
                         * @public
                         */
                        this.vm_test = function() {
                            return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
                        };
                        /**
                         * @description Enable/disable uppercase hexadecimal returned string
                         * @param {boolean}
                         * @return {Object} this
                         * @public
                         */
                        this.setUpperCase = function(a) {
                            if (typeof a === 'boolean') {
                                hexcase = a;
                            }
                            return this;
                        };
                        /**
                         * @description Defines a base64 pad string
                         * @param {string} Pad
                         * @return {Object} this
                         * @public
                         */
                        this.setPad = function(a) {
                            b64pad = a || b64pad;
                            return this;
                        };
                        /**
                         * @description Defines a base64 pad string
                         * @param {boolean}
                         * @return {Object} this
                         * @public
                         */
                        this.setUTF8 = function(a) {
                            if (typeof a === 'boolean') {
                                utf8 = a;
                            }
                            return this;
                        };

                        /* private methods */

                        /**
                         * Calculate the SHA-512 of a raw string
                         */

                        function rstr(s) {
                            s = (utf8) ? utf8Encode(s) : s;
                            return binb2rstr(binb(rstr2binb(s), s.length * 8));
                        }
                        /*
                         * Calculate the HMAC-SHA-512 of a key and some data (raw strings)
                         */

                        function rstr_hmac(key, data) {
                            key = (utf8) ? utf8Encode(key) : key;
                            data = (utf8) ? utf8Encode(data) : data;

                            var hash, i = 0,
                                bkey = rstr2binb(key),
                                ipad = Array(32),
                                opad = Array(32);

                            if (bkey.length > 32) {
                                bkey = binb(bkey, key.length * 8);
                            }

                            for (; i < 32; i += 1) {
                                ipad[i] = bkey[i] ^ 0x36363636;
                                opad[i] = bkey[i] ^ 0x5C5C5C5C;
                            }

                            hash = binb(ipad.concat(rstr2binb(data)), 1024 + data.length * 8);
                            return binb2rstr(binb(opad.concat(hash), 1024 + 512));
                        }

                        /**
                         * Calculate the SHA-512 of an array of big-endian dwords, and a bit length
                         */

                        function binb(x, len) {
                            var j, i, l,
                                W = new Array(80),
                                hash = new Array(16),
                                //Initial hash values
                                H = [
                                    new int64(0x6a09e667, -205731576),
                                    new int64(-1150833019, -2067093701),
                                    new int64(0x3c6ef372, -23791573),
                                    new int64(-1521486534, 0x5f1d36f1),
                                    new int64(0x510e527f, -1377402159),
                                    new int64(-1694144372, 0x2b3e6c1f),
                                    new int64(0x1f83d9ab, -79577749),
                                    new int64(0x5be0cd19, 0x137e2179)
                                ],
                                T1 = new int64(0, 0),
                                T2 = new int64(0, 0),
                                a = new int64(0, 0),
                                b = new int64(0, 0),
                                c = new int64(0, 0),
                                d = new int64(0, 0),
                                e = new int64(0, 0),
                                f = new int64(0, 0),
                                g = new int64(0, 0),
                                h = new int64(0, 0),
                                //Temporary variables not specified by the document
                                s0 = new int64(0, 0),
                                s1 = new int64(0, 0),
                                Ch = new int64(0, 0),
                                Maj = new int64(0, 0),
                                r1 = new int64(0, 0),
                                r2 = new int64(0, 0),
                                r3 = new int64(0, 0);

                            if (sha512_k === undefined) {
                                //SHA512 constants
                                sha512_k = [
                                    new int64(0x428a2f98, -685199838), new int64(0x71374491, 0x23ef65cd),
                                    new int64(-1245643825, -330482897), new int64(-373957723, -2121671748),
                                    new int64(0x3956c25b, -213338824), new int64(0x59f111f1, -1241133031),
                                    new int64(-1841331548, -1357295717), new int64(-1424204075, -630357736),
                                    new int64(-670586216, -1560083902), new int64(0x12835b01, 0x45706fbe),
                                    new int64(0x243185be, 0x4ee4b28c), new int64(0x550c7dc3, -704662302),
                                    new int64(0x72be5d74, -226784913), new int64(-2132889090, 0x3b1696b1),
                                    new int64(-1680079193, 0x25c71235), new int64(-1046744716, -815192428),
                                    new int64(-459576895, -1628353838), new int64(-272742522, 0x384f25e3),
                                    new int64(0xfc19dc6, -1953704523), new int64(0x240ca1cc, 0x77ac9c65),
                                    new int64(0x2de92c6f, 0x592b0275), new int64(0x4a7484aa, 0x6ea6e483),
                                    new int64(0x5cb0a9dc, -1119749164), new int64(0x76f988da, -2096016459),
                                    new int64(-1740746414, -295247957), new int64(-1473132947, 0x2db43210),
                                    new int64(-1341970488, -1728372417), new int64(-1084653625, -1091629340),
                                    new int64(-958395405, 0x3da88fc2), new int64(-710438585, -1828018395),
                                    new int64(0x6ca6351, -536640913), new int64(0x14292967, 0xa0e6e70),
                                    new int64(0x27b70a85, 0x46d22ffc), new int64(0x2e1b2138, 0x5c26c926),
                                    new int64(0x4d2c6dfc, 0x5ac42aed), new int64(0x53380d13, -1651133473),
                                    new int64(0x650a7354, -1951439906), new int64(0x766a0abb, 0x3c77b2a8),
                                    new int64(-2117940946, 0x47edaee6), new int64(-1838011259, 0x1482353b),
                                    new int64(-1564481375, 0x4cf10364), new int64(-1474664885, -1136513023),
                                    new int64(-1035236496, -789014639), new int64(-949202525, 0x654be30),
                                    new int64(-778901479, -688958952), new int64(-694614492, 0x5565a910),
                                    new int64(-200395387, 0x5771202a), new int64(0x106aa070, 0x32bbd1b8),
                                    new int64(0x19a4c116, -1194143544), new int64(0x1e376c08, 0x5141ab53),
                                    new int64(0x2748774c, -544281703), new int64(0x34b0bcb5, -509917016),
                                    new int64(0x391c0cb3, -976659869), new int64(0x4ed8aa4a, -482243893),
                                    new int64(0x5b9cca4f, 0x7763e373), new int64(0x682e6ff3, -692930397),
                                    new int64(0x748f82ee, 0x5defb2fc), new int64(0x78a5636f, 0x43172f60),
                                    new int64(-2067236844, -1578062990), new int64(-1933114872, 0x1a6439ec),
                                    new int64(-1866530822, 0x23631e28), new int64(-1538233109, -561857047),
                                    new int64(-1090935817, -1295615723), new int64(-965641998, -479046869),
                                    new int64(-903397682, -366583396), new int64(-779700025, 0x21c0c207),
                                    new int64(-354779690, -840897762), new int64(-176337025, -294727304),
                                    new int64(0x6f067aa, 0x72176fba), new int64(0xa637dc5, -1563912026),
                                    new int64(0x113f9804, -1090974290), new int64(0x1b710b35, 0x131c471b),
                                    new int64(0x28db77f5, 0x23047d84), new int64(0x32caab7b, 0x40c72493),
                                    new int64(0x3c9ebe0a, 0x15c9bebc), new int64(0x431d67c4, -1676669620),
                                    new int64(0x4cc5d4be, -885112138), new int64(0x597f299c, -60457430),
                                    new int64(0x5fcb6fab, 0x3ad6faec), new int64(0x6c44198c, 0x4a475817)
                                ];
                            }

                            for (i = 0; i < 80; i += 1) {
                                W[i] = new int64(0, 0);
                            }

                            // append padding to the source string. The format is described in the FIPS.
                            x[len >> 5] |= 0x80 << (24 - (len & 0x1f));
                            x[((len + 128 >> 10) << 5) + 31] = len;
                            l = x.length;
                            for (i = 0; i < l; i += 32) { //32 dwords is the block size
                                int64copy(a, H[0]);
                                int64copy(b, H[1]);
                                int64copy(c, H[2]);
                                int64copy(d, H[3]);
                                int64copy(e, H[4]);
                                int64copy(f, H[5]);
                                int64copy(g, H[6]);
                                int64copy(h, H[7]);

                                for (j = 0; j < 16; j += 1) {
                                    W[j].h = x[i + 2 * j];
                                    W[j].l = x[i + 2 * j + 1];
                                }

                                for (j = 16; j < 80; j += 1) {
                                    //sigma1
                                    int64rrot(r1, W[j - 2], 19);
                                    int64revrrot(r2, W[j - 2], 29);
                                    int64shr(r3, W[j - 2], 6);
                                    s1.l = r1.l ^ r2.l ^ r3.l;
                                    s1.h = r1.h ^ r2.h ^ r3.h;
                                    //sigma0
                                    int64rrot(r1, W[j - 15], 1);
                                    int64rrot(r2, W[j - 15], 8);
                                    int64shr(r3, W[j - 15], 7);
                                    s0.l = r1.l ^ r2.l ^ r3.l;
                                    s0.h = r1.h ^ r2.h ^ r3.h;

                                    int64add4(W[j], s1, W[j - 7], s0, W[j - 16]);
                                }

                                for (j = 0; j < 80; j += 1) {
                                    //Ch
                                    Ch.l = (e.l & f.l) ^ (~e.l & g.l);
                                    Ch.h = (e.h & f.h) ^ (~e.h & g.h);

                                    //Sigma1
                                    int64rrot(r1, e, 14);
                                    int64rrot(r2, e, 18);
                                    int64revrrot(r3, e, 9);
                                    s1.l = r1.l ^ r2.l ^ r3.l;
                                    s1.h = r1.h ^ r2.h ^ r3.h;

                                    //Sigma0
                                    int64rrot(r1, a, 28);
                                    int64revrrot(r2, a, 2);
                                    int64revrrot(r3, a, 7);
                                    s0.l = r1.l ^ r2.l ^ r3.l;
                                    s0.h = r1.h ^ r2.h ^ r3.h;

                                    //Maj
                                    Maj.l = (a.l & b.l) ^ (a.l & c.l) ^ (b.l & c.l);
                                    Maj.h = (a.h & b.h) ^ (a.h & c.h) ^ (b.h & c.h);

                                    int64add5(T1, h, s1, Ch, sha512_k[j], W[j]);
                                    int64add(T2, s0, Maj);

                                    int64copy(h, g);
                                    int64copy(g, f);
                                    int64copy(f, e);
                                    int64add(e, d, T1);
                                    int64copy(d, c);
                                    int64copy(c, b);
                                    int64copy(b, a);
                                    int64add(a, T1, T2);
                                }
                                int64add(H[0], H[0], a);
                                int64add(H[1], H[1], b);
                                int64add(H[2], H[2], c);
                                int64add(H[3], H[3], d);
                                int64add(H[4], H[4], e);
                                int64add(H[5], H[5], f);
                                int64add(H[6], H[6], g);
                                int64add(H[7], H[7], h);
                            }

                            //represent the hash as an array of 32-bit dwords
                            for (i = 0; i < 8; i += 1) {
                                hash[2 * i] = H[i].h;
                                hash[2 * i + 1] = H[i].l;
                            }
                            return hash;
                        }

                        //A constructor for 64-bit numbers

                        function int64(h, l) {
                            this.h = h;
                            this.l = l;
                            //this.toString = int64toString;
                        }

                        //Copies src into dst, assuming both are 64-bit numbers

                        function int64copy(dst, src) {
                            dst.h = src.h;
                            dst.l = src.l;
                        }

                        //Right-rotates a 64-bit number by shift
                        //Won't handle cases of shift>=32
                        //The function revrrot() is for that

                        function int64rrot(dst, x, shift) {
                            dst.l = (x.l >>> shift) | (x.h << (32 - shift));
                            dst.h = (x.h >>> shift) | (x.l << (32 - shift));
                        }

                        //Reverses the dwords of the source and then rotates right by shift.
                        //This is equivalent to rotation by 32+shift

                        function int64revrrot(dst, x, shift) {
                            dst.l = (x.h >>> shift) | (x.l << (32 - shift));
                            dst.h = (x.l >>> shift) | (x.h << (32 - shift));
                        }

                        //Bitwise-shifts right a 64-bit number by shift
                        //Won't handle shift>=32, but it's never needed in SHA512

                        function int64shr(dst, x, shift) {
                            dst.l = (x.l >>> shift) | (x.h << (32 - shift));
                            dst.h = (x.h >>> shift);
                        }

                        //Adds two 64-bit numbers
                        //Like the original implementation, does not rely on 32-bit operations

                        function int64add(dst, x, y) {
                            var w0 = (x.l & 0xffff) + (y.l & 0xffff);
                            var w1 = (x.l >>> 16) + (y.l >>> 16) + (w0 >>> 16);
                            var w2 = (x.h & 0xffff) + (y.h & 0xffff) + (w1 >>> 16);
                            var w3 = (x.h >>> 16) + (y.h >>> 16) + (w2 >>> 16);
                            dst.l = (w0 & 0xffff) | (w1 << 16);
                            dst.h = (w2 & 0xffff) | (w3 << 16);
                        }

                        //Same, except with 4 addends. Works faster than adding them one by one.

                        function int64add4(dst, a, b, c, d) {
                            var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff);
                            var w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (w0 >>> 16);
                            var w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (w1 >>> 16);
                            var w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (w2 >>> 16);
                            dst.l = (w0 & 0xffff) | (w1 << 16);
                            dst.h = (w2 & 0xffff) | (w3 << 16);
                        }

                        //Same, except with 5 addends

                        function int64add5(dst, a, b, c, d, e) {
                            var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff) + (e.l & 0xffff),
                                w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (e.l >>> 16) + (w0 >>> 16),
                                w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (e.h & 0xffff) + (w1 >>> 16),
                                w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (e.h >>> 16) + (w2 >>> 16);
                            dst.l = (w0 & 0xffff) | (w1 << 16);
                            dst.h = (w2 & 0xffff) | (w3 << 16);
                        }
                    },
                    /**
                     * @class Hashes.RMD160
                     * @constructor
                     * @param {Object} [config]
                     *
                     * A JavaScript implementation of the RIPEMD-160 Algorithm
                     * Version 2.2 Copyright Jeremy Lin, Paul Johnston 2000 - 2009.
                     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                     * See http://pajhome.org.uk/crypt/md5 for details.
                     * Also http://www.ocf.berkeley.edu/~jjlin/jsotp/
                     */
                    RMD160: function(options) {
                        /**
                         * Private properties configuration variables. You may need to tweak these to be compatible with
                         * the server-side, but the defaults work in most cases.
                         * @see this.setUpperCase() method
                         * @see this.setPad() method
                         */
                        var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false,
                            /* hexadecimal output case format. false - lowercase; true - uppercase  */
                            b64pad = (options && typeof options.pad === 'string') ? options.pa : '=',
                            /* base-64 pad character. Default '=' for strict RFC compliance   */
                            utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true,
                            /* enable/disable utf8 encoding */
                            rmd160_r1 = [
                                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                                7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                                3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                                1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                                4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
                            ],
                            rmd160_r2 = [
                                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                                6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                                15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                                8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                                12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
                            ],
                            rmd160_s1 = [
                                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                                7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                                11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                                11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                                9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
                            ],
                            rmd160_s2 = [
                                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                                9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                                9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                                15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                                8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
                            ];

                        /* privileged (public) methods */
                        this.hex = function(s) {
                            return rstr2hex(rstr(s, utf8));
                        };
                        this.b64 = function(s) {
                            return rstr2b64(rstr(s, utf8), b64pad);
                        };
                        this.any = function(s, e) {
                            return rstr2any(rstr(s, utf8), e);
                        };
                        this.raw = function(s) {
                            return rstr(s, utf8);
                        };
                        this.hex_hmac = function(k, d) {
                            return rstr2hex(rstr_hmac(k, d));
                        };
                        this.b64_hmac = function(k, d) {
                            return rstr2b64(rstr_hmac(k, d), b64pad);
                        };
                        this.any_hmac = function(k, d, e) {
                            return rstr2any(rstr_hmac(k, d), e);
                        };
                        /**
                         * Perform a simple self-test to see if the VM is working
                         * @return {String} Hexadecimal hash sample
                         * @public
                         */
                        this.vm_test = function() {
                            return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
                        };
                        /**
                         * @description Enable/disable uppercase hexadecimal returned string
                         * @param {boolean}
                         * @return {Object} this
                         * @public
                         */
                        this.setUpperCase = function(a) {
                            if (typeof a === 'boolean') {
                                hexcase = a;
                            }
                            return this;
                        };
                        /**
                         * @description Defines a base64 pad string
                         * @param {string} Pad
                         * @return {Object} this
                         * @public
                         */
                        this.setPad = function(a) {
                            if (typeof a !== 'undefined') {
                                b64pad = a;
                            }
                            return this;
                        };
                        /**
                         * @description Defines a base64 pad string
                         * @param {boolean}
                         * @return {Object} this
                         * @public
                         */
                        this.setUTF8 = function(a) {
                            if (typeof a === 'boolean') {
                                utf8 = a;
                            }
                            return this;
                        };

                        /* private methods */

                        /**
                         * Calculate the rmd160 of a raw string
                         */

                        function rstr(s) {
                            s = (utf8) ? utf8Encode(s) : s;
                            return binl2rstr(binl(rstr2binl(s), s.length * 8));
                        }

                        /**
                         * Calculate the HMAC-rmd160 of a key and some data (raw strings)
                         */

                        function rstr_hmac(key, data) {
                            key = (utf8) ? utf8Encode(key) : key;
                            data = (utf8) ? utf8Encode(data) : data;
                            var i, hash,
                                bkey = rstr2binl(key),
                                ipad = Array(16),
                                opad = Array(16);

                            if (bkey.length > 16) {
                                bkey = binl(bkey, key.length * 8);
                            }

                            for (i = 0; i < 16; i += 1) {
                                ipad[i] = bkey[i] ^ 0x36363636;
                                opad[i] = bkey[i] ^ 0x5C5C5C5C;
                            }
                            hash = binl(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
                            return binl2rstr(binl(opad.concat(hash), 512 + 160));
                        }

                        /**
                         * Convert an array of little-endian words to a string
                         */

                        function binl2rstr(input) {
                            var i, output = '',
                                l = input.length * 32;
                            for (i = 0; i < l; i += 8) {
                                output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
                            }
                            return output;
                        }

                        /**
                         * Calculate the RIPE-MD160 of an array of little-endian words, and a bit length.
                         */

                        function binl(x, len) {
                            var T, j, i, l,
                                h0 = 0x67452301,
                                h1 = 0xefcdab89,
                                h2 = 0x98badcfe,
                                h3 = 0x10325476,
                                h4 = 0xc3d2e1f0,
                                A1, B1, C1, D1, E1,
                                A2, B2, C2, D2, E2;

                            /* append padding */
                            x[len >> 5] |= 0x80 << (len % 32);
                            x[(((len + 64) >>> 9) << 4) + 14] = len;
                            l = x.length;

                            for (i = 0; i < l; i += 16) {
                                A1 = A2 = h0;
                                B1 = B2 = h1;
                                C1 = C2 = h2;
                                D1 = D2 = h3;
                                E1 = E2 = h4;
                                for (j = 0; j <= 79; j += 1) {
                                    T = safe_add(A1, rmd160_f(j, B1, C1, D1));
                                    T = safe_add(T, x[i + rmd160_r1[j]]);
                                    T = safe_add(T, rmd160_K1(j));
                                    T = safe_add(bit_rol(T, rmd160_s1[j]), E1);
                                    A1 = E1;
                                    E1 = D1;
                                    D1 = bit_rol(C1, 10);
                                    C1 = B1;
                                    B1 = T;
                                    T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2));
                                    T = safe_add(T, x[i + rmd160_r2[j]]);
                                    T = safe_add(T, rmd160_K2(j));
                                    T = safe_add(bit_rol(T, rmd160_s2[j]), E2);
                                    A2 = E2;
                                    E2 = D2;
                                    D2 = bit_rol(C2, 10);
                                    C2 = B2;
                                    B2 = T;
                                }

                                T = safe_add(h1, safe_add(C1, D2));
                                h1 = safe_add(h2, safe_add(D1, E2));
                                h2 = safe_add(h3, safe_add(E1, A2));
                                h3 = safe_add(h4, safe_add(A1, B2));
                                h4 = safe_add(h0, safe_add(B1, C2));
                                h0 = T;
                            }
                            return [h0, h1, h2, h3, h4];
                        }

                        // specific algorithm methods

                        function rmd160_f(j, x, y, z) {
                            return (0 <= j && j <= 15) ? (x ^ y ^ z) :
                                (16 <= j && j <= 31) ? (x & y) | (~x & z) :
                                (32 <= j && j <= 47) ? (x | ~y) ^ z :
                                (48 <= j && j <= 63) ? (x & z) | (y & ~z) :
                                (64 <= j && j <= 79) ? x ^ (y | ~z) :
                                'rmd160_f: j out of range';
                        }

                        function rmd160_K1(j) {
                            return (0 <= j && j <= 15) ? 0x00000000 :
                                (16 <= j && j <= 31) ? 0x5a827999 :
                                (32 <= j && j <= 47) ? 0x6ed9eba1 :
                                (48 <= j && j <= 63) ? 0x8f1bbcdc :
                                (64 <= j && j <= 79) ? 0xa953fd4e :
                                'rmd160_K1: j out of range';
                        }

                        function rmd160_K2(j) {
                            return (0 <= j && j <= 15) ? 0x50a28be6 :
                                (16 <= j && j <= 31) ? 0x5c4dd124 :
                                (32 <= j && j <= 47) ? 0x6d703ef3 :
                                (48 <= j && j <= 63) ? 0x7a6d76e9 :
                                (64 <= j && j <= 79) ? 0x00000000 :
                                'rmd160_K2: j out of range';
                        }
                    }
                };

                // exposes Hashes
                (function(window, undefined) {
                    var freeExports = false;
                    if (true) {
                        freeExports = exports;
                        if (exports && typeof global === 'object' && global && global === global.global) {
                            window = global;
                        }
                    }

                    if (true) {
                        // define as an anonymous module, so, through path mapping, it can be aliased
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                                return Hashes;
                            }.call(exports, __webpack_require__, exports, module),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else if (freeExports) {
                        // in Node.js or RingoJS v0.8.0+
                        if (typeof module === 'object' && module && module.exports === freeExports) {
                            module.exports = Hashes;
                        }
                        // in Narwhal or RingoJS v0.7.0-
                        else {
                            freeExports.Hashes = Hashes;
                        }
                    } else {
                        // in a browser or Rhino
                        window.Hashes = Hashes;
                    }
                }(this));
            }()); // IIFE

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(4)))

        /***/
    }),
    /* 148 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*
         * JXON framework - Copyleft 2011 by Mozilla Developer Network
         *
         * Revision #1 - September 5, 2014
         *
         * https://developer.mozilla.org/en-US/docs/JXON
         *
         * This framework is released under the GNU Public License, version 3 or later.
         * http://www.gnu.org/licenses/gpl-3.0-standalone.html
         *
         * small modifications performed by the iD project:
         * https://github.com/openstreetmap/iD/commits/18aa33ba97b52cacf454e95c65d154000e052a1f/js/lib/jxon.js
         *
         * small modifications performed by user @bugreport0
         * https://github.com/tyrasd/JXON/pull/2/commits
         *
         * some additions and modifications by user @igord
         * https://github.com/tyrasd/JXON/pull/5/commits
         *
         * bugfixes and code cleanup by user @laubstein
         * https://github.com/tyrasd/jxon/pull/32
         *
         * adapted for nodejs and npm by @tyrasd (Martin Raifer <tyr.asd@gmail.com>) 
         */

        (function(root, factory) {
            if (true) {
                // AMD. Register as an anonymous module.
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory(window)),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof exports === 'object') {
                if (typeof window === 'object' && window.DOMImplementation && window.XMLSerializer && window.DOMParser) {
                    // Browserify. hardcode usage of browser's own XMLDom implementation
                    // see https://github.com/tyrasd/jxon/issues/18

                    module.exports = factory(window);
                } else {
                    // Node. Does not work with strict CommonJS, but
                    // only CommonJS-like environments that support module.exports,
                    // like Node.

                    module.exports = factory(require('xmldom'), true);
                }
            } else {
                // Browser globals (root is window)

                root.JXON = factory(window);
            }
        }(this, function(xmlDom, isNodeJs) {
                var opts = {
                    valueKey: '_',
                    attrKey: '$',
                    attrPrefix: '$',
                    lowerCaseTags: false,
                    trueIsEmpty: false,
                    autoDate: false,
                    ignorePrefixedNodes: false,
                    parseValues: false
                };
                var aCache = [];
                var rIsNull = /^\s*$/;
                var rIsBool = /^(?:true|false)$/i;
                var DOMParser;

                return new(function() {

                    this.config = function(cfg) {
                        for (var k in cfg) {

                            opts[k] = cfg[k];
                        }
                        if (opts.parserErrorHandler) {
                            DOMParser = new xmlDom.DOMParser({
                                errorHandler: opts.parserErrorHandler,
                                locator: {}
                            });
                        }
                    };

                    function parseText(sValue) {
                        if (!opts.parseValues) {
                            return sValue;
                        }

                        if (rIsNull.test(sValue)) {
                            return null;
                        }

                        if (rIsBool.test(sValue)) {
                            return sValue.toLowerCase() === 'true';
                        }

                        if (isFinite(sValue)) {
                            return parseFloat(sValue);
                        }

                        if (opts.autoDate && isFinite(Date.parse(sValue))) {
                            return new Date(sValue);
                        }

                        return sValue;
                    }

                    function EmptyTree() {}
                    EmptyTree.prototype.toString = function() {
                        return 'null';
                    };

                    EmptyTree.prototype.valueOf = function() {
                        return null;
                    };

                    function objectify(vValue) {
                        return vValue === null ? new EmptyTree() : vValue instanceof Object ? vValue : new vValue.constructor(vValue);
                    }

                    function createObjTree(oParentNode, nVerb, bFreeze, bNesteAttr) {
                        var CDATA = 4,
                            TEXT = 3,
                            ELEMENT = 1,
                            nLevelStart = aCache.length,
                            bChildren = oParentNode.hasChildNodes(),
                            bAttributes = oParentNode.nodeType === oParentNode.ELEMENT_NODE && oParentNode.hasAttributes(),
                            bHighVerb = Boolean(nVerb & 2),
                            nLength = 0,
                            sCollectedTxt = '',
                            vResult = bHighVerb ? {} : /* put here the default value for empty nodes: */ (opts.trueIsEmpty ? true : ''),
                            sProp,
                            vContent;

                        if (bChildren) {
                            for (var oNode, nItem = 0; nItem < oParentNode.childNodes.length; nItem++) {

                                oNode = oParentNode.childNodes.item(nItem);
                                if (oNode.nodeType === CDATA) {
                                    sCollectedTxt += oNode.nodeValue;
                                } /* nodeType is "CDATASection" (4) */
                                else if (oNode.nodeType === TEXT) {
                                    sCollectedTxt += oNode.nodeValue.trim();
                                } /* nodeType is "Text" (3) */
                                else if (oNode.nodeType === ELEMENT && !(opts.ignorePrefixedNodes && oNode.prefix)) {
                                    aCache.push(oNode);
                                }
                                /* nodeType is "Element" (1) */
                            }
                        }

                        var nLevelEnd = aCache.length,
                            vBuiltVal = parseText(sCollectedTxt);

                        if (!bHighVerb && (bChildren || bAttributes)) {
                            vResult = nVerb === 0 ? objectify(vBuiltVal) : {};
                        }

                        for (var nElId = nLevelStart; nElId < nLevelEnd; nElId++) {

                            sProp = aCache[nElId].nodeName;
                            if (opts.lowerCaseTags) {
                                sProp = sProp.toLowerCase();
                            }

                            vContent = createObjTree(aCache[nElId], nVerb, bFreeze, bNesteAttr);
                            if (vResult.hasOwnProperty(sProp)) {
                                if (vResult[sProp].constructor !== Array) {
                                    vResult[sProp] = [vResult[sProp]];
                                }

                                vResult[sProp].push(vContent);
                            } else {
                                vResult[sProp] = vContent;

                                nLength++;
                            }
                        }

                        if (bAttributes) {
                            var nAttrLen = oParentNode.attributes.length,
                                sAPrefix = bNesteAttr ? '' : opts.attrPrefix,
                                oAttrParent = bNesteAttr ? {} : vResult;

                            for (var oAttrib, oAttribName, nAttrib = 0; nAttrib < nAttrLen; nLength++, nAttrib++) {

                                oAttrib = oParentNode.attributes.item(nAttrib);

                                oAttribName = oAttrib.name;
                                if (opts.lowerCaseTags) {
                                    oAttribName = oAttribName.toLowerCase();
                                }

                                oAttrParent[sAPrefix + oAttribName] = parseText(oAttrib.value.trim());
                            }

                            if (bNesteAttr) {
                                if (bFreeze) {
                                    Object.freeze(oAttrParent);
                                }

                                vResult[opts.attrKey] = oAttrParent;

                                nLength -= nAttrLen - 1;
                            }

                        }

                        if (nVerb === 3 || (nVerb === 2 || nVerb === 1 && nLength > 0) && sCollectedTxt) {
                            vResult[opts.valueKey] = vBuiltVal;
                        } else if (!bHighVerb && nLength === 0 && sCollectedTxt) {
                            vResult = vBuiltVal;
                        }
                        if (bFreeze && (bHighVerb || nLength > 0)) {
                            Object.freeze(vResult);
                        }

                        aCache.length = nLevelStart;

                        return vResult;
                    }

                    function loadObjTree(oXMLDoc, oParentEl, oParentObj) {
                        var vValue,
                            oChild,
                            elementNS;

                        if (oParentObj.constructor === String || oParentObj.constructor === Number || oParentObj.constructor === Boolean) {
                            oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toString())); /* verbosity level is 0 or 1 */
                            if (oParentObj === oParentObj.valueOf()) {
                                return;
                            }

                        } else if (oParentObj.constructor === Date) {
                            oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toISOString()));
                        }
                        for (var sName in oParentObj) {

                            vValue = oParentObj[sName];
                            if (vValue === undefined) {
                                continue;
                            }
                            if (vValue === null) {
                                vValue = {};
                            }

                            if (isFinite(sName) || vValue instanceof Function) {
                                continue;
                            }

                            /* verbosity level is 0 */
                            if (sName === opts.valueKey) {
                                if (vValue !== null && vValue !== true) {
                                    oParentEl.appendChild(oXMLDoc.createTextNode(vValue.constructor === Date ? vValue.toISOString() : String(vValue)));
                                }

                            } else if (sName === opts.attrKey) { /* verbosity level is 3 */
                                for (var sAttrib in vValue) {
                                    oParentEl.setAttribute(sAttrib, vValue[sAttrib]);
                                }
                            } else if (sName === opts.attrPrefix + 'xmlns') {
                                if (isNodeJs) {
                                    oParentEl.setAttribute(sName.slice(1), vValue);
                                }
                                // do nothing: special handling of xml namespaces is done via createElementNS()
                            } else if (sName.charAt(0) === opts.attrPrefix) {
                                oParentEl.setAttribute(sName.slice(1), vValue);
                            } else if (vValue.constructor === Array) {
                                for (var nItem in vValue) {
                                    if (!vValue.hasOwnProperty(nItem)) continue;
                                    elementNS = (vValue[nItem] && vValue[nItem][opts.attrPrefix + 'xmlns']) || oParentEl.namespaceURI;
                                    if (elementNS) {
                                        oChild = oXMLDoc.createElementNS(elementNS, sName);
                                    } else {
                                        oChild = oXMLDoc.createElement(sName);
                                    }

                                    loadObjTree(oXMLDoc, oChild, vValue[nItem] || {});
                                    oParentEl.appendChild(oChild);
                                }
                            } else {
                                elementNS = (vValue || {})[opts.attrPrefix + 'xmlns'] || oParentEl.namespaceURI;
                                if (elementNS) {
                                    oChild = oXMLDoc.createElementNS(elementNS, sName);
                                } else {
                                    oChild = oXMLDoc.createElement(sName);
                                }
                                if (vValue instanceof Object) {
                                    loadObjTree(oXMLDoc, oChild, vValue);
                                } else if (vValue !== null && (vValue !== true || !opts.trueIsEmpty)) {
                                    oChild.appendChild(oXMLDoc.createTextNode(vValue.toString()));
                                }
                                oParentEl.appendChild(oChild);
                            }
                        }
                    }
                    this.xmlToJs = this.build = function(oXMLParent, nVerbosity /* optional */ , bFreeze /* optional */ , bNesteAttributes /* optional */ ) {
                        var _nVerb = arguments.length > 1 && typeof nVerbosity === 'number' ? nVerbosity & 3 : /* put here the default verbosity level: */ 1;
                        return createObjTree(oXMLParent, _nVerb, bFreeze || false, arguments.length > 3 ? bNesteAttributes : _nVerb === 3);
                    };

                    this.jsToXml = this.unbuild = function(oObjTree, sNamespaceURI /* optional */ , sQualifiedName /* optional */ , oDocumentType /* optional */ ) {
                        var documentImplementation = xmlDom.document && xmlDom.document.implementation || new xmlDom.DOMImplementation();
                        var oNewDoc = documentImplementation.createDocument(sNamespaceURI || null, sQualifiedName || '', oDocumentType || null);
                        loadObjTree(oNewDoc, oNewDoc.documentElement || oNewDoc, oObjTree);
                        return oNewDoc;
                    };

                    this.stringToXml = function(xmlStr) {
                        if (!DOMParser) {
                            DOMParser = new xmlDom.DOMParser();
                        }

                        return DOMParser.parseFromString(xmlStr, 'application/xml');
                    };

                    this.xmlToString = function(xmlObj) {
                        if (typeof xmlObj.xml !== 'undefined') {
                            return xmlObj.xml;
                        } else {
                            return (new xmlDom.XMLSerializer()).serializeToString(xmlObj);
                        }
                    };

                    this.stringToJs = function(str) {
                        var xmlObj = this.stringToXml(str);
                        return this.xmlToJs(xmlObj);
                    };

                    this.jsToString = this.stringify = function(oObjTree, sNamespaceURI /* optional */ , sQualifiedName /* optional */ , oDocumentType /* optional */ ) {
                        return this.xmlToString(
                            this.jsToXml(oObjTree, sNamespaceURI, sQualifiedName, oDocumentType)
                        );
                    };

                    this.each = function(arr, func, thisArg) {
                        if (arr instanceof Array) {
                            arr.forEach(func, thisArg);
                        } else {
                            [arr].forEach(func, thisArg);
                        }
                    };
                })();

            }

        ));


        /***/
    }),
    /* 149 */
    /***/
    (function(module, exports, __webpack_require__) {

        var map = {
            "./af": 39,
            "./af.js": 39,
            "./ar": 42,
            "./ar-ma": 40,
            "./ar-ma.js": 40,
            "./ar-sa": 41,
            "./ar-sa.js": 41,
            "./ar.js": 42,
            "./az": 43,
            "./az.js": 43,
            "./be": 44,
            "./be.js": 44,
            "./bg": 45,
            "./bg.js": 45,
            "./bn": 46,
            "./bn.js": 46,
            "./bo": 47,
            "./bo.js": 47,
            "./br": 48,
            "./br.js": 48,
            "./bs": 49,
            "./bs.js": 49,
            "./ca": 50,
            "./ca.js": 50,
            "./cs": 51,
            "./cs.js": 51,
            "./cv": 52,
            "./cv.js": 52,
            "./cy": 53,
            "./cy.js": 53,
            "./da": 54,
            "./da.js": 54,
            "./de": 56,
            "./de-at": 55,
            "./de-at.js": 55,
            "./de.js": 56,
            "./el": 57,
            "./el.js": 57,
            "./en-au": 58,
            "./en-au.js": 58,
            "./en-ca": 59,
            "./en-ca.js": 59,
            "./en-gb": 60,
            "./en-gb.js": 60,
            "./eo": 61,
            "./eo.js": 61,
            "./es": 62,
            "./es.js": 62,
            "./et": 63,
            "./et.js": 63,
            "./eu": 64,
            "./eu.js": 64,
            "./fa": 65,
            "./fa.js": 65,
            "./fi": 66,
            "./fi.js": 66,
            "./fo": 67,
            "./fo.js": 67,
            "./fr": 69,
            "./fr-ca": 68,
            "./fr-ca.js": 68,
            "./fr.js": 69,
            "./gl": 70,
            "./gl.js": 70,
            "./he": 71,
            "./he.js": 71,
            "./hi": 72,
            "./hi.js": 72,
            "./hr": 73,
            "./hr.js": 73,
            "./hu": 74,
            "./hu.js": 74,
            "./hy-am": 75,
            "./hy-am.js": 75,
            "./id": 76,
            "./id.js": 76,
            "./is": 77,
            "./is.js": 77,
            "./it": 78,
            "./it.js": 78,
            "./ja": 79,
            "./ja.js": 79,
            "./ka": 80,
            "./ka.js": 80,
            "./km": 81,
            "./km.js": 81,
            "./ko": 82,
            "./ko.js": 82,
            "./lb": 83,
            "./lb.js": 83,
            "./lt": 84,
            "./lt.js": 84,
            "./lv": 85,
            "./lv.js": 85,
            "./mk": 86,
            "./mk.js": 86,
            "./ml": 87,
            "./ml.js": 87,
            "./mr": 88,
            "./mr.js": 88,
            "./ms-my": 89,
            "./ms-my.js": 89,
            "./my": 90,
            "./my.js": 90,
            "./nb": 91,
            "./nb.js": 91,
            "./ne": 92,
            "./ne.js": 92,
            "./nl": 93,
            "./nl.js": 93,
            "./nn": 94,
            "./nn.js": 94,
            "./pl": 95,
            "./pl.js": 95,
            "./pt": 97,
            "./pt-br": 96,
            "./pt-br.js": 96,
            "./pt.js": 97,
            "./ro": 98,
            "./ro.js": 98,
            "./ru": 99,
            "./ru.js": 99,
            "./sk": 100,
            "./sk.js": 100,
            "./sl": 101,
            "./sl.js": 101,
            "./sq": 102,
            "./sq.js": 102,
            "./sr": 104,
            "./sr-cyrl": 103,
            "./sr-cyrl.js": 103,
            "./sr.js": 104,
            "./sv": 105,
            "./sv.js": 105,
            "./ta": 106,
            "./ta.js": 106,
            "./th": 107,
            "./th.js": 107,
            "./tl-ph": 108,
            "./tl-ph.js": 108,
            "./tr": 109,
            "./tr.js": 109,
            "./tzm": 111,
            "./tzm-latn": 110,
            "./tzm-latn.js": 110,
            "./tzm.js": 111,
            "./uk": 112,
            "./uk.js": 112,
            "./uz": 113,
            "./uz.js": 113,
            "./vi": 114,
            "./vi.js": 114,
            "./zh-cn": 115,
            "./zh-cn.js": 115,
            "./zh-tw": 116,
            "./zh-tw.js": 116
        };

        function webpackContext(req) {
            return __webpack_require__(webpackContextResolve(req));
        };

        function webpackContextResolve(req) {
            var id = map[req];
            if (!(id + 1)) // check for number or string
                throw new Error("Cannot find module '" + req + "'.");
            return id;
        };
        webpackContext.keys = function webpackContextKeys() {
            return Object.keys(map);
        };
        webpackContext.resolve = webpackContextResolve;
        module.exports = webpackContext;
        webpackContext.id = 149;

        /***/
    }),
    /* 150 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var hashes = __webpack_require__(147),
            xtend = __webpack_require__(117),
            sha1 = new hashes.SHA1();

        var ohauth = {};

        ohauth.qsString = function(obj) {
            return Object.keys(obj).sort().map(function(key) {
                return ohauth.percentEncode(key) + '=' +
                    ohauth.percentEncode(obj[key]);
            }).join('&');
        };

        ohauth.stringQs = function(str) {
            return str.split('&').filter(function(pair) {
                return pair !== '';
            }).reduce(function(obj, pair) {
                var parts = pair.split('=');
                obj[decodeURIComponent(parts[0])] = (null === parts[1]) ?
                    '' : decodeURIComponent(parts[1]);
                return obj;
            }, {});
        };

        ohauth.rawxhr = function(method, url, data, headers, callback) {
            var xhr = new XMLHttpRequest(),
                twoHundred = /^20\d$/;
            xhr.onreadystatechange = function() {
                if (4 === xhr.readyState && 0 !== xhr.status) {
                    if (twoHundred.test(xhr.status)) callback(null, xhr);
                    else return callback(xhr, null);
                }
            };
            xhr.onerror = function(e) {
                return callback(e, null);
            };
            xhr.open(method, url, true);
            for (var h in headers) xhr.setRequestHeader(h, headers[h]);
            xhr.send(data);
            return xhr;
        };

        ohauth.xhr = function(method, url, auth, data, options, callback) {
            var headers = (options && options.header) || {
                'Content-Type': 'application/x-www-form-urlencoded'
            };
            headers.Authorization = 'OAuth ' + ohauth.authHeader(auth);
            return ohauth.rawxhr(method, url, data, headers, callback);
        };

        ohauth.nonce = function() {
            for (var o = ''; o.length < 6;) {
                o += '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz' [Math.floor(Math.random() * 61)];
            }
            return o;
        };

        ohauth.authHeader = function(obj) {
            return Object.keys(obj).sort().map(function(key) {
                return encodeURIComponent(key) + '="' + encodeURIComponent(obj[key]) + '"';
            }).join(', ');
        };

        ohauth.timestamp = function() {
            return ~~((+new Date()) / 1000);
        };

        ohauth.percentEncode = function(s) {
            return encodeURIComponent(s)
                .replace(/\!/g, '%21').replace(/\'/g, '%27')
                .replace(/\*/g, '%2A').replace(/\(/g, '%28').replace(/\)/g, '%29');
        };

        ohauth.baseString = function(method, url, params) {
            if (params.oauth_signature) delete params.oauth_signature;
            return [
                method,
                ohauth.percentEncode(url),
                ohauth.percentEncode(ohauth.qsString(params))
            ].join('&');
        };

        ohauth.signature = function(oauth_secret, token_secret, baseString) {
            return sha1.b64_hmac(
                ohauth.percentEncode(oauth_secret) + '&' +
                ohauth.percentEncode(token_secret),
                baseString);
        };

        /**
         * Takes an options object for configuration (consumer_key,
         * consumer_secret, version, signature_method, token, token_secret)
         * and returns a function that generates the Authorization header
         * for given data.
         *
         * The returned function takes these parameters:
         * - method: GET/POST/...
         * - uri: full URI with protocol, port, path and query string
         * - extra_params: any extra parameters (that are passed in the POST data),
         *   can be an object or a from-urlencoded string.
         *
         * Returned function returns full OAuth header with "OAuth" string in it.
         */

        ohauth.headerGenerator = function(options) {
            options = options || {};
            var consumer_key = options.consumer_key || '',
                consumer_secret = options.consumer_secret || '',
                signature_method = options.signature_method || 'HMAC-SHA1',
                version = options.version || '1.0',
                token = options.token || '',
                token_secret = options.token_secret || '';

            return function(method, uri, extra_params) {
                method = method.toUpperCase();
                if (typeof extra_params === 'string' && extra_params.length > 0) {
                    extra_params = ohauth.stringQs(extra_params);
                }

                var uri_parts = uri.split('?', 2),
                    base_uri = uri_parts[0];

                var query_params = uri_parts.length === 2 ?
                    ohauth.stringQs(uri_parts[1]) : {};

                var oauth_params = {
                    oauth_consumer_key: consumer_key,
                    oauth_signature_method: signature_method,
                    oauth_version: version,
                    oauth_timestamp: ohauth.timestamp(),
                    oauth_nonce: ohauth.nonce()
                };

                if (token) oauth_params.oauth_token = token;

                var all_params = xtend({}, oauth_params, query_params, extra_params),
                    base_str = ohauth.baseString(method, base_uri, all_params);

                oauth_params.oauth_signature = ohauth.signature(consumer_secret, token_secret, base_str);

                return 'OAuth ' + ohauth.authHeader(oauth_params);
            };
        };

        module.exports = ohauth;


        /***/
    }),
    /* 151 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var ohauth = __webpack_require__(150);
        var resolveUrl = __webpack_require__(154);
        var store = __webpack_require__(158);
        var xtend = __webpack_require__(117);


        // # osm-auth
        //
        // This code is only compatible with IE10+ because the [XDomainRequest](http://bit.ly/LfO7xo)
        // object, IE<10's idea of [CORS](http://en.wikipedia.org/wiki/Cross-origin_resource_sharing),
        // does not support custom headers, which this uses everywhere.
        module.exports = function(o) {

            var oauth = {};

            // authenticated users will also have a request token secret, but it's
            // not used in transactions with the server
            oauth.authenticated = function() {
                return !!(token('oauth_token') && token('oauth_token_secret'));
            };

            oauth.logout = function() {
                token('oauth_token', '');
                token('oauth_token_secret', '');
                token('oauth_request_token_secret', '');
                return oauth;
            };

            // TODO: detect lack of click event
            oauth.authenticate = function(callback) {
                if (oauth.authenticated()) return callback();

                oauth.logout();

                // ## Getting a request token
                var params = timenonce(getAuth(o)),
                    url = o.url + '/oauth/request_token';

                params.oauth_signature = ohauth.signature(
                    o.oauth_secret, '',
                    ohauth.baseString('POST', url, params));

                if (!o.singlepage) {
                    // Create a 600x550 popup window in the center of the screen
                    var w = 600,
                        h = 550,
                        settings = [
                            ['width', w],
                            ['height', h],
                            ['left', screen.width / 2 - w / 2],
                            ['top', screen.height / 2 - h / 2]
                        ].map(function(x) {
                            return x.join('=');
                        }).join(','),
                        popup = window.open('about:blank', 'oauth_window', settings);
                }

                // Request a request token. When this is complete, the popup
                // window is redirected to OSM's authorization page.
                ohauth.xhr('POST', url, params, null, {}, reqTokenDone);
                o.loading();

                function reqTokenDone(err, xhr) {
                    o.done();
                    if (err) return callback(err);
                    var resp = ohauth.stringQs(xhr.response);
                    token('oauth_request_token_secret', resp.oauth_token_secret);
                    var authorize_url = o.url + '/oauth/authorize?' + ohauth.qsString({
                        oauth_token: resp.oauth_token,
                        oauth_callback: resolveUrl(o.landing)
                    });

                    if (o.singlepage) {
                        location.href = authorize_url;
                    } else {
                        popup.location = authorize_url;
                    }
                }

                // Called by a function in a landing page, in the popup window. The
                // window closes itself.
                window.authComplete = function(token) {
                    var oauth_token = ohauth.stringQs(token.split('?')[1]);
                    get_access_token(oauth_token.oauth_token);
                    delete window.authComplete;
                };

                // ## Getting an request token
                //
                // At this point we have an `oauth_token`, brought in from a function
                // call on a landing page popup.
                function get_access_token(oauth_token) {
                    var url = o.url + '/oauth/access_token',
                        params = timenonce(getAuth(o)),
                        request_token_secret = token('oauth_request_token_secret');
                    params.oauth_token = oauth_token;
                    params.oauth_signature = ohauth.signature(
                        o.oauth_secret,
                        request_token_secret,
                        ohauth.baseString('POST', url, params));

                    // ## Getting an access token
                    //
                    // The final token required for authentication. At this point
                    // we have a `request token secret`
                    ohauth.xhr('POST', url, params, null, {}, accessTokenDone);
                    o.loading();
                }

                function accessTokenDone(err, xhr) {
                    o.done();
                    if (err) return callback(err);
                    var access_token = ohauth.stringQs(xhr.response);
                    token('oauth_token', access_token.oauth_token);
                    token('oauth_token_secret', access_token.oauth_token_secret);
                    callback(null, oauth);
                }
            };

            oauth.bootstrapToken = function(oauth_token, callback) {
                // ## Getting an request token
                // At this point we have an `oauth_token`, brought in from a function
                // call on a landing page popup.
                function get_access_token(oauth_token) {
                    var url = o.url + '/oauth/access_token',
                        params = timenonce(getAuth(o)),
                        request_token_secret = token('oauth_request_token_secret');
                    params.oauth_token = oauth_token;
                    params.oauth_signature = ohauth.signature(
                        o.oauth_secret,
                        request_token_secret,
                        ohauth.baseString('POST', url, params));

                    // ## Getting an access token
                    // The final token required for authentication. At this point
                    // we have a `request token secret`
                    ohauth.xhr('POST', url, params, null, {}, accessTokenDone);
                    o.loading();
                }

                function accessTokenDone(err, xhr) {
                    o.done();
                    if (err) return callback(err);
                    var access_token = ohauth.stringQs(xhr.response);
                    token('oauth_token', access_token.oauth_token);
                    token('oauth_token_secret', access_token.oauth_token_secret);
                    callback(null, oauth);
                }

                get_access_token(oauth_token);
            };

            // # xhr
            //
            // A single XMLHttpRequest wrapper that does authenticated calls if the
            // user has logged in.
            oauth.xhr = function(options, callback) {
                if (!oauth.authenticated()) {
                    if (o.auto) {
                        return oauth.authenticate(run);
                    } else {
                        callback('not authenticated', null);
                        return;
                    }
                } else {
                    return run();
                }

                function run() {
                    var params = timenonce(getAuth(o)),
                        oauth_token_secret = token('oauth_token_secret'),
                        url = (options.prefix !== false) ? o.url + options.path : options.path,
                        url_parts = url.replace(/#.*$/, '').split('?', 2),
                        base_url = url_parts[0],
                        query = (url_parts.length === 2) ? url_parts[1] : '';

                    // https://tools.ietf.org/html/rfc5849#section-3.4.1.3.1
                    if ((!options.options || !options.options.header ||
                            options.options.header['Content-Type'] === 'application/x-www-form-urlencoded') &&
                        options.content) {
                        params = xtend(params, ohauth.stringQs(options.content));
                    }

                    params.oauth_token = token('oauth_token');
                    params.oauth_signature = ohauth.signature(
                        o.oauth_secret,
                        oauth_token_secret,
                        ohauth.baseString(options.method, base_url, xtend(params, ohauth.stringQs(query)))
                    );

                    return ohauth.xhr(options.method, url, params, options.content, options.options, done);
                }

                function done(err, xhr) {
                    if (err) return callback(err);
                    else if (xhr.responseXML) return callback(err, xhr.responseXML);
                    else return callback(err, xhr.response);
                }
            };

            // pre-authorize this object, if we can just get a token and token_secret
            // from the start
            oauth.preauth = function(c) {
                if (!c) return;
                if (c.oauth_token) token('oauth_token', c.oauth_token);
                if (c.oauth_token_secret) token('oauth_token_secret', c.oauth_token_secret);
                return oauth;
            };

            oauth.options = function(_) {
                if (!arguments.length) return o;

                o = _;
                o.url = o.url || 'https://www.openstreetmap.org';
                o.landing = o.landing || 'land.html';
                o.singlepage = o.singlepage || false;

                // Optional loading and loading-done functions for nice UI feedback.
                // by default, no-ops
                o.loading = o.loading || function() {};
                o.done = o.done || function() {};

                return oauth.preauth(o);
            };

            // 'stamp' an authentication object from `getAuth()`
            // with a [nonce](http://en.wikipedia.org/wiki/Cryptographic_nonce)
            // and timestamp
            function timenonce(o) {
                o.oauth_timestamp = ohauth.timestamp();
                o.oauth_nonce = ohauth.nonce();
                return o;
            }

            // get/set tokens. These are prefixed with the base URL so that `osm-auth`
            // can be used with multiple APIs and the keys in `localStorage`
            // will not clash
            var token;

            if (store.enabled) {
                token = function(x, y) {
                    if (arguments.length === 1) return store.get(o.url + x);
                    else if (arguments.length === 2) return store.set(o.url + x, y);
                };
            } else {
                var storage = {};
                token = function(x, y) {
                    if (arguments.length === 1) return storage[o.url + x];
                    else if (arguments.length === 2) return storage[o.url + x] = y;
                };
            }

            // Get an authentication object. If you just add and remove properties
            // from a single object, you'll need to use `delete` to make sure that
            // it doesn't contain undesired properties for authentication
            function getAuth(o) {
                return {
                    oauth_consumer_key: o.oauth_consumer_key,
                    oauth_signature_method: 'HMAC-SHA1'
                };
            }

            // potentially pre-authorize
            oauth.options(o);

            return oauth;
        };


        /***/
    }),
    /* 152 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";
        /*
         * Generated by PEG.js 0.10.0.
         *
         * http://pegjs.org/
         */



        function peg$subclass(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
        }

        function peg$SyntaxError(message, expected, found, location) {
            this.message = message;
            this.expected = expected;
            this.found = found;
            this.location = location;
            this.name = "SyntaxError";

            if (typeof Error.captureStackTrace === "function") {
                Error.captureStackTrace(this, peg$SyntaxError);
            }
        }

        peg$subclass(peg$SyntaxError, Error);

        peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
                literal: function(expectation) {
                    return "\"" + literalEscape(expectation.text) + "\"";
                },

                "class": function(expectation) {
                    var escapedParts = "",
                        i;

                    for (i = 0; i < expectation.parts.length; i++) {
                        escapedParts += expectation.parts[i] instanceof Array ?
                            classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) :
                            classEscape(expectation.parts[i]);
                    }

                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                },

                any: function(expectation) {
                    return "any character";
                },

                end: function(expectation) {
                    return "end of input";
                },

                other: function(expectation) {
                    return expectation.description;
                }
            };

            function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
            }

            function literalEscape(s) {
                return s
                    .replace(/\\/g, '\\\\')
                    .replace(/"/g, '\\"')
                    .replace(/\0/g, '\\0')
                    .replace(/\t/g, '\\t')
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r')
                    .replace(/[\x00-\x0F]/g, function(ch) {
                        return '\\x0' + hex(ch);
                    })
                    .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                        return '\\x' + hex(ch);
                    });
            }

            function classEscape(s) {
                return s
                    .replace(/\\/g, '\\\\')
                    .replace(/\]/g, '\\]')
                    .replace(/\^/g, '\\^')
                    .replace(/-/g, '\\-')
                    .replace(/\0/g, '\\0')
                    .replace(/\t/g, '\\t')
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r')
                    .replace(/[\x00-\x0F]/g, function(ch) {
                        return '\\x0' + hex(ch);
                    })
                    .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                        return '\\x' + hex(ch);
                    });
            }

            function describeExpectation(expectation) {
                return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }

            function describeExpected(expected) {
                var descriptions = new Array(expected.length),
                    i, j;

                for (i = 0; i < expected.length; i++) {
                    descriptions[i] = describeExpectation(expected[i]);
                }

                descriptions.sort();

                if (descriptions.length > 0) {
                    for (i = 1, j = 1; i < descriptions.length; i++) {
                        if (descriptions[i - 1] !== descriptions[i]) {
                            descriptions[j] = descriptions[i];
                            j++;
                        }
                    }
                    descriptions.length = j;
                }

                switch (descriptions.length) {
                    case 1:
                        return descriptions[0];

                    case 2:
                        return descriptions[0] + " or " + descriptions[1];

                    default:
                        return descriptions.slice(0, -1).join(", ") +
                            ", or " +
                            descriptions[descriptions.length - 1];
                }
            }

            function describeFound(found) {
                return found ? "\"" + literalEscape(found) + "\"" : "end of input";
            }

            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };

        function peg$parse(input, options) {
            options = options !== void 0 ? options : {};

            var peg$FAILED = {},

                peg$startRuleIndices = {
                    start: 0
                },
                peg$startRuleIndex = 0,

                peg$consts = [
                    function(x) {
                        return x
                    },
                    "in bbox",
                    peg$literalExpectation("in bbox", false),
                    "IN BBOX",
                    peg$literalExpectation("IN BBOX", false),
                    function(x) {
                        return {
                            bounds: "bbox",
                            query: x
                        }
                    },
                    "in",
                    peg$literalExpectation("in", false),
                    "IN",
                    peg$literalExpectation("IN", false),
                    function(x, y) {
                        return {
                            bounds: "area",
                            query: x,
                            area: y
                        }
                    },
                    "around",
                    peg$literalExpectation("around", false),
                    "AROUND",
                    peg$literalExpectation("AROUND", false),
                    function(x, y) {
                        return {
                            bounds: "around",
                            query: x,
                            area: y
                        }
                    },
                    "global",
                    peg$literalExpectation("global", false),
                    "GLOBAL",
                    peg$literalExpectation("GLOBAL", false),
                    function(x) {
                        return {
                            bounds: "global",
                            query: x
                        }
                    },
                    "or",
                    peg$literalExpectation("or", false),
                    "OR",
                    peg$literalExpectation("OR", false),
                    "||",
                    peg$literalExpectation("||", false),
                    "|",
                    peg$literalExpectation("|", false),
                    function(x, y) {
                        return {
                            logical: "or",
                            queries: [x, y]
                        }
                    },
                    "and",
                    peg$literalExpectation("and", false),
                    "AND",
                    peg$literalExpectation("AND", false),
                    "&&",
                    peg$literalExpectation("&&", false),
                    "&",
                    peg$literalExpectation("&", false),
                    function(x, y) {
                        return {
                            logical: "and",
                            queries: [x, y]
                        }
                    },
                    "(",
                    peg$literalExpectation("(", false),
                    ")",
                    peg$literalExpectation(")", false),
                    function(x) {
                        return x;
                    },
                    "=",
                    peg$literalExpectation("=", false),
                    "==",
                    peg$literalExpectation("==", false),
                    function(x, y) {
                        return {
                            query: "eq",
                            key: x,
                            val: y
                        }
                    },
                    "!=",
                    peg$literalExpectation("!=", false),
                    "<>",
                    peg$literalExpectation("<>", false),
                    function(x, y) {
                        return {
                            query: "neq",
                            key: x,
                            val: y
                        }
                    },
                    "*",
                    peg$literalExpectation("*", false),
                    function(x) {
                        return {
                            query: "key",
                            key: x
                        }
                    },
                    "is",
                    peg$literalExpectation("is", false),
                    "not",
                    peg$literalExpectation("not", false),
                    "null",
                    peg$literalExpectation("null", false),
                    "IS",
                    peg$literalExpectation("IS", false),
                    "NOT",
                    peg$literalExpectation("NOT", false),
                    "NULL",
                    peg$literalExpectation("NULL", false),
                    function(x) {
                        return {
                            query: "nokey",
                            key: x
                        }
                    },
                    "~=",
                    peg$literalExpectation("~=", false),
                    "~",
                    peg$literalExpectation("~", false),
                    "=~",
                    peg$literalExpectation("=~", false),
                    function(x, y) {
                        return {
                            query: "like",
                            key: x,
                            val: y.regex ? y : {
                                regex: y
                            }
                        }
                    },
                    "like",
                    peg$literalExpectation("like", false),
                    "LIKE",
                    peg$literalExpectation("LIKE", false),
                    function(x, y) {
                        return {
                            query: "likelike",
                            key: x,
                            val: y.regex ? y : {
                                regex: y
                            }
                        }
                    },
                    "!~",
                    peg$literalExpectation("!~", false),
                    function(x, y) {
                        return {
                            query: "notlike",
                            key: x,
                            val: y.regex ? y : {
                                regex: y
                            }
                        }
                    },
                    ":",
                    peg$literalExpectation(":", false),
                    function(x, y) {
                        return {
                            query: "substr",
                            key: x,
                            val: y
                        }
                    },
                    "type",
                    peg$literalExpectation("type", false),
                    function(x) {
                        return {
                            query: "type",
                            type: x
                        }
                    },
                    "user",
                    peg$literalExpectation("user", false),
                    "uid",
                    peg$literalExpectation("uid", false),
                    "newer",
                    peg$literalExpectation("newer", false),
                    "id",
                    peg$literalExpectation("id", false),
                    function(x, y) {
                        return {
                            query: "meta",
                            meta: x,
                            val: y
                        }
                    },
                    function(x) {
                        return {
                            query: "free form",
                            free: x
                        }
                    },
                    peg$otherExpectation("Key"),
                    /^[a-zA-Z0-9_:\-]/,
                    peg$classExpectation([
                        ["a", "z"],
                        ["A", "Z"],
                        ["0", "9"], "_", ":", "-"
                    ], false, false),
                    function(s) {
                        return s.join('');
                    },
                    "\"",
                    peg$literalExpectation("\"", false),
                    "'",
                    peg$literalExpectation("'", false),
                    function(parts) {
                        return parts[1];
                    },
                    peg$otherExpectation("string"),
                    /^[^'" ()~=!*\/:<>&|[\]{}#+@$%?\^.,]/,
                    peg$classExpectation(["'", "\"", " ", "(", ")", "~", "=", "!", "*", "/", ":", "<", ">", "&", "|", "[", "]", "{", "}", "#", "+", "@", "$", "%", "?", "^", ".", ","], true, false),
                    function(chars) {
                        return chars.join("");
                    },
                    "\\",
                    peg$literalExpectation("\\", false),
                    peg$anyExpectation(),
                    function(char_) {
                        return char_;
                    },
                    function(sequence) {
                        return sequence;
                    },
                    /^['"\\bfnrtv]/,
                    peg$classExpectation(["'", "\"", "\\", "b", "f", "n", "r", "t", "v"], false, false),
                    function(char_) {
                        return char_
                            .replace("b", "\b")
                            .replace("f", "\f")
                            .replace("n", "\n")
                            .replace("r", "\r")
                            .replace("t", "\t")
                            .replace("v", "\x0B") // IE does not recognize "\v".
                    },
                    "/",
                    peg$literalExpectation("/", false),
                    "i",
                    peg$literalExpectation("i", false),
                    "",
                    function(parts) {
                        return {
                            regex: parts[1],
                            modifier: parts[3]
                        };
                    },
                    "\\/",
                    peg$literalExpectation("\\/", false),
                    function() {
                        return "/";
                    },
                    peg$otherExpectation("whitespace"),
                    /^[ \t\n\r]/,
                    peg$classExpectation([" ", "\t", "\n", "\r"], false, false)
                ],

                peg$bytecode = [
                    peg$decode("%;;/:#;!/1$;;/($8#: #!!)(#'#(\"'#&'#"),
                    peg$decode("%;\"/Y#$;</&#0#*;<&&&#/C$2!\"\"6!7\".) &2#\"\"6#7$/($8#:%#!\")(#'#(\"'#&'#.\u0141 &%;\"/y#$;</&#0#*;<&&&#/c$2&\"\"6&7'.) &2(\"\"6(7)/H$$;</&#0#*;<&&&#/2$;2/)$8%:*%\"$ )(%'#($'#(#'#(\"'#&'#.\xDB &%;\"/y#$;</&#0#*;<&&&#/c$2+\"\"6+7,.) &2-\"\"6-7./H$$;</&#0#*;<&&&#/2$;2/)$8%:/%\"$ )(%'#($'#(#'#(\"'#&'#.u &%;\"/Y#$;</&#0#*;<&&&#/C$20\"\"6071.) &22\"\"6273/($8#:4#!\")(#'#(\"'#&'#./ &%;\"/' 8!:%!! )"),
                    peg$decode("%;#/\x91#$;</&#0#*;<&&&#/{$25\"\"6576.A &27\"\"6778.5 &29\"\"697:.) &2;\"\"6;7</H$$;</&#0#*;<&&&#/2$;\"/)$8%:=%\"$ )(%'#($'#(#'#(\"'#&'#.# &;#"),
                    peg$decode("%;$/\x91#$;</&#0#*;<&&&#/{$2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E/H$$;</&#0#*;<&&&#/2$;#/)$8%:F%\"$ )(%'#($'#(#'#(\"'#&'#.# &;$"),
                    peg$decode(";%.b &%2G\"\"6G7H/R#;;/I$;\"/@$;;/7$2I\"\"6I7J/($8%:K%!\")(%'#($'#(#'#(\"'#&'#"),
                    peg$decode(";..Y &;/.S &;&.M &;'.G &;(.A &;).; &;*.5 &;+./ &;,.) &;-.# &;0"),
                    peg$decode("%;1/_#;;/V$2L\"\"6L7M.) &2N\"\"6N7O/;$;;/2$;2/)$8%:P%\"$ )(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%;1/_#;;/V$2Q\"\"6Q7R.) &2S\"\"6S7T/;$;;/2$;2/)$8%:U%\"$ )(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%;1/d#;;/[$2L\"\"6L7M.) &2N\"\"6N7O/@$;;/7$2V\"\"6V7W/($8%:X%!$)(%'#($'#(#'#(\"'#&'#.\u010B &%;2/\u0101#$;</&#0#*;<&&&#/\xEB$%2Y\"\"6Y7Z/m#$;</&#0#*;<&&&#/W$2[\"\"6[7\\/H$$;</&#0#*;<&&&#/2$2]\"\"6]7^/#$+%)(%'#($'#(#'#(\"'#&'#.} &%2_\"\"6_7`/m#$;</&#0#*;<&&&#/W$2a\"\"6a7b/H$$;</&#0#*;<&&&#/2$2c\"\"6c7d/#$+%)(%'#($'#(#'#(\"'#&'#/($8#:X#!\")(#'#(\"'#&'#"),
                    peg$decode("%;1/d#;;/[$2Q\"\"6Q7R.) &2S\"\"6S7T/@$;;/7$2V\"\"6V7W/($8%:e%!$)(%'#($'#(#'#(\"'#&'#.\xC1 &%;2/\xB7#$;</&#0#*;<&&&#/\xA1$%2Y\"\"6Y7Z/H#$;</&#0#*;<&&&#/2$2]\"\"6]7^/#$+#)(#'#(\"'#&'#.X &%2_\"\"6_7`/H#$;</&#0#*;<&&&#/2$2c\"\"6c7d/#$+#)(#'#(\"'#&'#/($8#:e#!\")(#'#(\"'#&'#"),
                    peg$decode("%;1/q#;;/h$2f\"\"6f7g.5 &2h\"\"6h7i.) &2j\"\"6j7k/A$;;/8$;2.# &;8/)$8%:l%\"$ )(%'#($'#(#'#(\"'#&'#.\x89 &%;2/\x7F#$;</&#0#*;<&&&#/i$2m\"\"6m7n.) &2o\"\"6o7p/N$$;</&#0#*;<&&&#/8$;2.# &;8/)$8%:l%\"$ )(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%2h\"\"6h7i/\x83#;;/z$;2/q$;;/h$2f\"\"6f7g.5 &2h\"\"6h7i.) &2j\"\"6j7k/A$;;/8$;2.# &;8/)$8':q'\"$ )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%;1/Y#;;/P$2r\"\"6r7s/A$;;/8$;2.# &;8/)$8%:t%\"$ )(%'#($'#(#'#(\"'#&'#.\xE7 &%;2/\xDD#$;</&#0#*;<&&&#/\xC7$%2[\"\"6[7\\/H#$;</&#0#*;<&&&#/2$2m\"\"6m7n/#$+#)(#'#(\"'#&'#.X &%2a\"\"6a7b/H#$;</&#0#*;<&&&#/2$2o\"\"6o7p/#$+#)(#'#(\"'#&'#/N$$;</&#0#*;<&&&#/8$;2.# &;8/)$8%:t%\"$ )(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%;2/S#;;/J$2u\"\"6u7v/;$;;/2$;2/)$8%:w%\"$ )(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%2x\"\"6x7y/R#;;/I$2u\"\"6u7v/:$;;/1$;2/($8%:z%! )(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%2{\"\"6{7|.A &2}\"\"6}7~.5 &2\x7F\"\"6\x7F7\x80.) &2\x81\"\"6\x817\x82/S#;;/J$2u\"\"6u7v/;$;;/2$;2/)$8%:\x83%\"$ )(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%;2/' 8!:\x84!! )"),
                    peg$decode("<%$4\x86\"\"5!7\x87/,#0)*4\x86\"\"5!7\x87&&&#/' 8!:\x88!! ).\x85 &%%2\x89\"\"6\x897\x8A/;#;3/2$2\x89\"\"6\x897\x8A/#$+#)(#'#(\"'#&'#.K &%2\x8B\"\"6\x8B7\x8C/;#;4/2$2\x8B\"\"6\x8B7\x8C/#$+#)(#'#(\"'#&'#/' 8!:\x8D!! )=.\" 7\x85"),
                    peg$decode("<%$4\x8F\"\"5!7\x90/,#0)*4\x8F\"\"5!7\x90&&&#/' 8!:\x88!! ).\x85 &%%2\x89\"\"6\x897\x8A/;#;3/2$2\x89\"\"6\x897\x8A/#$+#)(#'#(\"'#&'#.K &%2\x8B\"\"6\x8B7\x8C/;#;4/2$2\x8B\"\"6\x8B7\x8C/#$+#)(#'#(\"'#&'#/' 8!:\x8D!! )=.\" 7\x8E"),
                    peg$decode("%$;50#*;5&/' 8!:\x91!! )"),
                    peg$decode("%$;60#*;6&/' 8!:\x91!! )"),
                    peg$decode("%%<2\x89\"\"6\x897\x8A.) &2\x92\"\"6\x927\x93=.##&&!&'#/6#1\"\"5!7\x94/($8\":\x95\"! )(\"'#&'#.A &%2\x92\"\"6\x927\x93/1#;7/($8\":\x96\"! )(\"'#&'#"),
                    peg$decode("%%<2\x8B\"\"6\x8B7\x8C.) &2\x92\"\"6\x927\x93=.##&&!&'#/6#1\"\"5!7\x94/($8\":\x95\"! )(\"'#&'#.A &%2\x92\"\"6\x927\x93/1#;7/($8\":\x96\"! )(\"'#&'#"),
                    peg$decode("%4\x97\"\"5!7\x98/' 8!:\x99!! )"),
                    peg$decode("<%%2\x9A\"\"6\x9A7\x9B/U#;9/L$2\x9A\"\"6\x9A7\x9B/=$2\x9C\"\"6\x9C7\x9D.# & \x9E.\" &\"/#$+$)($'#(#'#(\"'#&'#/' 8!:\x9F!! )=.\" 7\x8E"),
                    peg$decode("%$;:/&#0#*;:&&&#/' 8!:\x91!! )"),
                    peg$decode("%%<2\x9A\"\"6\x9A7\x9B.) &2\xA0\"\"6\xA07\xA1=.##&&!&'#/6#1\"\"5!7\x94/($8\":\x95\"! )(\"'#&'#.4 &%2\xA0\"\"6\xA07\xA1/& 8!:\xA2! )"),
                    peg$decode("<$;<0#*;<&=.\" 7\xA3"),
                    peg$decode("<4\xA4\"\"5!7\xA5=.\" 7\xA3")
                ],

                peg$currPos = 0,
                peg$savedPos = 0,
                peg$posDetailsCache = [{
                    line: 1,
                    column: 1
                }],
                peg$maxFailPos = 0,
                peg$maxFailExpected = [],
                peg$silentFails = 0,

                peg$result;

            if ("startRule" in options) {
                if (!(options.startRule in peg$startRuleIndices)) {
                    throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
                }

                peg$startRuleIndex = peg$startRuleIndices[options.startRule];
            }

            function text() {
                return input.substring(peg$savedPos, peg$currPos);
            }

            function location() {
                return peg$computeLocation(peg$savedPos, peg$currPos);
            }

            function expected(description, location) {
                location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

                throw peg$buildStructuredError(
                    [peg$otherExpectation(description)],
                    input.substring(peg$savedPos, peg$currPos),
                    location
                );
            }

            function error(message, location) {
                location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

                throw peg$buildSimpleError(message, location);
            }

            function peg$literalExpectation(text, ignoreCase) {
                return {
                    type: "literal",
                    text: text,
                    ignoreCase: ignoreCase
                };
            }

            function peg$classExpectation(parts, inverted, ignoreCase) {
                return {
                    type: "class",
                    parts: parts,
                    inverted: inverted,
                    ignoreCase: ignoreCase
                };
            }

            function peg$anyExpectation() {
                return {
                    type: "any"
                };
            }

            function peg$endExpectation() {
                return {
                    type: "end"
                };
            }

            function peg$otherExpectation(description) {
                return {
                    type: "other",
                    description: description
                };
            }

            function peg$computePosDetails(pos) {
                var details = peg$posDetailsCache[pos],
                    p;

                if (details) {
                    return details;
                } else {
                    p = pos - 1;
                    while (!peg$posDetailsCache[p]) {
                        p--;
                    }

                    details = peg$posDetailsCache[p];
                    details = {
                        line: details.line,
                        column: details.column
                    };

                    while (p < pos) {
                        if (input.charCodeAt(p) === 10) {
                            details.line++;
                            details.column = 1;
                        } else {
                            details.column++;
                        }

                        p++;
                    }

                    peg$posDetailsCache[pos] = details;
                    return details;
                }
            }

            function peg$computeLocation(startPos, endPos) {
                var startPosDetails = peg$computePosDetails(startPos),
                    endPosDetails = peg$computePosDetails(endPos);

                return {
                    start: {
                        offset: startPos,
                        line: startPosDetails.line,
                        column: startPosDetails.column
                    },
                    end: {
                        offset: endPos,
                        line: endPosDetails.line,
                        column: endPosDetails.column
                    }
                };
            }

            function peg$fail(expected) {
                if (peg$currPos < peg$maxFailPos) {
                    return;
                }

                if (peg$currPos > peg$maxFailPos) {
                    peg$maxFailPos = peg$currPos;
                    peg$maxFailExpected = [];
                }

                peg$maxFailExpected.push(expected);
            }

            function peg$buildSimpleError(message, location) {
                return new peg$SyntaxError(message, null, null, location);
            }

            function peg$buildStructuredError(expected, found, location) {
                return new peg$SyntaxError(
                    peg$SyntaxError.buildMessage(expected, found),
                    expected,
                    found,
                    location
                );
            }

            function peg$decode(s) {
                var bc = new Array(s.length),
                    i;

                for (i = 0; i < s.length; i++) {
                    bc[i] = s.charCodeAt(i) - 32;
                }

                return bc;
            }

            function peg$parseRule(index) {
                var bc = peg$bytecode[index],
                    ip = 0,
                    ips = [],
                    end = bc.length,
                    ends = [],
                    stack = [],
                    params, i;

                while (true) {
                    while (ip < end) {
                        switch (bc[ip]) {
                            case 0:
                                stack.push(peg$consts[bc[ip + 1]]);
                                ip += 2;
                                break;

                            case 1:
                                stack.push(void 0);
                                ip++;
                                break;

                            case 2:
                                stack.push(null);
                                ip++;
                                break;

                            case 3:
                                stack.push(peg$FAILED);
                                ip++;
                                break;

                            case 4:
                                stack.push([]);
                                ip++;
                                break;

                            case 5:
                                stack.push(peg$currPos);
                                ip++;
                                break;

                            case 6:
                                stack.pop();
                                ip++;
                                break;

                            case 7:
                                peg$currPos = stack.pop();
                                ip++;
                                break;

                            case 8:
                                stack.length -= bc[ip + 1];
                                ip += 2;
                                break;

                            case 9:
                                stack.splice(-2, 1);
                                ip++;
                                break;

                            case 10:
                                stack[stack.length - 2].push(stack.pop());
                                ip++;
                                break;

                            case 11:
                                stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
                                ip += 2;
                                break;

                            case 12:
                                stack.push(input.substring(stack.pop(), peg$currPos));
                                ip++;
                                break;

                            case 13:
                                ends.push(end);
                                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

                                if (stack[stack.length - 1]) {
                                    end = ip + 3 + bc[ip + 1];
                                    ip += 3;
                                } else {
                                    end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                    ip += 3 + bc[ip + 1];
                                }

                                break;

                            case 14:
                                ends.push(end);
                                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

                                if (stack[stack.length - 1] === peg$FAILED) {
                                    end = ip + 3 + bc[ip + 1];
                                    ip += 3;
                                } else {
                                    end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                    ip += 3 + bc[ip + 1];
                                }

                                break;

                            case 15:
                                ends.push(end);
                                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

                                if (stack[stack.length - 1] !== peg$FAILED) {
                                    end = ip + 3 + bc[ip + 1];
                                    ip += 3;
                                } else {
                                    end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                    ip += 3 + bc[ip + 1];
                                }

                                break;

                            case 16:
                                if (stack[stack.length - 1] !== peg$FAILED) {
                                    ends.push(end);
                                    ips.push(ip);

                                    end = ip + 2 + bc[ip + 1];
                                    ip += 2;
                                } else {
                                    ip += 2 + bc[ip + 1];
                                }

                                break;

                            case 17:
                                ends.push(end);
                                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

                                if (input.length > peg$currPos) {
                                    end = ip + 3 + bc[ip + 1];
                                    ip += 3;
                                } else {
                                    end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                    ip += 3 + bc[ip + 1];
                                }

                                break;

                            case 18:
                                ends.push(end);
                                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

                                if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                                    end = ip + 4 + bc[ip + 2];
                                    ip += 4;
                                } else {
                                    end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                    ip += 4 + bc[ip + 2];
                                }

                                break;

                            case 19:
                                ends.push(end);
                                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

                                if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                                    end = ip + 4 + bc[ip + 2];
                                    ip += 4;
                                } else {
                                    end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                    ip += 4 + bc[ip + 2];
                                }

                                break;

                            case 20:
                                ends.push(end);
                                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

                                if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                                    end = ip + 4 + bc[ip + 2];
                                    ip += 4;
                                } else {
                                    end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                    ip += 4 + bc[ip + 2];
                                }

                                break;

                            case 21:
                                stack.push(input.substr(peg$currPos, bc[ip + 1]));
                                peg$currPos += bc[ip + 1];
                                ip += 2;
                                break;

                            case 22:
                                stack.push(peg$consts[bc[ip + 1]]);
                                peg$currPos += peg$consts[bc[ip + 1]].length;
                                ip += 2;
                                break;

                            case 23:
                                stack.push(peg$FAILED);
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$consts[bc[ip + 1]]);
                                }
                                ip += 2;
                                break;

                            case 24:
                                peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
                                ip += 2;
                                break;

                            case 25:
                                peg$savedPos = peg$currPos;
                                ip++;
                                break;

                            case 26:
                                params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
                                for (i = 0; i < bc[ip + 3]; i++) {
                                    params[i] = stack[stack.length - 1 - params[i]];
                                }

                                stack.splice(
                                    stack.length - bc[ip + 2],
                                    bc[ip + 2],
                                    peg$consts[bc[ip + 1]].apply(null, params)
                                );

                                ip += 4 + bc[ip + 3];
                                break;

                            case 27:
                                stack.push(peg$parseRule(bc[ip + 1]));
                                ip += 2;
                                break;

                            case 28:
                                peg$silentFails++;
                                ip++;
                                break;

                            case 29:
                                peg$silentFails--;
                                ip++;
                                break;

                            default:
                                throw new Error("Invalid opcode: " + bc[ip] + ".");
                        }
                    }

                    if (ends.length > 0) {
                        end = ends.pop();
                        ip = ips.pop();
                    } else {
                        break;
                    }
                }

                return stack[0];
            }

            peg$result = peg$parseRule(peg$startRuleIndex);

            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                return peg$result;
            } else {
                if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                    peg$fail(peg$endExpectation());
                }

                throw peg$buildStructuredError(
                    peg$maxFailExpected,
                    peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                    peg$maxFailPos < input.length ?
                    peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) :
                    peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
                );
            }
        }

        module.exports = {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
        };


        /***/
    }),
    /* 153 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(setImmediate) {
            (function(root) {

                // Store setTimeout reference so promise-polyfill will be unaffected by
                // other code modifying setTimeout (like sinon.useFakeTimers())
                var setTimeoutFunc = setTimeout;

                function noop() {}

                // Polyfill for Function.prototype.bind
                function bind(fn, thisArg) {
                    return function() {
                        fn.apply(thisArg, arguments);
                    };
                }

                function Promise(fn) {
                    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
                    if (typeof fn !== 'function') throw new TypeError('not a function');
                    this._state = 0;
                    this._handled = false;
                    this._value = undefined;
                    this._deferreds = [];

                    doResolve(fn, this);
                }

                function handle(self, deferred) {
                    while (self._state === 3) {
                        self = self._value;
                    }
                    if (self._state === 0) {
                        self._deferreds.push(deferred);
                        return;
                    }
                    self._handled = true;
                    Promise._immediateFn(function() {
                        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                        if (cb === null) {
                            (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
                            return;
                        }
                        var ret;
                        try {
                            ret = cb(self._value);
                        } catch (e) {
                            reject(deferred.promise, e);
                            return;
                        }
                        resolve(deferred.promise, ret);
                    });
                }

                function resolve(self, newValue) {
                    try {
                        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
                        if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
                        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                            var then = newValue.then;
                            if (newValue instanceof Promise) {
                                self._state = 3;
                                self._value = newValue;
                                finale(self);
                                return;
                            } else if (typeof then === 'function') {
                                doResolve(bind(then, newValue), self);
                                return;
                            }
                        }
                        self._state = 1;
                        self._value = newValue;
                        finale(self);
                    } catch (e) {
                        reject(self, e);
                    }
                }

                function reject(self, newValue) {
                    self._state = 2;
                    self._value = newValue;
                    finale(self);
                }

                function finale(self) {
                    if (self._state === 2 && self._deferreds.length === 0) {
                        Promise._immediateFn(function() {
                            if (!self._handled) {
                                Promise._unhandledRejectionFn(self._value);
                            }
                        });
                    }

                    for (var i = 0, len = self._deferreds.length; i < len; i++) {
                        handle(self, self._deferreds[i]);
                    }
                    self._deferreds = null;
                }

                function Handler(onFulfilled, onRejected, promise) {
                    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
                    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
                    this.promise = promise;
                }

                /**
                 * Take a potentially misbehaving resolver function and make sure
                 * onFulfilled and onRejected are only called once.
                 *
                 * Makes no guarantees about asynchrony.
                 */
                function doResolve(fn, self) {
                    var done = false;
                    try {
                        fn(function(value) {
                            if (done) return;
                            done = true;
                            resolve(self, value);
                        }, function(reason) {
                            if (done) return;
                            done = true;
                            reject(self, reason);
                        });
                    } catch (ex) {
                        if (done) return;
                        done = true;
                        reject(self, ex);
                    }
                }

                Promise.prototype['catch'] = function(onRejected) {
                    return this.then(null, onRejected);
                };

                Promise.prototype.then = function(onFulfilled, onRejected) {
                    var prom = new(this.constructor)(noop);

                    handle(this, new Handler(onFulfilled, onRejected, prom));
                    return prom;
                };

                Promise.all = function(arr) {
                    var args = Array.prototype.slice.call(arr);

                    return new Promise(function(resolve, reject) {
                        if (args.length === 0) return resolve([]);
                        var remaining = args.length;

                        function res(i, val) {
                            try {
                                if (val && (typeof val === 'object' || typeof val === 'function')) {
                                    var then = val.then;
                                    if (typeof then === 'function') {
                                        then.call(val, function(val) {
                                            res(i, val);
                                        }, reject);
                                        return;
                                    }
                                }
                                args[i] = val;
                                if (--remaining === 0) {
                                    resolve(args);
                                }
                            } catch (ex) {
                                reject(ex);
                            }
                        }

                        for (var i = 0; i < args.length; i++) {
                            res(i, args[i]);
                        }
                    });
                };

                Promise.resolve = function(value) {
                    if (value && typeof value === 'object' && value.constructor === Promise) {
                        return value;
                    }

                    return new Promise(function(resolve) {
                        resolve(value);
                    });
                };

                Promise.reject = function(value) {
                    return new Promise(function(resolve, reject) {
                        reject(value);
                    });
                };

                Promise.race = function(values) {
                    return new Promise(function(resolve, reject) {
                        for (var i = 0, len = values.length; i < len; i++) {
                            values[i].then(resolve, reject);
                        }
                    });
                };

                // Use polyfill for setImmediate for performance gains
                Promise._immediateFn = (typeof setImmediate === 'function' && function(fn) {
                        setImmediate(fn);
                    }) ||
                    function(fn) {
                        setTimeoutFunc(fn, 0);
                    };

                Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
                    if (typeof console !== 'undefined' && console) {
                        console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
                    }
                };

                /**
                 * Set the immediate function to execute callbacks
                 * @param fn {function} Function to execute
                 * @deprecated
                 */
                Promise._setImmediateFn = function _setImmediateFn(fn) {
                    Promise._immediateFn = fn;
                };

                /**
                 * Change the function to execute on unhandled rejection
                 * @param {function} fn Function to execute on unhandled rejection
                 * @deprecated
                 */
                Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
                    Promise._unhandledRejectionFn = fn;
                };

                if (typeof module !== 'undefined' && module.exports) {
                    module.exports = Promise;
                } else if (!root.Promise) {
                    root.Promise = Promise;
                }

            })(this);

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(170).setImmediate))

        /***/
    }),
    /* 154 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__; // Copyright 2014 Simon Lydell
        // X11 (MIT) Licensed. (See LICENSE.)

        void(function(root, factory) {
            if (true) {
                !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
                        __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
            } else if (typeof exports === "object") {
                module.exports = factory()
            } else {
                root.resolveUrl = factory()
            }
        }(this, function() {

            function resolveUrl( /* ...urls */ ) {
                var numUrls = arguments.length

                if (numUrls === 0) {
                    throw new Error("resolveUrl requires at least one argument; got none.")
                }

                var base = document.createElement("base")
                base.href = arguments[0]

                if (numUrls === 1) {
                    return base.href
                }

                var head = document.getElementsByTagName("head")[0]
                head.insertBefore(base, head.firstChild)

                var a = document.createElement("a")
                var resolved

                for (var index = 1; index < numUrls; index++) {
                    a.href = arguments[index]
                    resolved = a.href
                    base.href = resolved
                }

                head.removeChild(base)

                return resolved
            }

            return resolveUrl

        }));


        /***/
    }),
    /* 155 */
    /***/
    (function(module, exports) {

        /*
            Based on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>
            http://www.phpied.com/rgb-color-parser-in-javascript/
        */

        module.exports = function(color_string) {
            this.ok = false;
            this.alpha = 1.0;

            // strip any leading #
            if (color_string.charAt(0) == '#') { // remove # if any
                color_string = color_string.substr(1, 6);
            }

            color_string = color_string.replace(/ /g, '');
            color_string = color_string.toLowerCase();

            // before getting into regexps, try simple matches
            // and overwrite the input
            var simple_colors = {
                aliceblue: 'f0f8ff',
                antiquewhite: 'faebd7',
                aqua: '00ffff',
                aquamarine: '7fffd4',
                azure: 'f0ffff',
                beige: 'f5f5dc',
                bisque: 'ffe4c4',
                black: '000000',
                blanchedalmond: 'ffebcd',
                blue: '0000ff',
                blueviolet: '8a2be2',
                brown: 'a52a2a',
                burlywood: 'deb887',
                cadetblue: '5f9ea0',
                chartreuse: '7fff00',
                chocolate: 'd2691e',
                coral: 'ff7f50',
                cornflowerblue: '6495ed',
                cornsilk: 'fff8dc',
                crimson: 'dc143c',
                cyan: '00ffff',
                darkblue: '00008b',
                darkcyan: '008b8b',
                darkgoldenrod: 'b8860b',
                darkgray: 'a9a9a9',
                darkgreen: '006400',
                darkkhaki: 'bdb76b',
                darkmagenta: '8b008b',
                darkolivegreen: '556b2f',
                darkorange: 'ff8c00',
                darkorchid: '9932cc',
                darkred: '8b0000',
                darksalmon: 'e9967a',
                darkseagreen: '8fbc8f',
                darkslateblue: '483d8b',
                darkslategray: '2f4f4f',
                darkturquoise: '00ced1',
                darkviolet: '9400d3',
                deeppink: 'ff1493',
                deepskyblue: '00bfff',
                dimgray: '696969',
                dodgerblue: '1e90ff',
                feldspar: 'd19275',
                firebrick: 'b22222',
                floralwhite: 'fffaf0',
                forestgreen: '228b22',
                fuchsia: 'ff00ff',
                gainsboro: 'dcdcdc',
                ghostwhite: 'f8f8ff',
                gold: 'ffd700',
                goldenrod: 'daa520',
                gray: '808080',
                green: '008000',
                greenyellow: 'adff2f',
                honeydew: 'f0fff0',
                hotpink: 'ff69b4',
                indianred: 'cd5c5c',
                indigo: '4b0082',
                ivory: 'fffff0',
                khaki: 'f0e68c',
                lavender: 'e6e6fa',
                lavenderblush: 'fff0f5',
                lawngreen: '7cfc00',
                lemonchiffon: 'fffacd',
                lightblue: 'add8e6',
                lightcoral: 'f08080',
                lightcyan: 'e0ffff',
                lightgoldenrodyellow: 'fafad2',
                lightgrey: 'd3d3d3',
                lightgreen: '90ee90',
                lightpink: 'ffb6c1',
                lightsalmon: 'ffa07a',
                lightseagreen: '20b2aa',
                lightskyblue: '87cefa',
                lightslateblue: '8470ff',
                lightslategray: '778899',
                lightsteelblue: 'b0c4de',
                lightyellow: 'ffffe0',
                lime: '00ff00',
                limegreen: '32cd32',
                linen: 'faf0e6',
                magenta: 'ff00ff',
                maroon: '800000',
                mediumaquamarine: '66cdaa',
                mediumblue: '0000cd',
                mediumorchid: 'ba55d3',
                mediumpurple: '9370d8',
                mediumseagreen: '3cb371',
                mediumslateblue: '7b68ee',
                mediumspringgreen: '00fa9a',
                mediumturquoise: '48d1cc',
                mediumvioletred: 'c71585',
                midnightblue: '191970',
                mintcream: 'f5fffa',
                mistyrose: 'ffe4e1',
                moccasin: 'ffe4b5',
                navajowhite: 'ffdead',
                navy: '000080',
                oldlace: 'fdf5e6',
                olive: '808000',
                olivedrab: '6b8e23',
                orange: 'ffa500',
                orangered: 'ff4500',
                orchid: 'da70d6',
                palegoldenrod: 'eee8aa',
                palegreen: '98fb98',
                paleturquoise: 'afeeee',
                palevioletred: 'd87093',
                papayawhip: 'ffefd5',
                peachpuff: 'ffdab9',
                peru: 'cd853f',
                pink: 'ffc0cb',
                plum: 'dda0dd',
                powderblue: 'b0e0e6',
                purple: '800080',
                rebeccapurple: '663399',
                red: 'ff0000',
                rosybrown: 'bc8f8f',
                royalblue: '4169e1',
                saddlebrown: '8b4513',
                salmon: 'fa8072',
                sandybrown: 'f4a460',
                seagreen: '2e8b57',
                seashell: 'fff5ee',
                sienna: 'a0522d',
                silver: 'c0c0c0',
                skyblue: '87ceeb',
                slateblue: '6a5acd',
                slategray: '708090',
                snow: 'fffafa',
                springgreen: '00ff7f',
                steelblue: '4682b4',
                tan: 'd2b48c',
                teal: '008080',
                thistle: 'd8bfd8',
                tomato: 'ff6347',
                turquoise: '40e0d0',
                violet: 'ee82ee',
                violetred: 'd02090',
                wheat: 'f5deb3',
                white: 'ffffff',
                whitesmoke: 'f5f5f5',
                yellow: 'ffff00',
                yellowgreen: '9acd32'
            };
            color_string = simple_colors[color_string] || color_string;
            // emd of simple type-in colors

            // array of color definition objects
            var color_defs = [{
                    re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
                    example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],
                    process: function(bits) {
                        return [
                            parseInt(bits[1]),
                            parseInt(bits[2]),
                            parseInt(bits[3]),
                            parseFloat(bits[4])
                        ];
                    }
                },
                {
                    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                    example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
                    process: function(bits) {
                        return [
                            parseInt(bits[1]),
                            parseInt(bits[2]),
                            parseInt(bits[3])
                        ];
                    }
                },
                {
                    re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                    example: ['#00ff00', '336699'],
                    process: function(bits) {
                        return [
                            parseInt(bits[1], 16),
                            parseInt(bits[2], 16),
                            parseInt(bits[3], 16)
                        ];
                    }
                },
                {
                    re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    example: ['#fb0', 'f0f'],
                    process: function(bits) {
                        return [
                            parseInt(bits[1] + bits[1], 16),
                            parseInt(bits[2] + bits[2], 16),
                            parseInt(bits[3] + bits[3], 16)
                        ];
                    }
                }
            ];

            // search through the definitions to find a match
            for (var i = 0; i < color_defs.length; i++) {
                var re = color_defs[i].re;
                var processor = color_defs[i].process;
                var bits = re.exec(color_string);
                if (bits) {
                    var channels = processor(bits);
                    this.r = channels[0];
                    this.g = channels[1];
                    this.b = channels[2];
                    if (channels.length > 3) {
                        this.alpha = channels[3];
                    }
                    this.ok = true;
                }

            }

            // validate/cleanup values
            this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
            this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
            this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
            this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);

            // some getters
            this.toRGB = function() {
                return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
            }
            this.toRGBA = function() {
                return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';
            }
            this.toHex = function() {
                var r = this.r.toString(16);
                var g = this.g.toString(16);
                var b = this.b.toString(16);
                if (r.length == 1) r = '0' + r;
                if (g.length == 1) g = '0' + g;
                if (b.length == 1) b = '0' + b;
                return '#' + r + g + b;
            }

            // help
            this.getHelpXML = function() {

                var examples = new Array();
                // add regexps
                for (var i = 0; i < color_defs.length; i++) {
                    var example = color_defs[i].example;
                    for (var j = 0; j < example.length; j++) {
                        examples[examples.length] = example[j];
                    }
                }
                // add type-in colors
                for (var sc in simple_colors) {
                    examples[examples.length] = sc;
                }

                var xml = document.createElement('ul');
                xml.setAttribute('id', 'rgbcolor-examples');
                for (var i = 0; i < examples.length; i++) {
                    try {
                        var list_item = document.createElement('li');
                        var list_color = new RGBColor(examples[i]);
                        var example_div = document.createElement('div');
                        example_div.style.cssText =
                            'margin: 3px; ' +
                            'border: 1px solid black; ' +
                            'background:' + list_color.toHex() + '; ' +
                            'color:' + list_color.toHex();
                        example_div.appendChild(document.createTextNode('test'));
                        var list_item_value = document.createTextNode(
                            ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                        );
                        list_item.appendChild(example_div);
                        list_item.appendChild(list_item_value);
                        xml.appendChild(list_item);

                    } catch (e) {}
                }
                return xml;

            }

        }


        /***/
    }),
    /* 156 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global, process) {
            (function(global, undefined) {
                "use strict";

                if (global.setImmediate) {
                    return;
                }

                var nextHandle = 1; // Spec says greater than zero
                var tasksByHandle = {};
                var currentlyRunningATask = false;
                var doc = global.document;
                var registerImmediate;

                function setImmediate(callback) {
                    // Callback can either be a function or a string
                    if (typeof callback !== "function") {
                        callback = new Function("" + callback);
                    }
                    // Copy function arguments
                    var args = new Array(arguments.length - 1);
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i + 1];
                    }
                    // Store and register the task
                    var task = {
                        callback: callback,
                        args: args
                    };
                    tasksByHandle[nextHandle] = task;
                    registerImmediate(nextHandle);
                    return nextHandle++;
                }

                function clearImmediate(handle) {
                    delete tasksByHandle[handle];
                }

                function run(task) {
                    var callback = task.callback;
                    var args = task.args;
                    switch (args.length) {
                        case 0:
                            callback();
                            break;
                        case 1:
                            callback(args[0]);
                            break;
                        case 2:
                            callback(args[0], args[1]);
                            break;
                        case 3:
                            callback(args[0], args[1], args[2]);
                            break;
                        default:
                            callback.apply(undefined, args);
                            break;
                    }
                }

                function runIfPresent(handle) {
                    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
                    // So if we're currently running a task, we'll need to delay this invocation.
                    if (currentlyRunningATask) {
                        // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                        // "too much recursion" error.
                        setTimeout(runIfPresent, 0, handle);
                    } else {
                        var task = tasksByHandle[handle];
                        if (task) {
                            currentlyRunningATask = true;
                            try {
                                run(task);
                            } finally {
                                clearImmediate(handle);
                                currentlyRunningATask = false;
                            }
                        }
                    }
                }

                function installNextTickImplementation() {
                    registerImmediate = function(handle) {
                        process.nextTick(function() {
                            runIfPresent(handle);
                        });
                    };
                }

                function canUsePostMessage() {
                    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
                    // where `global.postMessage` means something completely different and can't be used for this purpose.
                    if (global.postMessage && !global.importScripts) {
                        var postMessageIsAsynchronous = true;
                        var oldOnMessage = global.onmessage;
                        global.onmessage = function() {
                            postMessageIsAsynchronous = false;
                        };
                        global.postMessage("", "*");
                        global.onmessage = oldOnMessage;
                        return postMessageIsAsynchronous;
                    }
                }

                function installPostMessageImplementation() {
                    // Installs an event handler on `global` for the `message` event: see
                    // * https://developer.mozilla.org/en/DOM/window.postMessage
                    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

                    var messagePrefix = "setImmediate$" + Math.random() + "$";
                    var onGlobalMessage = function(event) {
                        if (event.source === global &&
                            typeof event.data === "string" &&
                            event.data.indexOf(messagePrefix) === 0) {
                            runIfPresent(+event.data.slice(messagePrefix.length));
                        }
                    };

                    if (global.addEventListener) {
                        global.addEventListener("message", onGlobalMessage, false);
                    } else {
                        global.attachEvent("onmessage", onGlobalMessage);
                    }

                    registerImmediate = function(handle) {
                        global.postMessage(messagePrefix + handle, "*");
                    };
                }

                function installMessageChannelImplementation() {
                    var channel = new MessageChannel();
                    channel.port1.onmessage = function(event) {
                        var handle = event.data;
                        runIfPresent(handle);
                    };

                    registerImmediate = function(handle) {
                        channel.port2.postMessage(handle);
                    };
                }

                function installReadyStateChangeImplementation() {
                    var html = doc.documentElement;
                    registerImmediate = function(handle) {
                        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                        var script = doc.createElement("script");
                        script.onreadystatechange = function() {
                            runIfPresent(handle);
                            script.onreadystatechange = null;
                            html.removeChild(script);
                            script = null;
                        };
                        html.appendChild(script);
                    };
                }

                function installSetTimeoutImplementation() {
                    registerImmediate = function(handle) {
                        setTimeout(runIfPresent, 0, handle);
                    };
                }

                // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
                var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
                attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

                // Don't get fooled by e.g. browserify environments.
                if ({}.toString.call(global.process) === "[object process]") {
                    // For Node.js before 0.9
                    installNextTickImplementation();

                } else if (canUsePostMessage()) {
                    // For non-IE10 modern browsers
                    installPostMessageImplementation();

                } else if (global.MessageChannel) {
                    // For web workers, where supported
                    installMessageChannelImplementation();

                } else if (doc && "onreadystatechange" in doc.createElement("script")) {
                    // For IE 68
                    installReadyStateChangeImplementation();

                } else {
                    // For older browsers
                    installSetTimeoutImplementation();
                }

                attachTo.setImmediate = setImmediate;
                attachTo.clearImmediate = clearImmediate;
            }(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(4), __webpack_require__(175)))

        /***/
    }),
    /* 157 */
    /***/
    (function(module, exports) {

        /*

        StackBlur - a fast almost Gaussian Blur For Canvas

        Version:    0.5
        Author:     Mario Klingemann
        Contact:    mario@quasimondo.com
        Website:    http://www.quasimondo.com/StackBlurForCanvas
        Twitter:    @quasimondo

        In case you find this class useful - especially in commercial projects -
        I am not totally unhappy for a small donation to my PayPal account
        mario@quasimondo.de

        Or support me on flattr: 
        https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

        Copyright (c) 2010 Mario Klingemann

        Permission is hereby granted, free of charge, to any person
        obtaining a copy of this software and associated documentation
        files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following
        conditions:

        The above copyright notice and this permission notice shall be
        included in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
        */

        var mul_table = [
            512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,
            454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,
            482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,
            437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,
            497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,
            320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,
            446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,
            329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,
            505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,
            399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,
            324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,
            268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,
            451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,
            385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,
            332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
            289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259
        ];


        var shg_table = [
            9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
            17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
            19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
            20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
            21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
            21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
            23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
            23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
            23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
            23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
        ];

        function blur(pixels, width, height, radius) {
            if (isNaN(radius) || radius < 1) return;
            radius |= 0;

            var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
                r_out_sum, g_out_sum, b_out_sum, a_out_sum,
                r_in_sum, g_in_sum, b_in_sum, a_in_sum,
                pr, pg, pb, pa, rbs;

            var div = radius + radius + 1;
            var w4 = width << 2;
            var widthMinus1 = width - 1;
            var heightMinus1 = height - 1;
            var radiusPlus1 = radius + 1;
            var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

            var stackStart = new BlurStack();
            var stack = stackStart;
            for (i = 1; i < div; i++) {
                stack = stack.next = new BlurStack();
                if (i == radiusPlus1) var stackEnd = stack;
            }
            stack.next = stackStart;
            var stackIn = null;
            var stackOut = null;

            yw = yi = 0;

            var mul_sum = mul_table[radius];
            var shg_sum = shg_table[radius];

            for (y = 0; y < height; y++) {
                r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

                r_out_sum = radiusPlus1 * (pr = pixels[yi]);
                g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
                b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
                a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

                r_sum += sumFactor * pr;
                g_sum += sumFactor * pg;
                b_sum += sumFactor * pb;
                a_sum += sumFactor * pa;

                stack = stackStart;

                for (i = 0; i < radiusPlus1; i++) {
                    stack.r = pr;
                    stack.g = pg;
                    stack.b = pb;
                    stack.a = pa;
                    stack = stack.next;
                }

                for (i = 1; i < radiusPlus1; i++) {
                    p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                    r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
                    g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
                    b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;
                    a_sum += (stack.a = (pa = pixels[p + 3])) * rbs;

                    r_in_sum += pr;
                    g_in_sum += pg;
                    b_in_sum += pb;
                    a_in_sum += pa;

                    stack = stack.next;
                }


                stackIn = stackStart;
                stackOut = stackEnd;
                for (x = 0; x < width; x++) {
                    pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                    if (pa != 0) {
                        pa = 255 / pa;
                        pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
                        pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                        pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                    } else {
                        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                    }

                    r_sum -= r_out_sum;
                    g_sum -= g_out_sum;
                    b_sum -= b_out_sum;
                    a_sum -= a_out_sum;

                    r_out_sum -= stackIn.r;
                    g_out_sum -= stackIn.g;
                    b_out_sum -= stackIn.b;
                    a_out_sum -= stackIn.a;

                    p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

                    r_in_sum += (stackIn.r = pixels[p]);
                    g_in_sum += (stackIn.g = pixels[p + 1]);
                    b_in_sum += (stackIn.b = pixels[p + 2]);
                    a_in_sum += (stackIn.a = pixels[p + 3]);

                    r_sum += r_in_sum;
                    g_sum += g_in_sum;
                    b_sum += b_in_sum;
                    a_sum += a_in_sum;

                    stackIn = stackIn.next;

                    r_out_sum += (pr = stackOut.r);
                    g_out_sum += (pg = stackOut.g);
                    b_out_sum += (pb = stackOut.b);
                    a_out_sum += (pa = stackOut.a);

                    r_in_sum -= pr;
                    g_in_sum -= pg;
                    b_in_sum -= pb;
                    a_in_sum -= pa;

                    stackOut = stackOut.next;

                    yi += 4;
                }
                yw += width;
            }


            for (x = 0; x < width; x++) {
                g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

                yi = x << 2;
                r_out_sum = radiusPlus1 * (pr = pixels[yi]);
                g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
                b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
                a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

                r_sum += sumFactor * pr;
                g_sum += sumFactor * pg;
                b_sum += sumFactor * pb;
                a_sum += sumFactor * pa;

                stack = stackStart;

                for (i = 0; i < radiusPlus1; i++) {
                    stack.r = pr;
                    stack.g = pg;
                    stack.b = pb;
                    stack.a = pa;
                    stack = stack.next;
                }

                yp = width;

                for (i = 1; i <= radius; i++) {
                    yi = (yp + x) << 2;

                    r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
                    g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
                    b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;
                    a_sum += (stack.a = (pa = pixels[yi + 3])) * rbs;

                    r_in_sum += pr;
                    g_in_sum += pg;
                    b_in_sum += pb;
                    a_in_sum += pa;

                    stack = stack.next;

                    if (i < heightMinus1) {
                        yp += width;
                    }
                }

                yi = x;
                stackIn = stackStart;
                stackOut = stackEnd;
                for (y = 0; y < height; y++) {
                    p = yi << 2;
                    pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                    if (pa > 0) {
                        pa = 255 / pa;
                        pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
                        pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                        pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                    } else {
                        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
                    }

                    r_sum -= r_out_sum;
                    g_sum -= g_out_sum;
                    b_sum -= b_out_sum;
                    a_sum -= a_out_sum;

                    r_out_sum -= stackIn.r;
                    g_out_sum -= stackIn.g;
                    b_out_sum -= stackIn.b;
                    a_out_sum -= stackIn.a;

                    p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

                    r_sum += (r_in_sum += (stackIn.r = pixels[p]));
                    g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
                    b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));
                    a_sum += (a_in_sum += (stackIn.a = pixels[p + 3]));

                    stackIn = stackIn.next;

                    r_out_sum += (pr = stackOut.r);
                    g_out_sum += (pg = stackOut.g);
                    b_out_sum += (pb = stackOut.b);
                    a_out_sum += (pa = stackOut.a);

                    r_in_sum -= pr;
                    g_in_sum -= pg;
                    b_in_sum -= pb;
                    a_in_sum -= pa;

                    stackOut = stackOut.next;

                    yi += width;
                }
            }
        }

        function BlurStack() {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.next = null;
        }

        module.exports = blur;

        /***/
    }),
    /* 158 */
    /***/
    (function(module, exports, __webpack_require__) {

        var engine = __webpack_require__(161)

        var storages = __webpack_require__(162)
        var plugins = [__webpack_require__(159)]

        module.exports = engine.createStore(storages, plugins)


        /***/
    }),
    /* 159 */
    /***/
    (function(module, exports, __webpack_require__) {

        module.exports = json2Plugin

        function json2Plugin() {
            __webpack_require__(160)
            return {}
        }


        /***/
    }),
    /* 160 */
    /***/
    (function(module, exports) {

        /* eslint-disable */

        //  json2.js
        //  2016-10-28
        //  Public Domain.
        //  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
        //  See http://www.JSON.org/js.html
        //  This code should be minified before deployment.
        //  See http://javascript.crockford.com/jsmin.html

        //  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
        //  NOT CONTROL.

        //  This file creates a global JSON object containing two methods: stringify
        //  and parse. This file provides the ES5 JSON capability to ES3 systems.
        //  If a project might run on IE8 or earlier, then this file should be included.
        //  This file does nothing on ES5 systems.

        //      JSON.stringify(value, replacer, space)
        //          value       any JavaScript value, usually an object or array.
        //          replacer    an optional parameter that determines how object
        //                      values are stringified for objects. It can be a
        //                      function or an array of strings.
        //          space       an optional parameter that specifies the indentation
        //                      of nested structures. If it is omitted, the text will
        //                      be packed without extra whitespace. If it is a number,
        //                      it will specify the number of spaces to indent at each
        //                      level. If it is a string (such as "\t" or "&nbsp;"),
        //                      it contains the characters used to indent at each level.
        //          This method produces a JSON text from a JavaScript value.
        //          When an object value is found, if the object contains a toJSON
        //          method, its toJSON method will be called and the result will be
        //          stringified. A toJSON method does not serialize: it returns the
        //          value represented by the name/value pair that should be serialized,
        //          or undefined if nothing should be serialized. The toJSON method
        //          will be passed the key associated with the value, and this will be
        //          bound to the value.

        //          For example, this would serialize Dates as ISO strings.

        //              Date.prototype.toJSON = function (key) {
        //                  function f(n) {
        //                      // Format integers to have at least two digits.
        //                      return (n < 10)
        //                          ? "0" + n
        //                          : n;
        //                  }
        //                  return this.getUTCFullYear()   + "-" +
        //                       f(this.getUTCMonth() + 1) + "-" +
        //                       f(this.getUTCDate())      + "T" +
        //                       f(this.getUTCHours())     + ":" +
        //                       f(this.getUTCMinutes())   + ":" +
        //                       f(this.getUTCSeconds())   + "Z";
        //              };

        //          You can provide an optional replacer method. It will be passed the
        //          key and value of each member, with this bound to the containing
        //          object. The value that is returned from your method will be
        //          serialized. If your method returns undefined, then the member will
        //          be excluded from the serialization.

        //          If the replacer parameter is an array of strings, then it will be
        //          used to select the members to be serialized. It filters the results
        //          such that only members with keys listed in the replacer array are
        //          stringified.

        //          Values that do not have JSON representations, such as undefined or
        //          functions, will not be serialized. Such values in objects will be
        //          dropped; in arrays they will be replaced with null. You can use
        //          a replacer function to replace those with JSON values.

        //          JSON.stringify(undefined) returns undefined.

        //          The optional space parameter produces a stringification of the
        //          value that is filled with line breaks and indentation to make it
        //          easier to read.

        //          If the space parameter is a non-empty string, then that string will
        //          be used for indentation. If the space parameter is a number, then
        //          the indentation will be that many spaces.

        //          Example:

        //          text = JSON.stringify(["e", {pluribus: "unum"}]);
        //          // text is '["e",{"pluribus":"unum"}]'

        //          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
        //          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

        //          text = JSON.stringify([new Date()], function (key, value) {
        //              return this[key] instanceof Date
        //                  ? "Date(" + this[key] + ")"
        //                  : value;
        //          });
        //          // text is '["Date(---current time---)"]'

        //      JSON.parse(text, reviver)
        //          This method parses a JSON text to produce an object or array.
        //          It can throw a SyntaxError exception.

        //          The optional reviver parameter is a function that can filter and
        //          transform the results. It receives each of the keys and values,
        //          and its return value is used instead of the original value.
        //          If it returns what it received, then the structure is not modified.
        //          If it returns undefined then the member is deleted.

        //          Example:

        //          // Parse the text. Values that look like ISO date strings will
        //          // be converted to Date objects.

        //          myData = JSON.parse(text, function (key, value) {
        //              var a;
        //              if (typeof value === "string") {
        //                  a =
        //   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
        //                  if (a) {
        //                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
        //                          +a[5], +a[6]));
        //                  }
        //              }
        //              return value;
        //          });

        //          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
        //              var d;
        //              if (typeof value === "string" &&
        //                      value.slice(0, 5) === "Date(" &&
        //                      value.slice(-1) === ")") {
        //                  d = new Date(value.slice(5, -1));
        //                  if (d) {
        //                      return d;
        //                  }
        //              }
        //              return value;
        //          });

        //  This is a reference implementation. You are free to copy, modify, or
        //  redistribute.

        /*jslint
            eval, for, this
        */

        /*property
            JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
            getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
            lastIndex, length, parse, prototype, push, replace, slice, stringify,
            test, toJSON, toString, valueOf
        */


        // Create a JSON object only if one does not already exist. We create the
        // methods in a closure to avoid creating global variables.

        if (typeof JSON !== "object") {
            JSON = {};
        }

        (function() {
            "use strict";

            var rx_one = /^[\],:{}\s]*$/;
            var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
            var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
            var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
            var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
            var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

            function f(n) {
                // Format integers to have at least two digits.
                return n < 10 ?
                    "0" + n :
                    n;
            }

            function this_value() {
                return this.valueOf();
            }

            if (typeof Date.prototype.toJSON !== "function") {

                Date.prototype.toJSON = function() {

                    return isFinite(this.valueOf()) ?
                        this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z" :
                        null;
                };

                Boolean.prototype.toJSON = this_value;
                Number.prototype.toJSON = this_value;
                String.prototype.toJSON = this_value;
            }

            var gap;
            var indent;
            var meta;
            var rep;


            function quote(string) {

                // If the string contains no control characters, no quote characters, and no
                // backslash characters, then we can safely slap some quotes around it.
                // Otherwise we must also replace the offending characters with safe escape
                // sequences.

                rx_escapable.lastIndex = 0;
                return rx_escapable.test(string) ?
                    "\"" + string.replace(rx_escapable, function(a) {
                        var c = meta[a];
                        return typeof c === "string" ?
                            c :
                            "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                    }) + "\"" :
                    "\"" + string + "\"";
            }


            function str(key, holder) {

                // Produce a string from holder[key].

                var i; // The loop counter.
                var k; // The member key.
                var v; // The member value.
                var length;
                var mind = gap;
                var partial;
                var value = holder[key];

                // If the value has a toJSON method, call it to obtain a replacement value.

                if (value && typeof value === "object" &&
                    typeof value.toJSON === "function") {
                    value = value.toJSON(key);
                }

                // If we were called with a replacer function, then call the replacer to
                // obtain a replacement value.

                if (typeof rep === "function") {
                    value = rep.call(holder, key, value);
                }

                // What happens next depends on the value's type.

                switch (typeof value) {
                    case "string":
                        return quote(value);

                    case "number":

                        // JSON numbers must be finite. Encode non-finite numbers as null.

                        return isFinite(value) ?
                            String(value) :
                            "null";

                    case "boolean":
                    case "null":

                        // If the value is a boolean or null, convert it to a string. Note:
                        // typeof null does not produce "null". The case is included here in
                        // the remote chance that this gets fixed someday.

                        return String(value);

                        // If the type is "object", we might be dealing with an object or an array or
                        // null.

                    case "object":

                        // Due to a specification blunder in ECMAScript, typeof null is "object",
                        // so watch out for that case.

                        if (!value) {
                            return "null";
                        }

                        // Make an array to hold the partial results of stringifying this object value.

                        gap += indent;
                        partial = [];

                        // Is the value an array?

                        if (Object.prototype.toString.apply(value) === "[object Array]") {

                            // The value is an array. Stringify every element. Use null as a placeholder
                            // for non-JSON values.

                            length = value.length;
                            for (i = 0; i < length; i += 1) {
                                partial[i] = str(i, value) || "null";
                            }

                            // Join all of the elements together, separated with commas, and wrap them in
                            // brackets.

                            v = partial.length === 0 ?
                                "[]" :
                                gap ?
                                "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" :
                                "[" + partial.join(",") + "]";
                            gap = mind;
                            return v;
                        }

                        // If the replacer is an array, use it to select the members to be stringified.

                        if (rep && typeof rep === "object") {
                            length = rep.length;
                            for (i = 0; i < length; i += 1) {
                                if (typeof rep[i] === "string") {
                                    k = rep[i];
                                    v = str(k, value);
                                    if (v) {
                                        partial.push(quote(k) + (
                                            gap ?
                                            ": " :
                                            ":"
                                        ) + v);
                                    }
                                }
                            }
                        } else {

                            // Otherwise, iterate through all of the keys in the object.

                            for (k in value) {
                                if (Object.prototype.hasOwnProperty.call(value, k)) {
                                    v = str(k, value);
                                    if (v) {
                                        partial.push(quote(k) + (
                                            gap ?
                                            ": " :
                                            ":"
                                        ) + v);
                                    }
                                }
                            }
                        }

                        // Join all of the member texts together, separated with commas,
                        // and wrap them in braces.

                        v = partial.length === 0 ?
                            "{}" :
                            gap ?
                            "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" :
                            "{" + partial.join(",") + "}";
                        gap = mind;
                        return v;
                }
            }

            // If the JSON object does not yet have a stringify method, give it one.

            if (typeof JSON.stringify !== "function") {
                meta = { // table of character substitutions
                    "\b": "\\b",
                    "\t": "\\t",
                    "\n": "\\n",
                    "\f": "\\f",
                    "\r": "\\r",
                    "\"": "\\\"",
                    "\\": "\\\\"
                };
                JSON.stringify = function(value, replacer, space) {

                    // The stringify method takes a value and an optional replacer, and an optional
                    // space parameter, and returns a JSON text. The replacer can be a function
                    // that can replace values, or an array of strings that will select the keys.
                    // A default replacer method can be provided. Use of the space parameter can
                    // produce text that is more easily readable.

                    var i;
                    gap = "";
                    indent = "";

                    // If the space parameter is a number, make an indent string containing that
                    // many spaces.

                    if (typeof space === "number") {
                        for (i = 0; i < space; i += 1) {
                            indent += " ";
                        }

                        // If the space parameter is a string, it will be used as the indent string.

                    } else if (typeof space === "string") {
                        indent = space;
                    }

                    // If there is a replacer, it must be a function or an array.
                    // Otherwise, throw an error.

                    rep = replacer;
                    if (replacer && typeof replacer !== "function" &&
                        (typeof replacer !== "object" ||
                            typeof replacer.length !== "number")) {
                        throw new Error("JSON.stringify");
                    }

                    // Make a fake root object containing our value under the key of "".
                    // Return the result of stringifying the value.

                    return str("", {
                        "": value
                    });
                };
            }


            // If the JSON object does not yet have a parse method, give it one.

            if (typeof JSON.parse !== "function") {
                JSON.parse = function(text, reviver) {

                    // The parse method takes a text and an optional reviver function, and returns
                    // a JavaScript value if the text is a valid JSON text.

                    var j;

                    function walk(holder, key) {

                        // The walk method is used to recursively walk the resulting structure so
                        // that modifications can be made.

                        var k;
                        var v;
                        var value = holder[key];
                        if (value && typeof value === "object") {
                            for (k in value) {
                                if (Object.prototype.hasOwnProperty.call(value, k)) {
                                    v = walk(value, k);
                                    if (v !== undefined) {
                                        value[k] = v;
                                    } else {
                                        delete value[k];
                                    }
                                }
                            }
                        }
                        return reviver.call(holder, key, value);
                    }


                    // Parsing happens in four stages. In the first stage, we replace certain
                    // Unicode characters with escape sequences. JavaScript handles many characters
                    // incorrectly, either silently deleting them, or treating them as line endings.

                    text = String(text);
                    rx_dangerous.lastIndex = 0;
                    if (rx_dangerous.test(text)) {
                        text = text.replace(rx_dangerous, function(a) {
                            return "\\u" +
                                ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                        });
                    }

                    // In the second stage, we run the text against regular expressions that look
                    // for non-JSON patterns. We are especially concerned with "()" and "new"
                    // because they can cause invocation, and "=" because it can cause mutation.
                    // But just to be safe, we want to reject all unexpected forms.

                    // We split the second stage into 4 regexp operations in order to work around
                    // crippling inefficiencies in IE's and Safari's regexp engines. First we
                    // replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
                    // replace all simple value tokens with "]" characters. Third, we delete all
                    // open brackets that follow a colon or comma or that begin the text. Finally,
                    // we look to see that the remaining characters are only whitespace or "]" or
                    // "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

                    if (
                        rx_one.test(
                            text
                            .replace(rx_two, "@")
                            .replace(rx_three, "]")
                            .replace(rx_four, "")
                        )
                    ) {

                        // In the third stage we use the eval function to compile the text into a
                        // JavaScript structure. The "{" operator is subject to a syntactic ambiguity
                        // in JavaScript: it can begin a block or an object literal. We wrap the text
                        // in parens to eliminate the ambiguity.

                        j = eval("(" + text + ")");

                        // In the optional fourth stage, we recursively walk the new structure, passing
                        // each name/value pair to a reviver function for possible transformation.

                        return (typeof reviver === "function") ?
                            walk({
                                "": j
                            }, "") :
                            j;
                    }

                    // If the text is not JSON parseable, then a SyntaxError is thrown.

                    throw new SyntaxError("JSON.parse");
                };
            }
        }());

        /***/
    }),
    /* 161 */
    /***/
    (function(module, exports, __webpack_require__) {

        var util = __webpack_require__(9)
        var slice = util.slice
        var pluck = util.pluck
        var each = util.each
        var bind = util.bind
        var create = util.create
        var isList = util.isList
        var isFunction = util.isFunction
        var isObject = util.isObject

        module.exports = {
            createStore: createStore
        }

        var storeAPI = {
            version: '2.0.12',
            enabled: false,

            // get returns the value of the given key. If that value
            // is undefined, it returns optionalDefaultValue instead.
            get: function(key, optionalDefaultValue) {
                var data = this.storage.read(this._namespacePrefix + key)
                return this._deserialize(data, optionalDefaultValue)
            },

            // set will store the given value at key and returns value.
            // Calling set with value === undefined is equivalent to calling remove.
            set: function(key, value) {
                if (value === undefined) {
                    return this.remove(key)
                }
                this.storage.write(this._namespacePrefix + key, this._serialize(value))
                return value
            },

            // remove deletes the key and value stored at the given key.
            remove: function(key) {
                this.storage.remove(this._namespacePrefix + key)
            },

            // each will call the given callback once for each key-value pair
            // in this store.
            each: function(callback) {
                var self = this
                this.storage.each(function(val, namespacedKey) {
                    callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))
                })
            },

            // clearAll will remove all the stored key-value pairs in this store.
            clearAll: function() {
                this.storage.clearAll()
            },

            // additional functionality that can't live in plugins
            // ---------------------------------------------------

            // hasNamespace returns true if this store instance has the given namespace.
            hasNamespace: function(namespace) {
                return (this._namespacePrefix == '__storejs_' + namespace + '_')
            },

            // createStore creates a store.js instance with the first
            // functioning storage in the list of storage candidates,
            // and applies the the given mixins to the instance.
            createStore: function() {
                return createStore.apply(this, arguments)
            },

            addPlugin: function(plugin) {
                this._addPlugin(plugin)
            },

            namespace: function(namespace) {
                return createStore(this.storage, this.plugins, namespace)
            }
        }

        function _warn() {
            var _console = (typeof console == 'undefined' ? null : console)
            if (!_console) {
                return
            }
            var fn = (_console.warn ? _console.warn : _console.log)
            fn.apply(_console, arguments)
        }

        function createStore(storages, plugins, namespace) {
            if (!namespace) {
                namespace = ''
            }
            if (storages && !isList(storages)) {
                storages = [storages]
            }
            if (plugins && !isList(plugins)) {
                plugins = [plugins]
            }

            var namespacePrefix = (namespace ? '__storejs_' + namespace + '_' : '')
            var namespaceRegexp = (namespace ? new RegExp('^' + namespacePrefix) : null)
            var legalNamespaces = /^[a-zA-Z0-9_\-]*$/ // alpha-numeric + underscore and dash
            if (!legalNamespaces.test(namespace)) {
                throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
            }

            var _privateStoreProps = {
                _namespacePrefix: namespacePrefix,
                _namespaceRegexp: namespaceRegexp,

                _testStorage: function(storage) {
                    try {
                        var testStr = '__storejs__test__'
                        storage.write(testStr, testStr)
                        var ok = (storage.read(testStr) === testStr)
                        storage.remove(testStr)
                        return ok
                    } catch (e) {
                        return false
                    }
                },

                _assignPluginFnProp: function(pluginFnProp, propName) {
                    var oldFn = this[propName]
                    this[propName] = function pluginFn() {
                        var args = slice(arguments, 0)
                        var self = this

                        // super_fn calls the old function which was overwritten by
                        // this mixin.
                        function super_fn() {
                            if (!oldFn) {
                                return
                            }
                            each(arguments, function(arg, i) {
                                args[i] = arg
                            })
                            return oldFn.apply(self, args)
                        }

                        // Give mixing function access to super_fn by prefixing all mixin function
                        // arguments with super_fn.
                        var newFnArgs = [super_fn].concat(args)

                        return pluginFnProp.apply(self, newFnArgs)
                    }
                },

                _serialize: function(obj) {
                    return JSON.stringify(obj)
                },

                _deserialize: function(strVal, defaultVal) {
                    if (!strVal) {
                        return defaultVal
                    }
                    // It is possible that a raw string value has been previously stored
                    // in a storage without using store.js, meaning it will be a raw
                    // string value instead of a JSON serialized string. By defaulting
                    // to the raw string value in case of a JSON parse error, we allow
                    // for past stored values to be forwards-compatible with store.js
                    var val = ''
                    try {
                        val = JSON.parse(strVal)
                    } catch (e) {
                        val = strVal
                    }

                    return (val !== undefined ? val : defaultVal)
                },

                _addStorage: function(storage) {
                    if (this.enabled) {
                        return
                    }
                    if (this._testStorage(storage)) {
                        this.storage = storage
                        this.enabled = true
                    }
                },

                _addPlugin: function(plugin) {
                    var self = this

                    // If the plugin is an array, then add all plugins in the array.
                    // This allows for a plugin to depend on other plugins.
                    if (isList(plugin)) {
                        each(plugin, function(plugin) {
                            self._addPlugin(plugin)
                        })
                        return
                    }

                    // Keep track of all plugins we've seen so far, so that we
                    // don't add any of them twice.
                    var seenPlugin = pluck(this.plugins, function(seenPlugin) {
                        return (plugin === seenPlugin)
                    })
                    if (seenPlugin) {
                        return
                    }
                    this.plugins.push(plugin)

                    // Check that the plugin is properly formed
                    if (!isFunction(plugin)) {
                        throw new Error('Plugins must be function values that return objects')
                    }

                    var pluginProperties = plugin.call(this)
                    if (!isObject(pluginProperties)) {
                        throw new Error('Plugins must return an object of function properties')
                    }

                    // Add the plugin function properties to this store instance.
                    each(pluginProperties, function(pluginFnProp, propName) {
                        if (!isFunction(pluginFnProp)) {
                            throw new Error('Bad plugin property: ' + propName + ' from plugin ' + plugin.name + '. Plugins should only return functions.')
                        }
                        self._assignPluginFnProp(pluginFnProp, propName)
                    })
                },

                // Put deprecated properties in the private API, so as to not expose it to accidential
                // discovery through inspection of the store object.

                // Deprecated: addStorage
                addStorage: function(storage) {
                    _warn('store.addStorage(storage) is deprecated. Use createStore([storages])')
                    this._addStorage(storage)
                }
            }

            var store = create(_privateStoreProps, storeAPI, {
                plugins: []
            })
            store.raw = {}
            each(store, function(prop, propName) {
                if (isFunction(prop)) {
                    store.raw[propName] = bind(store, prop)
                }
            })
            each(storages, function(storage) {
                store._addStorage(storage)
            })
            each(plugins, function(plugin) {
                store._addPlugin(plugin)
            })
            return store
        }


        /***/
    }),
    /* 162 */
    /***/
    (function(module, exports, __webpack_require__) {

        module.exports = [
            // Listed in order of usage preference
            __webpack_require__(164),
            __webpack_require__(166),
            __webpack_require__(167),
            __webpack_require__(163),
            __webpack_require__(168),
            __webpack_require__(165)
        ]


        /***/
    }),
    /* 163 */
    /***/
    (function(module, exports, __webpack_require__) {

        // cookieStorage is useful Safari private browser mode, where localStorage
        // doesn't work but cookies do. This implementation is adopted from
        // https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

        var util = __webpack_require__(9)
        var Global = util.Global
        var trim = util.trim

        module.exports = {
            name: 'cookieStorage',
            read: read,
            write: write,
            each: each,
            remove: remove,
            clearAll: clearAll,
        }

        var doc = Global.document

        function read(key) {
            if (!key || !_has(key)) {
                return null
            }
            var regexpStr = "(?:^|.*;\\s*)" +
                escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
                "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"
            return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
        }

        function each(callback) {
            var cookies = doc.cookie.split(/; ?/g)
            for (var i = cookies.length - 1; i >= 0; i--) {
                if (!trim(cookies[i])) {
                    continue
                }
                var kvp = cookies[i].split('=')
                var key = unescape(kvp[0])
                var val = unescape(kvp[1])
                callback(val, key)
            }
        }

        function write(key, data) {
            if (!key) {
                return
            }
            doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/"
        }

        function remove(key) {
            if (!key || !_has(key)) {
                return
            }
            doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"
        }

        function clearAll() {
            each(function(_, key) {
                remove(key)
            })
        }

        function _has(key) {
            return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
        }


        /***/
    }),
    /* 164 */
    /***/
    (function(module, exports, __webpack_require__) {

        var util = __webpack_require__(9)
        var Global = util.Global

        module.exports = {
            name: 'localStorage',
            read: read,
            write: write,
            each: each,
            remove: remove,
            clearAll: clearAll,
        }

        function localStorage() {
            return Global.localStorage
        }

        function read(key) {
            return localStorage().getItem(key)
        }

        function write(key, data) {
            return localStorage().setItem(key, data)
        }

        function each(fn) {
            for (var i = localStorage().length - 1; i >= 0; i--) {
                var key = localStorage().key(i)
                fn(read(key), key)
            }
        }

        function remove(key) {
            return localStorage().removeItem(key)
        }

        function clearAll() {
            return localStorage().clear()
        }


        /***/
    }),
    /* 165 */
    /***/
    (function(module, exports) {

        // memoryStorage is a useful last fallback to ensure that the store
        // is functions (meaning store.get(), store.set(), etc will all function).
        // However, stored values will not persist when the browser navigates to
        // a new page or reloads the current page.

        module.exports = {
            name: 'memoryStorage',
            read: read,
            write: write,
            each: each,
            remove: remove,
            clearAll: clearAll,
        }

        var memoryStorage = {}

        function read(key) {
            return memoryStorage[key]
        }

        function write(key, data) {
            memoryStorage[key] = data
        }

        function each(callback) {
            for (var key in memoryStorage) {
                if (memoryStorage.hasOwnProperty(key)) {
                    callback(memoryStorage[key], key)
                }
            }
        }

        function remove(key) {
            delete memoryStorage[key]
        }

        function clearAll(key) {
            memoryStorage = {}
        }


        /***/
    }),
    /* 166 */
    /***/
    (function(module, exports, __webpack_require__) {

        // oldFF-globalStorage provides storage for Firefox
        // versions 6 and 7, where no localStorage, etc
        // is available.

        var util = __webpack_require__(9)
        var Global = util.Global

        module.exports = {
            name: 'oldFF-globalStorage',
            read: read,
            write: write,
            each: each,
            remove: remove,
            clearAll: clearAll,
        }

        var globalStorage = Global.globalStorage

        function read(key) {
            return globalStorage[key]
        }

        function write(key, data) {
            globalStorage[key] = data
        }

        function each(fn) {
            for (var i = globalStorage.length - 1; i >= 0; i--) {
                var key = globalStorage.key(i)
                fn(globalStorage[key], key)
            }
        }

        function remove(key) {
            return globalStorage.removeItem(key)
        }

        function clearAll() {
            each(function(key, _) {
                delete globalStorage[key]
            })
        }


        /***/
    }),
    /* 167 */
    /***/
    (function(module, exports, __webpack_require__) {

        // oldIE-userDataStorage provides storage for Internet Explorer
        // versions 6 and 7, where no localStorage, sessionStorage, etc
        // is available.

        var util = __webpack_require__(9)
        var Global = util.Global

        module.exports = {
            name: 'oldIE-userDataStorage',
            write: write,
            read: read,
            each: each,
            remove: remove,
            clearAll: clearAll,
        }

        var storageName = 'storejs'
        var doc = Global.document
        var _withStorageEl = _makeIEStorageElFunction()
        var disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./) // MSIE 9.x, MSIE 10.x

        function write(unfixedKey, data) {
            if (disable) {
                return
            }
            var fixedKey = fixKey(unfixedKey)
            _withStorageEl(function(storageEl) {
                storageEl.setAttribute(fixedKey, data)
                storageEl.save(storageName)
            })
        }

        function read(unfixedKey) {
            if (disable) {
                return
            }
            var fixedKey = fixKey(unfixedKey)
            var res = null
            _withStorageEl(function(storageEl) {
                res = storageEl.getAttribute(fixedKey)
            })
            return res
        }

        function each(callback) {
            _withStorageEl(function(storageEl) {
                var attributes = storageEl.XMLDocument.documentElement.attributes
                for (var i = attributes.length - 1; i >= 0; i--) {
                    var attr = attributes[i]
                    callback(storageEl.getAttribute(attr.name), attr.name)
                }
            })
        }

        function remove(unfixedKey) {
            var fixedKey = fixKey(unfixedKey)
            _withStorageEl(function(storageEl) {
                storageEl.removeAttribute(fixedKey)
                storageEl.save(storageName)
            })
        }

        function clearAll() {
            _withStorageEl(function(storageEl) {
                var attributes = storageEl.XMLDocument.documentElement.attributes
                storageEl.load(storageName)
                for (var i = attributes.length - 1; i >= 0; i--) {
                    storageEl.removeAttribute(attributes[i].name)
                }
                storageEl.save(storageName)
            })
        }

        // Helpers
        //////////

        // In IE7, keys cannot start with a digit or contain certain chars.
        // See https://github.com/marcuswestin/store.js/issues/40
        // See https://github.com/marcuswestin/store.js/issues/83
        var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")

        function fixKey(key) {
            return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
        }

        function _makeIEStorageElFunction() {
            if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
                return null
            }
            var scriptTag = 'script',
                storageOwner,
                storageContainer,
                storageEl

            // Since #userData storage applies only to specific paths, we need to
            // somehow link our data to a specific path.  We choose /favicon.ico
            // as a pretty safe option, since all browsers already make a request to
            // this URL anyway and being a 404 will not hurt us here.  We wrap an
            // iframe pointing to the favicon in an ActiveXObject(htmlfile) object
            // (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
            // since the iframe access rules appear to allow direct access and
            // manipulation of the document element, even for a 404 page.  This
            // document can be used instead of the current document (which would
            // have been limited to the current path) to perform #userData storage.
            try {
                /* global ActiveXObject */
                storageContainer = new ActiveXObject('htmlfile')
                storageContainer.open()
                storageContainer.write('<' + scriptTag + '>document.w=window</' + scriptTag + '><iframe src="/favicon.ico"></iframe>')
                storageContainer.close()
                storageOwner = storageContainer.w.frames[0].document
                storageEl = storageOwner.createElement('div')
            } catch (e) {
                // somehow ActiveXObject instantiation failed (perhaps some special
                // security settings or otherwse), fall back to per-path storage
                storageEl = doc.createElement('div')
                storageOwner = doc.body
            }

            return function(storeFunction) {
                var args = [].slice.call(arguments, 0)
                args.unshift(storageEl)
                // See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
                // and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
                storageOwner.appendChild(storageEl)
                storageEl.addBehavior('#default#userData')
                storageEl.load(storageName)
                storeFunction.apply(this, args)
                storageOwner.removeChild(storageEl)
                return
            }
        }


        /***/
    }),
    /* 168 */
    /***/
    (function(module, exports, __webpack_require__) {

        var util = __webpack_require__(9)
        var Global = util.Global

        module.exports = {
            name: 'sessionStorage',
            read: read,
            write: write,
            each: each,
            remove: remove,
            clearAll: clearAll
        }

        function sessionStorage() {
            return Global.sessionStorage
        }

        function read(key) {
            return sessionStorage().getItem(key)
        }

        function write(key, data) {
            return sessionStorage().setItem(key, data)
        }

        function each(fn) {
            for (var i = sessionStorage().length - 1; i >= 0; i--) {
                var key = sessionStorage().key(i)
                fn(read(key), key)
            }
        }

        function remove(key) {
            return sessionStorage().removeItem(key)
        }

        function clearAll() {
            return sessionStorage().clear()
        }


        /***/
    }),
    /* 169 */
    /***/
    (function(module, exports) {

        module.exports.attr = attr;
        module.exports.tagClose = tagClose;
        module.exports.tag = tag;
        module.exports.encode = encode;

        /**
         * @param {array} _ an array of attributes
         * @returns {string}
         */
        function attr(_) {
            return (_ && _.length) ? (' ' + _.map(function(a) {
                return a[0] + '="' + a[1] + '"';
            }).join(' ')) : '';
        }

        /**
         * @param {string} el element name
         * @param {array} attributes array of pairs
         * @returns {string}
         */
        function tagClose(el, attributes) {
            return '<' + el + attr(attributes) + '/>';
        }

        /**
         * @param {string} el element name
         * @param {string} contents innerXML
         * @param {array} attributes array of pairs
         * @returns {string}
         */
        function tag(el, contents, attributes) {
            return '<' + el + attr(attributes) + '>' + contents + '</' + el + '>';
        }

        /**
         * @param {string} _ a string of attribute
         * @returns {string}
         */
        function encode(_) {
            return (_ === null ? '' : _.toString()).replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }


        /***/
    }),
    /* 170 */
    /***/
    (function(module, exports, __webpack_require__) {

        var apply = Function.prototype.apply;

        // DOM APIs, for completeness

        exports.setTimeout = function() {
            return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
        };
        exports.setInterval = function() {
            return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
        };
        exports.clearTimeout =
            exports.clearInterval = function(timeout) {
                if (timeout) {
                    timeout.close();
                }
            };

        function Timeout(id, clearFn) {
            this._id = id;
            this._clearFn = clearFn;
        }
        Timeout.prototype.unref = Timeout.prototype.ref = function() {};
        Timeout.prototype.close = function() {
            this._clearFn.call(window, this._id);
        };

        // Does not start the time, just sets up the members needed.
        exports.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = msecs;
        };

        exports.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = -1;
        };

        exports._unrefActive = exports.active = function(item) {
            clearTimeout(item._idleTimeoutId);

            var msecs = item._idleTimeout;
            if (msecs >= 0) {
                item._idleTimeoutId = setTimeout(function onTimeout() {
                    if (item._onTimeout)
                        item._onTimeout();
                }, msecs);
            }
        };

        // setimmediate attaches itself to the global object
        __webpack_require__(156);
        exports.setImmediate = setImmediate;
        exports.clearImmediate = clearImmediate;


        /***/
    }),
    /* 171 */
    /***/
    (function(module, exports, __webpack_require__) {

        var JXON = __webpack_require__(148);
        JXON.config({
            attrPrefix: '@'
        });

        function togpx(geojson, options) {
            options = (function(defaults, options) {
                for (var k in defaults) {
                    if (options.hasOwnProperty(k))
                        defaults[k] = options[k];
                }
                return defaults;
            })({
                creator: "togpx",
                metadata: undefined,
                featureTitle: get_feature_title,
                featureDescription: get_feature_description,
                featureLink: undefined,
                featureCoordTimes: get_feature_coord_times,
            }, options || {});

            // is featureCoordTimes is a string -> look for the specified property
            if (typeof options.featureCoordTimes === 'string') {
                var customTimesFieldKey = options.featureCoordTimes;
                options.featureCoordTimes = function(feature) {
                    return feature.properties[customTimesFieldKey];
                }
            }

            function get_feature_title(props) {
                // a simple default heuristic to determine a title for a given feature
                // uses a nested `tags` object or the feature's `properties` if present
                // and then searchs for the following properties to construct a title:
                // `name`, `ref`, `id`
                if (!props) return "";
                if (typeof props.tags === "object") {
                    var tags_title = get_feature_title(props.tags);
                    if (tags_title !== "")
                        return tags_title;
                }
                if (props.name)
                    return props.name;
                if (props.ref)
                    return props.ref;
                if (props.id)
                    return props.id;
                return "";
            }

            function get_feature_description(props) {
                // constructs a description for a given feature
                // uses a nested `tags` object or the feature's `properties` if present
                // and then concatenates all properties to construct a description.
                if (!props) return "";
                if (typeof props.tags === "object")
                    return get_feature_description(props.tags);
                var res = "";
                for (var k in props) {
                    if (typeof props[k] === "object")
                        continue;
                    res += k + "=" + props[k] + "\n";
                }
                return res.substr(0, res.length - 1);
            }

            function get_feature_coord_times(feature) {
                if (!feature.properties) return null;
                return feature.properties.times || feature.properties.coordTimes || null;
            }

            function add_feature_link(o, f) {
                if (options.featureLink)
                    o.link = {
                        "@href": options.featureLink(f.properties)
                    }
            }
            // make gpx object
            var gpx = {
                "gpx": {
                    "@xmlns": "http://www.topografix.com/GPX/1/1",
                    "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
                    "@xsi:schemaLocation": "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd",
                    "@version": "1.1",
                    "metadata": null,
                    "wpt": [],
                    "trk": [],
                }
            };
            if (options.creator)
                gpx.gpx["@creator"] = options.creator;
            if (options.metadata)
                gpx.gpx["metadata"] = options.metadata;
            else
                delete options.metadata;

            var features;
            if (geojson.type === "FeatureCollection")
                features = geojson.features;
            else if (geojson.type === "Feature")
                features = [geojson];
            else
                features = [{
                    type: "Feature",
                    properties: {},
                    geometry: geojson
                }];
            features.forEach(function mapFeature(f) {
                switch (f.geometry.type) {
                    // POIs
                    case "Point":
                    case "MultiPoint":
                        var coords = f.geometry.coordinates;
                        if (f.geometry.type == "Point") coords = [coords];
                        coords.forEach(function(coordinates) {
                            o = {
                                "@lat": coordinates[1],
                                "@lon": coordinates[0],
                                "name": options.featureTitle(f.properties),
                                "desc": options.featureDescription(f.properties)
                            };
                            if (coordinates[2] !== undefined) {
                                o.ele = coordinates[2];
                            }
                            add_feature_link(o, f);
                            gpx.gpx.wpt.push(o);
                        });
                        break;
                        // LineStrings
                    case "LineString":
                    case "MultiLineString":
                        var coords = f.geometry.coordinates;
                        var times = options.featureCoordTimes(f);
                        if (f.geometry.type == "LineString") coords = [coords];
                        o = {
                            "name": options.featureTitle(f.properties),
                            "desc": options.featureDescription(f.properties)
                        };
                        add_feature_link(o, f);
                        o.trkseg = [];
                        coords.forEach(function(coordinates) {
                            var seg = {
                                trkpt: []
                            };
                            coordinates.forEach(function(c, i) {
                                var o = {
                                    "@lat": c[1],
                                    "@lon": c[0]
                                };
                                if (c[2] !== undefined) {
                                    o.ele = c[2];
                                }
                                if (times && times[i]) {
                                    o.time = times[i];
                                }
                                seg.trkpt.push(o);
                            });
                            o.trkseg.push(seg);
                        });
                        gpx.gpx.trk.push(o);
                        break;
                        // Polygons / Multipolygons
                    case "Polygon":
                    case "MultiPolygon":
                        o = {
                            "name": options.featureTitle(f.properties),
                            "desc": options.featureDescription(f.properties)
                        };
                        add_feature_link(o, f);
                        o.trkseg = [];
                        var coords = f.geometry.coordinates;
                        var times = options.featureCoordTimes(f);
                        if (f.geometry.type == "Polygon") coords = [coords];
                        coords.forEach(function(poly) {
                            poly.forEach(function(ring) {
                                var seg = {
                                    trkpt: []
                                };
                                var i = 0;
                                ring.forEach(function(c) {
                                    var o = {
                                        "@lat": c[1],
                                        "@lon": c[0]
                                    };
                                    if (c[2] !== undefined) {
                                        o.ele = c[2];
                                    }
                                    if (times && times[i]) {
                                        o.time = times[i];
                                    }
                                    i++;
                                    seg.trkpt.push(o);
                                });
                                o.trkseg.push(seg);
                            });
                        });
                        gpx.gpx.trk.push(o);
                        break;
                    case "GeometryCollection":
                        f.geometry.geometries.forEach(function(geometry) {
                            var pseudo_feature = {
                                "properties": f.properties,
                                "geometry": geometry
                            };
                            mapFeature(pseudo_feature);
                        });
                        break;
                    default:
                        console.log("warning: unsupported geometry type: " + f.geometry.type);
                }
            });
            gpx_str = JXON.stringify(gpx);
            return gpx_str;
        };

        module.exports = togpx;


        /***/
    }),
    /* 172 */
    /***/
    (function(module, exports, __webpack_require__) {

        var strxml = __webpack_require__(169),
            tag = strxml.tag,
            encode = strxml.encode;

        module.exports = function tokml(geojson, options) {

            options = options || {
                documentName: undefined,
                documentDescription: undefined,
                name: 'name',
                description: 'description',
                simplestyle: false,
                timestamp: 'timestamp'
            };

            return '<?xml version="1.0" encoding="UTF-8"?>' +
                tag('kml',
                    tag('Document',
                        documentName(options) +
                        documentDescription(options) +
                        root(geojson, options)
                    ), [
                        ['xmlns', 'http://www.opengis.net/kml/2.2']
                    ]);
        };

        function feature(options, styleHashesArray) {
            return function(_) {
                if (!_.properties || !geometry.valid(_.geometry)) return '';
                var geometryString = geometry.any(_.geometry);
                if (!geometryString) return '';

                var styleDefinition = '',
                    styleReference = '';
                if (options.simplestyle) {
                    var styleHash = hashStyle(_.properties);
                    if (styleHash) {
                        if (geometry.isPoint(_.geometry) && hasMarkerStyle(_.properties)) {
                            if (styleHashesArray.indexOf(styleHash) === -1) {
                                styleDefinition = markerStyle(_.properties, styleHash);
                                styleHashesArray.push(styleHash);
                            }
                            styleReference = tag('styleUrl', '#' + styleHash);
                        } else if ((geometry.isPolygon(_.geometry) || geometry.isLine(_.geometry)) &&
                            hasPolygonAndLineStyle(_.properties)) {
                            if (styleHashesArray.indexOf(styleHash) === -1) {
                                styleDefinition = polygonAndLineStyle(_.properties, styleHash);
                                styleHashesArray.push(styleHash);
                            }
                            styleReference = tag('styleUrl', '#' + styleHash);
                        }
                        // Note that style of GeometryCollection / MultiGeometry is not supported
                    }
                }

                return styleDefinition + tag('Placemark',
                    name(_.properties, options) +
                    description(_.properties, options) +
                    extendeddata(_.properties) +
                    timestamp(_.properties, options) +
                    geometryString +
                    styleReference);
            };
        }

        function root(_, options) {
            if (!_.type) return '';
            var styleHashesArray = [];

            switch (_.type) {
                case 'FeatureCollection':
                    if (!_.features) return '';
                    return _.features.map(feature(options, styleHashesArray)).join('');
                case 'Feature':
                    return feature(options, styleHashesArray)(_);
                default:
                    return feature(options, styleHashesArray)({
                        type: 'Feature',
                        geometry: _,
                        properties: {}
                    });
            }
        }

        function documentName(options) {
            return (options.documentName !== undefined) ? tag('name', options.documentName) : '';
        }

        function documentDescription(options) {
            return (options.documentDescription !== undefined) ? tag('description', options.documentDescription) : '';
        }

        function name(_, options) {
            return _[options.name] ? tag('name', encode(_[options.name])) : '';
        }

        function description(_, options) {
            return _[options.description] ? tag('description', encode(_[options.description])) : '';
        }

        function timestamp(_, options) {
            return _[options.timestamp] ? tag('TimeStamp', tag('when', encode(_[options.timestamp]))) : '';
        }

        // ## Geometry Types
        //
        // https://developers.google.com/kml/documentation/kmlreference#geometry
        var geometry = {
            Point: function(_) {
                return tag('Point', tag('coordinates', _.coordinates.join(',')));
            },
            LineString: function(_) {
                return tag('LineString', tag('coordinates', linearring(_.coordinates)));
            },
            Polygon: function(_) {
                if (!_.coordinates.length) return '';
                var outer = _.coordinates[0],
                    inner = _.coordinates.slice(1),
                    outerRing = tag('outerBoundaryIs',
                        tag('LinearRing', tag('coordinates', linearring(outer)))),
                    innerRings = inner.map(function(i) {
                        return tag('innerBoundaryIs',
                            tag('LinearRing', tag('coordinates', linearring(i))));
                    }).join('');
                return tag('Polygon', outerRing + innerRings);
            },
            MultiPoint: function(_) {
                if (!_.coordinates.length) return '';
                return tag('MultiGeometry', _.coordinates.map(function(c) {
                    return geometry.Point({
                        coordinates: c
                    });
                }).join(''));
            },
            MultiPolygon: function(_) {
                if (!_.coordinates.length) return '';
                return tag('MultiGeometry', _.coordinates.map(function(c) {
                    return geometry.Polygon({
                        coordinates: c
                    });
                }).join(''));
            },
            MultiLineString: function(_) {
                if (!_.coordinates.length) return '';
                return tag('MultiGeometry', _.coordinates.map(function(c) {
                    return geometry.LineString({
                        coordinates: c
                    });
                }).join(''));
            },
            GeometryCollection: function(_) {
                return tag('MultiGeometry',
                    _.geometries.map(geometry.any).join(''));
            },
            valid: function(_) {
                return _ && _.type && (_.coordinates ||
                    _.type === 'GeometryCollection' && _.geometries && _.geometries.every(geometry.valid));
            },
            any: function(_) {
                if (geometry[_.type]) {
                    return geometry[_.type](_);
                } else {
                    return '';
                }
            },
            isPoint: function(_) {
                return _.type === 'Point' ||
                    _.type === 'MultiPoint';
            },
            isPolygon: function(_) {
                return _.type === 'Polygon' ||
                    _.type === 'MultiPolygon';
            },
            isLine: function(_) {
                return _.type === 'LineString' ||
                    _.type === 'MultiLineString';
            }
        };

        function linearring(_) {
            return _.map(function(cds) {
                return cds.join(',');
            }).join(' ');
        }

        // ## Data
        function extendeddata(_) {
            return tag('ExtendedData', pairs(_).map(data).join(''));
        }

        function data(_) {
            return tag('Data', tag('value', encode(_[1])), [
                ['name', encode(_[0])]
            ]);
        }

        // ## Marker style
        function hasMarkerStyle(_) {
            return !!(_['marker-size'] || _['marker-symbol'] || _['marker-color']);
        }

        function markerStyle(_, styleHash) {
            return tag('Style',
                tag('IconStyle',
                    tag('Icon',
                        tag('href', iconUrl(_)))) +
                iconSize(_), [
                    ['id', styleHash]
                ]);
        }

        function iconUrl(_) {
            var size = _['marker-size'] || 'medium',
                symbol = _['marker-symbol'] ? '-' + _['marker-symbol'] : '',
                color = (_['marker-color'] || '7e7e7e').replace('#', '');

            return 'https://api.tiles.mapbox.com/v3/marker/' + 'pin-' + size.charAt(0) +
                symbol + '+' + color + '.png';
        }

        function iconSize(_) {
            return tag('hotSpot', '', [
                ['xunits', 'fraction'],
                ['yunits', 'fraction'],
                ['x', 0.5],
                ['y', 0.5]
            ]);
        }

        // ## Polygon and Line style
        function hasPolygonAndLineStyle(_) {
            for (var key in _) {
                if ({
                        "stroke": true,
                        "stroke-opacity": true,
                        "stroke-width": true,
                        "fill": true,
                        "fill-opacity": true
                    }[key]) return true;
            }
        }

        function polygonAndLineStyle(_, styleHash) {
            var lineStyle = tag('LineStyle', [
                tag('color', hexToKmlColor(_['stroke'], _['stroke-opacity']) || 'ff555555') +
                tag('width', _['stroke-width'] === undefined ? 2 : _['stroke-width'])
            ]);

            var polyStyle = '';

            if (_['fill'] || _['fill-opacity']) {
                polyStyle = tag('PolyStyle', [
                    tag('color', hexToKmlColor(_['fill'], _['fill-opacity']) || '88555555')
                ]);
            }

            return tag('Style', lineStyle + polyStyle, [
                ['id', styleHash]
            ]);
        }

        // ## Style helpers
        function hashStyle(_) {
            var hash = '';

            if (_['marker-symbol']) hash = hash + 'ms' + _['marker-symbol'];
            if (_['marker-color']) hash = hash + 'mc' + _['marker-color'].replace('#', '');
            if (_['marker-size']) hash = hash + 'ms' + _['marker-size'];
            if (_['stroke']) hash = hash + 's' + _['stroke'].replace('#', '');
            if (_['stroke-width']) hash = hash + 'sw' + _['stroke-width'].toString().replace('.', '');
            if (_['stroke-opacity']) hash = hash + 'mo' + _['stroke-opacity'].toString().replace('.', '');
            if (_['fill']) hash = hash + 'f' + _['fill'].replace('#', '');
            if (_['fill-opacity']) hash = hash + 'fo' + _['fill-opacity'].toString().replace('.', '');

            return hash;
        }

        function hexToKmlColor(hexColor, opacity) {
            if (typeof hexColor !== 'string') return '';

            hexColor = hexColor.replace('#', '').toLowerCase();

            if (hexColor.length === 3) {
                hexColor = hexColor[0] + hexColor[0] +
                    hexColor[1] + hexColor[1] +
                    hexColor[2] + hexColor[2];
            } else if (hexColor.length !== 6) {
                return '';
            }

            var r = hexColor[0] + hexColor[1];
            var g = hexColor[2] + hexColor[3];
            var b = hexColor[4] + hexColor[5];

            var o = 'ff';
            if (typeof opacity === 'number' && opacity >= 0.0 && opacity <= 1.0) {
                o = (opacity * 255).toString(16);
                if (o.indexOf('.') > -1) o = o.substr(0, o.indexOf('.'));
                if (o.length < 2) o = '0' + o;
            }

            return o + b + g + r;
        }

        // ## General helpers
        function pairs(_) {
            var o = [];
            for (var i in _) o.push([i, _[i]]);
            return o;
        }

        /***/
    }),
    /* 173 */
    /***/
    (function(module, exports) {

        module.exports = function() {
            throw new Error("define cannot be used indirect");
        };


        /***/
    }),
    /* 174 */
    /***/
    (function(module, exports) {

        /* WEBPACK VAR INJECTION */
        (function(__webpack_amd_options__) { /* globals __webpack_amd_options__ */
            module.exports = __webpack_amd_options__;

            /* WEBPACK VAR INJECTION */
        }.call(exports, {}))

        /***/
    }),
    /* 175 */
    /***/
    (function(module, exports) {

        // shim for using process in browser
        var process = module.exports = {};

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
        }

        function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
        }
        (function() {
            try {
                if (typeof setTimeout === 'function') {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === 'function') {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }())

        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                //normal enviroments in sane situations
                return setTimeout(fun, 0);
            }
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }


        }

        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                //normal enviroments in sane situations
                return clearTimeout(marker);
            }
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }



        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;

            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }

        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function(name) {
            return []
        }

        process.binding = function(name) {
            throw new Error('process.binding is not supported');
        };

        process.cwd = function() {
            return '/'
        };
        process.chdir = function(dir) {
            throw new Error('process.chdir is not supported');
        };
        process.umask = function() {
            return 0;
        };


        /***/
    })
    /******/
]);